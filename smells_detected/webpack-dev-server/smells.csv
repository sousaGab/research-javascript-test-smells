file,type,line,method,source
/test/validate-options.test.js,GeneralFixture,"{'startLine':562,'endLine':562}","beforeAll(() => {
    consoleMock = jest.spyOn(console, ""warn"").mockImplementation();
  })",snuts
/test/validate-options.test.js,NonFunctionalStatement,"{'startLine':176,'endLine':176}",Unknown,snuts
/test/validate-options.test.js,NonFunctionalStatement,"{'startLine':200,'endLine':200}",Unknown,snuts
/test/validate-options.test.js,NonFunctionalStatement,"{'startLine':240,'endLine':240}",Unknown,snuts
/test/validate-options.test.js,NonFunctionalStatement,"{'startLine':498,'endLine':498}",Unknown,snuts
/test/normalize-options.test.js,NonFunctionalStatement,"{'startLine':186,'endLine':186}","describe(""normalize options"", () => {
  const cases = [
    {
      title: ""no options"",
      multiCompiler: false,
      options: {},
    },
    {
      title: ""port string"",
      multiCompiler: false,
      options: {
        port: ""9000"",
      },
    },
    {
      title: ""client.webSocketTransport sockjs string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""sockjs"",
        },
      },
    },
    {
      title: ""client.webSocketTransport ws string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
      },
    },
    {
      title:
        ""client.webSocketTransport ws string and webSocketServer ws string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
        webSocketServer: ""ws"",
      },
    },
    {
      title: ""webSocketServer custom server path"",
      multiCompiler: false,
      options: {
        webSocketServer: ""/path/to/custom/server/"",
      },
    },
    {
      title: ""webSocketServer custom server class"",
      multiCompiler: false,
      options: {
        webSocketServer: class CustomServerImplementation {
          constructor() {
            this.implementation = {
              close: (callback) => {
                callback();
              },
            };
          }
        },
      },
    },
    {
      title: ""client.webSocketTransport ws string and webSocketServer object"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
        webSocketServer: {
          type: ""ws"",
          options: {
            host: ""127.0.0.1"",
            // TODO `jest` is freeze here
            // port: 43334,
            pathname: ""/ws"",
          },
        },
      },
    },
    {
      title:
        ""client.webSocketTransport ws string and webSocketServer object with port as string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
        webSocketServer: {
          type: ""ws"",
          options: {
            host: ""127.0.0.1"",
            // TODO `jest` is freeze here
            // port: ""43335"",
            pathname: ""/ws"",
          },
        },
      },
    },
    {
      title: ""client custom webSocketTransport path"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""/path/to/custom/client/"",
        },
      },
    },
    {
      title: ""client host and port"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            hostname: ""my.host"",
            port: 9000,
          },
        },
      },
    },
    {
      title: ""client host and string port"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            hostname: ""my.host"",
            port: ""9000"",
          },
        },
      },
    },
    {
      title: ""client path"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            pathname: ""/custom/path/"",
          },
        },
      },
    },
    {
      title: ""username and password"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
            password: ""chuntaro"",
          },
        },
      },
    },
    {
      title: ""client path without leading/ending slashes"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            pathname: ""custom/path"",
          },
        },
      },
    },
    {
      title:
        ""single compiler client.logging should default to infrastructureLogging.level"",
      multiCompiler: false,
      options: {},
      webpackConfig: {
        infrastructureLogging: {
          level: ""verbose"",
          stream: {
            write: () => {},
          },
        },
      },
    },
    {
      title:
        ""single compiler client.logging should override to infrastructureLogging.level"",
      multiCompiler: false,
      options: {
        client: {
          logging: ""none"",
        },
      },
      webpackConfig: {
        infrastructureLogging: {
          level: ""verbose"",
          stream: {
            write: () => {},
          },
        },
      },
    },
    {
      title:
        ""multi compiler client.logging should respect infrastructureLogging.level"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        {
          target: ""node"",
        },
        // infrastructureLogging is set on the second compiler
        {
          target: ""web"",
          infrastructureLogging: {
            level: ""warn"",
          },
        },
      ],
    },
    {
      title:
        ""multi compiler client.logging should respect infrastructureLogging.level"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        {},
        // infrastructureLogging is set on the second compiler
        {
          devServer: {},
          infrastructureLogging: {
            level: ""warn"",
          },
        },
      ],
    },
    {
      title:
        ""multi compiler client.logging should respect infrastructureLogging.level"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        // Fallback
        {
          infrastructureLogging: {
            level: ""warn"",
          },
        },
        {},
      ],
    },
    {
      title:
        ""multi compiler client.logging should override infrastructureLogging.level"",
      multiCompiler: true,
      options: {
        client: {
          logging: ""none"",
        },
      },
      webpackConfig: [
        {
          infrastructureLogging: {
            level: ""warn"",
          },
        },
        {},
      ],
    },
    {
      title: ""liveReload is true"",
      multiCompiler: false,
      options: {
        liveReload: true,
      },
    },
    {
      title: ""liveReload is false"",
      multiCompiler: false,
      options: {
        liveReload: false,
      },
    },
    {
      title: ""hot is true"",
      multiCompiler: false,
      options: {
        hot: true,
      },
    },
    {
      title: ""hot is false"",
      multiCompiler: false,
      options: {
        hot: false,
      },
    },
    {
      title: ""hot is only"",
      multiCompiler: false,
      options: {
        hot: ""only"",
      },
    },
    {
      title: ""dev is set"",
      multiCompiler: false,
      options: {
        devMiddleware: {
          serverSideRender: true,
        },
      },
    },
    {
      title: ""static is true"",
      multiCompiler: false,
      options: {
        static: true,
      },
    },
    {
      title: ""static is false"",
      multiCompiler: false,
      options: {
        static: false,
      },
    },
    {
      title: ""static is string"",
      multiCompiler: false,
      options: {
        static: ""/static/path"",
      },
    },
    {
      title: ""static is an array of strings"",
      multiCompiler: false,
      options: {
        static: [""/static/path1"", ""/static/path2""],
      },
    },
    {
      title: ""static is an array of static objects"",
      multiCompiler: false,
      options: {
        static: [
          {
            directory: ""/static/path1"",
          },
          {
            publicPath: ""/static/public/path"",
          },
        ],
      },
    },
    {
      title: ""static is an array of strings and static objects"",
      multiCompiler: false,
      options: {
        static: [
          ""/static/path1"",
          {
            publicPath: ""/static/public/path/"",
          },
        ],
      },
    },
    {
      title: ""static is an object"",
      multiCompiler: false,
      options: {
        static: {
          directory: ""/static/path"",
        },
      },
    },
    {
      title: ""static is an object with staticOptions"",
      multiCompiler: false,
      options: {
        static: {
          directory: ""/static/path"",
          staticOptions: {
            redirect: true,
            immutable: true,
          },
        },
      },
    },
    {
      title: ""static directory is an absolute url and throws error"",
      multiCompiler: false,
      options: {
        static: {
          directory: ""http://localhost:8080"",
        },
      },
      throws: ""Using a URL as static.directory is not supported"",
    },
    {
      title: ""static publicPath is a string"",
      multiCompiler: false,
      options: {
        static: {
          publicPath: ""/static/public/path/"",
        },
      },
    },
    {
      title: ""static publicPath is an array"",
      multiCompiler: false,
      options: {
        static: {
          publicPath: [""/static/public/path1/"", ""/static/public/path2/""],
        },
      },
    },
    {
      title: ""static watch is false"",
      multiCompiler: false,
      options: {
        static: {
          watch: false,
        },
      },
    },
    {
      title: ""static watch is true"",
      multiCompiler: false,
      options: {
        static: {
          watch: true,
        },
      },
    },
    {
      title: ""static watch is an object"",
      multiCompiler: false,
      options: {
        static: {
          watch: {
            poll: 500,
          },
        },
      },
    },
    {
      title: ""static serveIndex is false"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: false,
        },
      },
    },
    {
      title: ""static serveIndex is true"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: true,
        },
      },
    },
    {
      title: ""static serveIndex is an object with icons false"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: {
            icons: false,
          },
        },
      },
    },
    {
      title: ""static serveIndex is an object more options"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: {
            hidden: true,
            stylesheet: ""https://example.com/style.css"",
            view: ""details"",
          },
        },
      },
    },

    {
      title: ""single compiler watchOptions is object"",
      multiCompiler: false,
      options: {},
      webpackConfig: {
        watch: true,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title: ""single compiler watchOptions is object with watch false"",
      multiCompiler: false,
      options: {},
      webpackConfig: {
        watch: false,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title: ""single compiler watchOptions is object with static watch true"",
      multiCompiler: false,
      options: {
        static: {
          watch: true,
        },
      },
      webpackConfig: {
        watch: true,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title:
        ""single compiler watchOptions is object with static watch overriding it"",
      multiCompiler: false,
      options: {
        static: {
          watch: {
            poll: 500,
          },
        },
      },
      webpackConfig: {
        watch: true,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title: ""multi compiler watchOptions is set"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        {},
        // watchOptions are set on the second compiler
        {
          watch: true,
          watchOptions: {
            aggregateTimeout: 300,
          },
        },
      ],
    },
    {
      title: ""allowedHosts is string"",
      multiCompiler: false,
      options: {
        allowedHosts: ""all"",
      },
    },
    {
      title: ""allowedHosts is array"",
      multiCompiler: false,
      options: {
        allowedHosts: [""all""],
      },
    },
  ];

  for (const item of cases) {
    it(item.title, async () => {
      let webpackConfig;

      if (item.multiCompiler) {
        webpackConfig = require(""./fixtures/multi-compiler-one-configuration/webpack.config"");

        if (Array.isArray(item.webpackConfig)) {
          webpackConfig = item.webpackConfig.map((config, index) => ({
            ...webpackConfig[index],
            ...config,
          }));
        }
      } else {
        webpackConfig = require(""./fixtures/simple-config/webpack.config"");

        if (item.webpackConfig) {
          webpackConfig = {
            ...webpackConfig,
            ...item.webpackConfig,
          };
        }
      }

      const compiler = webpack(webpackConfig);
      const server = new Server({ ...item.options, port }, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      try {
        if (item.throws) {
          expect(errored.message).toMatch(item.throws);
        } else {
          const optionsForSnapshot = klona(server.options);

          optionsForSnapshot.port = ""<auto>"";

          if (optionsForSnapshot.static.length > 0) {
            for (const i of optionsForSnapshot.static) {
              i.directory = i.directory
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                );
            }
          }

          expect(optionsForSnapshot).toMatchSnapshot();
        }
      } finally {
        await server.stop();
      }
    });
  }
})",snuts
/test/normalize-options.test.js,NonFunctionalStatement,"{'startLine':204,'endLine':204}","describe(""normalize options"", () => {
  const cases = [
    {
      title: ""no options"",
      multiCompiler: false,
      options: {},
    },
    {
      title: ""port string"",
      multiCompiler: false,
      options: {
        port: ""9000"",
      },
    },
    {
      title: ""client.webSocketTransport sockjs string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""sockjs"",
        },
      },
    },
    {
      title: ""client.webSocketTransport ws string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
      },
    },
    {
      title:
        ""client.webSocketTransport ws string and webSocketServer ws string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
        webSocketServer: ""ws"",
      },
    },
    {
      title: ""webSocketServer custom server path"",
      multiCompiler: false,
      options: {
        webSocketServer: ""/path/to/custom/server/"",
      },
    },
    {
      title: ""webSocketServer custom server class"",
      multiCompiler: false,
      options: {
        webSocketServer: class CustomServerImplementation {
          constructor() {
            this.implementation = {
              close: (callback) => {
                callback();
              },
            };
          }
        },
      },
    },
    {
      title: ""client.webSocketTransport ws string and webSocketServer object"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
        webSocketServer: {
          type: ""ws"",
          options: {
            host: ""127.0.0.1"",
            // TODO `jest` is freeze here
            // port: 43334,
            pathname: ""/ws"",
          },
        },
      },
    },
    {
      title:
        ""client.webSocketTransport ws string and webSocketServer object with port as string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
        webSocketServer: {
          type: ""ws"",
          options: {
            host: ""127.0.0.1"",
            // TODO `jest` is freeze here
            // port: ""43335"",
            pathname: ""/ws"",
          },
        },
      },
    },
    {
      title: ""client custom webSocketTransport path"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""/path/to/custom/client/"",
        },
      },
    },
    {
      title: ""client host and port"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            hostname: ""my.host"",
            port: 9000,
          },
        },
      },
    },
    {
      title: ""client host and string port"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            hostname: ""my.host"",
            port: ""9000"",
          },
        },
      },
    },
    {
      title: ""client path"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            pathname: ""/custom/path/"",
          },
        },
      },
    },
    {
      title: ""username and password"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
            password: ""chuntaro"",
          },
        },
      },
    },
    {
      title: ""client path without leading/ending slashes"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            pathname: ""custom/path"",
          },
        },
      },
    },
    {
      title:
        ""single compiler client.logging should default to infrastructureLogging.level"",
      multiCompiler: false,
      options: {},
      webpackConfig: {
        infrastructureLogging: {
          level: ""verbose"",
          stream: {
            write: () => {},
          },
        },
      },
    },
    {
      title:
        ""single compiler client.logging should override to infrastructureLogging.level"",
      multiCompiler: false,
      options: {
        client: {
          logging: ""none"",
        },
      },
      webpackConfig: {
        infrastructureLogging: {
          level: ""verbose"",
          stream: {
            write: () => {},
          },
        },
      },
    },
    {
      title:
        ""multi compiler client.logging should respect infrastructureLogging.level"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        {
          target: ""node"",
        },
        // infrastructureLogging is set on the second compiler
        {
          target: ""web"",
          infrastructureLogging: {
            level: ""warn"",
          },
        },
      ],
    },
    {
      title:
        ""multi compiler client.logging should respect infrastructureLogging.level"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        {},
        // infrastructureLogging is set on the second compiler
        {
          devServer: {},
          infrastructureLogging: {
            level: ""warn"",
          },
        },
      ],
    },
    {
      title:
        ""multi compiler client.logging should respect infrastructureLogging.level"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        // Fallback
        {
          infrastructureLogging: {
            level: ""warn"",
          },
        },
        {},
      ],
    },
    {
      title:
        ""multi compiler client.logging should override infrastructureLogging.level"",
      multiCompiler: true,
      options: {
        client: {
          logging: ""none"",
        },
      },
      webpackConfig: [
        {
          infrastructureLogging: {
            level: ""warn"",
          },
        },
        {},
      ],
    },
    {
      title: ""liveReload is true"",
      multiCompiler: false,
      options: {
        liveReload: true,
      },
    },
    {
      title: ""liveReload is false"",
      multiCompiler: false,
      options: {
        liveReload: false,
      },
    },
    {
      title: ""hot is true"",
      multiCompiler: false,
      options: {
        hot: true,
      },
    },
    {
      title: ""hot is false"",
      multiCompiler: false,
      options: {
        hot: false,
      },
    },
    {
      title: ""hot is only"",
      multiCompiler: false,
      options: {
        hot: ""only"",
      },
    },
    {
      title: ""dev is set"",
      multiCompiler: false,
      options: {
        devMiddleware: {
          serverSideRender: true,
        },
      },
    },
    {
      title: ""static is true"",
      multiCompiler: false,
      options: {
        static: true,
      },
    },
    {
      title: ""static is false"",
      multiCompiler: false,
      options: {
        static: false,
      },
    },
    {
      title: ""static is string"",
      multiCompiler: false,
      options: {
        static: ""/static/path"",
      },
    },
    {
      title: ""static is an array of strings"",
      multiCompiler: false,
      options: {
        static: [""/static/path1"", ""/static/path2""],
      },
    },
    {
      title: ""static is an array of static objects"",
      multiCompiler: false,
      options: {
        static: [
          {
            directory: ""/static/path1"",
          },
          {
            publicPath: ""/static/public/path"",
          },
        ],
      },
    },
    {
      title: ""static is an array of strings and static objects"",
      multiCompiler: false,
      options: {
        static: [
          ""/static/path1"",
          {
            publicPath: ""/static/public/path/"",
          },
        ],
      },
    },
    {
      title: ""static is an object"",
      multiCompiler: false,
      options: {
        static: {
          directory: ""/static/path"",
        },
      },
    },
    {
      title: ""static is an object with staticOptions"",
      multiCompiler: false,
      options: {
        static: {
          directory: ""/static/path"",
          staticOptions: {
            redirect: true,
            immutable: true,
          },
        },
      },
    },
    {
      title: ""static directory is an absolute url and throws error"",
      multiCompiler: false,
      options: {
        static: {
          directory: ""http://localhost:8080"",
        },
      },
      throws: ""Using a URL as static.directory is not supported"",
    },
    {
      title: ""static publicPath is a string"",
      multiCompiler: false,
      options: {
        static: {
          publicPath: ""/static/public/path/"",
        },
      },
    },
    {
      title: ""static publicPath is an array"",
      multiCompiler: false,
      options: {
        static: {
          publicPath: [""/static/public/path1/"", ""/static/public/path2/""],
        },
      },
    },
    {
      title: ""static watch is false"",
      multiCompiler: false,
      options: {
        static: {
          watch: false,
        },
      },
    },
    {
      title: ""static watch is true"",
      multiCompiler: false,
      options: {
        static: {
          watch: true,
        },
      },
    },
    {
      title: ""static watch is an object"",
      multiCompiler: false,
      options: {
        static: {
          watch: {
            poll: 500,
          },
        },
      },
    },
    {
      title: ""static serveIndex is false"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: false,
        },
      },
    },
    {
      title: ""static serveIndex is true"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: true,
        },
      },
    },
    {
      title: ""static serveIndex is an object with icons false"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: {
            icons: false,
          },
        },
      },
    },
    {
      title: ""static serveIndex is an object more options"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: {
            hidden: true,
            stylesheet: ""https://example.com/style.css"",
            view: ""details"",
          },
        },
      },
    },

    {
      title: ""single compiler watchOptions is object"",
      multiCompiler: false,
      options: {},
      webpackConfig: {
        watch: true,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title: ""single compiler watchOptions is object with watch false"",
      multiCompiler: false,
      options: {},
      webpackConfig: {
        watch: false,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title: ""single compiler watchOptions is object with static watch true"",
      multiCompiler: false,
      options: {
        static: {
          watch: true,
        },
      },
      webpackConfig: {
        watch: true,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title:
        ""single compiler watchOptions is object with static watch overriding it"",
      multiCompiler: false,
      options: {
        static: {
          watch: {
            poll: 500,
          },
        },
      },
      webpackConfig: {
        watch: true,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title: ""multi compiler watchOptions is set"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        {},
        // watchOptions are set on the second compiler
        {
          watch: true,
          watchOptions: {
            aggregateTimeout: 300,
          },
        },
      ],
    },
    {
      title: ""allowedHosts is string"",
      multiCompiler: false,
      options: {
        allowedHosts: ""all"",
      },
    },
    {
      title: ""allowedHosts is array"",
      multiCompiler: false,
      options: {
        allowedHosts: [""all""],
      },
    },
  ];

  for (const item of cases) {
    it(item.title, async () => {
      let webpackConfig;

      if (item.multiCompiler) {
        webpackConfig = require(""./fixtures/multi-compiler-one-configuration/webpack.config"");

        if (Array.isArray(item.webpackConfig)) {
          webpackConfig = item.webpackConfig.map((config, index) => ({
            ...webpackConfig[index],
            ...config,
          }));
        }
      } else {
        webpackConfig = require(""./fixtures/simple-config/webpack.config"");

        if (item.webpackConfig) {
          webpackConfig = {
            ...webpackConfig,
            ...item.webpackConfig,
          };
        }
      }

      const compiler = webpack(webpackConfig);
      const server = new Server({ ...item.options, port }, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      try {
        if (item.throws) {
          expect(errored.message).toMatch(item.throws);
        } else {
          const optionsForSnapshot = klona(server.options);

          optionsForSnapshot.port = ""<auto>"";

          if (optionsForSnapshot.static.length > 0) {
            for (const i of optionsForSnapshot.static) {
              i.directory = i.directory
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                );
            }
          }

          expect(optionsForSnapshot).toMatchSnapshot();
        }
      } finally {
        await server.stop();
      }
    });
  }
})",snuts
/test/server/proxy-option.test.js,AnonymousTest,"{'startLine':745,'endLine':750}","it(""errors"", async () => {
      const response = await req.get(""/%"");

      expect(response.status).toBe(500);
      expect(response.text).toContain(""error from proxy"");
    })",snuts
/test/server/proxy-option.test.js,AnonymousTest,"{'startLine':752,'endLine':757}","it(""gET method"", async () => {
      const response = await req.get(""/get"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""GET method from proxy"");
    })",snuts
/test/server/proxy-option.test.js,AnonymousTest,"{'startLine':759,'endLine':763}","it(""hEAD method"", async () => {
      const response = await req.head(""/head"");

      expect(response.status).toBe(200);
    })",snuts
/test/server/proxy-option.test.js,AnonymousTest,"{'startLine':787,'endLine':792}","it(""dELETE method"", async () => {
      const response = await req.delete(""/delete"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""DELETE method from proxy"");
    })",snuts
/test/server/proxy-option.test.js,GeneralFixture,"{'startLine':1012,'endLine':1024}","beforeAll(async () => {
      customLogProvider = {
        log: jest.fn(),
        debug: jest.fn(),
        info: jest.fn(),
        warn: jest.fn(),
        error: jest.fn(),
      };

      const compiler = webpack({
        ...config,
        infrastructureLogging: { level: ""none"" },
      });

      server = new Server(
        {
          proxy: [
            {
              context: ""/my-path"",
              target: ""http://unknown:1234"",
              logProvider: () => customLogProvider,
            },
          ],
          port: port3,
        },
        compiler,
      );

      await server.start();

      req = request(server.app);
    })",snuts
/test/server/proxy-option.test.js,GeneralFixture,"{'startLine':731,'endLine':731}","beforeAll(async () => {
      const compiler = webpack(config);

      server = new Server(
        {
          proxy: [
            {
              context: ""**"",
              target: `http://localhost:${port1}`,
            },
          ],
          port: port3,
        },
        compiler,
      );

      await server.start();

      const proxy = express();

      // Parse application/x-www-form-urlencoded
      proxy.use(bodyParser.urlencoded({ extended: false }));

      // Parse application/json
      proxy.use(bodyParser.json());

      // This forces Express to try to decode URLs, which is needed for the test
      // associated with the middleware below.
      proxy.all(""*"", (_req, res, next) => {
        next();
      });
      // We must define all 4 params in order for this to be detected as an
      // error handling middleware.
      // eslint-disable-next-line no-unused-vars
      proxy.use((error, proxyReq, res, next) => {
        res.status(500);
        res.send(""error from proxy"");
      });

      proxy.get(""/get"", (proxyReq, res) => {
        res.send(""GET method from proxy"");
      });

      proxy.head(""/head"", (proxyReq, res) => {
        res.send(""HEAD method from proxy"");
      });

      proxy.post(""/post-x-www-form-urlencoded"", (proxyReq, res) => {
        const { id } = proxyReq.body;

        res.status(200).send(`POST method from proxy (id: ${id})`);
      });

      proxy.post(""/post-application-json"", (proxyReq, res) => {
        const { id } = proxyReq.body;

        res.status(200).send({ answer: `POST method from proxy (id: ${id})` });
      });

      proxy.delete(""/delete"", (proxyReq, res) => {
        res.send(""DELETE method from proxy"");
      });

      listener = proxy.listen(port1);
      req = request(server.app);
    })",snuts
/test/server/proxy-option.test.js,GeneralFixture,"{'startLine':625,'endLine':625}","beforeAll(async () => {
          const compiler = webpack(config);

          server = new Server(
            {
              webSocketServer: webSocketServerType,
              proxy: [
                {
                  context: ""/"",
                  target: `http://localhost:${port4}`,
                  ws: true,
                },
              ],
              port: port3,
            },
            compiler,
          );

          await server.start();

          webSocketServer = new WebSocketServer({ port: port4 });
          webSocketServer.on(""connection"", (connection) => {
            connection.on(""message"", (message) => {
              connection.send(message);
            });
          });
        })",snuts
/test/server/proxy-option.test.js,GeneralFixture,"{'startLine':634,'endLine':634}","beforeEach((done) => {
          ws = new WebSocket(`ws://localhost:${port3}/proxy3/socket`);

          ws.on(""message"", (message) => {
            responseMessage = message.toString();
            done();
          });

          ws.on(""open"", () => {
            ws.send(""foo"");
          });
        })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':366,'endLine':371}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':401,'endLine':406}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':436,'endLine':441}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':471,'endLine':476}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':524,'endLine':529}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':827,'endLine':832}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':879,'endLine':883}","it(""respects a proxy option when a request path is matched"", async () => {
        await req.get(""/my-path"");

        expect(customLogProvider.error).toHaveBeenCalledTimes(1);
      })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':931,'endLine':935}","it(""respects a proxy option when a request path is matched"", async () => {
        await req.get(""/my-path"");

        expect(customLogProvider.error).toHaveBeenCalledTimes(0);
      })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':985,'endLine':989}","it(""respects a proxy option when a request path is matched"", async () => {
        await req.get(""/my-path"");

        expect(customLogProvider.error).toHaveBeenCalledTimes(1);
      })",snuts
/test/server/proxy-option.test.js,IdenticalTestDescription,"{'startLine':1036,'endLine':1040}","it(""respects a proxy option when a request path is matched"", async () => {
        await req.get(""/my-path"");

        expect(customLogProvider.error).toHaveBeenCalledTimes(0);
      })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':743,'endLine':743}","it(""should log warning when can't open"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        port,
        open: true,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://localhost:${port}/`, {
      wait: false,
    });
    expect(loggerWarnSpy).toHaveBeenCalledWith(
      `Unable to open ""http://localhost:${port}/"" page. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':744,'endLine':744}","it(""should log warning when can't open"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        port,
        open: true,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://localhost:${port}/`, {
      wait: false,
    });
    expect(loggerWarnSpy).toHaveBeenCalledWith(
      `Unable to open ""http://localhost:${port}/"" page. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':777,'endLine':777}","it(""should log warning when can't open with string"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: ""index.html"",
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://localhost:${port}/index.html`, {
      wait: false,
    });
    expect(loggerWarnSpy).toHaveBeenCalledWith(
      `Unable to open ""http://localhost:${port}/index.html"" page. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':778,'endLine':778}","it(""should log warning when can't open with string"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: ""index.html"",
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://localhost:${port}/index.html`, {
      wait: false,
    });
    expect(loggerWarnSpy).toHaveBeenCalledWith(
      `Unable to open ""http://localhost:${port}/index.html"" page. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':811,'endLine':811}","it(""should log warning when can't open with object"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: ""index.html"",
          app: ""google-chrome"",
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://localhost:${port}/index.html`, {
      app: { name: ""google-chrome"" },
      wait: false,
    });
    expect(loggerWarnSpy).toHaveBeenCalledWith(
      `Unable to open ""http://localhost:${port}/index.html"" page in ""google-chrome"" app. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    loggerWarnSpy.mockRestore();
    getInfrastructureLoggerSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':812,'endLine':812}","it(""should log warning when can't open with object"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: ""index.html"",
          app: ""google-chrome"",
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://localhost:${port}/index.html`, {
      app: { name: ""google-chrome"" },
      wait: false,
    });
    expect(loggerWarnSpy).toHaveBeenCalledWith(
      `Unable to open ""http://localhost:${port}/index.html"" page in ""google-chrome"" app. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    loggerWarnSpy.mockRestore();
    getInfrastructureLoggerSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':849,'endLine':849}","it(""should log warning when can't open with object with the 'app' option with arguments"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: ""index.html"",
          app: {
            name: ""google-chrome"",
            arguments: [""--incognito"", ""--new-window""],
          },
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://localhost:${port}/index.html`, {
      app: {
        name: ""google-chrome"",
        arguments: [""--incognito"", ""--new-window""],
      },
      wait: false,
    });
    expect(loggerWarnSpy).toHaveBeenCalledWith(
      `Unable to open ""http://localhost:${port}/index.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':850,'endLine':850}","it(""should log warning when can't open with object with the 'app' option with arguments"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: ""index.html"",
          app: {
            name: ""google-chrome"",
            arguments: [""--incognito"", ""--new-window""],
          },
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://localhost:${port}/index.html`, {
      app: {
        name: ""google-chrome"",
        arguments: [""--incognito"", ""--new-window""],
      },
      wait: false,
    });
    expect(loggerWarnSpy).toHaveBeenCalledWith(
      `Unable to open ""http://localhost:${port}/index.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':893,'endLine':893}","it(""should log warning when can't open with object with the 'app' option with arguments #2"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: [""first.html"", `http://localhost:${port}/second.html`],
          app: {
            name: ""google-chrome"",
            arguments: [""--incognito"", ""--new-window""],
          },
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://localhost:${port}/first.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://localhost:${port}/second.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      1,
      `Unable to open ""http://localhost:${port}/first.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      2,
      `Unable to open ""http://localhost:${port}/second.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,NonFunctionalStatement,"{'startLine':894,'endLine':894}","it(""should log warning when can't open with object with the 'app' option with arguments #2"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: [""first.html"", `http://localhost:${port}/second.html`],
          app: {
            name: ""google-chrome"",
            arguments: [""--incognito"", ""--new-window""],
          },
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://localhost:${port}/first.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://localhost:${port}/second.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      1,
      `Unable to open ""http://localhost:${port}/first.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      2,
      `Unable to open ""http://localhost:${port}/second.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",snuts
/test/server/open-option.test.js,OnlyTest,"{'startLine':45,'endLine':60}","it.only(""should work with unspecified host"", async () => {
    const server = new Server(
      {
        open: true,
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://localhost:${port}/`, {
      wait: false,
    });
  })",snuts
/test/cli/basic.test.js,AnonymousTest,"{'startLine':24,'endLine':33}","it(""should work"", async () => {
      const { exitCode, stderr } = await testBin([
        // Ideally it should be empty to test without arguments, unfortunately it takes 8080 port and other test can failed
        ""--port"",
        port,
      ]);

      expect(exitCode).toBe(0);
      expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
    })",snuts
/test/cli/basic.test.js,ConditionalTestLogic,"{'startLine':91,'endLine':95}","it(""should exit the process when SIGINT is detected"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const examplePath = path.resolve(
        __dirname,
        ""../../examples/client/web-socket-url"",
      );
      const cp = execa(""node"", [""--port"", port, cliPath], { cwd: examplePath });

      cp.stdout.on(""data"", (data) => {
        const bits = data.toString();

        if (/main.js/.test(bits)) {
          expect(cp.pid).not.toBe(0);

          cp.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        done();
      });
    })",snuts
/test/cli/basic.test.js,ConditionalTestLogic,"{'startLine':114,'endLine':118}","it(""should exit the process when SIGINT is detected, even before the compilation is done"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");
      const cp = execa(""node"", [""--port"", port, cliPath], { cwd });

      let killed = false;

      cp.stdout.on(""data"", () => {
        if (!killed) {
          expect(cp.pid).not.toBe(0);

          cp.kill(""SIGINT"");
        }

        killed = true;
      });

      cp.on(""exit"", () => {
        done();
      });
    })",snuts
/test/cli/basic.test.js,ConditionalTestLogic,"{'startLine':148,'endLine':153}","it(""should exit the process when stdin ends if --watch-options-stdin"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const examplePath = path.resolve(
        __dirname,
        ""../../examples/client/web-socket-url"",
      );
      const cp = execa(
        ""node"",
        [cliPath, ""--port"", port, ""--watch-options-stdin""],
        {
          cwd: examplePath,
        },
      );

      cp.stdout.on(""data"", (data) => {
        const bits = data.toString();

        if (/main.js/.test(bits)) {
          expect(cp.pid).not.toBe(0);

          cp.stdin.write(""hello"");
          cp.stdin.end(""world"");
        }
      });

      cp.on(""exit"", () => {
        done();
      });
    })",snuts
/test/cli/basic.test.js,ConditionalTestLogic,"{'startLine':184,'endLine':189}","it(""should exit the process when stdin ends if --watch-options-stdin, even before the compilation is done"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");
      const cp = execa(
        ""node"",
        [cliPath, ""--port"", port, ""--watch-options-stdin""],
        { cwd },
      );

      let killed = false;

      cp.on(""error"", (error) => {
        done(error);
      });

      cp.stdin.on(""error"", (error) => {
        done(error);
      });

      cp.stdout.on(""data"", () => {
        if (!killed) {
          expect(cp.pid).not.toBe(0);

          cp.stdin.write(""hello"");
          cp.stdin.end(""world"");
        }

        killed = true;
      });

      cp.on(""exit"", () => {
        done();
      });
    })",snuts
/test/e2e/web-socket-communication.test.js,ConditionalTestLogic,"{'startLine':195,'endLine':197}","it('should work and do heartbeat using (""ws"" web socket server)', async () => {
    WebsocketServer.heartbeatInterval = 100;

    const compiler = webpack(config);
    const devServerOptions = {
      port,
      webSocketServer: ""ws"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    server.webSocketServer.heartbeatInterval = 100;

    let opened = false;
    let received = false;

    await new Promise((resolve, reject) => {
      const ws = new WebSocket(`ws://localhost:${devServerOptions.port}/ws`, {
        headers: {
          host: `localhost:${devServerOptions.port}`,
          origin: `http://localhost:${devServerOptions.port}`,
        },
      });

      ws.on(""open"", () => {
        opened = true;
      });

      ws.on(""error"", (error) => {
        reject(error);
      });

      ws.on(""ping"", () => {
        if (opened && received) {
          ws.close();
        }
      });

      ws.on(""message"", (data) => {
        const message = JSON.parse(data);

        if (message.type === ""ok"") {
          received = true;
        }
      });

      ws.on(""close"", () => {
        resolve();
      });
    });

    expect(opened).toBe(true);
    expect(received).toBe(true);

    await server.stop();
  })",snuts
/test/e2e/web-socket-communication.test.js,ConditionalTestLogic,"{'startLine':203,'endLine':205}","it('should work and do heartbeat using (""ws"" web socket server)', async () => {
    WebsocketServer.heartbeatInterval = 100;

    const compiler = webpack(config);
    const devServerOptions = {
      port,
      webSocketServer: ""ws"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    server.webSocketServer.heartbeatInterval = 100;

    let opened = false;
    let received = false;

    await new Promise((resolve, reject) => {
      const ws = new WebSocket(`ws://localhost:${devServerOptions.port}/ws`, {
        headers: {
          host: `localhost:${devServerOptions.port}`,
          origin: `http://localhost:${devServerOptions.port}`,
        },
      });

      ws.on(""open"", () => {
        opened = true;
      });

      ws.on(""error"", (error) => {
        reject(error);
      });

      ws.on(""ping"", () => {
        if (opened && received) {
          ws.close();
        }
      });

      ws.on(""message"", (data) => {
        const message = JSON.parse(data);

        if (message.type === ""ok"") {
          received = true;
        }
      });

      ws.on(""close"", () => {
        resolve();
      });
    });

    expect(opened).toBe(true);
    expect(received).toBe(true);

    await server.stop();
  })",snuts
/test/e2e/watch-files.test.js,GeneralFixture,"{'startLine':614,'endLine':614}","beforeEach(async () => {
          chokidarMock.mockClear();

          compiler = webpack(config);

          server = new Server(
            {
              watchFiles: {
                paths: file,
                options: optionCase,
              },
              port,
            },
            compiler,
          );

          await server.start();

          ({ page, browser } = await runBrowser());

          pageErrors = [];
          consoleMessages = [];
        })",snuts
/test/e2e/watch-files.test.js,IdenticalTestDescription,"{'startLine':123,'endLine':157}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""Kurosaki Ichigo"", ""utf8"");

      await new Promise((resolve) => {
        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          resolve();
        });
      });
    })",snuts
/test/e2e/watch-files.test.js,IdenticalTestDescription,"{'startLine':194,'endLine':228}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""Kurosaki Ichigo"", ""utf8"");

      await new Promise((resolve) => {
        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          resolve();
        });
      });
    })",snuts
/test/e2e/watch-files.test.js,IdenticalTestDescription,"{'startLine':270,'endLine':309}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      await new Promise((resolve) => {
        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(nonExistFile);
          resolve();
        });

        // create file content
        setTimeout(() => {
          fs.writeFileSync(nonExistFile, ""Kurosaki Ichigo"", ""utf8"");
          // change file content
          setTimeout(() => {
            fs.writeFileSync(nonExistFile, ""Kurosaki Ichigo"", ""utf8"");
          }, 1000);
        }, 1000);
      });
    })",snuts
/test/e2e/watch-files.test.js,IdenticalTestDescription,"{'startLine':346,'endLine':380}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""Kurosaki Ichigo"", ""utf8"");

      await new Promise((resolve) => {
        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          resolve();
        });
      });
    })",snuts
/test/e2e/watch-files.test.js,IdenticalTestDescription,"{'startLine':419,'endLine':461}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        const expected = [file, other];
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(expected.includes(changedPath)).toBeTruthy();

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",snuts
/test/e2e/watch-files.test.js,IdenticalTestDescription,"{'startLine':500,'endLine':553}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
        server.staticWatchers[1].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(other);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",snuts
/test/e2e/watch-files.test.js,IdenticalTestDescription,"{'startLine':641,'endLine':678}","it(""should reload when file content is changed"", async () => {
          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          // should pass correct options to chokidar config
          expect(chokidarMock.mock.calls[0][1]).toMatchSnapshot();

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");

          // change file content
          fs.writeFileSync(file, ""Kurosaki Ichigo"", ""utf8"");

          await new Promise((resolve) => {
            server.staticWatchers[0].on(""change"", async (changedPath) => {
              // page reload
              await page.waitForNavigation({ waitUntil: ""networkidle0"" });

              expect(changedPath).toBe(file);

              resolve();
            });
          });
        })",snuts
/test/e2e/watch-files.test.js,ConditionalTestLogic,"{'startLine':456,'endLine':458}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        const expected = [file, other];
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(expected.includes(changedPath)).toBeTruthy();

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",snuts
/test/e2e/watch-files.test.js,ConditionalTestLogic,"{'startLine':536,'endLine':538}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
        server.staticWatchers[1].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(other);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",snuts
/test/e2e/watch-files.test.js,ConditionalTestLogic,"{'startLine':548,'endLine':550}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
        server.staticWatchers[1].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(other);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",snuts
/test/e2e/static-public-path.test.js,GeneralFixture,"{'startLine':959,'endLine':959}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          static: [
            {
              directory: publicDirectory,
              publicPath: staticPublicPath,
              watch: true,
            },
            {
              directory: otherPublicDirectory,
              publicPath: [staticPublicPath, otherStaticPublicPath],
              watch: true,
            },
          ],
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/static-public-path.test.js,GeneralFixture,"{'startLine':961,'endLine':978}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          static: [
            {
              directory: publicDirectory,
              publicPath: staticPublicPath,
              watch: true,
            },
            {
              directory: otherPublicDirectory,
              publicPath: [staticPublicPath, otherStaticPublicPath],
              watch: true,
            },
          ],
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/static-public-path.test.js,GeneralFixture,"{'startLine':490,'endLine':492}","beforeEach(async () => {
      cwdSpy = jest
        .spyOn(process, ""cwd"")
        .mockImplementation(() => staticDirectory);

      compiler = webpack(config);

      server = new Server(
        {
          static: {
            publicPath: staticPublicPath,
          },
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/static-public-path.test.js,IdenticalTestDescription,"{'startLine':264,'endLine':289}","it(""should show Heyo. because bar has index.html inside it (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(
        `http://localhost:${port}${staticPublicPath}/bar`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/static-public-path.test.js,IdenticalTestDescription,"{'startLine':329,'endLine':354}","it(""should list the files inside the assets folder (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(
        `http://localhost:${port}${staticPublicPath}/assets`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toContain(""other.txt"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/static-public-path.test.js,IdenticalTestDescription,"{'startLine':356,'endLine':381}","it(""should show Heyo. because bar has index.html inside it (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(
        `http://localhost:${port}${staticPublicPath}/bar`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/static-public-path.test.js,IdenticalTestDescription,"{'startLine':993,'endLine':1018}","it(""should handle request to the index of first path"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(
        `http://localhost:${port}${staticPublicPath}/`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/static-public-path.test.js,IdenticalTestDescription,"{'startLine':1020,'endLine':1045}","it(""should handle request to the other file of first path"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(
        `http://localhost:${port}${staticPublicPath}/other.html`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/static-public-path.test.js,IdenticalTestDescription,"{'startLine':1074,'endLine':1099}","it(""should handle request to the /foo route of second path"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(
        `http://localhost:${port}${otherStaticPublicPath}/foo.html`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/static-public-path.test.js,ConditionalTestLogic,"{'startLine':683,'endLine':683}","it(""should handle HEAD request"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (interceptedRequest) => {
          if (interceptedRequest.isInterceptResolutionHandled()) return;

          interceptedRequest.continue({ method: ""HEAD"" });
        });

      const response = await page.goto(
        `http://localhost:${port}${staticPublicPath}/`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/static-directory.test.js,AnonymousTest,"{'startLine':117,'endLine':136}","it(""watches node_modules"", (done) => {
      const filePath = path.join(publicDirectory, ""node_modules"", ""index.html"");

      fs.writeFileSync(filePath, ""foo"", ""utf8"");

      // chokidar emitted a change,
      // meaning it watched the file correctly
      server.staticWatchers[0].on(""change"", (filepath) => {
        expect(typeof filepath).toBe(""string"");

        fs.unlinkSync(filePath);

        done();
      });

      // change a file manually
      setTimeout(() => {
        fs.writeFileSync(filePath, ""bar"", ""utf8"");
      }, 1000);
    })",snuts
/test/e2e/static-directory.test.js,GeneralFixture,"{'startLine':650,'endLine':650}","beforeEach(async () => {
      // This is a somewhat weird test, but it is important that we mock
      // the PWD here, and test if /other.html in our ""fake"" PWD really is not requested.
      jest.spyOn(process, ""cwd"").mockImplementation(() => publicDirectory);

      compiler = webpack(config);

      server = new Server(
        {
          static: false,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/static-directory.test.js,IdenticalTestDescription,"{'startLine':287,'endLine':309}","it(""should show Heyo. because bar has index.html inside it (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/bar/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/static-directory.test.js,IdenticalTestDescription,"{'startLine':347,'endLine':372}","it(""should list the files inside the assets folder (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/assets`, {
        waitUntil: ""networkidle0"",
      });

      const text = await response.text();

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(text).toContain(""example.txt"");
      expect(text).toContain(""other.txt"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/static-directory.test.js,IdenticalTestDescription,"{'startLine':374,'endLine':396}","it(""should show Heyo. because bar has index.html inside it (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/bar`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/setup-middlewares.test.js,GeneralFixture,"{'startLine':18,'endLine':18}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        setupMiddlewares: (middlewares, devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          devServer.app.use(""/setup-middleware/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option GET"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option POST"");
              return;
            }

            return next();
          });

          middlewares.push({
            name: ""hello-world-test-two"",
            middleware: (req, res, next) => {
              if (req.url !== ""/foo/bar/baz"") {
                next();
                return;
              }

              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World without path!"");
            },
          });
          middlewares.push({
            name: ""hello-world-test-one"",
            path: ""/foo/bar"",
            middleware: (req, res) => {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World with path!"");
            },
          });
          middlewares.push((req, res) => {
            res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
            res.end(""Hello World as function!"");
          });

          return middlewares;
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",snuts
/test/e2e/setup-middlewares.test.js,GeneralFixture,"{'startLine':19,'endLine':70}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        setupMiddlewares: (middlewares, devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          devServer.app.use(""/setup-middleware/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option GET"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option POST"");
              return;
            }

            return next();
          });

          middlewares.push({
            name: ""hello-world-test-two"",
            middleware: (req, res, next) => {
              if (req.url !== ""/foo/bar/baz"") {
                next();
                return;
              }

              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World without path!"");
            },
          });
          middlewares.push({
            name: ""hello-world-test-one"",
            path: ""/foo/bar"",
            middleware: (req, res) => {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World with path!"");
            },
          });
          middlewares.push((req, res) => {
            res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
            res.end(""Hello World as function!"");
          });

          return middlewares;
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",snuts
/test/e2e/setup-middlewares.test.js,ConditionalTestLogic,"{'startLine':157,'endLine':157}","it(""should handle POST request to /setup-middleware/some/path route"", async () => {
    await page.setRequestInterception(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      })
      .on(""request"", (interceptedRequest) => {
        if (interceptedRequest.isInterceptResolutionHandled()) return;

        interceptedRequest.continue({ method: ""POST"" });
      });

    const response = await page.goto(
      `http://localhost:${port}/setup-middleware/some/path`,
      {
        waitUntil: ""networkidle0"",
      },
    );

    expect(response.headers()[""content-type""]).toMatchSnapshot(
      ""response headers content-type"",
    );
    expect(response.status()).toMatchSnapshot(""response status"");
    expect(await response.text()).toMatchSnapshot(""response text"");
    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );
    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",snuts
/test/e2e/setup-middlewares.test.js,VerboseStatement,"{'startLine':85,'endLine':144}","it(""should handle GET request to /setup-middleware/some/path route"", async () => {
    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(
      `http://localhost:${port}/setup-middleware/some/path`,
      {
        waitUntil: ""networkidle0"",
      },
    );

    expect(response.headers()[""content-type""]).toMatchSnapshot(
      ""response headers content-type"",
    );
    expect(response.status()).toMatchSnapshot(""response status"");
    expect(await response.text()).toMatchSnapshot(""response text"");

    const response1 = await page.goto(`http://localhost:${port}/foo/bar`, {
      waitUntil: ""networkidle0"",
    });

    expect(response1.headers()[""content-type""]).toMatchSnapshot(
      ""response headers content-type"",
    );
    expect(response1.status()).toMatchSnapshot(""response status"");
    expect(await response1.text()).toMatchSnapshot(""response text"");

    const response2 = await page.goto(`http://localhost:${port}/foo/bar/baz`, {
      waitUntil: ""networkidle0"",
    });

    expect(response2.headers()[""content-type""]).toMatchSnapshot(
      ""response headers content-type"",
    );
    expect(response2.status()).toMatchSnapshot(""response status"");
    expect(await response2.text()).toMatchSnapshot(""response text"");

    const response3 = await page.goto(
      `http://localhost:${port}/setup-middleware/unknown`,
      {
        waitUntil: ""networkidle0"",
      },
    );

    expect(response3.headers()[""content-type""]).toMatchSnapshot(
      ""response headers content-type"",
    );
    expect(response3.status()).toMatchSnapshot(""response status"");
    expect(await response3.text()).toMatchSnapshot(""response text"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );
    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",snuts
/test/e2e/setup-exit-signals.test.js,GeneralFixture,"{'startLine':26,'endLine':26}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",snuts
/test/e2e/setup-exit-signals.test.js,GeneralFixture,"{'startLine':28,'endLine':34}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",snuts
/test/e2e/setup-exit-signals.test.js,GeneralFixture,"{'startLine':40,'endLine':40}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",snuts
/test/e2e/setup-exit-signals.test.js,GeneralFixture,"{'startLine':41,'endLine':41}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",snuts
/test/e2e/setup-exit-signals.test.js,GeneralFixture,"{'startLine':42,'endLine':42}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",snuts
/test/e2e/setup-exit-signals.test.js,GeneralFixture,"{'startLine':44,'endLine':46}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",snuts
/test/e2e/setup-exit-signals.test.js,GeneralFixture,"{'startLine':48,'endLine':50}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",snuts
/test/e2e/setup-exit-signals.test.js,GeneralFixture,"{'startLine':52,'endLine':52}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",snuts
/test/e2e/setup-exit-signals.test.js,NonFunctionalStatement,"{'startLine':50,'endLine':50}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",snuts
/test/e2e/server.test.js,GeneralFixture,"{'startLine':1285,'endLine':1285}","beforeEach(async () => {
        compiler = webpack(config);

        createServerSpy = jest.spyOn(customHTTP, ""createServer"");

        server = new Server(
          {
            static: {
              directory: staticDirectory,
              watch: false,
            },
            server: {
              type: path.join(__dirname, ""../helpers/custom-http.js""),
              options: {
                maxHeaderSize: 16384,
              },
            },
            port,
          },
          compiler,
        );

        await server.start();

        ({ page, browser } = await runBrowser());

        pageErrors = [];
        consoleMessages = [];
      })",snuts
/test/e2e/server.test.js,GeneralFixture,"{'startLine':1289,'endLine':1304}","beforeEach(async () => {
        compiler = webpack(config);

        createServerSpy = jest.spyOn(customHTTP, ""createServer"");

        server = new Server(
          {
            static: {
              directory: staticDirectory,
              watch: false,
            },
            server: {
              type: path.join(__dirname, ""../helpers/custom-http.js""),
              options: {
                maxHeaderSize: 16384,
              },
            },
            port,
          },
          compiler,
        );

        await server.start();

        ({ page, browser } = await runBrowser());

        pageErrors = [];
        consoleMessages = [];
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':126,'endLine':154}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        expect(HTTPVersion).not.toBe(""h2"");

        expect(response.status()).toMatchSnapshot(""response status"");

        expect(await response.text()).toMatchSnapshot(""response text"");

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':186,'endLine':214}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        expect(HTTPVersion).not.toBe(""h2"");

        expect(response.status()).toMatchSnapshot(""response status"");

        expect(await response.text()).toMatchSnapshot(""response text"");

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':246,'endLine':268}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        expect(HTTPVersion).toBe(""h2"");
        expect(response.status()).toBe(200);
        expect((await response.text()).trim()).toBe(""Heyo."");
        expect(consoleMessages).toHaveLength(0);
        expect(pageErrors).toHaveLength(0);
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':331,'endLine':353}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':422,'endLine':444}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':511,'endLine':533}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':609,'endLine':631}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':684,'endLine':706}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':759,'endLine':781}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':841,'endLine':858}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(response.status()).toBe(200);
        expect(await response.text()).toContain(""Heyo"");
        expect(consoleMessages.map((message) => message.text())).toEqual([]);
        expect(pageErrors).toEqual([]);
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':927,'endLine':949}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':1023,'endLine':1045}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':1107,'endLine':1129}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':1188,'endLine':1193}","it(""should handle GET request to index route (/)"", async () => {
        const response = await req.get(""/"");

        expect(response.status).toMatchSnapshot(""response status"");
        expect(response.text).toMatchSnapshot(""response text"");
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':1247,'endLine':1272}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        const options = normalizeOptions(createServerSpy.mock.calls[0][0]);

        expect(HTTPVersion).toBe(""h2"");
        expect(options.spdy).toEqual({ protocols: [""h2"", ""http/1.1""] });
        expect(response.status()).toBe(200);
        expect((await response.text()).trim()).toBe(""Heyo."");
        expect(consoleMessages).toHaveLength(0);
        expect(pageErrors).toHaveLength(0);
      })",snuts
/test/e2e/server.test.js,IdenticalTestDescription,"{'startLine':1321,'endLine':1348}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        expect(HTTPVersion).toBe(""http/1.1"");
        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""http options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",snuts
/test/e2e/range-header.test.js,GeneralFixture,"{'startLine':14,'endLine':14}","beforeAll(async () => {
    compiler = webpack(config);

    server = new Server({ port }, compiler);

    await server.start();
  })",snuts
/test/e2e/progress.test.js,ConditionalTestLogic,"{'startLine':44,'endLine':44}","it(""should work and log progress in a browser console"", async () => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");

    const compiler = webpack(reloadConfig);
    const devServerOptions = {
      port,
      client: {
        progress: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    try {
      const { page, browser } = await runBrowser();

      const consoleMessages = [];

      try {
        let doHotUpdate = false;

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""request"", (interceptedRequest) => {
            if (interceptedRequest.isInterceptResolutionHandled()) return;

            if (/\.hot-update\.(json|js)$/.test(interceptedRequest.url())) {
              doHotUpdate = true;
            }
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        fs.writeFileSync(
          cssFilePath,
          ""body { background-color: rgb(255, 0, 0); }"",
        );

        await new Promise((resolve) => {
          const timer = setInterval(() => {
            if (doHotUpdate) {
              clearInterval(timer);

              resolve();
            }
          }, 100);
        });
      } finally {
        await browser.close();
      }

      const progressConsoleMessage = consoleMessages.filter((message) =>
        /^\[webpack-dev-server\] (\[[a-zA-Z]+\] )?[0-9]{1,3}% - /.test(
          message.text(),
        ),
      );

      expect(progressConsoleMessage.length).toBeGreaterThan(0);
    } finally {
      fs.unlinkSync(cssFilePath);

      await server.stop();
    }
  })",snuts
/test/e2e/progress.test.js,ConditionalTestLogic,"{'startLine':46,'endLine':48}","it(""should work and log progress in a browser console"", async () => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");

    const compiler = webpack(reloadConfig);
    const devServerOptions = {
      port,
      client: {
        progress: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    try {
      const { page, browser } = await runBrowser();

      const consoleMessages = [];

      try {
        let doHotUpdate = false;

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""request"", (interceptedRequest) => {
            if (interceptedRequest.isInterceptResolutionHandled()) return;

            if (/\.hot-update\.(json|js)$/.test(interceptedRequest.url())) {
              doHotUpdate = true;
            }
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        fs.writeFileSync(
          cssFilePath,
          ""body { background-color: rgb(255, 0, 0); }"",
        );

        await new Promise((resolve) => {
          const timer = setInterval(() => {
            if (doHotUpdate) {
              clearInterval(timer);

              resolve();
            }
          }, 100);
        });
      } finally {
        await browser.close();
      }

      const progressConsoleMessage = consoleMessages.filter((message) =>
        /^\[webpack-dev-server\] (\[[a-zA-Z]+\] )?[0-9]{1,3}% - /.test(
          message.text(),
        ),
      );

      expect(progressConsoleMessage.length).toBeGreaterThan(0);
    } finally {
      fs.unlinkSync(cssFilePath);

      await server.stop();
    }
  })",snuts
/test/e2e/progress.test.js,ConditionalTestLogic,"{'startLine':62,'endLine':66}","it(""should work and log progress in a browser console"", async () => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");

    const compiler = webpack(reloadConfig);
    const devServerOptions = {
      port,
      client: {
        progress: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    try {
      const { page, browser } = await runBrowser();

      const consoleMessages = [];

      try {
        let doHotUpdate = false;

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""request"", (interceptedRequest) => {
            if (interceptedRequest.isInterceptResolutionHandled()) return;

            if (/\.hot-update\.(json|js)$/.test(interceptedRequest.url())) {
              doHotUpdate = true;
            }
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        fs.writeFileSync(
          cssFilePath,
          ""body { background-color: rgb(255, 0, 0); }"",
        );

        await new Promise((resolve) => {
          const timer = setInterval(() => {
            if (doHotUpdate) {
              clearInterval(timer);

              resolve();
            }
          }, 100);
        });
      } finally {
        await browser.close();
      }

      const progressConsoleMessage = consoleMessages.filter((message) =>
        /^\[webpack-dev-server\] (\[[a-zA-Z]+\] )?[0-9]{1,3}% - /.test(
          message.text(),
        ),
      );

      expect(progressConsoleMessage.length).toBeGreaterThan(0);
    } finally {
      fs.unlinkSync(cssFilePath);

      await server.stop();
    }
  })",snuts
/test/e2e/overlay.test.js,ConditionalTestLogic,"{'startLine':1545,'endLine':1549}","it(""should show a warning and hide them after closing connection"", async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = { port };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      await server.stop();

      await new Promise((resolve) => {
        const interval = setInterval(() => {
          if (consoleMessages.includes(""[webpack-dev-server] Disconnected!"")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      const pageHtmlAfterClose = await page.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtmlAfterClose, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
    }
  })",snuts
/test/e2e/options-middleware.test.js,ConditionalTestLogic,"{'startLine':76,'endLine':78}","it(""should response with 200 http code"", async () => {
    const compiler = webpack(config);
    const [portForServer, portForApp] = port;
    const closeApp = await (async () => {
      const { resolve, waiting } = createWaiting();
      const app = new Express();

      app.get(""/"", (req, res) => {
        res.sendStatus(200);
      });

      const server = app.listen(portForApp, () => {
        resolve();
      });

      await waiting;

      return async () => {
        const { resolve: resolve2, waiting: waiting2 } = createWaiting();

        server.close(() => {
          resolve2();
        });

        await waiting2;
      };
    })();
    const server = new Server(
      {
        port: portForServer,
        headers: {
          ""Access-Control-Allow-Origin"": ""*"",
          ""Access-Control-Allow-Headers"": ""*"",
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();
    const prefixUrl = ""http://localhost"";
    const htmlUrl = `${prefixUrl}:${portForServer}/test.html`;
    const appUrl = `${prefixUrl}:${portForApp}`;

    try {
      const responseStatus = [];

      page.on(""response"", (res) => {
        if (/test\.html$/.test(res.url())) {
          responseStatus.push(res.status());
        }
      });

      await page.goto(appUrl, {
        waitUntil: ""networkidle0"",
      });

      await page.evaluate(
        (url) =>
          globalThis.fetch(url, {
            headers: {
              ""another-header"": ""1"",
            },
          }),
        htmlUrl,
      );

      expect(responseStatus.sort()).toEqual([200, 204]);
    } finally {
      await browser.close();
      await server.stop();
      await closeApp();
    }
  })",snuts
/test/e2e/on-listening.test.js,GeneralFixture,"{'startLine':19,'endLine':19}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        onListening: (devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          onListeningIsRunning = true;

          devServer.app.use(""/listening/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening POST"");
              return;
            }

            return next();
          });
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",snuts
/test/e2e/on-listening.test.js,GeneralFixture,"{'startLine':20,'endLine':46}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        onListening: (devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          onListeningIsRunning = true;

          devServer.app.use(""/listening/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening POST"");
              return;
            }

            return next();
          });
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",snuts
/test/e2e/on-listening.test.js,ConditionalTestLogic,"{'startLine':105,'endLine':105}","it(""should handle POST request to /listening/some/path route"", async () => {
    await page.setRequestInterception(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      })
      .on(""request"", (interceptedRequest) => {
        if (interceptedRequest.isInterceptResolutionHandled()) return;

        interceptedRequest.continue({ method: ""POST"" });
      });

    const response = await page.goto(
      `http://localhost:${port}/listening/some/path`,
      {
        waitUntil: ""networkidle0"",
      },
    );

    expect(onListeningIsRunning).toBe(true);

    expect(response.headers()[""content-type""]).toMatchSnapshot(
      ""response headers content-type"",
    );

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(await response.text()).toMatchSnapshot(""response text"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",snuts
/test/e2e/multi-compiler.test.js,ConditionalTestLogic,"{'startLine':127,'endLine':131}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",snuts
/test/e2e/multi-compiler.test.js,ConditionalTestLogic,"{'startLine':204,'endLine':208}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",snuts
/test/e2e/multi-compiler.test.js,ConditionalTestLogic,"{'startLine':477,'endLine':481}","it(""should work with universal configuration when hot and live reloads are enabled, and do hot reload for browser compiler by default when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",snuts
/test/e2e/multi-compiler.test.js,ConditionalTestLogic,"{'startLine':550,'endLine':554}","it(""should work with universal configuration when only hot reload is enabled, and do hot reload for browser compiler when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
    }
  })",snuts
/test/e2e/module-federation.test.js,GeneralFixture,"{'startLine':229,'endLine':229}","beforeEach(async () => {
      compiler = webpack(pluginConfig);
      server = new Server({ port }, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/module-federation.test.js,GeneralFixture,"{'startLine':230,'endLine':230}","beforeEach(async () => {
      compiler = webpack(pluginConfig);
      server = new Server({ port }, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/module-federation.test.js,IdenticalTestDescription,"{'startLine':97,'endLine':127}","it(""should use the last entry export"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const textContent = await response.text();

      expect(textContent).toContain(""entry1"");

      let exports;

      expect(() => {
        exports = requireFromString(textContent);
      }).not.toThrow();

      expect(exports).toBe(""entry2"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/module-federation.test.js,IdenticalTestDescription,"{'startLine':187,'endLine':217}","it(""should use the last entry export"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const textContent = await response.text();

      expect(textContent).toContain(""entry1"");

      let exports;

      expect(() => {
        exports = requireFromString(textContent);
      }).not.toThrow();

      expect(exports).toBe(""entry2"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/mime-types.test.js,GeneralFixture,"{'startLine':82,'endLine':82}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          devMiddleware: {
            mimeTypes: {
              custom: ""text/html"",
            },
          },
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/mime-types.test.js,GeneralFixture,"{'startLine':84,'endLine':94}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          devMiddleware: {
            mimeTypes: {
              custom: ""text/html"",
            },
          },
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/mime-types.test.js,IdenticalTestDescription,"{'startLine':109,'endLine':133}","it(""should request file with different js mime type"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/file.custom`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/hot-and-live-reload.test.js,GeneralFixture,"{'startLine':720,'endLine':726}","beforeEach(() => {
    compiler = webpack({
      ...config,
      devServer: { hot: false },
      plugins: [...config.plugins, new webpack.HotModuleReplacementPlugin()],
    });

    loggerWarnSpy = jest.fn();

    getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));
  })",snuts
/test/e2e/hot-and-live-reload.test.js,IdenticalTestDescription,"{'startLine':663,'endLine':702}","it(""should register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port }, compiler);

    await server.start();

    expect(compiler.options.plugins).toHaveLength(2);
    expect(pluginFound).toBe(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",snuts
/test/e2e/hot-and-live-reload.test.js,IdenticalTestDescription,"{'startLine':793,'endLine':831}","it(""should register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.compilers[0].hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port }, compiler);

    await server.start();

    expect(pluginFound).toBe(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",snuts
/test/e2e/hot-and-live-reload.test.js,ConditionalTestLogic,"{'startLine':602,'endLine':604}","it(""should register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port }, compiler);

    await server.start();

    expect(pluginFound).toBe(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",snuts
/test/e2e/hot-and-live-reload.test.js,ConditionalTestLogic,"{'startLine':668,'endLine':670}","it(""should register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port }, compiler);

    await server.start();

    expect(compiler.options.plugins).toHaveLength(2);
    expect(pluginFound).toBe(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",snuts
/test/e2e/hot-and-live-reload.test.js,ConditionalTestLogic,"{'startLine':798,'endLine':800}","it(""should register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.compilers[0].hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port }, compiler);

    await server.start();

    expect(pluginFound).toBe(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",snuts
/test/e2e/hot-and-live-reload.test.js,ConditionalTestLogic,"{'startLine':861,'endLine':863}","it(""should NOT register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port, hot: false }, compiler);

    await server.start();

    expect(pluginFound).toBe(false);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",snuts
/test/e2e/hot-and-live-reload.test.js,NonFunctionalStatement,"{'startLine':724,'endLine':724}","beforeEach(() => {
    compiler = webpack({
      ...config,
      devServer: { hot: false },
      plugins: [...config.plugins, new webpack.HotModuleReplacementPlugin()],
    });

    loggerWarnSpy = jest.fn();

    getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));
  })",snuts
/test/e2e/hot-and-live-reload.test.js,NonFunctionalStatement,"{'startLine':725,'endLine':725}","beforeEach(() => {
    compiler = webpack({
      ...config,
      devServer: { hot: false },
      plugins: [...config.plugins, new webpack.HotModuleReplacementPlugin()],
    });

    loggerWarnSpy = jest.fn();

    getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));
  })",snuts
/test/e2e/history-api-fallback.test.js,GeneralFixture,"{'startLine':592,'endLine':592}","beforeEach(async () => {
      compiler = webpack(config3);

      server = new Server(
        {
          static: path.resolve(
            __dirname,
            ""../fixtures/historyapifallback-3-config"",
          ),
          historyApiFallback: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/history-api-fallback.test.js,GeneralFixture,"{'startLine':594,'endLine':604}","beforeEach(async () => {
      compiler = webpack(config3);

      server = new Server(
        {
          static: path.resolve(
            __dirname,
            ""../fixtures/historyapifallback-3-config"",
          ),
          historyApiFallback: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/history-api-fallback.test.js,IdenticalTestDescription,"{'startLine':108,'endLine':134}","it(""should handle GET request to directory"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/foo`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/history-api-fallback.test.js,IdenticalTestDescription,"{'startLine':175,'endLine':201}","it(""should handle GET request to directory"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/foo`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/history-api-fallback.test.js,IdenticalTestDescription,"{'startLine':546,'endLine':580}","it(""request to directory and log"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/foo`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""response text"");

      expect(consoleSpy).toHaveBeenCalledWith(
        ""Rewriting"",
        ""GET"",
        ""/foo"",
        ""to"",
        ""/bar.html"",
      );

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/headers.test.js,GeneralFixture,"{'startLine':404,'endLine':404}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          headers: { ""X-Foo"": ""dev-server headers"" },
          port,
        },
        compiler,
      );

      await server.start();

      req = request(server.app);

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/headers.test.js,GeneralFixture,"{'startLine':406,'endLine':412}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          headers: { ""X-Foo"": ""dev-server headers"" },
          port,
        },
        compiler,
      );

      await server.start();

      req = request(server.app);

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/headers.test.js,IdenticalTestDescription,"{'startLine':111,'endLine':139}","it(""should handle GET request with headers"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.headers()[""x-foo""]).toMatchSnapshot(
        ""response headers x-foo"",
      );

      expect(response.headers()[""x-bar""]).toMatchSnapshot(
        ""response headers x-bar"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/headers.test.js,IdenticalTestDescription,"{'startLine':301,'endLine':329}","it(""should handle GET request with headers"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.headers()[""x-foo""]).toMatchSnapshot(
        ""response headers x-foo"",
      );

      expect(response.headers()[""x-bar""]).toMatchSnapshot(
        ""response headers x-bar"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/headers.test.js,IdenticalTestDescription,"{'startLine':367,'endLine':391}","it(""should handle GET request with headers as a function"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.headers()[""x-foo""]).toMatchSnapshot(
        ""response headers x-foo"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/compress.test.js,GeneralFixture,"{'startLine':131,'endLine':131}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          compress: false,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/compress.test.js,GeneralFixture,"{'startLine':133,'endLine':139}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          compress: false,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/compress.test.js,IdenticalTestDescription,"{'startLine':95,'endLine':119}","it(""should handle GET request to bundle file"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(response.headers()[""content-encoding""]).toMatchSnapshot(
        ""response headers content-encoding"",
      );

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/compress.test.js,IdenticalTestDescription,"{'startLine':154,'endLine':178}","it(""should handle GET request to bundle file"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(response.headers()[""content-encoding""]).toMatchSnapshot(
        ""response headers content-encoding"",
      );

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/client.test.js,GeneralFixture,"{'startLine':217,'endLine':217}","beforeEach(async () => {
      compiler = webpack(config);

      server = new OverrideServer(
        {
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());
    })",snuts
/test/e2e/client.test.js,IdenticalTestDescription,"{'startLine':236,'endLine':246}","it(""should disable client entry"", async () => {
      const response = await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      const content = await response.text();
      expect(content).toContain(""CustomClientEntry.js"");
      expect(content).toContain(""CustomClientHotEntry.js"");
    })",snuts
/test/e2e/client-reconnect.test.js,GeneralFixture,"{'startLine':145,'endLine':145}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server({ port, client: { reconnect: 2 } }, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/client-reconnect.test.js,ConditionalTestLogic,"{'startLine':62,'endLine':66}","it(""should try to reconnect unlimited times"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      try {
        expect(response.status()).toMatchSnapshot(""response status"");
      } finally {
        await server.stop();
      }

      let interval;

      await new Promise((resolve) => {
        interval = setInterval(() => {
          const retryingMessages = consoleMessages.filter((message) =>
            message.text().includes(""Trying to reconnect...""),
          );

          if (retryingMessages.length >= 5) {
            clearInterval(interval);

            resolve();
          }
        }, 1000);
      });

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/built-in-routes.test.js,GeneralFixture,"{'startLine':256,'endLine':256}","beforeEach(async () => {
      compiler = webpack(multiConfig);
      server = new Server({ port }, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/built-in-routes.test.js,GeneralFixture,"{'startLine':257,'endLine':257}","beforeEach(async () => {
      compiler = webpack(multiConfig);
      server = new Server({ port }, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/built-in-routes.test.js,IdenticalTestDescription,"{'startLine':272,'endLine':301}","it(""should handle GET request to directory index and list all middleware directories"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(
        `http://localhost:${port}/webpack-dev-server/`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""directory list"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/built-in-routes.test.js,ConditionalTestLogic,"{'startLine':74,'endLine':74}","it(""should handles HEAD request to sockjs bundle"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (interceptedRequest) => {
          if (interceptedRequest.isInterceptResolutionHandled()) return;

          interceptedRequest.continue({ method: ""HEAD"" }, 10);
        });

      const response = await page.goto(
        `http://localhost:${port}/__webpack_dev_server__/sockjs.bundle.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/built-in-routes.test.js,ConditionalTestLogic,"{'startLine':166,'endLine':166}","it(""should handle HEAD request to directory index"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (interceptedRequest) => {
          if (interceptedRequest.isInterceptResolutionHandled()) return;

          interceptedRequest.continue({ method: ""HEAD"" });
        });

      const response = await page.goto(
        `http://localhost:${port}/webpack-dev-server/`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""directory list"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/built-in-routes.test.js,ConditionalTestLogic,"{'startLine':226,'endLine':226}","it(""should handle HEAD request to magic async chunk"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (interceptedRequest) => {
          if (interceptedRequest.isInterceptResolutionHandled()) return;

          interceptedRequest.continue({ method: ""HEAD"" });
        });

      const response = await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
    })",snuts
/test/e2e/bonjour.test.js,GeneralFixture,"{'startLine':261,'endLine':261}","beforeEach(async () => {
      jest.mock(""bonjour-service"", () => ({
        Bonjour: jest.fn().mockImplementation(() => ({
          publish: mockPublish,
          unpublishAll: mockUnpublishAll,
          destroy: mockDestroy,
        })),
      }));

      compiler = webpack(config);

      server = new Server(
        {
          port,
          bonjour: {
            type: ""http"",
            protocol: ""udp"",
          },
          server: {
            type: ""https"",
          },
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/bonjour.test.js,GeneralFixture,"{'startLine':263,'endLine':275}","beforeEach(async () => {
      jest.mock(""bonjour-service"", () => ({
        Bonjour: jest.fn().mockImplementation(() => ({
          publish: mockPublish,
          unpublishAll: mockUnpublishAll,
          destroy: mockDestroy,
        })),
      }));

      compiler = webpack(config);

      server = new Server(
        {
          port,
          bonjour: {
            type: ""http"",
            protocol: ""udp"",
          },
          server: {
            type: ""https"",
          },
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
    })",snuts
/test/e2e/bonjour.test.js,IdenticalTestDescription,"{'startLine':290,'endLine':323}","it(""should apply bonjour options"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`https://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(mockPublish).toHaveBeenCalledTimes(1);

      expect(mockPublish).toHaveBeenCalledWith({
        name: `Webpack Dev Server ${os.hostname()}:${port}`,
        port,
        type: ""http"",
        protocol: ""udp"",
        subtypes: [""webpack""],
      });

      expect(mockUnpublishAll).toHaveBeenCalledTimes(0);
      expect(mockDestroy).toHaveBeenCalledTimes(0);

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/app.test.js,GeneralFixture,"{'startLine':110,'endLine':110}","beforeEach(async () => {
        compiler = webpack(config);

        devServer = new Server(
          {
            static: {
              directory: staticDirectory,
              watch: false,
            },
            app,
            server,
            port,
            setupMiddlewares:
              typeof setupMiddlewares !== ""undefined""
                ? setupMiddlewares
                : undefined,
          },
          compiler,
        );

        await devServer.start();

        ({ page, browser } = await runBrowser());

        pageErrors = [];
        consoleMessages = [];
      })",snuts
/test/e2e/app.test.js,ConditionalTestLogic,"{'startLine':168,'endLine':176}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const pageUrl = devServer.isTlsServer
          ? `https://localhost:${port}/`
          : `http://localhost:${port}/`;

        const response = await page.goto(pageUrl, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        if (
          server === ""spdy"" ||
          server === ""http2"" ||
          (server.options && server.options.allowHTTP1)
        ) {
          expect(HTTPVersion).toBe(""h2"");
        } else {
          expect(HTTPVersion).toBe(""http/1.1"");
        }

        expect(response.status()).toBe(200);

        const text = await response.text();

        expect(text).toContain(
          '<script type=""text/javascript"" charset=""utf-8"" src=""/main.js""></script>',
        );
        expect(consoleMessages.map((message) => message.text())).toEqual([
          ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
          ""[HMR] Waiting for update signal from WDS..."",
          ""Hey."",
        ]);
        expect(pageErrors).toHaveLength(0);
      })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':475,'endLine':491}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':484,'endLine':490}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':497,'endLine':502}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':551,'endLine':567}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':560,'endLine':566}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':573,'endLine':578}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':627,'endLine':643}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':636,'endLine':642}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':650,'endLine':655}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':704,'endLine':720}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':713,'endLine':719}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':727,'endLine':732}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':783,'endLine':799}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':792,'endLine':798}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':803,'endLine':819}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':812,'endLine':818}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':867,'endLine':869}","it(""should allow access for every requests using an IP"", () => {
      const options = {
        allowedHosts: ""all"",
      };

      const tests = [
        ""192.168.1.123"",
        ""192.168.1.2:8080"",
        ""[::1]"",
        ""[::1]:8080"",
        ""[ad42::1de2:54c2:c2fa:1234]"",
        ""[ad42::1de2:54c2:c2fa:1234]:8080"",
      ];

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      let isValidHost = true;

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          isValidHost = false;
        }
      }

      expect(isValidHost).toBe(true);
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':929,'endLine':931}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':939,'endLine':942}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':957,'endLine':973}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':966,'endLine':972}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':977,'endLine':993}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",snuts
/test/e2e/api.test.js,ConditionalTestLogic,"{'startLine':986,'endLine':992}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",snuts
/test/e2e/allowed-hosts.test.js,ConditionalTestLogic,"{'startLine':1605,'endLine':1607}","it(""should always allow `localhost` if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/allowed-hosts.test.js,ConditionalTestLogic,"{'startLine':1646,'endLine':1648}","it(""should always allow `localhost` subdomain if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""app.localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/allowed-hosts.test.js,ConditionalTestLogic,"{'startLine':1689,'endLine':1691}","it(""should always allow value from the `host` options if options.allowedHosts is auto"", async () => {
      const networkIP = Server.internalIPSync(""v4"");
      const options = {
        host: networkIP,
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: networkIP,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://${networkIP}:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/allowed-hosts.test.js,ConditionalTestLogic,"{'startLine':1733,'endLine':1735}","it(""should always allow value of the `host` option from the `client.webSocketURL` option if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
        client: {
          webSocketURL: ""ws://test.host:80"",
        },
      };

      const headers = {
        host: ""test.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/allowed-hosts.test.js,ConditionalTestLogic,"{'startLine':1773,'endLine':1775}","it(""should always allow any host if options.allowedHosts is all"", async () => {
      const options = {
        allowedHosts: ""all"",
        port: port1,
      };
      const headers = {
        host: ""bad.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/allowed-hosts.test.js,ConditionalTestLogic,"{'startLine':1814,'endLine':1816}","it(""should allow hosts in allowedHosts"", async () => {
      const tests = [""test.host"", ""test2.host"", ""test3.host""];
      const options = {
        allowedHosts: tests,
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/e2e/allowed-hosts.test.js,ConditionalTestLogic,"{'startLine':1864,'endLine':1866}","it(""should allow hosts that pass a wildcard in allowedHosts"", async () => {
      const options = {
        allowedHosts: ["".example.com""],
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const tests = [
        ""www.example.com"",
        ""subdomain.example.com"",
        ""example.com"",
        ""subsubcomain.subdomain.example.com"",
        ""example.com:80"",
        ""subdomain.example.com:80"",
      ];

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",snuts
/test/client/bundle.test.js,GeneralFixture,"{'startLine':21,'endLine':21}","beforeAll(async () => {
      const compiler = webpack({
        ...config,
        target: [""es5"", ""web""],
      });

      server = new Server({ port }, compiler);

      await server.start();

      req = request(server.app);
    })",snuts
/test/client/bundle.test.js,OvercommentedTest,"{'startLine':32,'endLine':67}","it(""should get full user bundle and parse with ES5"", async () => {
      const { text } = await req
        .get(""/main.js"")
        .expect(""Content-Type"", ""text/javascript; charset=utf-8"")
        .expect(200);

      expect(() => {
        let evalStep = 0;

        acorn.parse(text, {
          ecmaVersion: 5,
          onToken: (token) => {
            // a webpack bundle is a series of evaluated JavaScript
            // strings like this: eval('...')
            // if we want the bundle to work using ES5, we need to
            // check that these strings are good with ES5 as well

            // this can be done by waiting for tokens during the main parse
            // then when we hit a string in an 'eval' function we also try
            // to parse that string with ES5
            if (token.type.label === ""name"" && token.value === ""eval"") {
              evalStep += 1;
            } else if (token.type.label === ""("" && evalStep === 1) {
              evalStep += 1;
            } else if (token.type.label === ""string"" && evalStep === 2) {
              const program = token.value;
              acorn.parse(program, {
                ecmaVersion: 5,
              });

              evalStep = 0;
            }
          },
        });
      }).not.toThrow();
    })",snuts
/test/client/bundle.test.js,ConditionalTestLogic,"{'startLine':52,'endLine':63}","it(""should get full user bundle and parse with ES5"", async () => {
      const { text } = await req
        .get(""/main.js"")
        .expect(""Content-Type"", ""text/javascript; charset=utf-8"")
        .expect(200);

      expect(() => {
        let evalStep = 0;

        acorn.parse(text, {
          ecmaVersion: 5,
          onToken: (token) => {
            // a webpack bundle is a series of evaluated JavaScript
            // strings like this: eval('...')
            // if we want the bundle to work using ES5, we need to
            // check that these strings are good with ES5 as well

            // this can be done by waiting for tokens during the main parse
            // then when we hit a string in an 'eval' function we also try
            // to parse that string with ES5
            if (token.type.label === ""name"" && token.value === ""eval"") {
              evalStep += 1;
            } else if (token.type.label === ""("" && evalStep === 1) {
              evalStep += 1;
            } else if (token.type.label === ""string"" && evalStep === 2) {
              const program = token.value;
              acorn.parse(program, {
                ecmaVersion: 5,
              });

              evalStep = 0;
            }
          },
        });
      }).not.toThrow();
    })",snuts
/test/client/bundle.test.js,ConditionalTestLogic,"{'startLine':54,'endLine':63}","it(""should get full user bundle and parse with ES5"", async () => {
      const { text } = await req
        .get(""/main.js"")
        .expect(""Content-Type"", ""text/javascript; charset=utf-8"")
        .expect(200);

      expect(() => {
        let evalStep = 0;

        acorn.parse(text, {
          ecmaVersion: 5,
          onToken: (token) => {
            // a webpack bundle is a series of evaluated JavaScript
            // strings like this: eval('...')
            // if we want the bundle to work using ES5, we need to
            // check that these strings are good with ES5 as well

            // this can be done by waiting for tokens during the main parse
            // then when we hit a string in an 'eval' function we also try
            // to parse that string with ES5
            if (token.type.label === ""name"" && token.value === ""eval"") {
              evalStep += 1;
            } else if (token.type.label === ""("" && evalStep === 1) {
              evalStep += 1;
            } else if (token.type.label === ""string"" && evalStep === 2) {
              const program = token.value;
              acorn.parse(program, {
                ecmaVersion: 5,
              });

              evalStep = 0;
            }
          },
        });
      }).not.toThrow();
    })",snuts
/test/client/bundle.test.js,ConditionalTestLogic,"{'startLine':56,'endLine':63}","it(""should get full user bundle and parse with ES5"", async () => {
      const { text } = await req
        .get(""/main.js"")
        .expect(""Content-Type"", ""text/javascript; charset=utf-8"")
        .expect(200);

      expect(() => {
        let evalStep = 0;

        acorn.parse(text, {
          ecmaVersion: 5,
          onToken: (token) => {
            // a webpack bundle is a series of evaluated JavaScript
            // strings like this: eval('...')
            // if we want the bundle to work using ES5, we need to
            // check that these strings are good with ES5 as well

            // this can be done by waiting for tokens during the main parse
            // then when we hit a string in an 'eval' function we also try
            // to parse that string with ES5
            if (token.type.label === ""name"" && token.value === ""eval"") {
              evalStep += 1;
            } else if (token.type.label === ""("" && evalStep === 1) {
              evalStep += 1;
            } else if (token.type.label === ""string"" && evalStep === 2) {
              const program = token.value;
              acorn.parse(program, {
                ecmaVersion: 5,
              });

              evalStep = 0;
            }
          },
        });
      }).not.toThrow();
    })",snuts
/test/client/clients/WebsocketClient.test.js,GeneralFixture,"{'startLine':31,'endLine':31}","beforeAll((done) => {
    // eslint-disable-next-line new-cap
    const app = new express();

    server = http.createServer(app);
    server.listen(port, ""localhost"", () => {
      socketServer = new ws.Server({
        server,
        path: ""/ws-server"",
      });
      done();
    });
  })",snuts
/test/client/clients/SockJSClient.test.js,GeneralFixture,"{'startLine':28,'endLine':28}","beforeAll((done) => {
    consoleMock = jest.spyOn(console, ""log"").mockImplementation();

    // eslint-disable-next-line new-cap
    const app = new express();

    server = http.createServer(app);
    server.listen(port, ""localhost"", () => {
      socketServer = sockjs.createServer();
      socketServer.installHandlers(server, {
        prefix: ""/ws"",
      });
      done();
    });
  })",snuts
/test/client/clients/SockJSClient.test.js,GeneralFixture,"{'startLine':33,'endLine':33}","beforeAll((done) => {
    consoleMock = jest.spyOn(console, ""log"").mockImplementation();

    // eslint-disable-next-line new-cap
    const app = new express();

    server = http.createServer(app);
    server.listen(port, ""localhost"", () => {
      socketServer = sockjs.createServer();
      socketServer.installHandlers(server, {
        prefix: ""/ws"",
      });
      done();
    });
  })",snuts
/test/helpers/conditional-test.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}","test.skip(reason, () => {})",snuts
/test/fixtures/worker-config-dev-server-false/webpack.config.js,NonFunctionalStatement,"{'startLine':22,'endLine':22}",Unknown,snuts
/test/fixtures/worker-config-dev-server-false/webpack.config.js,NonFunctionalStatement,"{'startLine':42,'endLine':42}",Unknown,snuts
/test/fixtures/worker-config/webpack.config.js,NonFunctionalStatement,"{'startLine':21,'endLine':21}",Unknown,snuts
/test/fixtures/worker-config/webpack.config.js,NonFunctionalStatement,"{'startLine':41,'endLine':41}",Unknown,snuts
/test/fixtures/universal-compiler-config/webpack.config.js,NonFunctionalStatement,"{'startLine':20,'endLine':20}",Unknown,snuts
/test/fixtures/universal-compiler-config/webpack.config.js,NonFunctionalStatement,"{'startLine':39,'endLine':39}",Unknown,snuts
/test/fixtures/simple-config/webpack.config.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/test/fixtures/reload-config-2/webpack.config.js,NonFunctionalStatement,"{'startLine':25,'endLine':25}",Unknown,snuts
/test/fixtures/reload-config/webpack.config.js,NonFunctionalStatement,"{'startLine':24,'endLine':24}",Unknown,snuts
/test/fixtures/provide-plugin-ws-config/webpack.config.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/test/fixtures/provide-plugin-default/webpack.config.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/test/fixtures/provide-plugin-sockjs-config/webpack.config.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/test/fixtures/provide-plugin-custom/webpack.config.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/test/fixtures/overlay-config/webpack.config.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/test/fixtures/overlay-config/trusted-types.webpack.config.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/test/fixtures/multi-compiler-two-configurations/webpack.config.js,NonFunctionalStatement,"{'startLine':21,'endLine':21}",Unknown,snuts
/test/fixtures/multi-compiler-two-configurations/webpack.config.js,NonFunctionalStatement,"{'startLine':40,'endLine':40}",Unknown,snuts
/test/fixtures/multi-compiler-one-configuration/webpack.config.js,NonFunctionalStatement,"{'startLine':19,'endLine':19}",Unknown,snuts
/test/fixtures/lazy-compilation-single-entry/webpack.config.js,NonFunctionalStatement,"{'startLine':30,'endLine':30}",Unknown,snuts
/test/fixtures/lazy-compilation-multiple-entries/webpack.config.js,NonFunctionalStatement,"{'startLine':44,'endLine':44}",Unknown,snuts
/test/fixtures/client-config/webpack.config.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/test/validate-options.test.js,Conditional Test Logic,"{'line': 571, 'column': 6, 'index': 12216}","describe(""validate"", () => {
    function stringifyValue(value) {
      if (
        Array.isArray(value) ||
        (value && typeof value === ""object"" && value.constructor === Object)
      ) {
        return JSON.stringify(value, (_key, replacedValue) => {
          if (
            replacedValue &&
            replacedValue.type &&
            replacedValue.type === ""Buffer""
          ) {
            return ""<Buffer>"";
          }

          if (typeof replacedValue === ""string"") {
            replacedValue = replacedValue
              .replaceAll(""\\"", ""/"")
              .replaceAll(
                new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                ""<cwd>"",
              );
          }

          return replacedValue;
        });
      }

      return value;
    }

    function createTestCase(type, key, value) {
      it(`should ${
        type === ""success"" ? ""successfully validate"" : ""throw an error on""
      } the ""${key}"" option with '${stringifyValue(
        value,
      )}' value`, async () => {
        const compiler = webpack(config);
        let thrownError;

        try {
          // eslint-disable-next-line no-new
          new Server({ [key]: value }, compiler);
        } catch (error) {
          thrownError = error;
        }

        if (type === ""success"") {
          expect(thrownError).toBeUndefined();
        } else {
          expect(thrownError).toBeDefined();
          expect(thrownError.toString()).toMatchSnapshot();
        }
      });
    }

    const memfs = createFsFromVolume(new Volume());

    // We need to patch memfs
    // https://github.com/webpack/webpack-dev-middleware#fs
    memfs.join = path.join;

    for (const [key, values] of Object.entries(tests)) {
      for (const type of Object.keys(values)) {
        for (const value of values[type]) {
          createTestCase(type, key, value);
        }
      }
    }
  })",steel
/test/validate-options.test.js,Conditional Test Logic,"{'line': 576, 'column': 10, 'index': 12414}","describe(""validate"", () => {
    function stringifyValue(value) {
      if (
        Array.isArray(value) ||
        (value && typeof value === ""object"" && value.constructor === Object)
      ) {
        return JSON.stringify(value, (_key, replacedValue) => {
          if (
            replacedValue &&
            replacedValue.type &&
            replacedValue.type === ""Buffer""
          ) {
            return ""<Buffer>"";
          }

          if (typeof replacedValue === ""string"") {
            replacedValue = replacedValue
              .replaceAll(""\\"", ""/"")
              .replaceAll(
                new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                ""<cwd>"",
              );
          }

          return replacedValue;
        });
      }

      return value;
    }

    function createTestCase(type, key, value) {
      it(`should ${
        type === ""success"" ? ""successfully validate"" : ""throw an error on""
      } the ""${key}"" option with '${stringifyValue(
        value,
      )}' value`, async () => {
        const compiler = webpack(config);
        let thrownError;

        try {
          // eslint-disable-next-line no-new
          new Server({ [key]: value }, compiler);
        } catch (error) {
          thrownError = error;
        }

        if (type === ""success"") {
          expect(thrownError).toBeUndefined();
        } else {
          expect(thrownError).toBeDefined();
          expect(thrownError.toString()).toMatchSnapshot();
        }
      });
    }

    const memfs = createFsFromVolume(new Volume());

    // We need to patch memfs
    // https://github.com/webpack/webpack-dev-middleware#fs
    memfs.join = path.join;

    for (const [key, values] of Object.entries(tests)) {
      for (const type of Object.keys(values)) {
        for (const value of values[type]) {
          createTestCase(type, key, value);
        }
      }
    }
  })",steel
/test/validate-options.test.js,Conditional Test Logic,"{'line': 584, 'column': 10, 'index': 12594}","describe(""validate"", () => {
    function stringifyValue(value) {
      if (
        Array.isArray(value) ||
        (value && typeof value === ""object"" && value.constructor === Object)
      ) {
        return JSON.stringify(value, (_key, replacedValue) => {
          if (
            replacedValue &&
            replacedValue.type &&
            replacedValue.type === ""Buffer""
          ) {
            return ""<Buffer>"";
          }

          if (typeof replacedValue === ""string"") {
            replacedValue = replacedValue
              .replaceAll(""\\"", ""/"")
              .replaceAll(
                new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                ""<cwd>"",
              );
          }

          return replacedValue;
        });
      }

      return value;
    }

    function createTestCase(type, key, value) {
      it(`should ${
        type === ""success"" ? ""successfully validate"" : ""throw an error on""
      } the ""${key}"" option with '${stringifyValue(
        value,
      )}' value`, async () => {
        const compiler = webpack(config);
        let thrownError;

        try {
          // eslint-disable-next-line no-new
          new Server({ [key]: value }, compiler);
        } catch (error) {
          thrownError = error;
        }

        if (type === ""success"") {
          expect(thrownError).toBeUndefined();
        } else {
          expect(thrownError).toBeDefined();
          expect(thrownError.toString()).toMatchSnapshot();
        }
      });
    }

    const memfs = createFsFromVolume(new Volume());

    // We need to patch memfs
    // https://github.com/webpack/webpack-dev-middleware#fs
    memfs.join = path.join;

    for (const [key, values] of Object.entries(tests)) {
      for (const type of Object.keys(values)) {
        for (const value of values[type]) {
          createTestCase(type, key, value);
        }
      }
    }
  })",steel
/test/validate-options.test.js,Conditional Test Logic,"{'line': 616, 'column': 8, 'index': 13441}","it(`should ${
        type === ""success"" ? ""successfully validate"" : ""throw an error on""
      } the ""${key}"" option with '${stringifyValue(
        value,
      )}' value`, async () => {
        const compiler = webpack(config);
        let thrownError;

        try {
          // eslint-disable-next-line no-new
          new Server({ [key]: value }, compiler);
        } catch (error) {
          thrownError = error;
        }

        if (type === ""success"") {
          expect(thrownError).toBeUndefined();
        } else {
          expect(thrownError).toBeDefined();
          expect(thrownError.toString()).toMatchSnapshot();
        }
      })",steel
/test/validate-options.test.js,Conditional Test Logic,"{'line': 631, 'column': 4, 'index': 13839}","describe(""validate"", () => {
    function stringifyValue(value) {
      if (
        Array.isArray(value) ||
        (value && typeof value === ""object"" && value.constructor === Object)
      ) {
        return JSON.stringify(value, (_key, replacedValue) => {
          if (
            replacedValue &&
            replacedValue.type &&
            replacedValue.type === ""Buffer""
          ) {
            return ""<Buffer>"";
          }

          if (typeof replacedValue === ""string"") {
            replacedValue = replacedValue
              .replaceAll(""\\"", ""/"")
              .replaceAll(
                new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                ""<cwd>"",
              );
          }

          return replacedValue;
        });
      }

      return value;
    }

    function createTestCase(type, key, value) {
      it(`should ${
        type === ""success"" ? ""successfully validate"" : ""throw an error on""
      } the ""${key}"" option with '${stringifyValue(
        value,
      )}' value`, async () => {
        const compiler = webpack(config);
        let thrownError;

        try {
          // eslint-disable-next-line no-new
          new Server({ [key]: value }, compiler);
        } catch (error) {
          thrownError = error;
        }

        if (type === ""success"") {
          expect(thrownError).toBeUndefined();
        } else {
          expect(thrownError).toBeDefined();
          expect(thrownError.toString()).toMatchSnapshot();
        }
      });
    }

    const memfs = createFsFromVolume(new Volume());

    // We need to patch memfs
    // https://github.com/webpack/webpack-dev-middleware#fs
    memfs.join = path.join;

    for (const [key, values] of Object.entries(tests)) {
      for (const type of Object.keys(values)) {
        for (const value of values[type]) {
          createTestCase(type, key, value);
        }
      }
    }
  })",steel
/test/validate-options.test.js,Conditional Test Logic,"{'line': 632, 'column': 6, 'index': 13898}","describe(""validate"", () => {
    function stringifyValue(value) {
      if (
        Array.isArray(value) ||
        (value && typeof value === ""object"" && value.constructor === Object)
      ) {
        return JSON.stringify(value, (_key, replacedValue) => {
          if (
            replacedValue &&
            replacedValue.type &&
            replacedValue.type === ""Buffer""
          ) {
            return ""<Buffer>"";
          }

          if (typeof replacedValue === ""string"") {
            replacedValue = replacedValue
              .replaceAll(""\\"", ""/"")
              .replaceAll(
                new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                ""<cwd>"",
              );
          }

          return replacedValue;
        });
      }

      return value;
    }

    function createTestCase(type, key, value) {
      it(`should ${
        type === ""success"" ? ""successfully validate"" : ""throw an error on""
      } the ""${key}"" option with '${stringifyValue(
        value,
      )}' value`, async () => {
        const compiler = webpack(config);
        let thrownError;

        try {
          // eslint-disable-next-line no-new
          new Server({ [key]: value }, compiler);
        } catch (error) {
          thrownError = error;
        }

        if (type === ""success"") {
          expect(thrownError).toBeUndefined();
        } else {
          expect(thrownError).toBeDefined();
          expect(thrownError.toString()).toMatchSnapshot();
        }
      });
    }

    const memfs = createFsFromVolume(new Volume());

    // We need to patch memfs
    // https://github.com/webpack/webpack-dev-middleware#fs
    memfs.join = path.join;

    for (const [key, values] of Object.entries(tests)) {
      for (const type of Object.keys(values)) {
        for (const value of values[type]) {
          createTestCase(type, key, value);
        }
      }
    }
  })",steel
/test/validate-options.test.js,Conditional Test Logic,"{'line': 633, 'column': 8, 'index': 13948}","describe(""validate"", () => {
    function stringifyValue(value) {
      if (
        Array.isArray(value) ||
        (value && typeof value === ""object"" && value.constructor === Object)
      ) {
        return JSON.stringify(value, (_key, replacedValue) => {
          if (
            replacedValue &&
            replacedValue.type &&
            replacedValue.type === ""Buffer""
          ) {
            return ""<Buffer>"";
          }

          if (typeof replacedValue === ""string"") {
            replacedValue = replacedValue
              .replaceAll(""\\"", ""/"")
              .replaceAll(
                new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                ""<cwd>"",
              );
          }

          return replacedValue;
        });
      }

      return value;
    }

    function createTestCase(type, key, value) {
      it(`should ${
        type === ""success"" ? ""successfully validate"" : ""throw an error on""
      } the ""${key}"" option with '${stringifyValue(
        value,
      )}' value`, async () => {
        const compiler = webpack(config);
        let thrownError;

        try {
          // eslint-disable-next-line no-new
          new Server({ [key]: value }, compiler);
        } catch (error) {
          thrownError = error;
        }

        if (type === ""success"") {
          expect(thrownError).toBeUndefined();
        } else {
          expect(thrownError).toBeDefined();
          expect(thrownError.toString()).toMatchSnapshot();
        }
      });
    }

    const memfs = createFsFromVolume(new Volume());

    // We need to patch memfs
    // https://github.com/webpack/webpack-dev-middleware#fs
    memfs.join = path.join;

    for (const [key, values] of Object.entries(tests)) {
      for (const type of Object.keys(values)) {
        for (const value of values[type]) {
          createTestCase(type, key, value);
        }
      }
    }
  })",steel
/test/normalize-options.test.js,Conditional Test Logic,"{'line': 582, 'column': 2, 'index': 12195}","describe(""normalize options"", () => {
  const cases = [
    {
      title: ""no options"",
      multiCompiler: false,
      options: {},
    },
    {
      title: ""port string"",
      multiCompiler: false,
      options: {
        port: ""9000"",
      },
    },
    {
      title: ""client.webSocketTransport sockjs string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""sockjs"",
        },
      },
    },
    {
      title: ""client.webSocketTransport ws string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
      },
    },
    {
      title:
        ""client.webSocketTransport ws string and webSocketServer ws string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
        webSocketServer: ""ws"",
      },
    },
    {
      title: ""webSocketServer custom server path"",
      multiCompiler: false,
      options: {
        webSocketServer: ""/path/to/custom/server/"",
      },
    },
    {
      title: ""webSocketServer custom server class"",
      multiCompiler: false,
      options: {
        webSocketServer: class CustomServerImplementation {
          constructor() {
            this.implementation = {
              close: (callback) => {
                callback();
              },
            };
          }
        },
      },
    },
    {
      title: ""client.webSocketTransport ws string and webSocketServer object"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
        webSocketServer: {
          type: ""ws"",
          options: {
            host: ""127.0.0.1"",
            // TODO `jest` is freeze here
            // port: 43334,
            pathname: ""/ws"",
          },
        },
      },
    },
    {
      title:
        ""client.webSocketTransport ws string and webSocketServer object with port as string"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""ws"",
        },
        webSocketServer: {
          type: ""ws"",
          options: {
            host: ""127.0.0.1"",
            // TODO `jest` is freeze here
            // port: ""43335"",
            pathname: ""/ws"",
          },
        },
      },
    },
    {
      title: ""client custom webSocketTransport path"",
      multiCompiler: false,
      options: {
        client: {
          webSocketTransport: ""/path/to/custom/client/"",
        },
      },
    },
    {
      title: ""client host and port"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            hostname: ""my.host"",
            port: 9000,
          },
        },
      },
    },
    {
      title: ""client host and string port"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            hostname: ""my.host"",
            port: ""9000"",
          },
        },
      },
    },
    {
      title: ""client path"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            pathname: ""/custom/path/"",
          },
        },
      },
    },
    {
      title: ""username and password"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
            password: ""chuntaro"",
          },
        },
      },
    },
    {
      title: ""client path without leading/ending slashes"",
      multiCompiler: false,
      options: {
        client: {
          webSocketURL: {
            pathname: ""custom/path"",
          },
        },
      },
    },
    {
      title:
        ""single compiler client.logging should default to infrastructureLogging.level"",
      multiCompiler: false,
      options: {},
      webpackConfig: {
        infrastructureLogging: {
          level: ""verbose"",
          stream: {
            write: () => {},
          },
        },
      },
    },
    {
      title:
        ""single compiler client.logging should override to infrastructureLogging.level"",
      multiCompiler: false,
      options: {
        client: {
          logging: ""none"",
        },
      },
      webpackConfig: {
        infrastructureLogging: {
          level: ""verbose"",
          stream: {
            write: () => {},
          },
        },
      },
    },
    {
      title:
        ""multi compiler client.logging should respect infrastructureLogging.level"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        {
          target: ""node"",
        },
        // infrastructureLogging is set on the second compiler
        {
          target: ""web"",
          infrastructureLogging: {
            level: ""warn"",
          },
        },
      ],
    },
    {
      title:
        ""multi compiler client.logging should respect infrastructureLogging.level"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        {},
        // infrastructureLogging is set on the second compiler
        {
          devServer: {},
          infrastructureLogging: {
            level: ""warn"",
          },
        },
      ],
    },
    {
      title:
        ""multi compiler client.logging should respect infrastructureLogging.level"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        // Fallback
        {
          infrastructureLogging: {
            level: ""warn"",
          },
        },
        {},
      ],
    },
    {
      title:
        ""multi compiler client.logging should override infrastructureLogging.level"",
      multiCompiler: true,
      options: {
        client: {
          logging: ""none"",
        },
      },
      webpackConfig: [
        {
          infrastructureLogging: {
            level: ""warn"",
          },
        },
        {},
      ],
    },
    {
      title: ""liveReload is true"",
      multiCompiler: false,
      options: {
        liveReload: true,
      },
    },
    {
      title: ""liveReload is false"",
      multiCompiler: false,
      options: {
        liveReload: false,
      },
    },
    {
      title: ""hot is true"",
      multiCompiler: false,
      options: {
        hot: true,
      },
    },
    {
      title: ""hot is false"",
      multiCompiler: false,
      options: {
        hot: false,
      },
    },
    {
      title: ""hot is only"",
      multiCompiler: false,
      options: {
        hot: ""only"",
      },
    },
    {
      title: ""dev is set"",
      multiCompiler: false,
      options: {
        devMiddleware: {
          serverSideRender: true,
        },
      },
    },
    {
      title: ""static is true"",
      multiCompiler: false,
      options: {
        static: true,
      },
    },
    {
      title: ""static is false"",
      multiCompiler: false,
      options: {
        static: false,
      },
    },
    {
      title: ""static is string"",
      multiCompiler: false,
      options: {
        static: ""/static/path"",
      },
    },
    {
      title: ""static is an array of strings"",
      multiCompiler: false,
      options: {
        static: [""/static/path1"", ""/static/path2""],
      },
    },
    {
      title: ""static is an array of static objects"",
      multiCompiler: false,
      options: {
        static: [
          {
            directory: ""/static/path1"",
          },
          {
            publicPath: ""/static/public/path"",
          },
        ],
      },
    },
    {
      title: ""static is an array of strings and static objects"",
      multiCompiler: false,
      options: {
        static: [
          ""/static/path1"",
          {
            publicPath: ""/static/public/path/"",
          },
        ],
      },
    },
    {
      title: ""static is an object"",
      multiCompiler: false,
      options: {
        static: {
          directory: ""/static/path"",
        },
      },
    },
    {
      title: ""static is an object with staticOptions"",
      multiCompiler: false,
      options: {
        static: {
          directory: ""/static/path"",
          staticOptions: {
            redirect: true,
            immutable: true,
          },
        },
      },
    },
    {
      title: ""static directory is an absolute url and throws error"",
      multiCompiler: false,
      options: {
        static: {
          directory: ""http://localhost:8080"",
        },
      },
      throws: ""Using a URL as static.directory is not supported"",
    },
    {
      title: ""static publicPath is a string"",
      multiCompiler: false,
      options: {
        static: {
          publicPath: ""/static/public/path/"",
        },
      },
    },
    {
      title: ""static publicPath is an array"",
      multiCompiler: false,
      options: {
        static: {
          publicPath: [""/static/public/path1/"", ""/static/public/path2/""],
        },
      },
    },
    {
      title: ""static watch is false"",
      multiCompiler: false,
      options: {
        static: {
          watch: false,
        },
      },
    },
    {
      title: ""static watch is true"",
      multiCompiler: false,
      options: {
        static: {
          watch: true,
        },
      },
    },
    {
      title: ""static watch is an object"",
      multiCompiler: false,
      options: {
        static: {
          watch: {
            poll: 500,
          },
        },
      },
    },
    {
      title: ""static serveIndex is false"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: false,
        },
      },
    },
    {
      title: ""static serveIndex is true"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: true,
        },
      },
    },
    {
      title: ""static serveIndex is an object with icons false"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: {
            icons: false,
          },
        },
      },
    },
    {
      title: ""static serveIndex is an object more options"",
      multiCompiler: false,
      options: {
        static: {
          serveIndex: {
            hidden: true,
            stylesheet: ""https://example.com/style.css"",
            view: ""details"",
          },
        },
      },
    },

    {
      title: ""single compiler watchOptions is object"",
      multiCompiler: false,
      options: {},
      webpackConfig: {
        watch: true,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title: ""single compiler watchOptions is object with watch false"",
      multiCompiler: false,
      options: {},
      webpackConfig: {
        watch: false,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title: ""single compiler watchOptions is object with static watch true"",
      multiCompiler: false,
      options: {
        static: {
          watch: true,
        },
      },
      webpackConfig: {
        watch: true,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title:
        ""single compiler watchOptions is object with static watch overriding it"",
      multiCompiler: false,
      options: {
        static: {
          watch: {
            poll: 500,
          },
        },
      },
      webpackConfig: {
        watch: true,
        watchOptions: {
          aggregateTimeout: 300,
        },
      },
    },
    {
      title: ""multi compiler watchOptions is set"",
      multiCompiler: true,
      options: {},
      webpackConfig: [
        {},
        // watchOptions are set on the second compiler
        {
          watch: true,
          watchOptions: {
            aggregateTimeout: 300,
          },
        },
      ],
    },
    {
      title: ""allowedHosts is string"",
      multiCompiler: false,
      options: {
        allowedHosts: ""all"",
      },
    },
    {
      title: ""allowedHosts is array"",
      multiCompiler: false,
      options: {
        allowedHosts: [""all""],
      },
    },
  ];

  for (const item of cases) {
    it(item.title, async () => {
      let webpackConfig;

      if (item.multiCompiler) {
        webpackConfig = require(""./fixtures/multi-compiler-one-configuration/webpack.config"");

        if (Array.isArray(item.webpackConfig)) {
          webpackConfig = item.webpackConfig.map((config, index) => ({
            ...webpackConfig[index],
            ...config,
          }));
        }
      } else {
        webpackConfig = require(""./fixtures/simple-config/webpack.config"");

        if (item.webpackConfig) {
          webpackConfig = {
            ...webpackConfig,
            ...item.webpackConfig,
          };
        }
      }

      const compiler = webpack(webpackConfig);
      const server = new Server({ ...item.options, port }, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      try {
        if (item.throws) {
          expect(errored.message).toMatch(item.throws);
        } else {
          const optionsForSnapshot = klona(server.options);

          optionsForSnapshot.port = ""<auto>"";

          if (optionsForSnapshot.static.length > 0) {
            for (const i of optionsForSnapshot.static) {
              i.directory = i.directory
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                );
            }
          }

          expect(optionsForSnapshot).toMatchSnapshot();
        }
      } finally {
        await server.stop();
      }
    });
  }
})",steel
/test/normalize-options.test.js,Conditional Test Logic,"{'line': 586, 'column': 6, 'index': 12288}","it(item.title, async () => {
      let webpackConfig;

      if (item.multiCompiler) {
        webpackConfig = require(""./fixtures/multi-compiler-one-configuration/webpack.config"");

        if (Array.isArray(item.webpackConfig)) {
          webpackConfig = item.webpackConfig.map((config, index) => ({
            ...webpackConfig[index],
            ...config,
          }));
        }
      } else {
        webpackConfig = require(""./fixtures/simple-config/webpack.config"");

        if (item.webpackConfig) {
          webpackConfig = {
            ...webpackConfig,
            ...item.webpackConfig,
          };
        }
      }

      const compiler = webpack(webpackConfig);
      const server = new Server({ ...item.options, port }, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      try {
        if (item.throws) {
          expect(errored.message).toMatch(item.throws);
        } else {
          const optionsForSnapshot = klona(server.options);

          optionsForSnapshot.port = ""<auto>"";

          if (optionsForSnapshot.static.length > 0) {
            for (const i of optionsForSnapshot.static) {
              i.directory = i.directory
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                );
            }
          }

          expect(optionsForSnapshot).toMatchSnapshot();
        }
      } finally {
        await server.stop();
      }
    })",steel
/test/normalize-options.test.js,Conditional Test Logic,"{'line': 589, 'column': 8, 'index': 12418}","it(item.title, async () => {
      let webpackConfig;

      if (item.multiCompiler) {
        webpackConfig = require(""./fixtures/multi-compiler-one-configuration/webpack.config"");

        if (Array.isArray(item.webpackConfig)) {
          webpackConfig = item.webpackConfig.map((config, index) => ({
            ...webpackConfig[index],
            ...config,
          }));
        }
      } else {
        webpackConfig = require(""./fixtures/simple-config/webpack.config"");

        if (item.webpackConfig) {
          webpackConfig = {
            ...webpackConfig,
            ...item.webpackConfig,
          };
        }
      }

      const compiler = webpack(webpackConfig);
      const server = new Server({ ...item.options, port }, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      try {
        if (item.throws) {
          expect(errored.message).toMatch(item.throws);
        } else {
          const optionsForSnapshot = klona(server.options);

          optionsForSnapshot.port = ""<auto>"";

          if (optionsForSnapshot.static.length > 0) {
            for (const i of optionsForSnapshot.static) {
              i.directory = i.directory
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                );
            }
          }

          expect(optionsForSnapshot).toMatchSnapshot();
        }
      } finally {
        await server.stop();
      }
    })",steel
/test/normalize-options.test.js,Conditional Test Logic,"{'line': 598, 'column': 8, 'index': 12715}","it(item.title, async () => {
      let webpackConfig;

      if (item.multiCompiler) {
        webpackConfig = require(""./fixtures/multi-compiler-one-configuration/webpack.config"");

        if (Array.isArray(item.webpackConfig)) {
          webpackConfig = item.webpackConfig.map((config, index) => ({
            ...webpackConfig[index],
            ...config,
          }));
        }
      } else {
        webpackConfig = require(""./fixtures/simple-config/webpack.config"");

        if (item.webpackConfig) {
          webpackConfig = {
            ...webpackConfig,
            ...item.webpackConfig,
          };
        }
      }

      const compiler = webpack(webpackConfig);
      const server = new Server({ ...item.options, port }, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      try {
        if (item.throws) {
          expect(errored.message).toMatch(item.throws);
        } else {
          const optionsForSnapshot = klona(server.options);

          optionsForSnapshot.port = ""<auto>"";

          if (optionsForSnapshot.static.length > 0) {
            for (const i of optionsForSnapshot.static) {
              i.directory = i.directory
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                );
            }
          }

          expect(optionsForSnapshot).toMatchSnapshot();
        }
      } finally {
        await server.stop();
      }
    })",steel
/test/normalize-options.test.js,Conditional Test Logic,"{'line': 618, 'column': 8, 'index': 13124}","it(item.title, async () => {
      let webpackConfig;

      if (item.multiCompiler) {
        webpackConfig = require(""./fixtures/multi-compiler-one-configuration/webpack.config"");

        if (Array.isArray(item.webpackConfig)) {
          webpackConfig = item.webpackConfig.map((config, index) => ({
            ...webpackConfig[index],
            ...config,
          }));
        }
      } else {
        webpackConfig = require(""./fixtures/simple-config/webpack.config"");

        if (item.webpackConfig) {
          webpackConfig = {
            ...webpackConfig,
            ...item.webpackConfig,
          };
        }
      }

      const compiler = webpack(webpackConfig);
      const server = new Server({ ...item.options, port }, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      try {
        if (item.throws) {
          expect(errored.message).toMatch(item.throws);
        } else {
          const optionsForSnapshot = klona(server.options);

          optionsForSnapshot.port = ""<auto>"";

          if (optionsForSnapshot.static.length > 0) {
            for (const i of optionsForSnapshot.static) {
              i.directory = i.directory
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                );
            }
          }

          expect(optionsForSnapshot).toMatchSnapshot();
        }
      } finally {
        await server.stop();
      }
    })",steel
/test/normalize-options.test.js,Conditional Test Logic,"{'line': 625, 'column': 10, 'index': 13334}","it(item.title, async () => {
      let webpackConfig;

      if (item.multiCompiler) {
        webpackConfig = require(""./fixtures/multi-compiler-one-configuration/webpack.config"");

        if (Array.isArray(item.webpackConfig)) {
          webpackConfig = item.webpackConfig.map((config, index) => ({
            ...webpackConfig[index],
            ...config,
          }));
        }
      } else {
        webpackConfig = require(""./fixtures/simple-config/webpack.config"");

        if (item.webpackConfig) {
          webpackConfig = {
            ...webpackConfig,
            ...item.webpackConfig,
          };
        }
      }

      const compiler = webpack(webpackConfig);
      const server = new Server({ ...item.options, port }, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      try {
        if (item.throws) {
          expect(errored.message).toMatch(item.throws);
        } else {
          const optionsForSnapshot = klona(server.options);

          optionsForSnapshot.port = ""<auto>"";

          if (optionsForSnapshot.static.length > 0) {
            for (const i of optionsForSnapshot.static) {
              i.directory = i.directory
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                );
            }
          }

          expect(optionsForSnapshot).toMatchSnapshot();
        }
      } finally {
        await server.stop();
      }
    })",steel
/test/normalize-options.test.js,Conditional Test Logic,"{'line': 626, 'column': 12, 'index': 13390}","it(item.title, async () => {
      let webpackConfig;

      if (item.multiCompiler) {
        webpackConfig = require(""./fixtures/multi-compiler-one-configuration/webpack.config"");

        if (Array.isArray(item.webpackConfig)) {
          webpackConfig = item.webpackConfig.map((config, index) => ({
            ...webpackConfig[index],
            ...config,
          }));
        }
      } else {
        webpackConfig = require(""./fixtures/simple-config/webpack.config"");

        if (item.webpackConfig) {
          webpackConfig = {
            ...webpackConfig,
            ...item.webpackConfig,
          };
        }
      }

      const compiler = webpack(webpackConfig);
      const server = new Server({ ...item.options, port }, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      try {
        if (item.throws) {
          expect(errored.message).toMatch(item.throws);
        } else {
          const optionsForSnapshot = klona(server.options);

          optionsForSnapshot.port = ""<auto>"";

          if (optionsForSnapshot.static.length > 0) {
            for (const i of optionsForSnapshot.static) {
              i.directory = i.directory
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                );
            }
          }

          expect(optionsForSnapshot).toMatchSnapshot();
        }
      } finally {
        await server.stop();
      }
    })",steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 30, 'column': 6, 'index': 855}",Unknown,steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 40, 'column': 6, 'index': 1023}",Unknown,steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 48, 'column': 6, 'index': 1176}",Unknown,steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 64, 'column': 6, 'index': 1568}",Unknown,steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 82, 'column': 4, 'index': 1922}",Unknown,steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 85, 'column': 6, 'index': 2042}",Unknown,steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 97, 'column': 8, 'index': 2346}",Unknown,steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 102, 'column': 10, 'index': 2551}",Unknown,steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 602, 'column': 4, 'index': 14067}","describe(""should handles external websocket upgrade"", () => {
    let ws;
    let server;
    let webSocketServer;
    let responseMessage;

    const webSocketServerTypes = [""sockjs"", ""ws""];

    for (const webSocketServerType of webSocketServerTypes) {
      // eslint-disable-next-line no-loop-func
      describe(`with webSocketServerType: ${webSocketServerType}`, () => {
        beforeAll(async () => {
          const compiler = webpack(config);

          server = new Server(
            {
              webSocketServer: webSocketServerType,
              proxy: [
                {
                  context: ""/"",
                  target: `http://localhost:${port4}`,
                  ws: true,
                },
              ],
              port: port3,
            },
            compiler,
          );

          await server.start();

          webSocketServer = new WebSocketServer({ port: port4 });
          webSocketServer.on(""connection"", (connection) => {
            connection.on(""message"", (message) => {
              connection.send(message);
            });
          });
        });

        beforeEach((done) => {
          ws = new WebSocket(`ws://localhost:${port3}/proxy3/socket`);

          ws.on(""message"", (message) => {
            responseMessage = message.toString();
            done();
          });

          ws.on(""open"", () => {
            ws.send(""foo"");
          });
        });

        afterAll(async () => {
          webSocketServer.close();

          for (const client of webSocketServer.clients) {
            client.terminate();
          }

          await server.stop();
        });

        it(""should receive response"", () => {
          expect(responseMessage).toBe(""foo"");
        });
      });
    }
  })",steel
/test/server/proxy-option.test.js,Conditional Test Logic,"{'line': 649, 'column': 10, 'index': 15380}","afterAll(async () => {
          webSocketServer.close();

          for (const client of webSocketServer.clients) {
            client.terminate();
          }

          await server.stop();
        })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 220, 'column': 37, 'index': 4903}","it(""respects a proxy option when a request path is matched"", async () => {
        const response = await req.get(""/proxy1"");

        expect(response.status).toBe(200);
        expect(response.text).toContain(""from proxy1"");
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 229, 'column': 37, 'index': 5169}","it(""respects a pathRewrite option"", async () => {
        const response = await req.get(""/api/proxy2"");

        expect(response.status).toBe(200);
        expect(response.text).toContain(""from proxy2"");
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 240, 'column': 37, 'index': 5509}","it(""should log deprecation warning when bypass is used"", async () => {
        const utilSpy = jest.spyOn(util, ""deprecate"");

        const response = await req.get(""/foo/bar.html"");

        expect(response.status).toBe(200);
        expect(response.text).toContain(""Hello"");

        const lastCall = utilSpy.mock.calls[utilSpy.mock.calls.length - 1];

        expect(lastCall[1]).toBe(
          ""Using the 'bypass' option is deprecated. Please use the 'router' or 'context' options. Read more at https://github.com/chimurai/http-proxy-middleware/tree/v2.0.6#http-proxy-middleware-options"",
        );
        expect(lastCall[2]).toBe(
          ""DEP_WEBPACK_DEV_SERVER_PROXY_BYPASS_ARGUMENT"",
        );

        utilSpy.mockRestore();
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 258, 'column': 37, 'index': 6187}","it(""can rewrite a request path"", async () => {
        const response = await req.get(""/foo/bar.html"");

        expect(response.status).toBe(200);
        expect(response.text).toContain(""Hello"");
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 265, 'column': 37, 'index': 6452}","it(""can rewrite a request path regardless of the target defined a bypass option"", async () => {
        const response = await req.get(""/baz/hoge.html"");

        expect(response.status).toBe(200);
        expect(response.text).toContain(""Hello"");
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 272, 'column': 37, 'index': 6698}","it(""should pass through a proxy when a bypass function returns null"", async () => {
        const response = await req.get(""/foo.js"");

        expect(response.status).toBe(200);
        expect(response.text).toContain(""Hey"");
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 279, 'column': 37, 'index': 6951}","it(""should not pass through a proxy when a bypass function returns false"", async () => {
        const response = await req.get(""/proxyfalse"");

        expect(response.status).toBe(404);
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 285, 'column': 37, 'index': 7126}","it(""should wait if bypass returns promise"", async () => {
        const response = await req.get(""/proxy/async"");

        expect(response.status).toBe(200);
        expect(response.text).toContain(""proxy async response"");
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 292, 'column': 37, 'index': 7379}","it(""should work with the 'target' option"", async () => {
        const response = await req.get(""/bypass-with-target/foo.js"");

        expect(response.status).toBe(404);
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 298, 'column': 37, 'index': 7574}","it(""should work with the 'target' option #2"", async () => {
        const response = await req.get(""/bypass-with-target/index.html"");

        expect(response.status).toBe(200);
        expect(response.text).toContain(""Hello"");
      })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 334, 'column': 35, 'index': 8292}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 369, 'column': 35, 'index': 9020}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 404, 'column': 35, 'index': 9749}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 439, 'column': 35, 'index': 10472}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 474, 'column': 35, 'index': 11151}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 481, 'column': 35, 'index': 11369}","it(""respects a proxy option of function"", async () => {
      const response = await req.get(""/api/proxy2"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy2"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 488, 'column': 39, 'index': 11596}","it(""should allow req, res, and next"", async () => {
      const response = await req.get(""/api/proxy2?foo=true"");

      expect(response.statusCode).toBe(200);
      expect(response.text).toBe(""foo+next+function"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 493, 'column': 53, 'index': 11793}","it(""should not exist multiple close events registered"", async () => {
      expect(maxServerListeners).toBeLessThanOrEqual(1);
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 527, 'column': 35, 'index': 12456}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 582, 'column': 35, 'index': 13594}","it(""respects proxy1 option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 589, 'column': 35, 'index': 13794}","it(""respects proxy2 option"", async () => {
      const response = await req.get(""/proxy2"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 748, 'column': 35, 'index': 17835}","it(""errors"", async () => {
      const response = await req.get(""/%"");

      expect(response.status).toBe(500);
      expect(response.text).toContain(""error from proxy"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 755, 'column': 35, 'index': 18026}","it(""gET method"", async () => {
      const response = await req.get(""/get"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""GET method from proxy"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 762, 'column': 35, 'index': 18225}","it(""hEAD method"", async () => {
      const response = await req.head(""/head"");

      expect(response.status).toBe(200);
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 770, 'column': 35, 'index': 18449}","it(""pOST method (application/x-www-form-urlencoded)"", async () => {
      const response = await req
        .post(""/post-x-www-form-urlencoded"")
        .send(""id=1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""POST method from proxy (id: 1)"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 780, 'column': 35, 'index': 18772}","it(""pOST method (application/json)"", async () => {
      const response = await req
        .post(""/post-application-json"")
        .send({ id: ""1"" })
        .set(""Accept"", ""application/json"");

      expect(response.status).toBe(200);
      expect(response.headers[""content-type""]).toBe(
        ""application/json; charset=utf-8"",
      );
      expect(response.text).toContain(""POST method from proxy (id: 1)"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 790, 'column': 35, 'index': 19091}","it(""dELETE method"", async () => {
      const response = await req.delete(""/delete"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""DELETE method from proxy"");
    })",steel
/test/server/proxy-option.test.js,Magic Number,"{'line': 830, 'column': 35, 'index': 19926}","it(""respects a proxy option"", async () => {
      const response = await req.get(""/proxy1"");

      expect(response.status).toBe(200);
      expect(response.text).toContain(""from proxy1"");
    })",steel
/test/server/open-option.test.js,Conditional Test Logic,"{'line': 15, 'column': 0, 'index': 378}",Unknown,steel
/test/server/open-option.test.js,Conditional Test Logic,"{'line': 31, 'column': 4, 'index': 632}","beforeEach(async () => {
    compiler = webpack(config);

    if (!needRequireMock) {
      jest.unstable_mockModule(""open"", () => ({
        default: jest.fn(() => Promise.resolve()),
      }));

      open = (await import(""open"")).default;
    }
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 349, 'column': 4, 'index': 6653}","it(""should work with multiple relative strings"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host: ""localhost"",
        port,
        open: [""first.html"", ""second.html""],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 356, 'column': 4, 'index': 6792}","it(""should work with multiple relative strings"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host: ""localhost"",
        port,
        open: [""first.html"", ""second.html""],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 383, 'column': 4, 'index': 7322}","it(""should work with multiple absolute strings"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host: ""localhost"",
        port,
        open: [
          `http://${host}:${port}/first.html`,
          `http://${host}:${port}/second.html`,
        ],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 390, 'column': 4, 'index': 7461}","it(""should work with multiple absolute strings"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host: ""localhost"",
        port,
        open: [
          `http://${host}:${port}/first.html`,
          `http://${host}:${port}/second.html`,
        ],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 414, 'column': 4, 'index': 7919}","it('should work with ""<url>"" pattern in multiple strings', async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host: ""localhost"",
        port,
        open: [""<url>"", ""second.html""],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(1, `http://${host}:${port}/`, {
      wait: false,
    });
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 417, 'column': 4, 'index': 8019}","it('should work with ""<url>"" pattern in multiple strings', async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host: ""localhost"",
        port,
        open: [""<url>"", ""second.html""],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(1, `http://${host}:${port}/`, {
      wait: false,
    });
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 485, 'column': 4, 'index': 9301}","it(""should work with object and with multiple values of the 'target' option"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: {
          target: [""first.html"", ""second.html""],
        },
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 492, 'column': 4, 'index': 9440}","it(""should work with object and with multiple values of the 'target' option"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: {
          target: [""first.html"", ""second.html""],
        },
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 613, 'column': 4, 'index': 12030}","it(""should work with object, with multiple value of the 'target' option and with the 'app' and 'arguments' options"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: {
          target: [""first.html"", ""second.html""],
          app: { name: ""google-chrome"", arguments: [""--incognito""] },
        },
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
        app: { name: ""google-chrome"", arguments: [""--incognito""] },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
        app: { name: ""google-chrome"", arguments: [""--incognito""] },
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 621, 'column': 4, 'index': 12237}","it(""should work with object, with multiple value of the 'target' option and with the 'app' and 'arguments' options"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: {
          target: [""first.html"", ""second.html""],
          app: { name: ""google-chrome"", arguments: [""--incognito""] },
        },
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
        app: { name: ""google-chrome"", arguments: [""--incognito""] },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
        app: { name: ""google-chrome"", arguments: [""--incognito""] },
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 649, 'column': 4, 'index': 12964}","it(""should work with object, with multiple value of the 'target' option (relative and absolute URLs) and with the 'app' option with arguments"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: {
          target: [""first.html"", `http://${host}:${port}/second.html`],
          app: { name: ""google-chrome"", arguments: [""--incognito""] },
        },
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
        app: { name: ""google-chrome"", arguments: [""--incognito""] },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
        app: { name: ""google-chrome"", arguments: [""--incognito""] },
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 657, 'column': 4, 'index': 13171}","it(""should work with object, with multiple value of the 'target' option (relative and absolute URLs) and with the 'app' option with arguments"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: {
          target: [""first.html"", `http://${host}:${port}/second.html`],
          app: { name: ""google-chrome"", arguments: [""--incognito""] },
        },
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://${host}:${port}/first.html`,
      {
        wait: false,
        app: { name: ""google-chrome"", arguments: [""--incognito""] },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://${host}:${port}/second.html`,
      {
        wait: false,
        app: { name: ""google-chrome"", arguments: [""--incognito""] },
      },
    );
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 691, 'column': 4, 'index': 13844}","it(""should work with <url> pattern in multiple open options"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: [
          {
            target: ""<url>"",
            app: ""google-chrome"",
          },
          {
            target: ""<url>"",
            app: ""firefox"",
          },
        ],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://${host}:${port}/`, {
      app: { name: ""google-chrome"" },
      wait: false,
    });

    expect(open).toHaveBeenCalledWith(`http://${host}:${port}/`, {
      app: { name: ""firefox"" },
      wait: false,
    });
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 696, 'column': 4, 'index': 13977}","it(""should work with <url> pattern in multiple open options"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: [
          {
            target: ""<url>"",
            app: ""google-chrome"",
          },
          {
            target: ""<url>"",
            app: ""firefox"",
          },
        ],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://${host}:${port}/`, {
      app: { name: ""google-chrome"" },
      wait: false,
    });

    expect(open).toHaveBeenCalledWith(`http://${host}:${port}/`, {
      app: { name: ""firefox"" },
      wait: false,
    });
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 724, 'column': 4, 'index': 14508}","it(""should work with multiple open options without target"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: [
          {
            app: ""google-chrome"",
          },
          {
            app: ""firefox"",
          },
        ],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://${host}:${port}/`, {
      app: { name: ""google-chrome"" },
      wait: false,
    });

    expect(open).toHaveBeenCalledWith(`http://${host}:${port}/`, {
      app: { name: ""firefox"" },
      wait: false,
    });
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 729, 'column': 4, 'index': 14641}","it(""should work with multiple open options without target"", async () => {
    const host = ""localhost"";

    const server = new Server(
      {
        host,
        port,
        open: [
          {
            app: ""google-chrome"",
          },
          {
            app: ""firefox"",
          },
        ],
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenCalledWith(`http://${host}:${port}/`, {
      app: { name: ""google-chrome"" },
      wait: false,
    });

    expect(open).toHaveBeenCalledWith(`http://${host}:${port}/`, {
      app: { name: ""firefox"" },
      wait: false,
    });
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 914, 'column': 4, 'index': 19976}","it(""should log warning when can't open with object with the 'app' option with arguments #2"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: [""first.html"", `http://localhost:${port}/second.html`],
          app: {
            name: ""google-chrome"",
            arguments: [""--incognito"", ""--new-window""],
          },
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://localhost:${port}/first.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://localhost:${port}/second.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      1,
      `Unable to open ""http://localhost:${port}/first.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      2,
      `Unable to open ""http://localhost:${port}/second.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 925, 'column': 4, 'index': 20230}","it(""should log warning when can't open with object with the 'app' option with arguments #2"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: [""first.html"", `http://localhost:${port}/second.html`],
          app: {
            name: ""google-chrome"",
            arguments: [""--incognito"", ""--new-window""],
          },
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://localhost:${port}/first.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://localhost:${port}/second.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      1,
      `Unable to open ""http://localhost:${port}/first.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      2,
      `Unable to open ""http://localhost:${port}/second.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 936, 'column': 4, 'index': 20485}","it(""should log warning when can't open with object with the 'app' option with arguments #2"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: [""first.html"", `http://localhost:${port}/second.html`],
          app: {
            name: ""google-chrome"",
            arguments: [""--incognito"", ""--new-window""],
          },
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://localhost:${port}/first.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://localhost:${port}/second.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      1,
      `Unable to open ""http://localhost:${port}/first.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      2,
      `Unable to open ""http://localhost:${port}/second.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",steel
/test/server/open-option.test.js,Duplicate Assert,"{'line': 940, 'column': 4, 'index': 20839}","it(""should log warning when can't open with object with the 'app' option with arguments #2"", async () => {
    open.mockRejectedValue(undefined);

    const loggerWarnSpy = jest.fn();
    const getInfrastructureLoggerSpy = jest
      .spyOn(compiler, ""getInfrastructureLogger"")
      .mockImplementation(() => ({
        warn: loggerWarnSpy,
        info: () => {},
        log: () => {},
      }));

    const server = new Server(
      {
        open: {
          target: [""first.html"", `http://localhost:${port}/second.html`],
          app: {
            name: ""google-chrome"",
            arguments: [""--incognito"", ""--new-window""],
          },
        },
        port,
      },
      compiler,
    );

    await server.start();
    await server.stop();

    expect(open).toHaveBeenNthCalledWith(
      1,
      `http://localhost:${port}/first.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(open).toHaveBeenNthCalledWith(
      2,
      `http://localhost:${port}/second.html`,
      {
        wait: false,
        app: {
          name: ""google-chrome"",
          arguments: [""--incognito"", ""--new-window""],
        },
      },
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      1,
      `Unable to open ""http://localhost:${port}/first.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );
    expect(loggerWarnSpy).toHaveBeenNthCalledWith(
      2,
      `Unable to open ""http://localhost:${port}/second.html"" page in ""google-chrome"" app with ""--incognito --new-window"" arguments. If you are running in a headless environment, please do not use the ""open"" option or related flags like ""--open"", ""--open-target"", and ""--open-app-name"".`,
    );

    getInfrastructureLoggerSpy.mockRestore();
    loggerWarnSpy.mockRestore();
  })",steel
/test/e2e/web-socket-server.test.js,Eager Test,"{'line': 23, 'column': 36, 'index': 726}","it(""should work allow to disable"", async () => {
    const devServerPort = port;

    const compiler = webpack(config);
    const devServerOptions = {
      webSocketServer: false,
      port: devServerPort,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const webSocketRequests = [];
      const session = await page.target().createCDPSession();

      session.on(""Network.webSocketCreated"", (test) => {
        webSocketRequests.push(test);
      });

      await session.send(""Target.setAutoAttach"", {
        autoAttach: true,
        flatten: true,
        waitForDebuggerOnStart: true,
      });

      sessionSubscribe(session);

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(webSocketRequests).toHaveLength(0);
      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/web-socket-server.test.js,Eager Test,"{'line': 50, 'column': 6, 'index': 1361}","it(""should work allow to disable"", async () => {
    const devServerPort = port;

    const compiler = webpack(config);
    const devServerOptions = {
      webSocketServer: false,
      port: devServerPort,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const webSocketRequests = [];
      const session = await page.target().createCDPSession();

      session.on(""Network.webSocketCreated"", (test) => {
        webSocketRequests.push(test);
      });

      await session.send(""Target.setAutoAttach"", {
        autoAttach: true,
        flatten: true,
        waitForDebuggerOnStart: true,
      });

      sessionSubscribe(session);

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(webSocketRequests).toHaveLength(0);
      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/web-socket-server.test.js,Exception Handling,"{'line': 25, 'column': 4, 'index': 745}","it(""should work allow to disable"", async () => {
    const devServerPort = port;

    const compiler = webpack(config);
    const devServerOptions = {
      webSocketServer: false,
      port: devServerPort,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const webSocketRequests = [];
      const session = await page.target().createCDPSession();

      session.on(""Network.webSocketCreated"", (test) => {
        webSocketRequests.push(test);
      });

      await session.send(""Target.setAutoAttach"", {
        autoAttach: true,
        flatten: true,
        waitForDebuggerOnStart: true,
      });

      sessionSubscribe(session);

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(webSocketRequests).toHaveLength(0);
      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/web-socket-server.test.js,Magic Number,"{'line': 56, 'column': 45, 'index': 1533}","it(""should work allow to disable"", async () => {
    const devServerPort = port;

    const compiler = webpack(config);
    const devServerOptions = {
      webSocketServer: false,
      port: devServerPort,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const webSocketRequests = [];
      const session = await page.target().createCDPSession();

      session.on(""Network.webSocketCreated"", (test) => {
        webSocketRequests.push(test);
      });

      await session.send(""Target.setAutoAttach"", {
        autoAttach: true,
        flatten: true,
        waitForDebuggerOnStart: true,
      });

      sessionSubscribe(session);

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(webSocketRequests).toHaveLength(0);
      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 15, 'column': 2, 'index': 549}","describe(""web socket server URL"", () => {
  for (const webSocketServer of webSocketServers) {
    const websocketURLProtocol = webSocketServer === ""ws"" ? ""ws"" : ""http"";

    it(`should work behind proxy, when hostnames are same and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });
        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when hostnames are different and ports are same (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when hostnames are different and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: devServerHost,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when the ""host"" option is ""local-ip"" and the ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 40000;

      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""local-ip"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedHost = server.options.host;
      const resolvedPort = server.options.port;

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${resolvedHost}:${resolvedPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${resolvedHost}:${resolvedPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option using ""auto:"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""auto:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option using ""http:"" value and convert to ""ws:"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""http:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.host"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""127.0.0.1"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.host"" option using ""0.0.0.0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""0.0.0.0"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port1,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: `${port1}`,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with ""client.webSocketURL.port"" and ""webSocketServer.options.port"" options as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            host: ""0.0.0.0"",
            // ""sockjs"" doesn't support external server
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        client: {
          webSocketURL: {
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""sockjs""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port2}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option using ""0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: 0,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with default ""/ws"" value of the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.username"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL:
            webSocketServer === ""ws""
              ? {
                  username: ""foo"",
                  password: ""chuntaro"",
                }
              : {},
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          // ""sockjs"" has bug with parsing URL
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://foo:chuntaro@127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.username"" and ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
            password: ""chuntaro"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu:chuntaro@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server
    it(`should work with the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws/foo/bar"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending without slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server, ""sockjs"" adds ""/"" be default, because need do requests like ""/custom-ws/info?t=1624462615772""
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending with slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""sockjs"" server
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""prefix"" for compatibility with ""sockjs"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options:
            webSocketServer === ""ws""
              ? { path: ""/custom-ws"" }
              : { prefix: ""/custom-ws"" },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is IPv4 (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: hostname,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is ""local-ip"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ip"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is ""local-ipv4"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ipv4"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with ""server: 'https'"" option (""${webSocketServer}"")`, async () => {
      const hostname = ""localhost"";
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        server: ""https"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`https://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        if (webSocketServer === ""ws"") {
          expect(webSocketRequest.url).toContain(
            `wss://${hostname}:${port1}/ws`,
          );
        } else {
          expect(webSocketRequest.url).toContain(
            `https://${hostname}:${port1}/ws`,
          );
        }

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    const [major] = process.versions.node.split(""."").map(Number);

    (major >= 24 ? it.skip : it)(
      `should work with ""server: 'spdy'"" option (""${webSocketServer}"")`,
      async () => {
        const hostname = ""localhost"";
        const compiler = webpack(config);
        const devServerOptions = {
          webSocketServer,
          port: port1,
          server: ""spdy"",
        };
        const server = new Server(devServerOptions, compiler);

        await server.start();

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const webSocketRequests = [];

          if (webSocketServer === ""ws"") {
            const session = await page.target().createCDPSession();

            session.on(""Network.webSocketCreated"", (test) => {
              webSocketRequests.push(test);
            });

            await session.send(""Target.setAutoAttach"", {
              autoAttach: true,
              flatten: true,
              waitForDebuggerOnStart: true,
            });

            sessionSubscribe(session);
          } else {
            page.on(""request"", (request) => {
              if (/\/ws\//.test(request.url())) {
                webSocketRequests.push({ url: request.url() });
              }
            });
          }

          await page.goto(`https://${hostname}:${port1}/`, {
            waitUntil: ""networkidle0"",
          });

          const [webSocketRequest] = webSocketRequests;

          /* eslint-disable jest/no-standalone-expect */
          if (webSocketServer === ""ws"") {
            expect(webSocketRequest.url).toContain(
              `wss://${hostname}:${port1}/ws`,
            );
          } else {
            expect(webSocketRequest.url).toContain(
              `https://${hostname}:${port1}/ws`,
            );
          }

          expect(consoleMessages.map((message) => message.text())).toEqual([
            ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
            ""[HMR] Waiting for update signal from WDS..."",
            ""Hey."",
          ]);
          expect(pageErrors).toHaveLength(0);
          /* eslint-enable jest/no-standalone-expect */
        } finally {
          await browser.close();
          await server.stop();
        }
      },
    );

    it(`should work when ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 50000;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedFreePort = server.options.port;

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${resolvedFreePort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${resolvedFreePort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    });

    it(`should work with ""client.webSocketURL.*"" options (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
            hostname: ""127.0.0.1"",
            port: port1,
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL"" option as ""string"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: `ws://127.0.0.1:${port1}/ws`,
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work and throw an error on invalid web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""unknown://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) =>
            pageError.message.split(""\n"")[0].replace(""SyntaxError: "", """"),
          ),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should not work and output disconnect wrong web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""ws://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        let isDisconnected = false;

        page
          .on(""console"", (message) => {
            const text = message.text();

            if (!isDisconnected) {
              isDisconnected = /Disconnected!/.test(text);
              consoleMessages.push(text.replaceAll(/:[\d]+/g, "":<port>""));
            }
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (
              consoleMessages.includes(""[webpack-dev-server] Disconnected!"")
            ) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });

        expect(consoleMessages).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) => pageError.message.split(""\n"")[0]),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });
  }
})",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 72, 'column': 8, 'index': 2142}","it(`should work behind proxy, when hostnames are same and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });
        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 88, 'column': 12, 'index': 2638}","it(`should work behind proxy, when hostnames are same and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });
        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 167, 'column': 8, 'index': 4858}","it(`should work behind proxy, when hostnames are different and ports are same (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 183, 'column': 12, 'index': 5354}","it(`should work behind proxy, when hostnames are different and ports are same (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 268, 'column': 8, 'index': 7685}","it(`should work behind proxy, when hostnames are different and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: devServerHost,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 284, 'column': 12, 'index': 8181}","it(`should work behind proxy, when hostnames are different and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: devServerHost,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 368, 'column': 8, 'index': 10490}","it(`should work behind proxy, when the ""host"" option is ""local-ip"" and the ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 40000;

      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""local-ip"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedHost = server.options.host;
      const resolvedPort = server.options.port;

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${resolvedHost}:${resolvedPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${resolvedHost}:${resolvedPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 384, 'column': 12, 'index': 10986}","it(`should work behind proxy, when the ""host"" option is ""local-ip"" and the ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 40000;

      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""local-ip"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedHost = server.options.host;
      const resolvedPort = server.options.port;

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${resolvedHost}:${resolvedPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${resolvedHost}:${resolvedPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 446, 'column': 8, 'index': 12639}","it(`should work with the ""client.webSocketURL.protocol"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 462, 'column': 12, 'index': 13135}","it(`should work with the ""client.webSocketURL.protocol"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 520, 'column': 8, 'index': 14708}","it(`should work with the ""client.webSocketURL.protocol"" option using ""auto:"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""auto:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 536, 'column': 12, 'index': 15204}","it(`should work with the ""client.webSocketURL.protocol"" option using ""auto:"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""auto:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 594, 'column': 8, 'index': 16798}","it(`should work with the ""client.webSocketURL.protocol"" option using ""http:"" value and convert to ""ws:"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""http:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 610, 'column': 12, 'index': 17294}","it(`should work with the ""client.webSocketURL.protocol"" option using ""http:"" value and convert to ""ws:"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""http:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 668, 'column': 8, 'index': 18847}","it(`should work with the ""client.webSocketURL.host"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""127.0.0.1"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 684, 'column': 12, 'index': 19343}","it(`should work with the ""client.webSocketURL.host"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""127.0.0.1"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 742, 'column': 8, 'index': 20916}","it(`should work with the ""client.webSocketURL.host"" option using ""0.0.0.0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""0.0.0.0"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 758, 'column': 12, 'index': 21412}","it(`should work with the ""client.webSocketURL.host"" option using ""0.0.0.0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""0.0.0.0"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 815, 'column': 8, 'index': 22954}","it(`should work with the ""client.webSocketURL.port"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port1,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 831, 'column': 12, 'index': 23450}","it(`should work with the ""client.webSocketURL.port"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port1,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 889, 'column': 8, 'index': 25008}","it(`should work with the ""client.webSocketURL.port"" option as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: `${port1}`,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 905, 'column': 12, 'index': 25504}","it(`should work with the ""client.webSocketURL.port"" option as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: `${port1}`,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 970, 'column': 8, 'index': 27377}","it(`should work with ""client.webSocketURL.port"" and ""webSocketServer.options.port"" options as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            host: ""0.0.0.0"",
            // ""sockjs"" doesn't support external server
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        client: {
          webSocketURL: {
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""sockjs""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port2}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 986, 'column': 12, 'index': 27873}","it(`should work with ""client.webSocketURL.port"" and ""webSocketServer.options.port"" options as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            host: ""0.0.0.0"",
            // ""sockjs"" doesn't support external server
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        client: {
          webSocketURL: {
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""sockjs""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port2}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1046, 'column': 8, 'index': 29535}","it(`should work with the ""client.webSocketURL.port"" option using ""0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: 0,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1062, 'column': 12, 'index': 30031}","it(`should work with the ""client.webSocketURL.port"" option using ""0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: 0,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1119, 'column': 8, 'index': 31581}","it(`should work with the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1135, 'column': 12, 'index': 32077}","it(`should work with the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1188, 'column': 8, 'index': 33554}","it(`should work with default ""/ws"" value of the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1204, 'column': 12, 'index': 34050}","it(`should work with default ""/ws"" value of the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1262, 'column': 8, 'index': 35605}","it(`should work with the ""client.webSocketURL.username"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1278, 'column': 12, 'index': 36101}","it(`should work with the ""client.webSocketURL.username"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1339, 'column': 8, 'index': 37783}","it(`should work with the ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL:
            webSocketServer === ""ws""
              ? {
                  username: ""foo"",
                  password: ""chuntaro"",
                }
              : {},
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          // ""sockjs"" has bug with parsing URL
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://foo:chuntaro@127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1355, 'column': 12, 'index': 38279}","it(`should work with the ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL:
            webSocketServer === ""ws""
              ? {
                  username: ""foo"",
                  password: ""chuntaro"",
                }
              : {},
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          // ""sockjs"" has bug with parsing URL
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://foo:chuntaro@127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1416, 'column': 8, 'index': 40065}","it(`should work with the ""client.webSocketURL.username"" and ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
            password: ""chuntaro"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu:chuntaro@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1432, 'column': 12, 'index': 40561}","it(`should work with the ""client.webSocketURL.username"" and ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
            password: ""chuntaro"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu:chuntaro@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1490, 'column': 8, 'index': 42146}","it(`should work with the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1506, 'column': 12, 'index': 42642}","it(`should work with the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1565, 'column': 8, 'index': 44316}","it(`should work with the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1581, 'column': 12, 'index': 44812}","it(`should work with the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1646, 'column': 8, 'index': 46652}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws/foo/bar"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1662, 'column': 12, 'index': 47148}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws/foo/bar"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1725, 'column': 8, 'index': 48909}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending without slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1741, 'column': 12, 'index': 49405}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending without slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1805, 'column': 8, 'index': 51362}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending with slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1821, 'column': 12, 'index': 51858}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending with slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1884, 'column': 8, 'index': 53698}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1900, 'column': 12, 'index': 54194}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1967, 'column': 8, 'index': 56161}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""prefix"" for compatibility with ""sockjs"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options:
            webSocketServer === ""ws""
              ? { path: ""/custom-ws"" }
              : { prefix: ""/custom-ws"" },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 1983, 'column': 12, 'index': 56657}","it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""prefix"" for compatibility with ""sockjs"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options:
            webSocketServer === ""ws""
              ? { path: ""/custom-ws"" }
              : { prefix: ""/custom-ws"" },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2036, 'column': 8, 'index': 58125}","it(`should work when ""host"" option is IPv4 (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: hostname,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2052, 'column': 12, 'index': 58621}","it(`should work when ""host"" option is IPv4 (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: hostname,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2104, 'column': 8, 'index': 60088}","it(`should work when ""host"" option is ""local-ip"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ip"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2120, 'column': 12, 'index': 60584}","it(`should work when ""host"" option is ""local-ip"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ip"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2173, 'column': 8, 'index': 62056}","it(`should work when ""host"" option is ""local-ipv4"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ipv4"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2189, 'column': 12, 'index': 62552}","it(`should work when ""host"" option is ""local-ipv4"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ipv4"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2241, 'column': 8, 'index': 63999}","it(`should work with ""server: 'https'"" option (""${webSocketServer}"")`, async () => {
      const hostname = ""localhost"";
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        server: ""https"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`https://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        if (webSocketServer === ""ws"") {
          expect(webSocketRequest.url).toContain(
            `wss://${hostname}:${port1}/ws`,
          );
        } else {
          expect(webSocketRequest.url).toContain(
            `https://${hostname}:${port1}/ws`,
          );
        }

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2257, 'column': 12, 'index': 64495}","it(`should work with ""server: 'https'"" option (""${webSocketServer}"")`, async () => {
      const hostname = ""localhost"";
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        server: ""https"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`https://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        if (webSocketServer === ""ws"") {
          expect(webSocketRequest.url).toContain(
            `wss://${hostname}:${port1}/ws`,
          );
        } else {
          expect(webSocketRequest.url).toContain(
            `https://${hostname}:${port1}/ws`,
          );
        }

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2269, 'column': 8, 'index': 64804}","it(`should work with ""server: 'https'"" option (""${webSocketServer}"")`, async () => {
      const hostname = ""localhost"";
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        server: ""https"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`https://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        if (webSocketServer === ""ws"") {
          expect(webSocketRequest.url).toContain(
            `wss://${hostname}:${port1}/ws`,
          );
        } else {
          expect(webSocketRequest.url).toContain(
            `https://${hostname}:${port1}/ws`,
          );
        }

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2321, 'column': 10, 'index': 66256}","describe(""web socket server URL"", () => {
  for (const webSocketServer of webSocketServers) {
    const websocketURLProtocol = webSocketServer === ""ws"" ? ""ws"" : ""http"";

    it(`should work behind proxy, when hostnames are same and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });
        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when hostnames are different and ports are same (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when hostnames are different and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: devServerHost,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when the ""host"" option is ""local-ip"" and the ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 40000;

      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""local-ip"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedHost = server.options.host;
      const resolvedPort = server.options.port;

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${resolvedHost}:${resolvedPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${resolvedHost}:${resolvedPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option using ""auto:"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""auto:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option using ""http:"" value and convert to ""ws:"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""http:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.host"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""127.0.0.1"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.host"" option using ""0.0.0.0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""0.0.0.0"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port1,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: `${port1}`,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with ""client.webSocketURL.port"" and ""webSocketServer.options.port"" options as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            host: ""0.0.0.0"",
            // ""sockjs"" doesn't support external server
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        client: {
          webSocketURL: {
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""sockjs""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port2}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option using ""0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: 0,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with default ""/ws"" value of the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.username"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL:
            webSocketServer === ""ws""
              ? {
                  username: ""foo"",
                  password: ""chuntaro"",
                }
              : {},
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          // ""sockjs"" has bug with parsing URL
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://foo:chuntaro@127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.username"" and ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
            password: ""chuntaro"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu:chuntaro@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server
    it(`should work with the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws/foo/bar"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending without slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server, ""sockjs"" adds ""/"" be default, because need do requests like ""/custom-ws/info?t=1624462615772""
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending with slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""sockjs"" server
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""prefix"" for compatibility with ""sockjs"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options:
            webSocketServer === ""ws""
              ? { path: ""/custom-ws"" }
              : { prefix: ""/custom-ws"" },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is IPv4 (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: hostname,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is ""local-ip"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ip"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is ""local-ipv4"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ipv4"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with ""server: 'https'"" option (""${webSocketServer}"")`, async () => {
      const hostname = ""localhost"";
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        server: ""https"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`https://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        if (webSocketServer === ""ws"") {
          expect(webSocketRequest.url).toContain(
            `wss://${hostname}:${port1}/ws`,
          );
        } else {
          expect(webSocketRequest.url).toContain(
            `https://${hostname}:${port1}/ws`,
          );
        }

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    const [major] = process.versions.node.split(""."").map(Number);

    (major >= 24 ? it.skip : it)(
      `should work with ""server: 'spdy'"" option (""${webSocketServer}"")`,
      async () => {
        const hostname = ""localhost"";
        const compiler = webpack(config);
        const devServerOptions = {
          webSocketServer,
          port: port1,
          server: ""spdy"",
        };
        const server = new Server(devServerOptions, compiler);

        await server.start();

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const webSocketRequests = [];

          if (webSocketServer === ""ws"") {
            const session = await page.target().createCDPSession();

            session.on(""Network.webSocketCreated"", (test) => {
              webSocketRequests.push(test);
            });

            await session.send(""Target.setAutoAttach"", {
              autoAttach: true,
              flatten: true,
              waitForDebuggerOnStart: true,
            });

            sessionSubscribe(session);
          } else {
            page.on(""request"", (request) => {
              if (/\/ws\//.test(request.url())) {
                webSocketRequests.push({ url: request.url() });
              }
            });
          }

          await page.goto(`https://${hostname}:${port1}/`, {
            waitUntil: ""networkidle0"",
          });

          const [webSocketRequest] = webSocketRequests;

          /* eslint-disable jest/no-standalone-expect */
          if (webSocketServer === ""ws"") {
            expect(webSocketRequest.url).toContain(
              `wss://${hostname}:${port1}/ws`,
            );
          } else {
            expect(webSocketRequest.url).toContain(
              `https://${hostname}:${port1}/ws`,
            );
          }

          expect(consoleMessages.map((message) => message.text())).toEqual([
            ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
            ""[HMR] Waiting for update signal from WDS..."",
            ""Hey."",
          ]);
          expect(pageErrors).toHaveLength(0);
          /* eslint-enable jest/no-standalone-expect */
        } finally {
          await browser.close();
          await server.stop();
        }
      },
    );

    it(`should work when ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 50000;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedFreePort = server.options.port;

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${resolvedFreePort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${resolvedFreePort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    });

    it(`should work with ""client.webSocketURL.*"" options (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
            hostname: ""127.0.0.1"",
            port: port1,
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL"" option as ""string"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: `ws://127.0.0.1:${port1}/ws`,
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work and throw an error on invalid web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""unknown://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) =>
            pageError.message.split(""\n"")[0].replace(""SyntaxError: "", """"),
          ),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should not work and output disconnect wrong web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""ws://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        let isDisconnected = false;

        page
          .on(""console"", (message) => {
            const text = message.text();

            if (!isDisconnected) {
              isDisconnected = /Disconnected!/.test(text);
              consoleMessages.push(text.replaceAll(/:[\d]+/g, "":<port>""));
            }
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (
              consoleMessages.includes(""[webpack-dev-server] Disconnected!"")
            ) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });

        expect(consoleMessages).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) => pageError.message.split(""\n"")[0]),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });
  }
})",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2337, 'column': 14, 'index': 66778}","describe(""web socket server URL"", () => {
  for (const webSocketServer of webSocketServers) {
    const websocketURLProtocol = webSocketServer === ""ws"" ? ""ws"" : ""http"";

    it(`should work behind proxy, when hostnames are same and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });
        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when hostnames are different and ports are same (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when hostnames are different and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: devServerHost,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when the ""host"" option is ""local-ip"" and the ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 40000;

      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""local-ip"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedHost = server.options.host;
      const resolvedPort = server.options.port;

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${resolvedHost}:${resolvedPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${resolvedHost}:${resolvedPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option using ""auto:"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""auto:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option using ""http:"" value and convert to ""ws:"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""http:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.host"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""127.0.0.1"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.host"" option using ""0.0.0.0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""0.0.0.0"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port1,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: `${port1}`,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with ""client.webSocketURL.port"" and ""webSocketServer.options.port"" options as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            host: ""0.0.0.0"",
            // ""sockjs"" doesn't support external server
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        client: {
          webSocketURL: {
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""sockjs""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port2}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option using ""0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: 0,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with default ""/ws"" value of the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.username"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL:
            webSocketServer === ""ws""
              ? {
                  username: ""foo"",
                  password: ""chuntaro"",
                }
              : {},
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          // ""sockjs"" has bug with parsing URL
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://foo:chuntaro@127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.username"" and ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
            password: ""chuntaro"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu:chuntaro@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server
    it(`should work with the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws/foo/bar"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending without slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server, ""sockjs"" adds ""/"" be default, because need do requests like ""/custom-ws/info?t=1624462615772""
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending with slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""sockjs"" server
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""prefix"" for compatibility with ""sockjs"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options:
            webSocketServer === ""ws""
              ? { path: ""/custom-ws"" }
              : { prefix: ""/custom-ws"" },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is IPv4 (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: hostname,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is ""local-ip"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ip"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is ""local-ipv4"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ipv4"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with ""server: 'https'"" option (""${webSocketServer}"")`, async () => {
      const hostname = ""localhost"";
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        server: ""https"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`https://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        if (webSocketServer === ""ws"") {
          expect(webSocketRequest.url).toContain(
            `wss://${hostname}:${port1}/ws`,
          );
        } else {
          expect(webSocketRequest.url).toContain(
            `https://${hostname}:${port1}/ws`,
          );
        }

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    const [major] = process.versions.node.split(""."").map(Number);

    (major >= 24 ? it.skip : it)(
      `should work with ""server: 'spdy'"" option (""${webSocketServer}"")`,
      async () => {
        const hostname = ""localhost"";
        const compiler = webpack(config);
        const devServerOptions = {
          webSocketServer,
          port: port1,
          server: ""spdy"",
        };
        const server = new Server(devServerOptions, compiler);

        await server.start();

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const webSocketRequests = [];

          if (webSocketServer === ""ws"") {
            const session = await page.target().createCDPSession();

            session.on(""Network.webSocketCreated"", (test) => {
              webSocketRequests.push(test);
            });

            await session.send(""Target.setAutoAttach"", {
              autoAttach: true,
              flatten: true,
              waitForDebuggerOnStart: true,
            });

            sessionSubscribe(session);
          } else {
            page.on(""request"", (request) => {
              if (/\/ws\//.test(request.url())) {
                webSocketRequests.push({ url: request.url() });
              }
            });
          }

          await page.goto(`https://${hostname}:${port1}/`, {
            waitUntil: ""networkidle0"",
          });

          const [webSocketRequest] = webSocketRequests;

          /* eslint-disable jest/no-standalone-expect */
          if (webSocketServer === ""ws"") {
            expect(webSocketRequest.url).toContain(
              `wss://${hostname}:${port1}/ws`,
            );
          } else {
            expect(webSocketRequest.url).toContain(
              `https://${hostname}:${port1}/ws`,
            );
          }

          expect(consoleMessages.map((message) => message.text())).toEqual([
            ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
            ""[HMR] Waiting for update signal from WDS..."",
            ""Hey."",
          ]);
          expect(pageErrors).toHaveLength(0);
          /* eslint-enable jest/no-standalone-expect */
        } finally {
          await browser.close();
          await server.stop();
        }
      },
    );

    it(`should work when ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 50000;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedFreePort = server.options.port;

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${resolvedFreePort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${resolvedFreePort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    });

    it(`should work with ""client.webSocketURL.*"" options (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
            hostname: ""127.0.0.1"",
            port: port1,
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL"" option as ""string"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: `ws://127.0.0.1:${port1}/ws`,
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work and throw an error on invalid web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""unknown://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) =>
            pageError.message.split(""\n"")[0].replace(""SyntaxError: "", """"),
          ),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should not work and output disconnect wrong web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""ws://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        let isDisconnected = false;

        page
          .on(""console"", (message) => {
            const text = message.text();

            if (!isDisconnected) {
              isDisconnected = /Disconnected!/.test(text);
              consoleMessages.push(text.replaceAll(/:[\d]+/g, "":<port>""));
            }
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (
              consoleMessages.includes(""[webpack-dev-server] Disconnected!"")
            ) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });

        expect(consoleMessages).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) => pageError.message.split(""\n"")[0]),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });
  }
})",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2350, 'column': 10, 'index': 67162}","describe(""web socket server URL"", () => {
  for (const webSocketServer of webSocketServers) {
    const websocketURLProtocol = webSocketServer === ""ws"" ? ""ws"" : ""http"";

    it(`should work behind proxy, when hostnames are same and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });
        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when hostnames are different and ports are same (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();
        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when hostnames are different and ports are different (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const devServerPort = port1;
      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: devServerHost,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();
        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${devServerPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should work behind proxy, when the ""host"" option is ""local-ip"" and the ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 40000;

      const proxyHost = Server.internalIPSync(""v4"");
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""local-ip"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedHost = server.options.host;
      const resolvedPort = server.options.port;

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${resolvedHost}:${resolvedPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${resolvedHost}:${resolvedPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option using ""auto:"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""auto:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.protocol"" option using ""http:"" value and convert to ""ws:"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""http:"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://localhost:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.host"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""127.0.0.1"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.host"" option using ""0.0.0.0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            hostname: ""0.0.0.0"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port1,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: `${port1}`,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with ""client.webSocketURL.port"" and ""webSocketServer.options.port"" options as string (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            host: ""0.0.0.0"",
            // ""sockjs"" doesn't support external server
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        client: {
          webSocketURL: {
            port: webSocketServer === ""sockjs"" ? `${port1}` : `${port2}`,
          },
        },
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""sockjs""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port2}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.port"" option using ""0"" value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: 0,
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with default ""/ws"" value of the ""client.webSocketURL.pathname"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.username"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL:
            webSocketServer === ""ws""
              ? {
                  username: ""foo"",
                  password: ""chuntaro"",
                }
              : {},
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          // ""sockjs"" has bug with parsing URL
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://foo:chuntaro@127.0.0.1:${port1}/ws`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.username"" and ""client.webSocketURL.password"" option (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            username: ""zenitsu"",
            password: ""chuntaro"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://zenitsu:chuntaro@127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server
    it(`should work with the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws/foo/bar"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws/foo/bar"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\/foo\/bar/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/foo/bar`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending without slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server, ""sockjs"" adds ""/"" be default, because need do requests like ""/custom-ws/info?t=1624462615772""
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" ending with slash (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? ""/custom-ws/"" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws/`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""ws"" server
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""path"" using empty value (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options: {
            path: webSocketServer === ""ws"" ? """" : ""/custom-ws"",
          },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          webSocketServer === ""ws""
            ? `${websocketURLProtocol}://127.0.0.1:${port1}`
            : `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    // Only works for ""sockjs"" server
    it(`should work with the ""client.webSocketURL.pathname"" option and the custom web socket server ""prefix"" for compatibility with ""sockjs"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            pathname: ""/custom-ws"",
          },
        },
        webSocketServer: {
          type: webSocketServer,
          options:
            webSocketServer === ""ws""
              ? { path: ""/custom-ws"" }
              : { prefix: ""/custom-ws"" },
        },
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/custom-ws/.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/custom-ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is IPv4 (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: hostname,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is ""local-ip"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ip"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work when ""host"" option is ""local-ipv4"" (""${webSocketServer}"")`, async () => {
      const hostname = Server.internalIPSync(""v4"");
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        host: ""local-ipv4"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }
        await page.goto(`http://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${hostname}:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with ""server: 'https'"" option (""${webSocketServer}"")`, async () => {
      const hostname = ""localhost"";
      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: port1,
        server: ""https"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`https://${hostname}:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        if (webSocketServer === ""ws"") {
          expect(webSocketRequest.url).toContain(
            `wss://${hostname}:${port1}/ws`,
          );
        } else {
          expect(webSocketRequest.url).toContain(
            `https://${hostname}:${port1}/ws`,
          );
        }

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    const [major] = process.versions.node.split(""."").map(Number);

    (major >= 24 ? it.skip : it)(
      `should work with ""server: 'spdy'"" option (""${webSocketServer}"")`,
      async () => {
        const hostname = ""localhost"";
        const compiler = webpack(config);
        const devServerOptions = {
          webSocketServer,
          port: port1,
          server: ""spdy"",
        };
        const server = new Server(devServerOptions, compiler);

        await server.start();

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const webSocketRequests = [];

          if (webSocketServer === ""ws"") {
            const session = await page.target().createCDPSession();

            session.on(""Network.webSocketCreated"", (test) => {
              webSocketRequests.push(test);
            });

            await session.send(""Target.setAutoAttach"", {
              autoAttach: true,
              flatten: true,
              waitForDebuggerOnStart: true,
            });

            sessionSubscribe(session);
          } else {
            page.on(""request"", (request) => {
              if (/\/ws\//.test(request.url())) {
                webSocketRequests.push({ url: request.url() });
              }
            });
          }

          await page.goto(`https://${hostname}:${port1}/`, {
            waitUntil: ""networkidle0"",
          });

          const [webSocketRequest] = webSocketRequests;

          /* eslint-disable jest/no-standalone-expect */
          if (webSocketServer === ""ws"") {
            expect(webSocketRequest.url).toContain(
              `wss://${hostname}:${port1}/ws`,
            );
          } else {
            expect(webSocketRequest.url).toContain(
              `https://${hostname}:${port1}/ws`,
            );
          }

          expect(consoleMessages.map((message) => message.text())).toEqual([
            ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
            ""[HMR] Waiting for update signal from WDS..."",
            ""Hey."",
          ]);
          expect(pageErrors).toHaveLength(0);
          /* eslint-enable jest/no-standalone-expect */
        } finally {
          await browser.close();
          await server.stop();
        }
      },
    );

    it(`should work when ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 50000;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedFreePort = server.options.port;

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${resolvedFreePort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${resolvedFreePort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    });

    it(`should work with ""client.webSocketURL.*"" options (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
            hostname: ""127.0.0.1"",
            port: port1,
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""client.webSocketURL"" option as ""string"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: `ws://127.0.0.1:${port1}/ws`,
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work and throw an error on invalid web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""unknown://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) =>
            pageError.message.split(""\n"")[0].replace(""SyntaxError: "", """"),
          ),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should not work and output disconnect wrong web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""ws://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        let isDisconnected = false;

        page
          .on(""console"", (message) => {
            const text = message.text();

            if (!isDisconnected) {
              isDisconnected = /Disconnected!/.test(text);
              consoleMessages.push(text.replaceAll(/:[\d]+/g, "":<port>""));
            }
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (
              consoleMessages.includes(""[webpack-dev-server] Disconnected!"")
            ) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });

        expect(consoleMessages).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) => pageError.message.split(""\n"")[0]),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });
  }
})",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2406, 'column': 8, 'index': 68835}","it(`should work when ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 50000;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedFreePort = server.options.port;

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${resolvedFreePort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${resolvedFreePort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2422, 'column': 12, 'index': 69331}","it(`should work when ""port"" option is ""auto"" (""${webSocketServer}"")`, async () => {
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = 50000;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        port: ""auto"",
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const resolvedFreePort = server.options.port;

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${resolvedFreePort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${resolvedFreePort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();

        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2485, 'column': 8, 'index': 71041}","it(`should work with ""client.webSocketURL.*"" options (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
            hostname: ""127.0.0.1"",
            port: port1,
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2501, 'column': 12, 'index': 71537}","it(`should work with ""client.webSocketURL.*"" options (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            protocol: ""ws:"",
            hostname: ""127.0.0.1"",
            port: port1,
            pathname: ""/ws"",
          },
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2557, 'column': 8, 'index': 73077}","it(`should work with the ""client.webSocketURL"" option as ""string"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: `ws://127.0.0.1:${port1}/ws`,
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2573, 'column': 12, 'index': 73573}","it(`should work with the ""client.webSocketURL"" option as ""string"" (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: `ws://127.0.0.1:${port1}/ws`,
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://127.0.0.1:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://127.0.0.1:${port1}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2672, 'column': 12, 'index': 76319}","it(`should not work and output disconnect wrong web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""ws://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        let isDisconnected = false;

        page
          .on(""console"", (message) => {
            const text = message.text();

            if (!isDisconnected) {
              isDisconnected = /Disconnected!/.test(text);
              consoleMessages.push(text.replaceAll(/:[\d]+/g, "":<port>""));
            }
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (
              consoleMessages.includes(""[webpack-dev-server] Disconnected!"")
            ) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });

        expect(consoleMessages).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) => pageError.message.split(""\n"")[0]),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-server-url.test.js,Conditional Test Logic,"{'line': 2687, 'column': 12, 'index': 76800}","it(`should not work and output disconnect wrong web socket URL (""${webSocketServer}"")`, async () => {
      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: ""ws://unknown.unknown/unknown"",
        },
        webSocketServer,
        port: port1,
        host: ""0.0.0.0"",
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        let isDisconnected = false;

        page
          .on(""console"", (message) => {
            const text = message.text();

            if (!isDisconnected) {
              isDisconnected = /Disconnected!/.test(text);
              consoleMessages.push(text.replaceAll(/:[\d]+/g, "":<port>""));
            }
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port1}/`, {
          waitUntil: ""networkidle0"",
        });

        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (
              consoleMessages.includes(""[webpack-dev-server] Disconnected!"")
            ) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });

        expect(consoleMessages).toMatchSnapshot(""console messages"");
        expect(
          pageErrors.map((pageError) => pageError.message.split(""\n"")[0]),
        ).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/web-socket-communication.test.js,Conditional Test Logic,"{'line': 14, 'column': 2, 'index': 480}","describe(""web socket communication"", () => {
  const webSocketServers = [""ws"", ""sockjs""];

  for (const websocketServer of webSocketServers) {
    it(`should work and close web socket client connection when web socket server closed (""${websocketServer}"")`, async () => {
      WebsocketServer.heartbeatInterval = 100;

      const compiler = webpack(config);
      const devServerOptions = {
        port,
        webSocketServer: websocketServer,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message.text());
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        await server.stop();
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (
              consoleMessages.includes(""[webpack-dev-server] Disconnected!"")
            ) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });

        expect(consoleMessages).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
      }
    });

    it(`should work and terminate client that is not alive (""${websocketServer}"")`, async () => {
      WebsocketServer.heartbeatInterval = 100;

      const compiler = webpack(config);
      const devServerOptions = {
        port,
        webSocketServer: websocketServer,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });
        await browser.close();

        // Wait heartbeat
        await new Promise((resolve) => {
          setTimeout(() => {
            resolve();
          }, 200);
        });

        expect(server.webSocketServer.clients).toHaveLength(0);
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await server.stop();
      }
    });

    it(`should work and reconnect when the connection is lost (""${websocketServer}"")`, async () => {
      WebsocketServer.heartbeatInterval = 100;

      const compiler = webpack(config);
      const devServerOptions = {
        port,
        webSocketServer: websocketServer,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        await server.stop();
        await server.start();

        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });
  }

  it('should work and do heartbeat using (""ws"" web socket server)', async () => {
    WebsocketServer.heartbeatInterval = 100;

    const compiler = webpack(config);
    const devServerOptions = {
      port,
      webSocketServer: ""ws"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    server.webSocketServer.heartbeatInterval = 100;

    let opened = false;
    let received = false;

    await new Promise((resolve, reject) => {
      const ws = new WebSocket(`ws://localhost:${devServerOptions.port}/ws`, {
        headers: {
          host: `localhost:${devServerOptions.port}`,
          origin: `http://localhost:${devServerOptions.port}`,
        },
      });

      ws.on(""open"", () => {
        opened = true;
      });

      ws.on(""error"", (error) => {
        reject(error);
      });

      ws.on(""ping"", () => {
        if (opened && received) {
          ws.close();
        }
      });

      ws.on(""message"", (data) => {
        const message = JSON.parse(data);

        if (message.type === ""ok"") {
          received = true;
        }
      });

      ws.on(""close"", () => {
        resolve();
      });
    });

    expect(opened).toBe(true);
    expect(received).toBe(true);

    await server.stop();
  });
})",steel
/test/e2e/web-socket-communication.test.js,Conditional Test Logic,"{'line': 48, 'column': 12, 'index': 1509}","it(`should work and close web socket client connection when web socket server closed (""${websocketServer}"")`, async () => {
      WebsocketServer.heartbeatInterval = 100;

      const compiler = webpack(config);
      const devServerOptions = {
        port,
        webSocketServer: websocketServer,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message.text());
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        await server.stop();
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (
              consoleMessages.includes(""[webpack-dev-server] Disconnected!"")
            ) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });

        expect(consoleMessages).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/web-socket-communication.test.js,Conditional Test Logic,"{'line': 195, 'column': 8, 'index': 5347}","it('should work and do heartbeat using (""ws"" web socket server)', async () => {
    WebsocketServer.heartbeatInterval = 100;

    const compiler = webpack(config);
    const devServerOptions = {
      port,
      webSocketServer: ""ws"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    server.webSocketServer.heartbeatInterval = 100;

    let opened = false;
    let received = false;

    await new Promise((resolve, reject) => {
      const ws = new WebSocket(`ws://localhost:${devServerOptions.port}/ws`, {
        headers: {
          host: `localhost:${devServerOptions.port}`,
          origin: `http://localhost:${devServerOptions.port}`,
        },
      });

      ws.on(""open"", () => {
        opened = true;
      });

      ws.on(""error"", (error) => {
        reject(error);
      });

      ws.on(""ping"", () => {
        if (opened && received) {
          ws.close();
        }
      });

      ws.on(""message"", (data) => {
        const message = JSON.parse(data);

        if (message.type === ""ok"") {
          received = true;
        }
      });

      ws.on(""close"", () => {
        resolve();
      });
    });

    expect(opened).toBe(true);
    expect(received).toBe(true);

    await server.stop();
  })",steel
/test/e2e/web-socket-communication.test.js,Conditional Test Logic,"{'line': 203, 'column': 8, 'index': 5502}","it('should work and do heartbeat using (""ws"" web socket server)', async () => {
    WebsocketServer.heartbeatInterval = 100;

    const compiler = webpack(config);
    const devServerOptions = {
      port,
      webSocketServer: ""ws"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    server.webSocketServer.heartbeatInterval = 100;

    let opened = false;
    let received = false;

    await new Promise((resolve, reject) => {
      const ws = new WebSocket(`ws://localhost:${devServerOptions.port}/ws`, {
        headers: {
          host: `localhost:${devServerOptions.port}`,
          origin: `http://localhost:${devServerOptions.port}`,
        },
      });

      ws.on(""open"", () => {
        opened = true;
      });

      ws.on(""error"", (error) => {
        reject(error);
      });

      ws.on(""ping"", () => {
        if (opened && received) {
          ws.close();
        }
      });

      ws.on(""message"", (data) => {
        const message = JSON.parse(data);

        if (message.type === ""ok"") {
          received = true;
        }
      });

      ws.on(""close"", () => {
        resolve();
      });
    });

    expect(opened).toBe(true);
    expect(received).toBe(true);

    await server.stop();
  })",steel
/test/e2e/watch-files.test.js,Conditional Test Logic,"{'line': 456, 'column': 10, 'index': 11176}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        const expected = [file, other];
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(expected.includes(changedPath)).toBeTruthy();

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",steel
/test/e2e/watch-files.test.js,Conditional Test Logic,"{'line': 536, 'column': 10, 'index': 13093}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
        server.staticWatchers[1].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(other);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",steel
/test/e2e/watch-files.test.js,Conditional Test Logic,"{'line': 548, 'column': 10, 'index': 13408}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
        server.staticWatchers[1].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(other);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",steel
/test/e2e/watch-files.test.js,Conditional Test Logic,"{'line': 602, 'column': 4, 'index': 14283}","describe(""should work with options"", () => {
    const file = path.join(watchDir, ""assets/example.txt"");

    const chokidarMock = jest.spyOn(chokidar, ""watch"");

    const optionCases = [
      {
        poll: true,
      },
      {
        poll: 200,
      },
      {
        usePolling: true,
      },
      {
        usePolling: true,
        poll: 200,
      },
      {
        usePolling: false,
      },
      {
        usePolling: false,
        poll: 200,
      },
      {
        usePolling: false,
        poll: true,
      },
      {
        interval: 400,
        poll: 200,
      },
      {
        usePolling: true,
        interval: 200,
        poll: 400,
      },
      {
        usePolling: false,
        interval: 200,
        poll: 400,
      },
    ];

    for (const optionCase of optionCases) {
      describe(JSON.stringify(optionCase), () => {
        let compiler;
        let server;
        let page;
        let browser;
        let pageErrors;
        let consoleMessages;

        beforeEach(async () => {
          chokidarMock.mockClear();

          compiler = webpack(config);

          server = new Server(
            {
              watchFiles: {
                paths: file,
                options: optionCase,
              },
              port,
            },
            compiler,
          );

          await server.start();

          ({ page, browser } = await runBrowser());

          pageErrors = [];
          consoleMessages = [];
        });

        afterEach(async () => {
          await server.stop();
          await browser.close();
          fs.truncateSync(file);
        });

        it(""should reload when file content is changed"", async () => {
          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          // should pass correct options to chokidar config
          expect(chokidarMock.mock.calls[0][1]).toMatchSnapshot();

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");

          // change file content
          fs.writeFileSync(file, ""Kurosaki Ichigo"", ""utf8"");

          await new Promise((resolve) => {
            server.staticWatchers[0].on(""change"", async (changedPath) => {
              // page reload
              await page.waitForNavigation({ waitUntil: ""networkidle0"" });

              expect(changedPath).toBe(file);

              resolve();
            });
          });
        });
      });
    }
  })",steel
/test/e2e/watch-files.test.js,Duplicate Assert,"{'line': 532, 'column': 10, 'index': 13025}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
        server.staticWatchers[1].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(other);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",steel
/test/e2e/watch-files.test.js,Duplicate Assert,"{'line': 544, 'column': 10, 'index': 13339}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      // change file content
      fs.writeFileSync(file, ""foo"", ""utf8"");
      fs.writeFileSync(other, ""bar"", ""utf8"");

      await new Promise((resolve) => {
        let changed = 0;

        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(file);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
        server.staticWatchers[1].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(other);

          changed += 1;

          if (changed === 2) {
            resolve();
          }
        });
      });
    })",steel
/test/e2e/watch-files.test.js,Sleepy Test,"{'line': 301, 'column': 8, 'index': 7297}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      await new Promise((resolve) => {
        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(nonExistFile);
          resolve();
        });

        // create file content
        setTimeout(() => {
          fs.writeFileSync(nonExistFile, ""Kurosaki Ichigo"", ""utf8"");
          // change file content
          setTimeout(() => {
            fs.writeFileSync(nonExistFile, ""Kurosaki Ichigo"", ""utf8"");
          }, 1000);
        }, 1000);
      });
    })",steel
/test/e2e/watch-files.test.js,Sleepy Test,"{'line': 304, 'column': 10, 'index': 7428}","it(""should reload when file content is changed"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");

      await new Promise((resolve) => {
        server.staticWatchers[0].on(""change"", async (changedPath) => {
          // page reload
          await page.waitForNavigation({ waitUntil: ""networkidle0"" });

          expect(changedPath).toBe(nonExistFile);
          resolve();
        });

        // create file content
        setTimeout(() => {
          fs.writeFileSync(nonExistFile, ""Kurosaki Ichigo"", ""utf8"");
          // change file content
          setTimeout(() => {
            fs.writeFileSync(nonExistFile, ""Kurosaki Ichigo"", ""utf8"");
          }, 1000);
        }, 1000);
      });
    })",steel
/test/e2e/target.test.js,Conditional Test Logic,"{'line': 32, 'column': 2, 'index': 867}","describe(""target"", () => {
  const targets = [
    false,
    ""browserslist:defaults"",
    ""web"",
    ""webworker"",
    ""node"",
    ""async-node"",
    ""electron-main"",
    ""electron-preload"",
    ""electron-renderer"",
    ""nwjs"",
    ""node-webkit"",
    ""es5"",
    [""web"", ""es5""],
  ];

  for (const target of targets) {
    it(`should work using ""${target}"" target`, async () => {
      const compiler = webpack({
        ...config,
        target,
        ...(target === false || target === ""es5""
          ? {
              output: { chunkFormat: ""array-push"", path: ""/"" },
            }
          : {}),
      });
      const server = new Server({ port }, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        if (
          target === ""node"" ||
          target === ""async-node"" ||
          target === ""electron-main"" ||
          target === ""electron-preload"" ||
          target === ""electron-renderer"" ||
          target === ""nwjs"" ||
          target === ""node-webkit""
        ) {
          const hasRequireOrGlobalError =
            pageErrors.filter((pageError) =>
              /require is not defined|global is not defined/.test(pageError),
            ).length === 1;

          expect(hasRequireOrGlobalError).toBe(true);
        } else {
          expect(pageErrors).toMatchSnapshot(""page errors"");
        }
      } finally {
        await browser.close();
        await server.stop();
      }
    });
  }

  it(""should work using multi compiler mode with `web` and `webworker` targets"", async () => {
    const compiler = webpack(workerConfig);
    const server = new Server({ port }, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(
        sortByTerm(
          consoleMessages.map((message) => message.text()),
          ""Worker said:"",
        ),
      ).toMatchSnapshot(""console messages"");

      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  });

  it(""should work using multi compiler mode with `web` and `webworker` targets with `devServer: false`"", async () => {
    const compiler = webpack(workerConfigDevServerFalse);
    const server = new Server(
      {
        port,
        static: {
          directory: path.resolve(
            __dirname,
            ""../fixtures/worker-config-dev-server-false/public/"",
          ),
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(
        sortByTerm(
          consoleMessages.map((message) => message.text()),
          ""Worker said:"",
        ),
      ).toMatchSnapshot(""console messages"");

      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  });
})",steel
/test/e2e/target.test.js,Conditional Test Logic,"{'line': 69, 'column': 8, 'index': 1849}","it(`should work using ""${target}"" target`, async () => {
      const compiler = webpack({
        ...config,
        target,
        ...(target === false || target === ""es5""
          ? {
              output: { chunkFormat: ""array-push"", path: ""/"" },
            }
          : {}),
      });
      const server = new Server({ port }, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        if (
          target === ""node"" ||
          target === ""async-node"" ||
          target === ""electron-main"" ||
          target === ""electron-preload"" ||
          target === ""electron-renderer"" ||
          target === ""nwjs"" ||
          target === ""node-webkit""
        ) {
          const hasRequireOrGlobalError =
            pageErrors.filter((pageError) =>
              /require is not defined|global is not defined/.test(pageError),
            ).length === 1;

          expect(hasRequireOrGlobalError).toBe(true);
        } else {
          expect(pageErrors).toMatchSnapshot(""page errors"");
        }
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/target.test.js,Exception Handling,"{'line': 102, 'column': 4, 'index': 2835}","it(""should work using multi compiler mode with `web` and `webworker` targets"", async () => {
    const compiler = webpack(workerConfig);
    const server = new Server({ port }, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(
        sortByTerm(
          consoleMessages.map((message) => message.text()),
          ""Worker said:"",
        ),
      ).toMatchSnapshot(""console messages"");

      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/target.test.js,Exception Handling,"{'line': 151, 'column': 4, 'index': 4020}","it(""should work using multi compiler mode with `web` and `webworker` targets with `devServer: false`"", async () => {
    const compiler = webpack(workerConfigDevServerFalse);
    const server = new Server(
      {
        port,
        static: {
          directory: path.resolve(
            __dirname,
            ""../fixtures/worker-config-dev-server-false/public/"",
          ),
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(
        sortByTerm(
          consoleMessages.map((message) => message.text()),
          ""Worker said:"",
        ),
      ).toMatchSnapshot(""console messages"");

      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/target.test.js,Lazy Test,"{'line': 100, 'column': 36, 'index': 2816}","it(""should work using multi compiler mode with `web` and `webworker` targets"", async () => {
    const compiler = webpack(workerConfig);
    const server = new Server({ port }, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(
        sortByTerm(
          consoleMessages.map((message) => message.text()),
          ""Worker said:"",
        ),
      ).toMatchSnapshot(""console messages"");

      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/target.test.js,Lazy Test,"{'line': 149, 'column': 36, 'index': 4001}","it(""should work using multi compiler mode with `web` and `webworker` targets with `devServer: false`"", async () => {
    const compiler = webpack(workerConfigDevServerFalse);
    const server = new Server(
      {
        port,
        static: {
          directory: path.resolve(
            __dirname,
            ""../fixtures/worker-config-dev-server-false/public/"",
          ),
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(
        sortByTerm(
          consoleMessages.map((message) => message.text()),
          ""Worker said:"",
        ),
      ).toMatchSnapshot(""console messages"");

      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/stats.test.js,Conditional Test Logic,"{'line': 86, 'column': 2, 'index': 2175}","describe(""stats"", () => {
  const cases = [
    {
      title: 'should work when ""stats"" is not specified',
      webpackOptions: {},
    },
    {
      title: 'should work using ""{}"" value for the ""stats"" option',
      webpackOptions: {
        stats: {},
      },
    },
    {
      title: 'should work using ""undefined"" value for the ""stats"" option',
      webpackOptions: {
        stats: undefined,
      },
    },
    {
      title: 'should work using ""false"" value for the ""stats"" option',
      webpackOptions: {
        stats: false,
      },
    },
    {
      title: 'should work using ""errors-only"" value for the ""stats"" option',
      webpackOptions: {
        stats: ""errors-only"",
      },
    },
    {
      title:
        'should work using ""{ assets: false }"" value for the ""stats"" option',
      webpackOptions: {
        stats: {
          assets: false,
        },
      },
    },
    {
      title:
        'should work using ""{ assets: false }"" value for the ""stats"" option',
      webpackOptions: {
        stats: {
          colors: {
            green: ""\u001B[32m"",
          },
        },
      },
    },
    {
      title:
        'should work using ""{ warningsFilter: \'test\' }"" value for the ""stats"" option',
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
        stats: { warningsFilter: /Warning from compilation/ },
      },
    },
  ];

  if (webpack.version.startsWith(""5"")) {
    cases.push({
      title: 'should work and respect the ""ignoreWarnings"" option',
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
        ignoreWarnings: [/Warning from compilation/],
      },
    });
  }

  for (const testCase of cases) {
    it(testCase.title, async () => {
      const compiler = webpack({ ...config, ...testCase.webpackOptions });
      const devServerOptions = {
        port,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const consoleMessages = [];

        page.on(""console"", (message) => {
          consoleMessages.push(message);
        });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot();
      } finally {
        await browser.close();
        await server.stop();
      }
    });
  }
})",steel
/test/e2e/stats.test.js,Conditional Test Logic,"{'line': 110, 'column': 2, 'index': 2827}","describe(""stats"", () => {
  const cases = [
    {
      title: 'should work when ""stats"" is not specified',
      webpackOptions: {},
    },
    {
      title: 'should work using ""{}"" value for the ""stats"" option',
      webpackOptions: {
        stats: {},
      },
    },
    {
      title: 'should work using ""undefined"" value for the ""stats"" option',
      webpackOptions: {
        stats: undefined,
      },
    },
    {
      title: 'should work using ""false"" value for the ""stats"" option',
      webpackOptions: {
        stats: false,
      },
    },
    {
      title: 'should work using ""errors-only"" value for the ""stats"" option',
      webpackOptions: {
        stats: ""errors-only"",
      },
    },
    {
      title:
        'should work using ""{ assets: false }"" value for the ""stats"" option',
      webpackOptions: {
        stats: {
          assets: false,
        },
      },
    },
    {
      title:
        'should work using ""{ assets: false }"" value for the ""stats"" option',
      webpackOptions: {
        stats: {
          colors: {
            green: ""\u001B[32m"",
          },
        },
      },
    },
    {
      title:
        'should work using ""{ warningsFilter: \'test\' }"" value for the ""stats"" option',
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
        stats: { warningsFilter: /Warning from compilation/ },
      },
    },
  ];

  if (webpack.version.startsWith(""5"")) {
    cases.push({
      title: 'should work and respect the ""ignoreWarnings"" option',
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
        ignoreWarnings: [/Warning from compilation/],
      },
    });
  }

  for (const testCase of cases) {
    it(testCase.title, async () => {
      const compiler = webpack({ ...config, ...testCase.webpackOptions });
      const devServerOptions = {
        port,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const consoleMessages = [];

        page.on(""console"", (message) => {
          consoleMessages.push(message);
        });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot();
      } finally {
        await browser.close();
        await server.stop();
      }
    });
  }
})",steel
/test/e2e/static-public-path.test.js,Conditional Test Logic,"{'line': 683, 'column': 10, 'index': 16649}","it(""should handle HEAD request"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (interceptedRequest) => {
          if (interceptedRequest.isInterceptResolutionHandled()) return;

          interceptedRequest.continue({ method: ""HEAD"" });
        });

      const response = await page.goto(
        `http://localhost:${port}${staticPublicPath}/`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/static-directory.test.js,Duplicate Assert,"{'line': 277, 'column': 6, 'index': 7175}","it(""should list the files inside the assets folder (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/assets/`, {
        waitUntil: ""networkidle0"",
      });

      const text = await response.text();

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(text).toContain(""example.txt"");
      expect(text).toContain(""other.txt"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/static-directory.test.js,Duplicate Assert,"{'line': 278, 'column': 6, 'index': 7220}","it(""should list the files inside the assets folder (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/assets/`, {
        waitUntil: ""networkidle0"",
      });

      const text = await response.text();

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(text).toContain(""example.txt"");
      expect(text).toContain(""other.txt"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/static-directory.test.js,Duplicate Assert,"{'line': 364, 'column': 6, 'index': 9383}","it(""should list the files inside the assets folder (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/assets`, {
        waitUntil: ""networkidle0"",
      });

      const text = await response.text();

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(text).toContain(""example.txt"");
      expect(text).toContain(""other.txt"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/static-directory.test.js,Duplicate Assert,"{'line': 365, 'column': 6, 'index': 9428}","it(""should list the files inside the assets folder (200)"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/assets`, {
        waitUntil: ""networkidle0"",
      });

      const text = await response.text();

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(text).toContain(""example.txt"");
      expect(text).toContain(""other.txt"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/static-directory.test.js,Sleepy Test,"{'line': 112, 'column': 6, 'index': 3095}","it(""watches folder recursively"", (done) => {
      // chokidar emitted a change,
      // meaning it watched the file correctly
      server.staticWatchers[0].on(""change"", (filepath) => {
        expect(typeof filepath).toBe(""string"");
        done();
      });

      // change a file manually
      setTimeout(() => {
        fs.writeFileSync(nestedFile, ""Heyo"", ""utf8"");
      }, 1000);
    })",steel
/test/e2e/static-directory.test.js,Sleepy Test,"{'line': 133, 'column': 6, 'index': 3659}","it(""watches node_modules"", (done) => {
      const filePath = path.join(publicDirectory, ""node_modules"", ""index.html"");

      fs.writeFileSync(filePath, ""foo"", ""utf8"");

      // chokidar emitted a change,
      // meaning it watched the file correctly
      server.staticWatchers[0].on(""change"", (filepath) => {
        expect(typeof filepath).toBe(""string"");

        fs.unlinkSync(filePath);

        done();
      });

      // change a file manually
      setTimeout(() => {
        fs.writeFileSync(filePath, ""bar"", ""utf8"");
      }, 1000);
    })",steel
/test/e2e/setup-middlewares.test.js,Conditional Test Logic,"{'line': 22, 'column': 10, 'index': 585}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        setupMiddlewares: (middlewares, devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          devServer.app.use(""/setup-middleware/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option GET"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option POST"");
              return;
            }

            return next();
          });

          middlewares.push({
            name: ""hello-world-test-two"",
            middleware: (req, res, next) => {
              if (req.url !== ""/foo/bar/baz"") {
                next();
                return;
              }

              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World without path!"");
            },
          });
          middlewares.push({
            name: ""hello-world-test-one"",
            path: ""/foo/bar"",
            middleware: (req, res) => {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World with path!"");
            },
          });
          middlewares.push((req, res) => {
            res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
            res.end(""Hello World as function!"");
          });

          return middlewares;
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",steel
/test/e2e/setup-middlewares.test.js,Conditional Test Logic,"{'line': 27, 'column': 12, 'index': 775}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        setupMiddlewares: (middlewares, devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          devServer.app.use(""/setup-middleware/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option GET"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option POST"");
              return;
            }

            return next();
          });

          middlewares.push({
            name: ""hello-world-test-two"",
            middleware: (req, res, next) => {
              if (req.url !== ""/foo/bar/baz"") {
                next();
                return;
              }

              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World without path!"");
            },
          });
          middlewares.push({
            name: ""hello-world-test-one"",
            path: ""/foo/bar"",
            middleware: (req, res) => {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World with path!"");
            },
          });
          middlewares.push((req, res) => {
            res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
            res.end(""Hello World as function!"");
          });

          return middlewares;
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",steel
/test/e2e/setup-middlewares.test.js,Conditional Test Logic,"{'line': 31, 'column': 19, 'index': 972}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        setupMiddlewares: (middlewares, devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          devServer.app.use(""/setup-middleware/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option GET"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option POST"");
              return;
            }

            return next();
          });

          middlewares.push({
            name: ""hello-world-test-two"",
            middleware: (req, res, next) => {
              if (req.url !== ""/foo/bar/baz"") {
                next();
                return;
              }

              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World without path!"");
            },
          });
          middlewares.push({
            name: ""hello-world-test-one"",
            path: ""/foo/bar"",
            middleware: (req, res) => {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World with path!"");
            },
          });
          middlewares.push((req, res) => {
            res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
            res.end(""Hello World as function!"");
          });

          return middlewares;
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",steel
/test/e2e/setup-middlewares.test.js,Conditional Test Logic,"{'line': 43, 'column': 14, 'index': 1340}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        setupMiddlewares: (middlewares, devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          devServer.app.use(""/setup-middleware/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option GET"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""setup-middlewares option POST"");
              return;
            }

            return next();
          });

          middlewares.push({
            name: ""hello-world-test-two"",
            middleware: (req, res, next) => {
              if (req.url !== ""/foo/bar/baz"") {
                next();
                return;
              }

              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World without path!"");
            },
          });
          middlewares.push({
            name: ""hello-world-test-one"",
            path: ""/foo/bar"",
            middleware: (req, res) => {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""Hello World with path!"");
            },
          });
          middlewares.push((req, res) => {
            res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
            res.end(""Hello World as function!"");
          });

          return middlewares;
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",steel
/test/e2e/setup-middlewares.test.js,Conditional Test Logic,"{'line': 157, 'column': 8, 'index': 4697}","it(""should handle POST request to /setup-middleware/some/path route"", async () => {
    await page.setRequestInterception(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      })
      .on(""request"", (interceptedRequest) => {
        if (interceptedRequest.isInterceptResolutionHandled()) return;

        interceptedRequest.continue({ method: ""POST"" });
      });

    const response = await page.goto(
      `http://localhost:${port}/setup-middleware/some/path`,
      {
        waitUntil: ""networkidle0"",
      },
    );

    expect(response.headers()[""content-type""]).toMatchSnapshot(
      ""response headers content-type"",
    );
    expect(response.status()).toMatchSnapshot(""response status"");
    expect(await response.text()).toMatchSnapshot(""response text"");
    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );
    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/setup-exit-signals.test.js,Conditional Test Logic,"{'line': 54, 'column': 6, 'index': 1281}","beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    })",steel
/test/e2e/setup-exit-signals.test.js,Conditional Test Logic,"{'line': 62, 'column': 6, 'index': 1487}","afterEach(async () => {
      exitSpy.mockReset();
      stdinResumeSpy.mockReset();
      for (const signal of signals) {
        process.removeAllListeners(signal);
      }
      process.stdin.removeAllListeners(""end"");
      await browser.close();
      await server.stop();
    })",steel
/test/e2e/setup-exit-signals.test.js,Conditional Test Logic,"{'line': 89, 'column': 10, 'index': 2249}","describe(""should handle 'SIGINT' and 'SIGTERM' signals"", () => {
    let compiler;
    let server;
    let page;
    let browser;
    let pageErrors;
    let consoleMessages;
    let doExit;
    let exitSpy;
    let stopCallbackSpy;
    let stdinResumeSpy;
    let closeCallbackSpy;

    const signals = [""SIGINT"", ""SIGTERM""];

    beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    });

    afterEach(async () => {
      exitSpy.mockReset();
      stdinResumeSpy.mockReset();
      for (const signal of signals) {
        process.removeAllListeners(signal);
      }
      process.stdin.removeAllListeners(""end"");
      await browser.close();
      await server.stop();
    });

    it.each(signals)(""should close and exit on %s"", async (signal) => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      process.emit(signal);

      await new Promise((resolve) => {
        const interval = setInterval(() => {
          if (doExit) {
            expect(stopCallbackSpy.mock.calls).toHaveLength(1);

            if (server.compiler.close) {
              expect(closeCallbackSpy.mock.calls).toHaveLength(1);
            }

            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      consoleMessages = consoleMessages.filter(
        (message) =>
          !(
            message.text().includes(""Trying to reconnect..."") ||
            message.text().includes(""Disconnected"")
          ),
      );

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    });
  })",steel
/test/e2e/setup-exit-signals.test.js,Conditional Test Logic,"{'line': 92, 'column': 12, 'index': 2340}","describe(""should handle 'SIGINT' and 'SIGTERM' signals"", () => {
    let compiler;
    let server;
    let page;
    let browser;
    let pageErrors;
    let consoleMessages;
    let doExit;
    let exitSpy;
    let stopCallbackSpy;
    let stdinResumeSpy;
    let closeCallbackSpy;

    const signals = [""SIGINT"", ""SIGTERM""];

    beforeEach(async () => {
      compiler = webpack(config);

      server = new Server(
        {
          setupExitSignals: true,
          port,
        },
        compiler,
      );

      await server.start();

      ({ page, browser } = await runBrowser());

      pageErrors = [];
      consoleMessages = [];
      doExit = false;

      exitSpy = jest.spyOn(process, ""exit"").mockImplementation(() => {
        doExit = true;
      });

      stdinResumeSpy = jest
        .spyOn(process.stdin, ""resume"")
        .mockImplementation(() => {});

      stopCallbackSpy = jest.spyOn(server, ""stopCallback"");

      if (server.compiler.close) {
        closeCallbackSpy = jest.spyOn(server.compiler, ""close"");
      }
    });

    afterEach(async () => {
      exitSpy.mockReset();
      stdinResumeSpy.mockReset();
      for (const signal of signals) {
        process.removeAllListeners(signal);
      }
      process.stdin.removeAllListeners(""end"");
      await browser.close();
      await server.stop();
    });

    it.each(signals)(""should close and exit on %s"", async (signal) => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      process.emit(signal);

      await new Promise((resolve) => {
        const interval = setInterval(() => {
          if (doExit) {
            expect(stopCallbackSpy.mock.calls).toHaveLength(1);

            if (server.compiler.close) {
              expect(closeCallbackSpy.mock.calls).toHaveLength(1);
            }

            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      consoleMessages = consoleMessages.filter(
        (message) =>
          !(
            message.text().includes(""Trying to reconnect..."") ||
            message.text().includes(""Disconnected"")
          ),
      );

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    });
  })",steel
/test/e2e/server.test.js,Conditional Test Logic,"{'line': 785, 'column': 6, 'index': 21626}","describe(""ca, pfx, key and cert are symlinks"", () => {
      if (skipTestOnWindows(""Symlinks are not supported on Windows"")) {
        return;
      }

      let compiler;
      let server;
      let createServerSpy;
      let page;
      let browser;
      let pageErrors;
      let consoleMessages;

      beforeEach(async () => {
        compiler = webpack(config);

        createServerSpy = jest.spyOn(https, ""createServer"");

        server = new Server(
          {
            static: {
              directory: staticDirectory,
              watch: false,
            },
            server: {
              type: ""https"",
              options: {
                ca: path.join(httpsCertificateDirectory, ""ca-symlink.pem""),
                pfx: path.join(httpsCertificateDirectory, ""server-symlink.pfx""),
                key: path.join(httpsCertificateDirectory, ""server-symlink.key""),
                cert: path.join(
                  httpsCertificateDirectory,
                  ""server-symlink.crt"",
                ),
                passphrase: ""webpack-dev-server"",
              },
            },
            port,
          },
          compiler,
        );

        await server.start();

        ({ page, browser } = await runBrowser());

        pageErrors = [];
        consoleMessages = [];
      });

      afterEach(async () => {
        createServerSpy.mockRestore();

        await browser.close();
        await server.stop();
      });

      it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(response.status()).toBe(200);
        expect(await response.text()).toContain(""Heyo"");
        expect(consoleMessages.map((message) => message.text())).toEqual([]);
        expect(pageErrors).toEqual([]);
      });
    })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 345, 'column': 10, 'index': 8919}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 436, 'column': 10, 'index': 11459}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 525, 'column': 10, 'index': 14027}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 623, 'column': 10, 'index': 16805}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 698, 'column': 10, 'index': 18955}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 773, 'column': 10, 'index': 21122}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 941, 'column': 10, 'index': 25797}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 1037, 'column': 10, 'index': 28568}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 1121, 'column': 10, 'index': 30959}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 1184, 'column': 10, 'index': 32883}","it(""should pass options to the 'https.createServer' method"", async () => {
        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""https options"");
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 1264, 'column': 24, 'index': 35158}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        const options = normalizeOptions(createServerSpy.mock.calls[0][0]);

        expect(HTTPVersion).toBe(""h2"");
        expect(options.spdy).toEqual({ protocols: [""h2"", ""http/1.1""] });
        expect(response.status()).toBe(200);
        expect((await response.text()).trim()).toBe(""Heyo."");
        expect(consoleMessages).toHaveLength(0);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/server.test.js,Lazy Test,"{'line': 1340, 'column': 10, 'index': 37154}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        expect(HTTPVersion).toBe(""http/1.1"");
        expect(
          normalizeOptions(createServerSpy.mock.calls[0][0]),
        ).toMatchSnapshot(""http options"");
        expect(response.status()).toMatchSnapshot(""response status"");
        expect(await response.text()).toMatchSnapshot(""response text"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      })",steel
/test/e2e/server.test.js,Magic Number,"{'line': 264, 'column': 39, 'index': 6782}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        expect(HTTPVersion).toBe(""h2"");
        expect(response.status()).toBe(200);
        expect((await response.text()).trim()).toBe(""Heyo."");
        expect(consoleMessages).toHaveLength(0);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/server.test.js,Magic Number,"{'line': 266, 'column': 45, 'index': 6895}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        expect(HTTPVersion).toBe(""h2"");
        expect(response.status()).toBe(200);
        expect((await response.text()).trim()).toBe(""Heyo."");
        expect(consoleMessages).toHaveLength(0);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/server.test.js,Magic Number,"{'line': 267, 'column': 40, 'index': 6939}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        expect(HTTPVersion).toBe(""h2"");
        expect(response.status()).toBe(200);
        expect((await response.text()).trim()).toBe(""Heyo."");
        expect(consoleMessages).toHaveLength(0);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/server.test.js,Magic Number,"{'line': 854, 'column': 39, 'index': 23463}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(response.status()).toBe(200);
        expect(await response.text()).toContain(""Heyo"");
        expect(consoleMessages.map((message) => message.text())).toEqual([]);
        expect(pageErrors).toEqual([]);
      })",steel
/test/e2e/server.test.js,Magic Number,"{'line': 1268, 'column': 39, 'index': 35363}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        const options = normalizeOptions(createServerSpy.mock.calls[0][0]);

        expect(HTTPVersion).toBe(""h2"");
        expect(options.spdy).toEqual({ protocols: [""h2"", ""http/1.1""] });
        expect(response.status()).toBe(200);
        expect((await response.text()).trim()).toBe(""Heyo."");
        expect(consoleMessages).toHaveLength(0);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/server.test.js,Magic Number,"{'line': 1270, 'column': 45, 'index': 35476}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        const options = normalizeOptions(createServerSpy.mock.calls[0][0]);

        expect(HTTPVersion).toBe(""h2"");
        expect(options.spdy).toEqual({ protocols: [""h2"", ""http/1.1""] });
        expect(response.status()).toBe(200);
        expect((await response.text()).trim()).toBe(""Heyo."");
        expect(consoleMessages).toHaveLength(0);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/server.test.js,Magic Number,"{'line': 1271, 'column': 40, 'index': 35520}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const response = await page.goto(`https://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        const options = normalizeOptions(createServerSpy.mock.calls[0][0]);

        expect(HTTPVersion).toBe(""h2"");
        expect(options.spdy).toEqual({ protocols: [""h2"", ""http/1.1""] });
        expect(response.status()).toBe(200);
        expect((await response.text()).trim()).toBe(""Heyo."");
        expect(consoleMessages).toHaveLength(0);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 25, 'column': 4, 'index': 976}","it('should use default web socket server (""ws"")', async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 62, 'column': 4, 'index': 1916}","it('should use ""ws"" web socket server when specify ""ws"" value', async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      webSocketServer: ""ws"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 101, 'column': 4, 'index': 2894}","it('should use ""ws"" web socket server when specify ""ws"" value using object', async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      webSocketServer: {
        type: ""ws"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 138, 'column': 4, 'index': 3845}","it('should use ""sockjs"" web socket server when specify ""sockjs"" value', async () => {
    const compiler = webpack(sockjsConfig);
    const devServerOptions = {
      port,
      webSocketServer: ""sockjs"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 177, 'column': 4, 'index': 4834}","it('should use ""sockjs"" web socket server when specify ""sockjs"" value using object', async () => {
    const compiler = webpack(sockjsConfig);
    const devServerOptions = {
      port,
      webSocketServer: {
        type: ""sockjs"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 217, 'column': 4, 'index': 5841}","it(""should use custom web socket server when specify class"", async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: WebsocketServer,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 259, 'column': 4, 'index': 6886}","it(""should use custom web socket server when specify class using object"", async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: {
        type: WebsocketServer,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 299, 'column': 4, 'index': 7938}","it(""should use custom web socket server when specify path to class"", async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: require.resolve(""../../lib/servers/WebsocketServer""),
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 341, 'column': 4, 'index': 9028}","it(""should use custom web socket server when specify path to class using object"", async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: {
        type: require.resolve(""../../lib/servers/WebsocketServer""),
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 378, 'column': 4, 'index': 9945}","it(""should throw an error on wrong path"", async () => {
    expect.assertions(1);

    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      webSocketServer: {
        type: ""/bad/path/to/implementation"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    try {
      await server.start();
    } catch (error) {
      expect(error.message).toMatchSnapshot();
    } finally {
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 401, 'column': 4, 'index': 10494}","it('should use ""sockjs"" transport, when web socket server is not specify', async () => {
    const compiler = webpack(sockjsConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""sockjs"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 440, 'column': 4, 'index': 11473}","it('should use ""ws"" transport, when web socket server is not specify', async () => {
    const compiler = webpack(wsConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 480, 'column': 4, 'index': 12482}","it('should use ""sockjs"" transport and ""sockjs"" web socket server', async () => {
    const compiler = webpack(sockjsConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""sockjs"",
      },
      webSocketServer: ""sockjs"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 520, 'column': 4, 'index': 13471}","it('should use ""ws"" transport and ""ws"" web socket server', async () => {
    const compiler = webpack(wsConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: ""ws"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Exception Handling,"{'line': 562, 'column': 4, 'index': 14554}","it('should use custom transport and ""sockjs"" web socket server', async () => {
    const compiler = webpack(customConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: require.resolve(
          ""../fixtures/custom-client/CustomSockJSClient"",
        ),
      },
      webSocketServer: ""sockjs"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 23, 'column': 36, 'index': 957}","it('should use default web socket server (""ws"")', async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 60, 'column': 36, 'index': 1897}","it('should use ""ws"" web socket server when specify ""ws"" value', async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      webSocketServer: ""ws"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 99, 'column': 36, 'index': 2875}","it('should use ""ws"" web socket server when specify ""ws"" value using object', async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      webSocketServer: {
        type: ""ws"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 136, 'column': 36, 'index': 3826}","it('should use ""sockjs"" web socket server when specify ""sockjs"" value', async () => {
    const compiler = webpack(sockjsConfig);
    const devServerOptions = {
      port,
      webSocketServer: ""sockjs"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 175, 'column': 36, 'index': 4815}","it('should use ""sockjs"" web socket server when specify ""sockjs"" value using object', async () => {
    const compiler = webpack(sockjsConfig);
    const devServerOptions = {
      port,
      webSocketServer: {
        type: ""sockjs"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 215, 'column': 36, 'index': 5822}","it(""should use custom web socket server when specify class"", async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: WebsocketServer,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 257, 'column': 36, 'index': 6867}","it(""should use custom web socket server when specify class using object"", async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: {
        type: WebsocketServer,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 297, 'column': 36, 'index': 7919}","it(""should use custom web socket server when specify path to class"", async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: require.resolve(""../../lib/servers/WebsocketServer""),
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 339, 'column': 36, 'index': 9009}","it(""should use custom web socket server when specify path to class using object"", async () => {
    const compiler = webpack(defaultConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: {
        type: require.resolve(""../../lib/servers/WebsocketServer""),
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 399, 'column': 36, 'index': 10475}","it('should use ""sockjs"" transport, when web socket server is not specify', async () => {
    const compiler = webpack(sockjsConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""sockjs"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 438, 'column': 36, 'index': 11454}","it('should use ""ws"" transport, when web socket server is not specify', async () => {
    const compiler = webpack(wsConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 478, 'column': 36, 'index': 12463}","it('should use ""sockjs"" transport and ""sockjs"" web socket server', async () => {
    const compiler = webpack(sockjsConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""sockjs"",
      },
      webSocketServer: ""sockjs"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 518, 'column': 36, 'index': 13452}","it('should use ""ws"" transport and ""ws"" web socket server', async () => {
    const compiler = webpack(wsConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: ""ws"",
      },
      webSocketServer: ""ws"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/server-and-client-transport.test.js,Lazy Test,"{'line': 560, 'column': 36, 'index': 14535}","it('should use custom transport and ""sockjs"" web socket server', async () => {
    const compiler = webpack(customConfig);
    const devServerOptions = {
      port,
      client: {
        webSocketTransport: require.resolve(
          ""../fixtures/custom-client/CustomSockJSClient"",
        ),
      },
      webSocketServer: ""sockjs"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message);
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const isCorrectTransport = await page.evaluate(
        () => globalThis.injectedClient === globalThis.expectedClient,
      );

      expect(isCorrectTransport).toBe(true);
      expect(
        consoleMessages.map((message) => message.text()),
      ).toMatchSnapshot();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/range-header.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1303}","it('should work with ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseContent = response.text;
    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes=0-499"");

    expect(responseRange.status).toBe(206);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.headers[""content-length""]).toBe(""500"");
    expect(responseRange.headers[""content-range""]).toMatch(/^bytes 0-499\//);
    expect(responseRange.text).toBe(responseContent.slice(0, 500));
    expect(responseRange.text).toHaveLength(500);
  })",steel
/test/e2e/range-header.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1371}","it('should work with ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseContent = response.text;
    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes=0-499"");

    expect(responseRange.status).toBe(206);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.headers[""content-length""]).toBe(""500"");
    expect(responseRange.headers[""content-range""]).toMatch(/^bytes 0-499\//);
    expect(responseRange.text).toBe(responseContent.slice(0, 500));
    expect(responseRange.text).toHaveLength(500);
  })",steel
/test/e2e/range-header.test.js,Duplicate Assert,"{'line': 108, 'column': 4, 'index': 3513}","it('should work with malformed ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseContent = response.text;
    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes"");

    expect(responseRange.status).toBe(200);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.text).toBe(responseContent);
    expect(responseRange.text).toHaveLength(responseContent.length);
  })",steel
/test/e2e/range-header.test.js,Duplicate Assert,"{'line': 109, 'column': 4, 'index': 3567}","it('should work with malformed ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseContent = response.text;
    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes"");

    expect(responseRange.status).toBe(200);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.text).toBe(responseContent);
    expect(responseRange.text).toHaveLength(responseContent.length);
  })",steel
/test/e2e/range-header.test.js,Magic Number,"{'line': 28, 'column': 33, 'index': 688}","it('should work with ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseContent = response.text;
    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes=0-499"");

    expect(responseRange.status).toBe(206);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.headers[""content-length""]).toBe(""500"");
    expect(responseRange.headers[""content-range""]).toMatch(/^bytes 0-499\//);
    expect(responseRange.text).toBe(responseContent.slice(0, 500));
    expect(responseRange.text).toHaveLength(500);
  })",steel
/test/e2e/range-header.test.js,Magic Number,"{'line': 39, 'column': 38, 'index': 1047}","it('should work with ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseContent = response.text;
    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes=0-499"");

    expect(responseRange.status).toBe(206);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.headers[""content-length""]).toBe(""500"");
    expect(responseRange.headers[""content-range""]).toMatch(/^bytes 0-499\//);
    expect(responseRange.text).toBe(responseContent.slice(0, 500));
    expect(responseRange.text).toHaveLength(500);
  })",steel
/test/e2e/range-header.test.js,Magic Number,"{'line': 46, 'column': 44, 'index': 1411}","it('should work with ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseContent = response.text;
    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes=0-499"");

    expect(responseRange.status).toBe(206);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.headers[""content-length""]).toBe(""500"");
    expect(responseRange.headers[""content-range""]).toMatch(/^bytes 0-499\//);
    expect(responseRange.text).toBe(responseContent.slice(0, 500));
    expect(responseRange.text).toHaveLength(500);
  })",steel
/test/e2e/range-header.test.js,Magic Number,"{'line': 52, 'column': 33, 'index': 1597}","it('should work with ""Range"" header using ""HEAD"" method', async () => {
    const response = await request(server.app).head(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseRange = await request(server.app)
      .head(""/main.js"")
      .set(""Range"", ""bytes=0-499"");

    expect(responseRange.status).toBe(206);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.headers[""content-length""]).toBe(""500"");
    expect(responseRange.headers[""content-range""]).toMatch(/^bytes 0-499\//);
  })",steel
/test/e2e/range-header.test.js,Magic Number,"{'line': 62, 'column': 38, 'index': 1914}","it('should work with ""Range"" header using ""HEAD"" method', async () => {
    const response = await request(server.app).head(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseRange = await request(server.app)
      .head(""/main.js"")
      .set(""Range"", ""bytes=0-499"");

    expect(responseRange.status).toBe(206);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.headers[""content-length""]).toBe(""500"");
    expect(responseRange.headers[""content-range""]).toMatch(/^bytes 0-499\//);
  })",steel
/test/e2e/range-header.test.js,Magic Number,"{'line': 73, 'column': 33, 'index': 2358}","it('should work with unsatisfiable ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes=99999999999-"");

    expect(responseRange.status).toBe(416);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/html; charset=utf-8"",
    );
    expect(responseRange.headers[""content-range""]).toMatch(/^bytes \*\//);
  })",steel
/test/e2e/range-header.test.js,Magic Number,"{'line': 83, 'column': 38, 'index': 2681}","it('should work with unsatisfiable ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes=99999999999-"");

    expect(responseRange.status).toBe(416);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/html; charset=utf-8"",
    );
    expect(responseRange.headers[""content-range""]).toMatch(/^bytes \*\//);
  })",steel
/test/e2e/range-header.test.js,Magic Number,"{'line': 93, 'column': 33, 'index': 3047}","it('should work with malformed ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseContent = response.text;
    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes"");

    expect(responseRange.status).toBe(200);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.text).toBe(responseContent);
    expect(responseRange.text).toHaveLength(responseContent.length);
  })",steel
/test/e2e/range-header.test.js,Magic Number,"{'line': 104, 'column': 38, 'index': 3400}","it('should work with malformed ""Range"" header using ""GET"" method', async () => {
    const response = await request(server.app).get(""/main.js"");

    expect(response.status).toBe(200);
    expect(response.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(response.headers[""accept-ranges""]).toBe(""bytes"");

    const responseContent = response.text;
    const responseRange = await request(server.app)
      .get(""/main.js"")
      .set(""Range"", ""bytes"");

    expect(responseRange.status).toBe(200);
    expect(responseRange.headers[""content-type""]).toBe(
      ""text/javascript; charset=utf-8"",
    );
    expect(responseRange.text).toBe(responseContent);
    expect(responseRange.text).toHaveLength(responseContent.length);
  })",steel
/test/e2e/progress.test.js,Conditional Test Logic,"{'line': 44, 'column': 12, 'index': 1165}","it(""should work and log progress in a browser console"", async () => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");

    const compiler = webpack(reloadConfig);
    const devServerOptions = {
      port,
      client: {
        progress: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    try {
      const { page, browser } = await runBrowser();

      const consoleMessages = [];

      try {
        let doHotUpdate = false;

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""request"", (interceptedRequest) => {
            if (interceptedRequest.isInterceptResolutionHandled()) return;

            if (/\.hot-update\.(json|js)$/.test(interceptedRequest.url())) {
              doHotUpdate = true;
            }
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        fs.writeFileSync(
          cssFilePath,
          ""body { background-color: rgb(255, 0, 0); }"",
        );

        await new Promise((resolve) => {
          const timer = setInterval(() => {
            if (doHotUpdate) {
              clearInterval(timer);

              resolve();
            }
          }, 100);
        });
      } finally {
        await browser.close();
      }

      const progressConsoleMessage = consoleMessages.filter((message) =>
        /^\[webpack-dev-server\] (\[[a-zA-Z]+\] )?[0-9]{1,3}% - /.test(
          message.text(),
        ),
      );

      expect(progressConsoleMessage.length).toBeGreaterThan(0);
    } finally {
      fs.unlinkSync(cssFilePath);

      await server.stop();
    }
  })",steel
/test/e2e/progress.test.js,Conditional Test Logic,"{'line': 46, 'column': 12, 'index': 1241}","it(""should work and log progress in a browser console"", async () => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");

    const compiler = webpack(reloadConfig);
    const devServerOptions = {
      port,
      client: {
        progress: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    try {
      const { page, browser } = await runBrowser();

      const consoleMessages = [];

      try {
        let doHotUpdate = false;

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""request"", (interceptedRequest) => {
            if (interceptedRequest.isInterceptResolutionHandled()) return;

            if (/\.hot-update\.(json|js)$/.test(interceptedRequest.url())) {
              doHotUpdate = true;
            }
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        fs.writeFileSync(
          cssFilePath,
          ""body { background-color: rgb(255, 0, 0); }"",
        );

        await new Promise((resolve) => {
          const timer = setInterval(() => {
            if (doHotUpdate) {
              clearInterval(timer);

              resolve();
            }
          }, 100);
        });
      } finally {
        await browser.close();
      }

      const progressConsoleMessage = consoleMessages.filter((message) =>
        /^\[webpack-dev-server\] (\[[a-zA-Z]+\] )?[0-9]{1,3}% - /.test(
          message.text(),
        ),
      );

      expect(progressConsoleMessage.length).toBeGreaterThan(0);
    } finally {
      fs.unlinkSync(cssFilePath);

      await server.stop();
    }
  })",steel
/test/e2e/progress.test.js,Conditional Test Logic,"{'line': 62, 'column': 12, 'index': 1688}","it(""should work and log progress in a browser console"", async () => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");

    const compiler = webpack(reloadConfig);
    const devServerOptions = {
      port,
      client: {
        progress: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    try {
      const { page, browser } = await runBrowser();

      const consoleMessages = [];

      try {
        let doHotUpdate = false;

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""request"", (interceptedRequest) => {
            if (interceptedRequest.isInterceptResolutionHandled()) return;

            if (/\.hot-update\.(json|js)$/.test(interceptedRequest.url())) {
              doHotUpdate = true;
            }
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        fs.writeFileSync(
          cssFilePath,
          ""body { background-color: rgb(255, 0, 0); }"",
        );

        await new Promise((resolve) => {
          const timer = setInterval(() => {
            if (doHotUpdate) {
              clearInterval(timer);

              resolve();
            }
          }, 100);
        });
      } finally {
        await browser.close();
      }

      const progressConsoleMessage = consoleMessages.filter((message) =>
        /^\[webpack-dev-server\] (\[[a-zA-Z]+\] )?[0-9]{1,3}% - /.test(
          message.text(),
        ),
      );

      expect(progressConsoleMessage.length).toBeGreaterThan(0);
    } finally {
      fs.unlinkSync(cssFilePath);

      await server.stop();
    }
  })",steel
/test/e2e/progress.test.js,Exception Handling,"{'line': 31, 'column': 4, 'index': 853}","it(""should work and log progress in a browser console"", async () => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");

    const compiler = webpack(reloadConfig);
    const devServerOptions = {
      port,
      client: {
        progress: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    try {
      const { page, browser } = await runBrowser();

      const consoleMessages = [];

      try {
        let doHotUpdate = false;

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""request"", (interceptedRequest) => {
            if (interceptedRequest.isInterceptResolutionHandled()) return;

            if (/\.hot-update\.(json|js)$/.test(interceptedRequest.url())) {
              doHotUpdate = true;
            }
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        fs.writeFileSync(
          cssFilePath,
          ""body { background-color: rgb(255, 0, 0); }"",
        );

        await new Promise((resolve) => {
          const timer = setInterval(() => {
            if (doHotUpdate) {
              clearInterval(timer);

              resolve();
            }
          }, 100);
        });
      } finally {
        await browser.close();
      }

      const progressConsoleMessage = consoleMessages.filter((message) =>
        /^\[webpack-dev-server\] (\[[a-zA-Z]+\] )?[0-9]{1,3}% - /.test(
          message.text(),
        ),
      );

      expect(progressConsoleMessage.length).toBeGreaterThan(0);
    } finally {
      fs.unlinkSync(cssFilePath);

      await server.stop();
    }
  })",steel
/test/e2e/progress.test.js,Exception Handling,"{'line': 36, 'column': 6, 'index': 953}","it(""should work and log progress in a browser console"", async () => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");

    const compiler = webpack(reloadConfig);
    const devServerOptions = {
      port,
      client: {
        progress: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    try {
      const { page, browser } = await runBrowser();

      const consoleMessages = [];

      try {
        let doHotUpdate = false;

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""request"", (interceptedRequest) => {
            if (interceptedRequest.isInterceptResolutionHandled()) return;

            if (/\.hot-update\.(json|js)$/.test(interceptedRequest.url())) {
              doHotUpdate = true;
            }
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        fs.writeFileSync(
          cssFilePath,
          ""body { background-color: rgb(255, 0, 0); }"",
        );

        await new Promise((resolve) => {
          const timer = setInterval(() => {
            if (doHotUpdate) {
              clearInterval(timer);

              resolve();
            }
          }, 100);
        });
      } finally {
        await browser.close();
      }

      const progressConsoleMessage = consoleMessages.filter((message) =>
        /^\[webpack-dev-server\] (\[[a-zA-Z]+\] )?[0-9]{1,3}% - /.test(
          message.text(),
        ),
      );

      expect(progressConsoleMessage.length).toBeGreaterThan(0);
    } finally {
      fs.unlinkSync(cssFilePath);

      await server.stop();
    }
  })",steel
/test/e2e/progress.test.js,Magic Number,"{'line': 79, 'column': 60, 'index': 2124}","it(""should work and log progress in a browser console"", async () => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");

    const compiler = webpack(reloadConfig);
    const devServerOptions = {
      port,
      client: {
        progress: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    try {
      const { page, browser } = await runBrowser();

      const consoleMessages = [];

      try {
        let doHotUpdate = false;

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""request"", (interceptedRequest) => {
            if (interceptedRequest.isInterceptResolutionHandled()) return;

            if (/\.hot-update\.(json|js)$/.test(interceptedRequest.url())) {
              doHotUpdate = true;
            }
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        fs.writeFileSync(
          cssFilePath,
          ""body { background-color: rgb(255, 0, 0); }"",
        );

        await new Promise((resolve) => {
          const timer = setInterval(() => {
            if (doHotUpdate) {
              clearInterval(timer);

              resolve();
            }
          }, 100);
        });
      } finally {
        await browser.close();
      }

      const progressConsoleMessage = consoleMessages.filter((message) =>
        /^\[webpack-dev-server\] (\[[a-zA-Z]+\] )?[0-9]{1,3}% - /.test(
          message.text(),
        ),
      );

      expect(progressConsoleMessage.length).toBeGreaterThan(0);
    } finally {
      fs.unlinkSync(cssFilePath);

      await server.stop();
    }
  })",steel
/test/e2e/port.test.js,Conditional Test Logic,"{'line': 22, 'column': 2, 'index': 417}","describe(""port"", () => {
  const ports = [
    ""<not-specified>"",

    undefined,
    ""auto"",
    port,
    `${port}`,
    0,
    ""-1"",
    ""99999"",
  ];

  for (const testedPort of ports) {
    it(`should work using ""${testedPort}"" port `, async () => {
      const compiler = webpack(config);
      const devServerOptions = {};

      let usedPort;

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        usedPort = port;
      } else if (testedPort === ""auto"") {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        devServerOptions.port = testedPort;
        usedPort = port;
      } else {
        devServerOptions.port = testedPort;
        usedPort = testedPort;
      }

      const server = new Server(devServerOptions, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      if (testedPort === ""-1"" || testedPort === ""99999"") {
        const errorMessageRegExp = /options.port should be >= 0 and < 65536/;

        try {
          expect(errored.message).toMatch(errorMessageRegExp);
        } finally {
          await server.stop();
        }

        return;
      }

      const address = server.server.address();

      if (testedPort === 0) {
        expect(typeof address.port).toBe(""number"");
      } else {
        expect(address.port).toBe(Number(usedPort));
      }

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    });
  }
})",steel
/test/e2e/port.test.js,Conditional Test Logic,"{'line': 29, 'column': 6, 'index': 618}","it(`should work using ""${testedPort}"" port `, async () => {
      const compiler = webpack(config);
      const devServerOptions = {};

      let usedPort;

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        usedPort = port;
      } else if (testedPort === ""auto"") {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        devServerOptions.port = testedPort;
        usedPort = port;
      } else {
        devServerOptions.port = testedPort;
        usedPort = testedPort;
      }

      const server = new Server(devServerOptions, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      if (testedPort === ""-1"" || testedPort === ""99999"") {
        const errorMessageRegExp = /options.port should be >= 0 and < 65536/;

        try {
          expect(errored.message).toMatch(errorMessageRegExp);
        } finally {
          await server.stop();
        }

        return;
      }

      const address = server.server.address();

      if (testedPort === 0) {
        expect(typeof address.port).toBe(""number"");
      } else {
        expect(address.port).toBe(Number(usedPort));
      }

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    })",steel
/test/e2e/port.test.js,Conditional Test Logic,"{'line': 35, 'column': 13, 'index': 814}","it(`should work using ""${testedPort}"" port `, async () => {
      const compiler = webpack(config);
      const devServerOptions = {};

      let usedPort;

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        usedPort = port;
      } else if (testedPort === ""auto"") {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        devServerOptions.port = testedPort;
        usedPort = port;
      } else {
        devServerOptions.port = testedPort;
        usedPort = testedPort;
      }

      const server = new Server(devServerOptions, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      if (testedPort === ""-1"" || testedPort === ""99999"") {
        const errorMessageRegExp = /options.port should be >= 0 and < 65536/;

        try {
          expect(errored.message).toMatch(errorMessageRegExp);
        } finally {
          await server.stop();
        }

        return;
      }

      const address = server.server.address();

      if (testedPort === 0) {
        expect(typeof address.port).toBe(""number"");
      } else {
        expect(address.port).toBe(Number(usedPort));
      }

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    })",steel
/test/e2e/port.test.js,Conditional Test Logic,"{'line': 54, 'column': 6, 'index': 1256}","it(`should work using ""${testedPort}"" port `, async () => {
      const compiler = webpack(config);
      const devServerOptions = {};

      let usedPort;

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        usedPort = port;
      } else if (testedPort === ""auto"") {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        devServerOptions.port = testedPort;
        usedPort = port;
      } else {
        devServerOptions.port = testedPort;
        usedPort = testedPort;
      }

      const server = new Server(devServerOptions, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      if (testedPort === ""-1"" || testedPort === ""99999"") {
        const errorMessageRegExp = /options.port should be >= 0 and < 65536/;

        try {
          expect(errored.message).toMatch(errorMessageRegExp);
        } finally {
          await server.stop();
        }

        return;
      }

      const address = server.server.address();

      if (testedPort === 0) {
        expect(typeof address.port).toBe(""number"");
      } else {
        expect(address.port).toBe(Number(usedPort));
      }

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    })",steel
/test/e2e/port.test.js,Conditional Test Logic,"{'line': 68, 'column': 6, 'index': 1606}","it(`should work using ""${testedPort}"" port `, async () => {
      const compiler = webpack(config);
      const devServerOptions = {};

      let usedPort;

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        usedPort = port;
      } else if (testedPort === ""auto"") {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        devServerOptions.port = testedPort;
        usedPort = port;
      } else {
        devServerOptions.port = testedPort;
        usedPort = testedPort;
      }

      const server = new Server(devServerOptions, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      if (testedPort === ""-1"" || testedPort === ""99999"") {
        const errorMessageRegExp = /options.port should be >= 0 and < 65536/;

        try {
          expect(errored.message).toMatch(errorMessageRegExp);
        } finally {
          await server.stop();
        }

        return;
      }

      const address = server.server.address();

      if (testedPort === 0) {
        expect(typeof address.port).toBe(""number"");
      } else {
        expect(address.port).toBe(Number(usedPort));
      }

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    })",steel
/test/e2e/port.test.js,Conditional Test Logic,"{'line': 101, 'column': 6, 'index': 2480}","it(`should work using ""${testedPort}"" port `, async () => {
      const compiler = webpack(config);
      const devServerOptions = {};

      let usedPort;

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        usedPort = port;
      } else if (testedPort === ""auto"") {
        process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;
        devServerOptions.port = testedPort;
        usedPort = port;
      } else {
        devServerOptions.port = testedPort;
        usedPort = testedPort;
      }

      const server = new Server(devServerOptions, compiler);

      let errored;

      try {
        await server.start();
      } catch (error) {
        errored = error;
      }

      if (testedPort === ""-1"" || testedPort === ""99999"") {
        const errorMessageRegExp = /options.port should be >= 0 and < 65536/;

        try {
          expect(errored.message).toMatch(errorMessageRegExp);
        } finally {
          await server.stop();
        }

        return;
      }

      const address = server.server.address();

      if (testedPort === 0) {
        expect(typeof address.port).toBe(""number"");
      } else {
        expect(address.port).toBe(Number(usedPort));
      }

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }

      if (
        testedPort === ""<not-specified>"" ||
        typeof testedPort === ""undefined""
      ) {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      }
    })",steel
/test/e2e/overlay.test.js,Conditional Test Logic,"{'line': 25, 'column': 8, 'index': 814}",Unknown,steel
/test/e2e/overlay.test.js,Conditional Test Logic,"{'line': 51, 'column': 8, 'index': 1375}",Unknown,steel
/test/e2e/overlay.test.js,Conditional Test Logic,"{'line': 1545, 'column': 10, 'index': 42032}","it(""should show a warning and hide them after closing connection"", async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = { port };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      await server.stop();

      await new Promise((resolve) => {
        const interval = setInterval(() => {
          if (consoleMessages.includes(""[webpack-dev-server] Disconnected!"")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      const pageHtmlAfterClose = await page.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtmlAfterClose, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 345, 'column': 6, 'index': 9575}","it(""should not show initially, then show on an error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 345, 'column': 6, 'index': 9575}","it(""should not show initially, then show on an error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 346, 'column': 6, 'index': 9615}","it(""should not show initially, then show on an error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 371, 'column': 6, 'index': 10400}","it(""should not show initially, then show on an error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 393, 'column': 6, 'index': 11079}","it(""should not show initially, then show on an error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 393, 'column': 6, 'index': 11079}","it(""should not show initially, then show on an error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 394, 'column': 6, 'index': 11119}","it(""should not show initially, then show on an error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 425, 'column': 6, 'index': 11999}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 425, 'column': 6, 'index': 11999}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 426, 'column': 6, 'index': 12039}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 451, 'column': 6, 'index': 12820}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 457, 'column': 6, 'index': 13011}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 457, 'column': 6, 'index': 13011}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 477, 'column': 6, 'index': 13702}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 483, 'column': 6, 'index': 13899}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 483, 'column': 6, 'index': 13899}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 499, 'column': 6, 'index': 14387}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 499, 'column': 6, 'index': 14387}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 500, 'column': 6, 'index': 14427}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 531, 'column': 6, 'index': 15285}","it(""should not show initially, then show on an error and allow to close"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      const frame = await page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const buttonHandle = await frame.$(""button"");

      await buttonHandle.click();

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after close"");

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 531, 'column': 6, 'index': 15285}","it(""should not show initially, then show on an error and allow to close"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      const frame = await page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const buttonHandle = await frame.$(""button"");

      await buttonHandle.click();

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after close"");

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 532, 'column': 6, 'index': 15325}","it(""should not show initially, then show on an error and allow to close"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      const frame = await page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const buttonHandle = await frame.$(""button"");

      await buttonHandle.click();

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after close"");

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 557, 'column': 6, 'index': 16110}","it(""should not show initially, then show on an error and allow to close"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      const frame = await page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const buttonHandle = await frame.$(""button"");

      await buttonHandle.click();

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after close"");

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 585, 'column': 6, 'index': 16954}","it(""should not show initially, then show on an error and allow to close"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      const frame = await page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const buttonHandle = await frame.$(""button"");

      await buttonHandle.click();

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after close"");

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 585, 'column': 6, 'index': 16954}","it(""should not show initially, then show on an error and allow to close"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      const frame = await page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const buttonHandle = await frame.$(""button"");

      await buttonHandle.click();

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after close"");

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Duplicate Assert,"{'line': 586, 'column': 6, 'index': 16994}","it(""should not show initially, then show on an error and allow to close"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      const frame = await page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const buttonHandle = await frame.$(""button"");

      await buttonHandle.click();

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after close"");

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 98, 'column': 4, 'index': 2507}","it(""should show a warning for initial compilation"", async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 145, 'column': 4, 'index': 3790}","it(""should show an error for initial compilation"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 196, 'column': 4, 'index': 5244}","it(""should show a warning and error for initial compilation"", async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);
    new WarningPlugin().apply(compiler);
    new ErrorPlugin().apply(compiler);
    new ErrorPlugin().apply(compiler);
    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 245, 'column': 4, 'index': 6638}","it(""should show an ansi formatted error for initial compilation"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin(
      ""[0m [90m 18 |[39m           [33mRender[39m [33mansi formatted text[39m[0m"",
    ).apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 293, 'column': 4, 'index': 8048}","it(""should show a warning and error for initial compilation and protects against xss"", async () => {
    const compiler = webpack(config);

    new WarningPlugin(""<strong>strong</strong>"").apply(compiler);
    new ErrorPlugin(""<strong>strong</strong>"").apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 337, 'column': 4, 'index': 9312}","it(""should not show initially, then show on an error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 417, 'column': 4, 'index': 11736}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 523, 'column': 4, 'index': 15022}","it(""should not show initially, then show on an error and allow to close"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      const frame = await page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const buttonHandle = await frame.$(""button"");

      await buttonHandle.click();

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after close"");

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 614, 'column': 4, 'index': 17725}","it(""should open editor when error with file info is clicked"", async () => {
    const mockLaunchEditorCb = jest.fn();
    jest.mock(""launch-editor"", () => mockLaunchEditorCb);

    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      const frame = page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const errorHandle = await frame.$(""[data-can-open]"");

      await errorHandle.click();

      await waitForExpect(() => {
        expect(mockLaunchEditorCb).toHaveBeenCalledTimes(1);
      });

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 665, 'column': 4, 'index': 18976}","it('should not show a warning when ""client.overlay"" is ""false""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: false,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 708, 'column': 4, 'index': 20054}","it('should not show a warning when ""client.overlay.warnings"" is ""false""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          warnings: false,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 757, 'column': 4, 'index': 21317}","it(""should not show warning when it is filtered"", async () => {
    const compiler = webpack(config);

    new WarningPlugin(""My special warning"").apply(compiler);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            warnings: (error) => {
              // error is string in webpack 4
              const message = typeof error === ""string"" ? error : error.message;
              return message !== ""My special warning"";
            },
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 795, 'column': 4, 'index': 22127}","it(""should show warning when it is not filtered"", async () => {
    const compiler = webpack(config);

    new WarningPlugin(""Unfiltered warning"").apply(compiler);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            warnings: () => true,
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 845, 'column': 4, 'index': 23469}","it('should show a warning when ""client.overlay"" is ""true""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 897, 'column': 4, 'index': 24853}","it('should show a warning when ""client.overlay.warnings"" is ""true""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          warnings: true,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 949, 'column': 4, 'index': 26233}","it('should show a warning when ""client.overlay.errors"" is ""true""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          errors: true,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 999, 'column': 4, 'index': 27578}","it('should not show an error when ""client.overlay"" is ""false""', async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: false,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1042, 'column': 4, 'index': 28649}","it('should not show an error when ""client.overlay.errors"" is ""false""', async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          errors: false,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1092, 'column': 4, 'index': 29903}","it(""should not show error when it is filtered"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin(""My special error"").apply(compiler);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            errors: (error) => {
              // error is string in webpack 4
              const message = typeof error === ""string"" ? error : error.message;

              return message !== ""My special error"";
            },
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1130, 'column': 4, 'index': 30705}","it(""should show error when it is not filtered"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin(""Unfiltered error"").apply(compiler);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            errors: () => true,
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1180, 'column': 4, 'index': 32044}","it('should show an error when ""client.overlay"" is ""true""', async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1232, 'column': 4, 'index': 33457}","it(""should show overlay when Trusted Types are enabled"", async () => {
    const compiler = webpack(trustedTypesConfig);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          trustedTypesPolicyName: ""webpack#dev-overlay"",
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        consoleMessages.filter((item) =>
          /requires 'TrustedHTML' assignment/.test(item),
        ),
      ).toHaveLength(0);
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1301, 'column': 4, 'index': 35358}","it(""should show overlay when Trusted Types are enabled and the \""require-trusted-types-for 'script'\"" header was used"", async () => {
    const compiler = webpack(trustedTypesConfig);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      headers: [
        {
          key: ""Content-Security-Policy"",
          value: ""require-trusted-types-for 'script'"",
        },
      ],
      client: {
        overlay: {
          trustedTypesPolicyName: ""webpack#dev-overlay"",
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(
        consoleMessages.filter((item) =>
          /requires 'TrustedHTML' assignment/.test(item),
        ),
      ).toHaveLength(0);
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1368, 'column': 4, 'index': 37180}","it(""should not show overlay when Trusted Types are enabled, but policy is not allowed"", async () => {
    const compiler = webpack(trustedTypesConfig);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          trustedTypesPolicyName: ""disallowed-policy"",
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1410, 'column': 4, 'index': 38244}","it('should show an error when ""client.overlay.errors"" is ""true""', async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          errors: true,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1462, 'column': 4, 'index': 39627}","it('should show an error when ""client.overlay.warnings"" is ""true""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          warnings: true,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1507, 'column': 4, 'index': 40917}","it(""should show a warning and hide them after closing connection"", async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = { port };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      await server.stop();

      await new Promise((resolve) => {
        const interval = setInterval(() => {
          if (consoleMessages.includes(""[webpack-dev-server] Disconnected!"")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      const pageHtmlAfterClose = await page.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtmlAfterClose, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1582, 'column': 4, 'index': 42914}","it(""should show an error after invalidation"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin(""Error from compilation"", 1).apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await new Promise((resolve) => {
        server.middleware.invalidate(() => {
          resolve();
        });
      });

      await new Promise((resolve) => {
        server.middleware.waitUntilValid(() => {
          resolve();
        });
      });

      // Delay for the overlay to appear
      await delay(1000);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1643, 'column': 4, 'index': 44557}","it(""should show a warning after invalidation"", async () => {
    const compiler = webpack(config);

    new WarningPlugin(""Warning from compilation"", 1).apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await new Promise((resolve) => {
        server.middleware.invalidate(() => {
          resolve();
        });
      });

      await new Promise((resolve) => {
        server.middleware.waitUntilValid(() => {
          resolve();
        });
      });

      // Delay for the overlay to appear
      await delay(1000);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1704, 'column': 4, 'index': 46109}","it(""should show error for uncaught runtime error"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        throw new Error('Injected error');
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1755, 'column': 4, 'index': 47353}","it(""should not show filtered runtime error"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            runtimeErrors: (error) => error && !/Injected/.test(error.message),
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        throw new Error('Injected error');
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1792, 'column': 4, 'index': 48152}","it(""should show error for uncaught promise rejection"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        setTimeout(function () {
          Promise.reject(new Error('Async error'));
        }, 0);
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1845, 'column': 4, 'index': 49448}","it(""should not show filtered promise rejection"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            runtimeErrors: (error) => !/Injected/.test(error.message),
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        setTimeout(function () {
          Promise.reject(new Error('Injected async error'));
        }, 0);
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1890, 'column': 4, 'index': 50493}","it(""should not show filtered promise rejection with specific error cause"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            runtimeErrors: (error) =>
              !/Injected/.test(error.cause.error.message),
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        setTimeout(function () {
          Promise.reject({ error: new Error('Injected async error') });
        }, 0);
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Exception Handling,"{'line': 1935, 'column': 4, 'index': 51621}","it('should show overlay when ""Content-Security-Policy"" is ""default-src \'self\'"" was used', async () => {
    const compiler = webpack({ ...config, devtool: false });

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      headers: [
        {
          key: ""Content-Security-Policy"",
          value: ""default-src 'self'"",
        },
      ],
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(
          overlayHtml.replace(
            /<button ([^>]+)>.+<\/button>/m,
            ""<button $1>X</button>"",
          ),
          {
            parser: ""html"",
            plugins: [prettierHTML, prettierCSS],
          },
        ),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 96, 'column': 36, 'index': 2488}","it(""should show a warning for initial compilation"", async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 143, 'column': 36, 'index': 3771}","it(""should show an error for initial compilation"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 194, 'column': 36, 'index': 5225}","it(""should show a warning and error for initial compilation"", async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);
    new WarningPlugin().apply(compiler);
    new ErrorPlugin().apply(compiler);
    new ErrorPlugin().apply(compiler);
    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 243, 'column': 36, 'index': 6619}","it(""should show an ansi formatted error for initial compilation"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin(
      ""[0m [90m 18 |[39m           [33mRender[39m [33mansi formatted text[39m[0m"",
    ).apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 291, 'column': 36, 'index': 8029}","it(""should show a warning and error for initial compilation and protects against xss"", async () => {
    const compiler = webpack(config);

    new WarningPlugin(""<strong>strong</strong>"").apply(compiler);
    new ErrorPlugin(""<strong>strong</strong>"").apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 335, 'column': 36, 'index': 9293}","it(""should not show initially, then show on an error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 415, 'column': 36, 'index': 11717}","it(""should not show initially, then show on an error, then show other error, then hide on fix"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      let overlayFrame = await overlayHandle.contentFrame();
      let overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, ""`;a"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });
      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      overlayFrame = await overlayHandle.contentFrame();
      overlayHtml = await overlayFrame.evaluate(() => document.body.outerHTML);

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with other error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      fs.writeFileSync(pathToFile, originalCode);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after fix error"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 521, 'column': 36, 'index': 15003}","it(""should not show initially, then show on an error and allow to close"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      let pageHtml = await page.evaluate(() => document.body.outerHTML);
      let overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html initial"");

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      pageHtml = await page.evaluate(() => document.body.outerHTML);

      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html with error"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      const frame = await page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const buttonHandle = await frame.$(""button"");

      await buttonHandle.click();

      await page.waitForSelector(""#webpack-dev-server-client-overlay"", {
        hidden: true,
      });

      pageHtml = await page.evaluate(() => document.body.outerHTML);
      overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html after close"");

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 612, 'column': 36, 'index': 17706}","it(""should open editor when error with file info is clicked"", async () => {
    const mockLaunchEditorCb = jest.fn();
    jest.mock(""launch-editor"", () => mockLaunchEditorCb);

    const compiler = webpack(config);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      const pathToFile = path.resolve(
        __dirname,
        ""../fixtures/overlay-config/foo.js"",
      );
      const originalCode = fs.readFileSync(pathToFile);

      fs.writeFileSync(pathToFile, ""`;"");

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      const frame = page
        .frames()
        .find((item) => item.name() === ""webpack-dev-server-client-overlay"");

      const errorHandle = await frame.$(""[data-can-open]"");

      await errorHandle.click();

      await waitForExpect(() => {
        expect(mockLaunchEditorCb).toHaveBeenCalledTimes(1);
      });

      fs.writeFileSync(pathToFile, originalCode);
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 663, 'column': 36, 'index': 18957}","it('should not show a warning when ""client.overlay"" is ""false""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: false,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 706, 'column': 36, 'index': 20035}","it('should not show a warning when ""client.overlay.warnings"" is ""false""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          warnings: false,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 755, 'column': 36, 'index': 21298}","it(""should not show warning when it is filtered"", async () => {
    const compiler = webpack(config);

    new WarningPlugin(""My special warning"").apply(compiler);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            warnings: (error) => {
              // error is string in webpack 4
              const message = typeof error === ""string"" ? error : error.message;
              return message !== ""My special warning"";
            },
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 793, 'column': 36, 'index': 22108}","it(""should show warning when it is not filtered"", async () => {
    const compiler = webpack(config);

    new WarningPlugin(""Unfiltered warning"").apply(compiler);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            warnings: () => true,
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 843, 'column': 36, 'index': 23450}","it('should show a warning when ""client.overlay"" is ""true""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 895, 'column': 36, 'index': 24834}","it('should show a warning when ""client.overlay.warnings"" is ""true""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          warnings: true,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 947, 'column': 36, 'index': 26214}","it('should show a warning when ""client.overlay.errors"" is ""true""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          errors: true,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 997, 'column': 36, 'index': 27559}","it('should not show an error when ""client.overlay"" is ""false""', async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: false,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1040, 'column': 36, 'index': 28630}","it('should not show an error when ""client.overlay.errors"" is ""false""', async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          errors: false,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1090, 'column': 36, 'index': 29884}","it(""should not show error when it is filtered"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin(""My special error"").apply(compiler);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            errors: (error) => {
              // error is string in webpack 4
              const message = typeof error === ""string"" ? error : error.message;

              return message !== ""My special error"";
            },
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1128, 'column': 36, 'index': 30686}","it(""should show error when it is not filtered"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin(""Unfiltered error"").apply(compiler);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            errors: () => true,
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1178, 'column': 36, 'index': 32025}","it('should show an error when ""client.overlay"" is ""true""', async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: true,
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1230, 'column': 36, 'index': 33438}","it(""should show overlay when Trusted Types are enabled"", async () => {
    const compiler = webpack(trustedTypesConfig);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          trustedTypesPolicyName: ""webpack#dev-overlay"",
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        consoleMessages.filter((item) =>
          /requires 'TrustedHTML' assignment/.test(item),
        ),
      ).toHaveLength(0);
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1299, 'column': 36, 'index': 35339}","it(""should show overlay when Trusted Types are enabled and the \""require-trusted-types-for 'script'\"" header was used"", async () => {
    const compiler = webpack(trustedTypesConfig);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      headers: [
        {
          key: ""Content-Security-Policy"",
          value: ""require-trusted-types-for 'script'"",
        },
      ],
      client: {
        overlay: {
          trustedTypesPolicyName: ""webpack#dev-overlay"",
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(
        consoleMessages.filter((item) =>
          /requires 'TrustedHTML' assignment/.test(item),
        ),
      ).toHaveLength(0);
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1366, 'column': 36, 'index': 37161}","it(""should not show overlay when Trusted Types are enabled, but policy is not allowed"", async () => {
    const compiler = webpack(trustedTypesConfig);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          trustedTypesPolicyName: ""disallowed-policy"",
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      expect(overlayHandle).toBeNull();
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1408, 'column': 36, 'index': 38225}","it('should show an error when ""client.overlay.errors"" is ""true""', async () => {
    const compiler = webpack(config);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          errors: true,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1460, 'column': 36, 'index': 39608}","it('should show an error when ""client.overlay.warnings"" is ""true""', async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          warnings: true,
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1505, 'column': 36, 'index': 40898}","it(""should show a warning and hide them after closing connection"", async () => {
    const compiler = webpack(config);

    new WarningPlugin().apply(compiler);

    const devServerOptions = { port };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");

      await server.stop();

      await new Promise((resolve) => {
        const interval = setInterval(() => {
          if (consoleMessages.includes(""[webpack-dev-server] Disconnected!"")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      const pageHtmlAfterClose = await page.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtmlAfterClose, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
    } finally {
      await browser.close();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1580, 'column': 36, 'index': 42895}","it(""should show an error after invalidation"", async () => {
    const compiler = webpack(config);

    new ErrorPlugin(""Error from compilation"", 1).apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await new Promise((resolve) => {
        server.middleware.invalidate(() => {
          resolve();
        });
      });

      await new Promise((resolve) => {
        server.middleware.waitUntilValid(() => {
          resolve();
        });
      });

      // Delay for the overlay to appear
      await delay(1000);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1641, 'column': 36, 'index': 44538}","it(""should show a warning after invalidation"", async () => {
    const compiler = webpack(config);

    new WarningPlugin(""Warning from compilation"", 1).apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await new Promise((resolve) => {
        server.middleware.invalidate(() => {
          resolve();
        });
      });

      await new Promise((resolve) => {
        server.middleware.waitUntilValid(() => {
          resolve();
        });
      });

      // Delay for the overlay to appear
      await delay(1000);

      await page.waitForSelector(""#webpack-dev-server-client-overlay"");

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1702, 'column': 36, 'index': 46090}","it(""should show error for uncaught runtime error"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        throw new Error('Injected error');
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1753, 'column': 36, 'index': 47334}","it(""should not show filtered runtime error"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            runtimeErrors: (error) => error && !/Injected/.test(error.message),
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        throw new Error('Injected error');
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1790, 'column': 36, 'index': 48133}","it(""should show error for uncaught promise rejection"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        setTimeout(function () {
          Promise.reject(new Error('Async error'));
        }, 0);
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1843, 'column': 36, 'index': 49429}","it(""should not show filtered promise rejection"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            runtimeErrors: (error) => !/Injected/.test(error.message),
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        setTimeout(function () {
          Promise.reject(new Error('Injected async error'));
        }, 0);
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1888, 'column': 36, 'index': 50474}","it(""should not show filtered promise rejection with specific error cause"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
        client: {
          overlay: {
            runtimeErrors: (error) =>
              !/Injected/.test(error.cause.error.message),
          },
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      await page.addScriptTag({
        content: `(function throwError() {
        setTimeout(function () {
          Promise.reject({ error: new Error('Injected async error') });
        }, 0);
      })();`,
      });

      // Delay for the overlay to appear
      await delay(1000);

      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");

      expect(overlayHandle).toBeNull();
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Lazy Test,"{'line': 1933, 'column': 36, 'index': 51602}","it('should show overlay when ""Content-Security-Policy"" is ""default-src \'self\'"" was used', async () => {
    const compiler = webpack({ ...config, devtool: false });

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      headers: [
        {
          key: ""Content-Security-Policy"",
          value: ""default-src 'self'"",
        },
      ],
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(
          overlayHtml.replace(
            /<button ([^>]+)>.+<\/button>/m,
            ""<button $1>X</button>"",
          ),
          {
            parser: ""html"",
            plugins: [prettierHTML, prettierCSS],
          },
        ),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Magic Number,"{'line': 1257, 'column': 21, 'index': 34228}","it(""should show overlay when Trusted Types are enabled"", async () => {
    const compiler = webpack(trustedTypesConfig);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      client: {
        overlay: {
          trustedTypesPolicyName: ""webpack#dev-overlay"",
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      expect(
        consoleMessages.filter((item) =>
          /requires 'TrustedHTML' assignment/.test(item),
        ),
      ).toHaveLength(0);
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/overlay.test.js,Magic Number,"{'line': 1330, 'column': 21, 'index': 36228}","it(""should show overlay when Trusted Types are enabled and the \""require-trusted-types-for 'script'\"" header was used"", async () => {
    const compiler = webpack(trustedTypesConfig);

    new ErrorPlugin().apply(compiler);

    const devServerOptions = {
      port,
      headers: [
        {
          key: ""Content-Security-Policy"",
          value: ""require-trusted-types-for 'script'"",
        },
      ],
      client: {
        overlay: {
          trustedTypesPolicyName: ""webpack#dev-overlay"",
        },
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const consoleMessages = [];

      page.on(""console"", (message) => {
        consoleMessages.push(message.text());
      });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      // Delay for the overlay to appear
      await delay(1000);

      const pageHtml = await page.evaluate(() => document.body.outerHTML);
      const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
      const overlayFrame = await overlayHandle.contentFrame();
      const overlayHtml = await overlayFrame.evaluate(
        () => document.body.outerHTML,
      );

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(
        consoleMessages.filter((item) =>
          /requires 'TrustedHTML' assignment/.test(item),
        ),
      ).toHaveLength(0);
      expect(
        await prettier.format(pageHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""page html"");
      expect(
        await prettier.format(overlayHtml, {
          parser: ""html"",
          plugins: [prettierHTML, prettierCSS],
        }),
      ).toMatchSnapshot(""overlay html"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/options-middleware.test.js,Conditional Test Logic,"{'line': 76, 'column': 8, 'index': 1801}","it(""should response with 200 http code"", async () => {
    const compiler = webpack(config);
    const [portForServer, portForApp] = port;
    const closeApp = await (async () => {
      const { resolve, waiting } = createWaiting();
      const app = new Express();

      app.get(""/"", (req, res) => {
        res.sendStatus(200);
      });

      const server = app.listen(portForApp, () => {
        resolve();
      });

      await waiting;

      return async () => {
        const { resolve: resolve2, waiting: waiting2 } = createWaiting();

        server.close(() => {
          resolve2();
        });

        await waiting2;
      };
    })();
    const server = new Server(
      {
        port: portForServer,
        headers: {
          ""Access-Control-Allow-Origin"": ""*"",
          ""Access-Control-Allow-Headers"": ""*"",
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();
    const prefixUrl = ""http://localhost"";
    const htmlUrl = `${prefixUrl}:${portForServer}/test.html`;
    const appUrl = `${prefixUrl}:${portForApp}`;

    try {
      const responseStatus = [];

      page.on(""response"", (res) => {
        if (/test\.html$/.test(res.url())) {
          responseStatus.push(res.status());
        }
      });

      await page.goto(appUrl, {
        waitUntil: ""networkidle0"",
      });

      await page.evaluate(
        (url) =>
          globalThis.fetch(url, {
            headers: {
              ""another-header"": ""1"",
            },
          }),
        htmlUrl,
      );

      expect(responseStatus.sort()).toEqual([200, 204]);
    } finally {
      await browser.close();
      await server.stop();
      await closeApp();
    }
  })",steel
/test/e2e/options-middleware.test.js,Exception Handling,"{'line': 72, 'column': 4, 'index': 1716}","it(""should response with 200 http code"", async () => {
    const compiler = webpack(config);
    const [portForServer, portForApp] = port;
    const closeApp = await (async () => {
      const { resolve, waiting } = createWaiting();
      const app = new Express();

      app.get(""/"", (req, res) => {
        res.sendStatus(200);
      });

      const server = app.listen(portForApp, () => {
        resolve();
      });

      await waiting;

      return async () => {
        const { resolve: resolve2, waiting: waiting2 } = createWaiting();

        server.close(() => {
          resolve2();
        });

        await waiting2;
      };
    })();
    const server = new Server(
      {
        port: portForServer,
        headers: {
          ""Access-Control-Allow-Origin"": ""*"",
          ""Access-Control-Allow-Headers"": ""*"",
        },
      },
      compiler,
    );

    await server.start();

    const { page, browser } = await runBrowser();
    const prefixUrl = ""http://localhost"";
    const htmlUrl = `${prefixUrl}:${portForServer}/test.html`;
    const appUrl = `${prefixUrl}:${portForApp}`;

    try {
      const responseStatus = [];

      page.on(""response"", (res) => {
        if (/test\.html$/.test(res.url())) {
          responseStatus.push(res.status());
        }
      });

      await page.goto(appUrl, {
        waitUntil: ""networkidle0"",
      });

      await page.evaluate(
        (url) =>
          globalThis.fetch(url, {
            headers: {
              ""another-header"": ""1"",
            },
          }),
        htmlUrl,
      );

      expect(responseStatus.sort()).toEqual([200, 204]);
    } finally {
      await browser.close();
      await server.stop();
      await closeApp();
    }
  })",steel
/test/e2e/on-listening.test.js,Conditional Test Logic,"{'line': 23, 'column': 10, 'index': 593}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        onListening: (devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          onListeningIsRunning = true;

          devServer.app.use(""/listening/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening POST"");
              return;
            }

            return next();
          });
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",steel
/test/e2e/on-listening.test.js,Conditional Test Logic,"{'line': 30, 'column': 12, 'index': 816}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        onListening: (devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          onListeningIsRunning = true;

          devServer.app.use(""/listening/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening POST"");
              return;
            }

            return next();
          });
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",steel
/test/e2e/on-listening.test.js,Conditional Test Logic,"{'line': 34, 'column': 19, 'index': 994}","beforeEach(async () => {
    compiler = webpack(config);
    server = new Server(
      {
        onListening: (devServer) => {
          if (!devServer) {
            throw new Error(""webpack-dev-server is not defined"");
          }

          onListeningIsRunning = true;

          devServer.app.use(""/listening/some/path"", (req, res, next) => {
            if (req.method === ""GET"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening"");
              return;
            } else if (req.method === ""POST"") {
              res.setHeader(""Content-Type"", ""text/html; charset=utf-8"");
              res.end(""listening POST"");
              return;
            }

            return next();
          });
        },
        port,
      },
      compiler,
    );

    await server.start();

    ({ page, browser } = await runBrowser());

    pageErrors = [];
    consoleMessages = [];
  })",steel
/test/e2e/on-listening.test.js,Conditional Test Logic,"{'line': 105, 'column': 8, 'index': 2705}","it(""should handle POST request to /listening/some/path route"", async () => {
    await page.setRequestInterception(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      })
      .on(""request"", (interceptedRequest) => {
        if (interceptedRequest.isInterceptResolutionHandled()) return;

        interceptedRequest.continue({ method: ""POST"" });
      });

    const response = await page.goto(
      `http://localhost:${port}/listening/some/path`,
      {
        waitUntil: ""networkidle0"",
      },
    );

    expect(onListeningIsRunning).toBe(true);

    expect(response.headers()[""content-type""]).toMatchSnapshot(
      ""response headers content-type"",
    );

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(await response.text()).toMatchSnapshot(""response text"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/multi-compiler.test.js,Conditional Test Logic,"{'line': 127, 'column': 10, 'index': 3727}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Conditional Test Logic,"{'line': 204, 'column': 10, 'index': 6071}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Conditional Test Logic,"{'line': 477, 'column': 10, 'index': 14335}","it(""should work with universal configuration when hot and live reloads are enabled, and do hot reload for browser compiler by default when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Conditional Test Logic,"{'line': 550, 'column': 10, 'index': 16480}","it(""should work with universal configuration when only hot reload is enabled, and do hot reload for browser compiler when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 77, 'column': 6, 'index': 2230}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 77, 'column': 6, 'index': 2230}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 78, 'column': 6, 'index': 2297}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 78, 'column': 6, 'index': 2297}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 87, 'column': 6, 'index': 2519}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 87, 'column': 6, 'index': 2519}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 88, 'column': 6, 'index': 2586}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 88, 'column': 6, 'index': 2586}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 147, 'column': 6, 'index': 4310}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 147, 'column': 6, 'index': 4310}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 148, 'column': 6, 'index': 4377}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 148, 'column': 6, 'index': 4377}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 161, 'column': 6, 'index': 4748}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 161, 'column': 6, 'index': 4748}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 162, 'column': 6, 'index': 4815}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 162, 'column': 6, 'index': 4815}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 224, 'column': 6, 'index': 6654}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 224, 'column': 6, 'index': 6654}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 225, 'column': 6, 'index': 6721}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 225, 'column': 6, 'index': 6721}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 238, 'column': 6, 'index': 7092}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 238, 'column': 6, 'index': 7092}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 239, 'column': 6, 'index': 7159}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 239, 'column': 6, 'index': 7159}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 293, 'column': 6, 'index': 8780}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 293, 'column': 6, 'index': 8780}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 294, 'column': 6, 'index': 8847}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 294, 'column': 6, 'index': 8847}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 307, 'column': 6, 'index': 9218}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 307, 'column': 6, 'index': 9218}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 308, 'column': 6, 'index': 9285}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 308, 'column': 6, 'index': 9285}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 362, 'column': 6, 'index': 10907}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 362, 'column': 6, 'index': 10907}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 363, 'column': 6, 'index': 10974}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 363, 'column': 6, 'index': 10974}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 376, 'column': 6, 'index': 11345}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 376, 'column': 6, 'index': 11345}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 377, 'column': 6, 'index': 11412}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 377, 'column': 6, 'index': 11412}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 410, 'column': 6, 'index': 12297}","it(""should work with universal configuration and do nothing"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    const pageErrors = [];
    const consoleMessages = [];
    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });
    } finally {
      await browser.close();
      await server.stop();
    }

    expect(consoleMessages).toMatchSnapshot(""console messages"");
    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 411, 'column': 6, 'index': 12366}","it(""should work with universal configuration and do nothing"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    const pageErrors = [];
    const consoleMessages = [];
    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });
    } finally {
      await browser.close();
      await server.stop();
    }

    expect(consoleMessages).toMatchSnapshot(""console messages"");
    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 467, 'column': 6, 'index': 14043}","it(""should work with universal configuration when hot and live reloads are enabled, and do hot reload for browser compiler by default when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 468, 'column': 6, 'index': 14112}","it(""should work with universal configuration when hot and live reloads are enabled, and do hot reload for browser compiler by default when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 540, 'column': 6, 'index': 16188}","it(""should work with universal configuration when only hot reload is enabled, and do hot reload for browser compiler when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 541, 'column': 6, 'index': 16257}","it(""should work with universal configuration when only hot reload is enabled, and do hot reload for browser compiler when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 617, 'column': 6, 'index': 18478}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 618, 'column': 6, 'index': 18547}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 642, 'column': 6, 'index': 19161}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 642, 'column': 6, 'index': 19161}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 643, 'column': 6, 'index': 19228}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 643, 'column': 6, 'index': 19228}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 659, 'column': 6, 'index': 19629}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 659, 'column': 6, 'index': 19629}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 660, 'column': 6, 'index': 19696}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 660, 'column': 6, 'index': 19696}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 704, 'column': 6, 'index': 21083}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 705, 'column': 6, 'index': 21152}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 729, 'column': 6, 'index': 21764}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 729, 'column': 6, 'index': 21764}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 730, 'column': 6, 'index': 21831}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 730, 'column': 6, 'index': 21831}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 746, 'column': 6, 'index': 22234}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 746, 'column': 6, 'index': 22234}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 747, 'column': 6, 'index': 22301}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Duplicate Assert,"{'line': 747, 'column': 6, 'index': 22301}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 25, 'column': 4, 'index': 952}","it(""should work with one web target configuration and do nothing"", async () => {
    const compiler = webpack(oneWebTargetConfiguration);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 61, 'column': 4, 'index': 1853}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 119, 'column': 4, 'index': 3564}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 196, 'column': 4, 'index': 5908}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 273, 'column': 4, 'index': 8254}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 342, 'column': 4, 'index': 10381}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 400, 'column': 4, 'index': 12062}","it(""should work with universal configuration and do nothing"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    const pageErrors = [];
    const consoleMessages = [];
    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });
    } finally {
      await browser.close();
      await server.stop();
    }

    expect(consoleMessages).toMatchSnapshot(""console messages"");
    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 457, 'column': 4, 'index': 13808}","it(""should work with universal configuration when hot and live reloads are enabled, and do hot reload for browser compiler by default when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 530, 'column': 4, 'index': 15953}","it(""should work with universal configuration when only hot reload is enabled, and do hot reload for browser compiler when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 607, 'column': 4, 'index': 18243}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Exception Handling,"{'line': 694, 'column': 4, 'index': 20848}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 23, 'column': 36, 'index': 933}","it(""should work with one web target configuration and do nothing"", async () => {
    const compiler = webpack(oneWebTargetConfiguration);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 59, 'column': 36, 'index': 1834}","it(""should work with web target configurations and do nothing"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
    };

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 117, 'column': 36, 'index': 3545}","it(""should work with web target configurations when hot and live reloads are enabled, and do hot reload by default when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 194, 'column': 36, 'index': 5889}","it(""should work with web target configurations when only hot reload is enabled, and do hot reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 271, 'column': 36, 'index': 8235}","it(""should work with web target configurations when only live reload is enabled, and do live reload when changing own entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 340, 'column': 36, 'index': 10362}","it(""should work with web target configurations when only live reload is enabled and do live reload when changing other entries"", async () => {
    const compiler = webpack(twoWebTargetConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToOneEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/one.js"",
    );
    const originalOneEntryContent = fs.readFileSync(pathToOneEntry);
    const pathToTwoEntry = path.resolve(
      __dirname,
      ""../fixtures/multi-compiler-two-configurations/two.js"",
    );
    const originalTwoEntryContent = fs.readFileSync(pathToTwoEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/one-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToTwoEntry, `${originalTwoEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/two-main.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(pathToOneEntry, `${originalOneEntryContent}// comment`);

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToOneEntry, originalOneEntryContent);
      fs.writeFileSync(pathToTwoEntry, originalTwoEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 396, 'column': 36, 'index': 11984}","it(""should work with universal configuration and do nothing"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    const pageErrors = [];
    const consoleMessages = [];
    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });
    } finally {
      await browser.close();
      await server.stop();
    }

    expect(consoleMessages).toMatchSnapshot(""console messages"");
    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 455, 'column': 36, 'index': 13789}","it(""should work with universal configuration when hot and live reloads are enabled, and do hot reload for browser compiler by default when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 528, 'column': 36, 'index': 15934}","it(""should work with universal configuration when only hot reload is enabled, and do hot reload for browser compiler when browser entry changed"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: true,
      liveReload: false,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          let text = message.text();

          if (/Error: Aborted because/.test(text)) {
            const splittedText = text.split(""\n"");

            text = `${splittedText[0]}\n${splittedText[1]}\n    <stack>`;
          }

          consoleMessages.push(text);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 605, 'column': 36, 'index': 18224}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing browser and server entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/multi-compiler.test.js,Lazy Test,"{'line': 692, 'column': 36, 'index': 20829}","it(""should work with universal configuration when only live reload is enabled, and do live reload for browser compiler when changing server and browser entries"", async () => {
    const compiler = webpack(universalConfiguration);
    const devServerOptions = {
      port,
      hot: false,
      liveReload: true,
    };
    const pathToBrowserEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/browser.js"",
    );
    const originalBrowserEntryContent = fs.readFileSync(pathToBrowserEntry);
    const pathToServerEntry = path.resolve(
      __dirname,
      ""../fixtures/universal-compiler-config/server.js"",
    );
    const originalServerEntryContent = fs.readFileSync(pathToServerEntry);

    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const serverResponse = await page.goto(
        `http://localhost:${port}/server.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      const serverResponseText = await serverResponse.text();

      expect(serverResponseText).toContain(""Hello from the server"");
      expect(serverResponseText).not.toContain(""WebsocketServer"");

      let pageErrors = [];
      let consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToServerEntry,
        `${originalServerEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");

      pageErrors = [];
      consoleMessages = [];

      await page.goto(`http://localhost:${port}/browser.html`, {
        waitUntil: ""networkidle0"",
      });

      fs.writeFileSync(
        pathToBrowserEntry,
        `${originalBrowserEntryContent}// comment`,
      );

      await page.waitForNavigation({ waitUntil: ""networkidle0"" });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();

      fs.writeFileSync(pathToBrowserEntry, originalBrowserEntryContent);
      fs.writeFileSync(pathToServerEntry, originalServerEntryContent);
    }
  })",steel
/test/e2e/logging.test.js,Conditional Test Logic,"{'line': 191, 'column': 2, 'index': 4805}","describe(""logging"", () => {
  const webSocketServers = [
    { webSocketServer: ""ws"" },
    { webSocketServer: ""sockjs"" },
  ];

  const cases = [
    {
      title: ""should work and log message about live reloading is enabled"",
      devServerOptions: {
        hot: false,
      },
    },
    {
      title:
        ""should work and log messages about hot and live reloading is enabled"",
      devServerOptions: {
        hot: true,
      },
    },
    {
      title: ""should work and log messages about hot is enabled"",
      devServerOptions: {
        liveReload: false,
      },
    },
    {
      title:
        ""should work and log messages about hot and live reloading is enabled"",
      devServerOptions: {
        liveReload: true,
      },
    },
    {
      title:
        ""should work and do not log messages about hot and live reloading is enabled"",
      devServerOptions: {
        liveReload: false,
        hot: false,
      },
    },
    {
      title:
        ""should work and log messages about hot and live reloading is enabled"",
      devServerOptions: {
        liveReload: true,
        hot: true,
      },
    },
    {
      title: ""should work and log warnings by default"",
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
      },
    },
    {
      title: ""should work and log errors by default"",
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.errors.push(new Error(""Error from compilation""));
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
      },
    },
    {
      title: 'should work when the ""client.logging"" is ""info""',
      devServerOptions: {
        client: {
          logging: ""info"",
        },
      },
    },
    {
      title: 'should work when the ""client.logging"" is ""log""',
      devServerOptions: {
        client: {
          logging: ""log"",
        },
      },
    },
    {
      title: 'should work when the ""client.logging"" is ""verbose""',
      devServerOptions: {
        client: {
          logging: ""verbose"",
        },
      },
    },
    {
      title: 'should work when the ""client.logging"" is ""none""',
      devServerOptions: {
        client: {
          logging: ""none"",
        },
      },
    },
    {
      title: ""should work and log only error"",
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                  compilation.errors.push(new Error(""Error from compilation""));
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
      },
      devServerOptions: {
        client: {
          logging: ""error"",
        },
      },
    },
    {
      title: ""should work and log warning and errors"",
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                  compilation.errors.push(new Error(""Error from compilation""));
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
      },
      devServerOptions: {
        client: {
          logging: ""warn"",
        },
      },
    },
    {
      title: ""should work and log static changes"",
      devServerOptions: {
        static: path.resolve(__dirname, ""../fixtures/client-config/static""),
      },
    },
  ];

  for (const webSocketServer of webSocketServers) {
    for (const testCase of cases) {
      it(`${testCase.title} (${
        webSocketServer.webSocketServer || ""default""
      })`, async () => {
        const compiler = webpack({ ...config, ...testCase.webpackOptions });
        const devServerOptions = {
          port,
          ...testCase.devServerOptions,
        };
        const server = new Server(devServerOptions, compiler);

        await server.start();

        const { page, browser } = await runBrowser();

        try {
          const consoleMessages = [];

          page.on(""console"", (message) => {
            consoleMessages.push(message);
          });

          await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (testCase.devServerOptions && testCase.devServerOptions.static) {
            fs.writeFileSync(
              path.join(testCase.devServerOptions.static, ""./foo.txt""),
              ""Text"",
            );

            await page.waitForNavigation({
              waitUntil: ""networkidle0"",
            });
          }

          expect(
            consoleMessages.map((message) =>
              message
                .text()
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                ),
            ),
          ).toMatchSnapshot();
        } finally {
          await browser.close();
          await server.stop();
        }
      });
    }
  }
})",steel
/test/e2e/logging.test.js,Conditional Test Logic,"{'line': 192, 'column': 4, 'index': 4859}","describe(""logging"", () => {
  const webSocketServers = [
    { webSocketServer: ""ws"" },
    { webSocketServer: ""sockjs"" },
  ];

  const cases = [
    {
      title: ""should work and log message about live reloading is enabled"",
      devServerOptions: {
        hot: false,
      },
    },
    {
      title:
        ""should work and log messages about hot and live reloading is enabled"",
      devServerOptions: {
        hot: true,
      },
    },
    {
      title: ""should work and log messages about hot is enabled"",
      devServerOptions: {
        liveReload: false,
      },
    },
    {
      title:
        ""should work and log messages about hot and live reloading is enabled"",
      devServerOptions: {
        liveReload: true,
      },
    },
    {
      title:
        ""should work and do not log messages about hot and live reloading is enabled"",
      devServerOptions: {
        liveReload: false,
        hot: false,
      },
    },
    {
      title:
        ""should work and log messages about hot and live reloading is enabled"",
      devServerOptions: {
        liveReload: true,
        hot: true,
      },
    },
    {
      title: ""should work and log warnings by default"",
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
      },
    },
    {
      title: ""should work and log errors by default"",
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.errors.push(new Error(""Error from compilation""));
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
      },
    },
    {
      title: 'should work when the ""client.logging"" is ""info""',
      devServerOptions: {
        client: {
          logging: ""info"",
        },
      },
    },
    {
      title: 'should work when the ""client.logging"" is ""log""',
      devServerOptions: {
        client: {
          logging: ""log"",
        },
      },
    },
    {
      title: 'should work when the ""client.logging"" is ""verbose""',
      devServerOptions: {
        client: {
          logging: ""verbose"",
        },
      },
    },
    {
      title: 'should work when the ""client.logging"" is ""none""',
      devServerOptions: {
        client: {
          logging: ""none"",
        },
      },
    },
    {
      title: ""should work and log only error"",
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                  compilation.errors.push(new Error(""Error from compilation""));
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
      },
      devServerOptions: {
        client: {
          logging: ""error"",
        },
      },
    },
    {
      title: ""should work and log warning and errors"",
      webpackOptions: {
        plugins: [
          {
            apply(compiler) {
              compiler.hooks.thisCompilation.tap(
                ""warnings-webpack-plugin"",
                (compilation) => {
                  compilation.warnings.push(
                    new Error(""Warning from compilation""),
                  );
                  compilation.errors.push(new Error(""Error from compilation""));
                },
              );
            },
          },
          new HTMLGeneratorPlugin(),
        ],
      },
      devServerOptions: {
        client: {
          logging: ""warn"",
        },
      },
    },
    {
      title: ""should work and log static changes"",
      devServerOptions: {
        static: path.resolve(__dirname, ""../fixtures/client-config/static""),
      },
    },
  ];

  for (const webSocketServer of webSocketServers) {
    for (const testCase of cases) {
      it(`${testCase.title} (${
        webSocketServer.webSocketServer || ""default""
      })`, async () => {
        const compiler = webpack({ ...config, ...testCase.webpackOptions });
        const devServerOptions = {
          port,
          ...testCase.devServerOptions,
        };
        const server = new Server(devServerOptions, compiler);

        await server.start();

        const { page, browser } = await runBrowser();

        try {
          const consoleMessages = [];

          page.on(""console"", (message) => {
            consoleMessages.push(message);
          });

          await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (testCase.devServerOptions && testCase.devServerOptions.static) {
            fs.writeFileSync(
              path.join(testCase.devServerOptions.static, ""./foo.txt""),
              ""Text"",
            );

            await page.waitForNavigation({
              waitUntil: ""networkidle0"",
            });
          }

          expect(
            consoleMessages.map((message) =>
              message
                .text()
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                ),
            ),
          ).toMatchSnapshot();
        } finally {
          await browser.close();
          await server.stop();
        }
      });
    }
  }
})",steel
/test/e2e/logging.test.js,Conditional Test Logic,"{'line': 218, 'column': 10, 'index': 5606}","it(`${testCase.title} (${
        webSocketServer.webSocketServer || ""default""
      })`, async () => {
        const compiler = webpack({ ...config, ...testCase.webpackOptions });
        const devServerOptions = {
          port,
          ...testCase.devServerOptions,
        };
        const server = new Server(devServerOptions, compiler);

        await server.start();

        const { page, browser } = await runBrowser();

        try {
          const consoleMessages = [];

          page.on(""console"", (message) => {
            consoleMessages.push(message);
          });

          await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (testCase.devServerOptions && testCase.devServerOptions.static) {
            fs.writeFileSync(
              path.join(testCase.devServerOptions.static, ""./foo.txt""),
              ""Text"",
            );

            await page.waitForNavigation({
              waitUntil: ""networkidle0"",
            });
          }

          expect(
            consoleMessages.map((message) =>
              message
                .text()
                .replaceAll(""\\"", ""/"")
                .replaceAll(
                  new RegExp(process.cwd().replaceAll(""\\"", ""/""), ""g""),
                  ""<cwd>"",
                ),
            ),
          ).toMatchSnapshot();
        } finally {
          await browser.close();
          await server.stop();
        }
      })",steel
/test/e2e/lazy-compilation.test.js,Conditional Test Logic,"{'line': 38, 'column': 10, 'index': 1356}","it.skip(""should work with single entry"", async () => {
    const compiler = webpack(lazyCompilationSingleEntryConfig);
    const server = new Server({ port }, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test.html`, {
        waitUntil: ""domcontentloaded"",
      });
      await new Promise((resolve) => {
        const interval = setInterval(() => {
          if (consoleMessages.includes(""Hey."")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/lazy-compilation.test.js,Conditional Test Logic,"{'line': 80, 'column': 10, 'index': 2481}","it.skip(""should work with multiple entries"", async () => {
    const compiler = webpack(lazyCompilationMultipleEntriesConfig);
    const server = new Server({ port }, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test-one.html`, {
        waitUntil: ""domcontentloaded"",
      });
      await new Promise((resolve) => {
        const interval = setInterval(() => {
          console.log(consoleMessages);
          if (consoleMessages.includes(""One."")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      await page.goto(`http://localhost:${port}/test-two.html`, {
        waitUntil: ""domcontentloaded"",
      });
      await new Promise((resolve) => {
        const interval = setInterval(() => {
          console.log(consoleMessages);
          if (consoleMessages.includes(""Two."")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/lazy-compilation.test.js,Conditional Test Logic,"{'line': 94, 'column': 10, 'index': 2871}","it.skip(""should work with multiple entries"", async () => {
    const compiler = webpack(lazyCompilationMultipleEntriesConfig);
    const server = new Server({ port }, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test-one.html`, {
        waitUntil: ""domcontentloaded"",
      });
      await new Promise((resolve) => {
        const interval = setInterval(() => {
          console.log(consoleMessages);
          if (consoleMessages.includes(""One."")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      await page.goto(`http://localhost:${port}/test-two.html`, {
        waitUntil: ""domcontentloaded"",
      });
      await new Promise((resolve) => {
        const interval = setInterval(() => {
          console.log(consoleMessages);
          if (consoleMessages.includes(""Two."")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/lazy-compilation.test.js,Ignored Test,"{'line': 13, 'column': 5, 'index': 638}","it.skip(""should work with single entry"", async () => {
    const compiler = webpack(lazyCompilationSingleEntryConfig);
    const server = new Server({ port }, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test.html`, {
        waitUntil: ""domcontentloaded"",
      });
      await new Promise((resolve) => {
        const interval = setInterval(() => {
          if (consoleMessages.includes(""Hey."")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/lazy-compilation.test.js,Ignored Test,"{'line': 54, 'column': 5, 'index': 1711}","it.skip(""should work with multiple entries"", async () => {
    const compiler = webpack(lazyCompilationMultipleEntriesConfig);
    const server = new Server({ port }, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test-one.html`, {
        waitUntil: ""domcontentloaded"",
      });
      await new Promise((resolve) => {
        const interval = setInterval(() => {
          console.log(consoleMessages);
          if (consoleMessages.includes(""One."")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      await page.goto(`http://localhost:${port}/test-two.html`, {
        waitUntil: ""domcontentloaded"",
      });
      await new Promise((resolve) => {
        const interval = setInterval(() => {
          console.log(consoleMessages);
          if (consoleMessages.includes(""Two."")) {
            clearInterval(interval);

            resolve();
          }
        }, 100);
      });

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/ipc.test.js,Conditional Test Logic,"{'line': 18, 'column': 2, 'index': 590}","describe(""web socket server URL"", () => {
  for (const webSocketServer of webSocketServers) {
    const websocketURLProtocol = webSocketServer === ""ws"" ? ""ws"" : ""http"";

    it(`should work with the ""ipc"" option using ""true"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        ipc: true,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: server.options.ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should work with the ""ipc"" option using ""string"" value (""${webSocketServer}"")`, async () => {
      const isWindows = process.platform === ""win32"";
      const pipePrefix = isWindows ? ""\\\\.\\pipe\\"" : os.tmpdir();
      const pipeName = `webpack-dev-server.${process.pid}-1.sock`;
      const ipc = path.join(pipePrefix, pipeName);

      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        ipc,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    // TODO un skip after implement new API
    // eslint-disable-next-line jest/no-disabled-tests
    it.skip(`should work with the ""ipc"" option using ""string"" value and remove old (""${webSocketServer}"")`, async () => {
      const isWindows = process.platform === ""win32"";
      const localRelative = path.relative(process.cwd(), `${os.tmpdir()}/`);
      const pipePrefix = isWindows ? ""\\\\.\\pipe\\"" : localRelative;
      const pipeName = `webpack-dev-server.${process.pid}-2.sock`;
      const ipc = path.join(pipePrefix, pipeName);

      const ipcServer = await new Promise((resolve, reject) => {
        // eslint-disable-next-line new-cap
        const server = net.Server();

        server.on(""error"", (error) => {
          reject(error);
        });

        // eslint-disable-next-line no-promise-executor-return
        return server.listen(ipc, () => {
          resolve();
        });
      });

      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        host: devServerHost,
        ipc,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await new Promise((resolve, reject) => {
          ipcServer.close((error) => {
            if (error) {
              reject(error);

              return;
            }

            resolve();
          });
        });
        await browser.close();
        await server.stop();
      }
    });
  }
})",steel
/test/e2e/ipc.test.js,Conditional Test Logic,"{'line': 75, 'column': 8, 'index': 2272}","it(`should work with the ""ipc"" option using ""true"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        ipc: true,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: server.options.ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/ipc.test.js,Conditional Test Logic,"{'line': 91, 'column': 12, 'index': 2768}","it(`should work with the ""ipc"" option using ""true"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        ipc: true,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: server.options.ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/ipc.test.js,Conditional Test Logic,"{'line': 177, 'column': 8, 'index': 5283}","it(`should work with the ""ipc"" option using ""string"" value (""${webSocketServer}"")`, async () => {
      const isWindows = process.platform === ""win32"";
      const pipePrefix = isWindows ? ""\\\\.\\pipe\\"" : os.tmpdir();
      const pipeName = `webpack-dev-server.${process.pid}-1.sock`;
      const ipc = path.join(pipePrefix, pipeName);

      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        ipc,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/ipc.test.js,Conditional Test Logic,"{'line': 193, 'column': 12, 'index': 5779}","it(`should work with the ""ipc"" option using ""string"" value (""${webSocketServer}"")`, async () => {
      const isWindows = process.platform === ""win32"";
      const pipePrefix = isWindows ? ""\\\\.\\pipe\\"" : os.tmpdir();
      const pipeName = `webpack-dev-server.${process.pid}-1.sock`;
      const ipc = path.join(pipePrefix, pipeName);

      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        ipc,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/ipc.test.js,Conditional Test Logic,"{'line': 297, 'column': 8, 'index': 8895}","it.skip(`should work with the ""ipc"" option using ""string"" value and remove old (""${webSocketServer}"")`, async () => {
      const isWindows = process.platform === ""win32"";
      const localRelative = path.relative(process.cwd(), `${os.tmpdir()}/`);
      const pipePrefix = isWindows ? ""\\\\.\\pipe\\"" : localRelative;
      const pipeName = `webpack-dev-server.${process.pid}-2.sock`;
      const ipc = path.join(pipePrefix, pipeName);

      const ipcServer = await new Promise((resolve, reject) => {
        // eslint-disable-next-line new-cap
        const server = net.Server();

        server.on(""error"", (error) => {
          reject(error);
        });

        // eslint-disable-next-line no-promise-executor-return
        return server.listen(ipc, () => {
          resolve();
        });
      });

      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        host: devServerHost,
        ipc,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await new Promise((resolve, reject) => {
          ipcServer.close((error) => {
            if (error) {
              reject(error);

              return;
            }

            resolve();
          });
        });
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/ipc.test.js,Conditional Test Logic,"{'line': 313, 'column': 12, 'index': 9391}","it.skip(`should work with the ""ipc"" option using ""string"" value and remove old (""${webSocketServer}"")`, async () => {
      const isWindows = process.platform === ""win32"";
      const localRelative = path.relative(process.cwd(), `${os.tmpdir()}/`);
      const pipePrefix = isWindows ? ""\\\\.\\pipe\\"" : localRelative;
      const pipeName = `webpack-dev-server.${process.pid}-2.sock`;
      const ipc = path.join(pipePrefix, pipeName);

      const ipcServer = await new Promise((resolve, reject) => {
        // eslint-disable-next-line new-cap
        const server = net.Server();

        server.on(""error"", (error) => {
          reject(error);
        });

        // eslint-disable-next-line no-promise-executor-return
        return server.listen(ipc, () => {
          resolve();
        });
      });

      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        host: devServerHost,
        ipc,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await new Promise((resolve, reject) => {
          ipcServer.close((error) => {
            if (error) {
              reject(error);

              return;
            }

            resolve();
          });
        });
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/ipc.test.js,Conditional Test Logic,"{'line': 337, 'column': 12, 'index': 10151}","it.skip(`should work with the ""ipc"" option using ""string"" value and remove old (""${webSocketServer}"")`, async () => {
      const isWindows = process.platform === ""win32"";
      const localRelative = path.relative(process.cwd(), `${os.tmpdir()}/`);
      const pipePrefix = isWindows ? ""\\\\.\\pipe\\"" : localRelative;
      const pipeName = `webpack-dev-server.${process.pid}-2.sock`;
      const ipc = path.join(pipePrefix, pipeName);

      const ipcServer = await new Promise((resolve, reject) => {
        // eslint-disable-next-line new-cap
        const server = net.Server();

        server.on(""error"", (error) => {
          reject(error);
        });

        // eslint-disable-next-line no-promise-executor-return
        return server.listen(ipc, () => {
          resolve();
        });
      });

      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        host: devServerHost,
        ipc,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await new Promise((resolve, reject) => {
          ipcServer.close((error) => {
            if (error) {
              reject(error);

              return;
            }

            resolve();
          });
        });
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/ipc.test.js,Ignored Test,"{'line': 222, 'column': 7, 'index': 6622}","it.skip(`should work with the ""ipc"" option using ""string"" value and remove old (""${webSocketServer}"")`, async () => {
      const isWindows = process.platform === ""win32"";
      const localRelative = path.relative(process.cwd(), `${os.tmpdir()}/`);
      const pipePrefix = isWindows ? ""\\\\.\\pipe\\"" : localRelative;
      const pipeName = `webpack-dev-server.${process.pid}-2.sock`;
      const ipc = path.join(pipePrefix, pipeName);

      const ipcServer = await new Promise((resolve, reject) => {
        // eslint-disable-next-line new-cap
        const server = net.Server();

        server.on(""error"", (error) => {
          reject(error);
        });

        // eslint-disable-next-line no-promise-executor-return
        return server.listen(ipc, () => {
          resolve();
        });
      });

      const devServerHost = ""localhost"";
      const proxyHost = devServerHost;
      const proxyPort = port1;

      const compiler = webpack(config);
      const devServerOptions = {
        webSocketServer,
        host: devServerHost,
        ipc,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const proxy = httpProxy.createProxyServer({
          target: { socketPath: ipc },
        });

        const proxyServer = http.createServer((request, response) => {
          // You can define here your custom logic to handle the request
          // and then proxy the request.
          proxy.web(request, response);
        });

        proxyServer.on(""upgrade"", (request, socket, head) => {
          proxy.ws(request, socket, head);
        });

        return proxyServer.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];

        if (webSocketServer === ""ws"") {
          const session = await page.target().createCDPSession();

          session.on(""Network.webSocketCreated"", (test) => {
            webSocketRequests.push(test);
          });

          await session.send(""Target.setAutoAttach"", {
            autoAttach: true,
            flatten: true,
            waitForDebuggerOnStart: true,
          });

          sessionSubscribe(session);
        } else {
          page.on(""request"", (request) => {
            if (/\/ws\//.test(request.url())) {
              webSocketRequests.push({ url: request.url() });
            }
          });
        }

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const [webSocketRequest] = webSocketRequests;

        expect(webSocketRequest.url).toContain(
          `${websocketURLProtocol}://${devServerHost}:${proxyPort}/ws`,
        );
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await new Promise((resolve, reject) => {
          ipcServer.close((error) => {
            if (error) {
              reject(error);

              return;
            }

            resolve();
          });
        });
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 318, 'column': 4, 'index': 8420}","afterEach(async () => {
    if (browser) {
      await browser.close();
    }

    if (server) {
      await server.stop();
    }

    fs.unlinkSync(cssFilePath);
  })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 322, 'column': 4, 'index': 8475}","afterEach(async () => {
    if (browser) {
      await browser.close();
    }

    if (server) {
      await server.stop();
    }

    fs.unlinkSync(cssFilePath);
  })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 329, 'column': 2, 'index': 8564}","describe(""hot and live reload"", () => {
  // ""sockjs"" client cannot add additional headers
  const modes = [
    {
      title: ""should work and refresh content using hot module replacement"",
    },
    {
      title: ""should work and do nothing when web socket server disabled"",
      options: {
        webSocketServer: false,
      },
    },
    // Default web socket serve (""ws"")
    {
      title:
        ""should work and refresh content using hot module replacement when hot enabled"",
      options: {
        hot: true,
      },
    },
    {
      title:
        ""should work and refresh content using hot module replacement when live reload enabled"",
      options: {
        liveReload: true,
      },
    },
    {
      title: ""should not refresh content when hot and no live reload disabled"",
      options: {
        hot: false,
        liveReload: false,
      },
    },
    {
      title:
        ""should work and refresh content using hot module replacement when live reload disabled and hot enabled"",
      options: {
        liveReload: false,
        hot: true,
      },
    },
    {
      title: ""should work and refresh content using live reload"",
      options: {
        liveReload: true,
        hot: false,
      },
    },
    {
      title:
        ""should work and refresh content using hot module replacement when live reload enabled and hot disabled"",
      options: {
        liveReload: true,
        hot: true,
      },
    },
    // ""ws"" web socket serve
    {
      title:
        ""should work and refresh content using hot module replacement when hot enabled"",
      options: {
        webSocketServer: ""ws"",
        hot: true,
      },
    },
    {
      title:
        ""should work and refresh content using hot module replacement when live reload enabled"",
      options: {
        webSocketServer: ""ws"",
        liveReload: true,
      },
    },
    {
      title: ""should not refresh content when hot and no live reload disabled"",
      options: {
        webSocketServer: ""ws"",
        hot: false,
        liveReload: false,
      },
    },
    {
      title:
        ""should work and refresh content using hot module replacement when live reload disabled and hot enabled"",
      options: {
        webSocketServer: ""ws"",
        liveReload: false,
        hot: true,
      },
    },
    {
      title:
        ""should work and refresh content using live reload when live reload enabled and hot disabled"",
      options: {
        webSocketServer: ""ws"",
        liveReload: true,
        hot: false,
      },
    },
    {
      title:
        ""should work and refresh content using hot module replacement when live reload and hot enabled"",
      options: {
        webSocketServer: ""ws"",
        liveReload: true,
        hot: true,
      },
    },
    // ""sockjs"" web socket serve
    {
      title:
        ""should work and refresh content using hot module replacement when hot enabled"",
      options: {
        allowedHosts: ""all"",

        webSocketServer: ""sockjs"",
        hot: true,
      },
    },
    {
      title:
        ""should work and refresh content using hot module replacement when live reload enabled"",
      options: {
        allowedHosts: ""all"",

        webSocketServer: ""sockjs"",
        liveReload: true,
      },
    },
    {
      title: ""should not refresh content when hot and no live reload disabled"",
      options: {
        allowedHosts: ""all"",

        webSocketServer: ""sockjs"",
        hot: false,
        liveReload: false,
      },
    },
    {
      title:
        ""should work and refresh content using hot module replacement when live reload disabled and hot enabled"",
      options: {
        allowedHosts: ""all"",

        webSocketServer: ""sockjs"",
        liveReload: false,
        hot: true,
      },
    },
    {
      title:
        ""should work and refresh content using live reload when live reload disabled and hot enabled"",
      options: {
        allowedHosts: ""all"",

        webSocketServer: ""sockjs"",
        liveReload: true,
        hot: false,
      },
    },
    {
      title:
        ""should work and refresh content using hot module replacement when live reload and hot enabled"",
      options: {
        allowedHosts: ""all"",

        webSocketServer: ""sockjs"",
        liveReload: true,
        hot: true,
      },
    },
    {
      title:
        'should work and allow to disable hot module replacement using the ""webpack-dev-server-hot=false""',
      query: ""?webpack-dev-server-hot=false"",
      options: {
        liveReload: true,
        hot: true,
      },
    },
    {
      title:
        'should work and allow to disable live reload using the ""webpack-dev-server-live-reload=false""',
      query: ""?webpack-dev-server-live-reload=false"",
      options: {
        liveReload: true,
        hot: false,
      },
    },
    {
      title:
        'should work and allow to disable hot module replacement and live reload using the ""webpack-dev-server-hot=false&webpack-dev-server-live-reload=false""',
      query:
        ""?webpack-dev-server-hot=false&webpack-dev-server-live-reload=false"",
      options: {
        liveReload: true,
        hot: true,
      },
    },
    {
      title: ""should work with manual client setup"",
      webpackOptions: {
        entry: [
          require.resolve(""../../client-src/index.js""),
          require.resolve(""../fixtures/reload-config/foo.js""),
        ],
      },
      options: {
        client: false,
        liveReload: true,
        hot: true,
      },
    },
    // TODO we still output logs from webpack, need to improve this
    {
      title:
        ""should work with manual client setup and allow to enable hot module replacement"",
      webpackOptions: {
        entry: [
          ""webpack/hot/dev-server"",
          `${require.resolve(""../../client-src/index.js"")}?hot=true`,
          require.resolve(""../fixtures/reload-config/foo.js""),
        ],
        plugins: [
          new webpack.HotModuleReplacementPlugin(),
          new HTMLGeneratorPlugin(),
        ],
      },
      options: {
        client: false,
        liveReload: false,
        hot: false,
      },
    },
    {
      title:
        ""should work with manual client setup and allow to disable hot module replacement"",
      webpackOptions: {
        entry: [
          `${require.resolve(""../../client-src/index.js"")}?hot=false`,
          require.resolve(""../fixtures/reload-config/foo.js""),
        ],
      },
      options: {
        client: false,
        liveReload: true,
        hot: true,
      },
    },
    {
      title:
        ""should work with manual client setup and allow to enable live reload"",
      webpackOptions: {
        entry: [
          `${require.resolve(""../../client-src/index.js"")}?live-reload=true`,
          require.resolve(""../fixtures/reload-config/foo.js""),
        ],
      },
      options: {
        client: false,
        liveReload: false,
        hot: false,
      },
    },
    {
      title:
        ""should work with manual client setup and allow to disable live reload"",
      webpackOptions: {
        entry: [
          `${require.resolve(""../../client-src/index.js"")}?live-reload=false`,
          require.resolve(""../fixtures/reload-config/foo.js""),
        ],
      },
      options: {
        client: false,
        liveReload: true,
        hot: false,
      },
    },
  ];

  let browser;
  let server;

  beforeEach(() => {
    fs.writeFileSync(cssFilePath, ""body { background-color: rgb(0, 0, 255); }"");
  });

  afterEach(async () => {
    if (browser) {
      await browser.close();
    }

    if (server) {
      await server.stop();
    }

    fs.unlinkSync(cssFilePath);
  });

  for (const mode of modes) {
    const webSocketServerTitle =
      mode.options && mode.options.webSocketServer
        ? mode.options.webSocketServer
        : ""default"";

    // eslint-disable-next-line no-loop-func
    it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    });
  }
})",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 356, 'column': 8, 'index': 9554}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 384, 'column': 12, 'index': 10270}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 392, 'column': 12, 'index': 10431}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 394, 'column': 19, 'index': 10513}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 418, 'column': 12, 'index': 11087}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 426, 'column': 12, 'index': 11258}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 428, 'column': 19, 'index': 11340}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 449, 'column': 10, 'index': 11783}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 460, 'column': 10, 'index': 12118}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 491, 'column': 6, 'index': 12977}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 496, 'column': 6, 'index': 13090}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 497, 'column': 8, 'index': 13141}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 499, 'column': 15, 'index': 13252}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 506, 'column': 6, 'index': 13395}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 507, 'column': 8, 'index': 13446}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 511, 'column': 15, 'index': 13592}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 522, 'column': 6, 'index': 13813}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 526, 'column': 6, 'index': 13907}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 530, 'column': 6, 'index': 14016}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 538, 'column': 13, 'index': 14248}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 542, 'column': 13, 'index': 14371}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 545, 'column': 12, 'index': 14502}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 560, 'column': 6, 'index': 14845}","it(`${mode.title} (${webSocketServerTitle})`, async () => {
      const webpackOptions = { ...reloadConfig, ...mode.webpackOptions };
      const compiler = webpack(webpackOptions);
      const testDevServerOptions = mode.options || {};
      const devServerOptions = { port, ...testDevServerOptions };

      server = new Server(devServerOptions, compiler);

      await server.start();

      const webSocketServerLaunched =
        testDevServerOptions.webSocketServer !== false;

      await new Promise((resolve) => {
        const webSocketTransport =
          typeof testDevServerOptions.webSocketServer !== ""undefined"" &&
          testDevServerOptions.webSocketServer !== false
            ? testDevServerOptions.webSocketServer
            : ""ws"";

        if (webSocketTransport === ""ws"") {
          const ws = new WebSocket(
            `ws://localhost:${devServerOptions.port}/ws`,
            {
              headers: {
                host: `localhost:${devServerOptions.port}`,
                origin: `http://localhost:${devServerOptions.port}`,
              },
            },
          );

          let opened = false;
          let received = false;
          let errored = false;

          ws.on(""error"", (_error) => {
            errored = true;

            ws.close();
          });

          ws.on(""open"", () => {
            opened = true;
          });

          ws.on(""message"", (data) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              ws.close();
            }
          });

          ws.on(""close"", () => {
            if (opened && received && !errored) {
              resolve();
            } else if (!webSocketServerLaunched && errored) {
              resolve();
            }
          });
        } else {
          const sockjs = new SockJS(
            `http://localhost:${devServerOptions.port}/ws`,
          );

          let opened = false;
          let received = false;
          let errored = false;

          sockjs.onerror = () => {
            errored = true;
          };

          sockjs.onopen = () => {
            opened = true;
          };

          sockjs.onmessage = ({ data }) => {
            const message = JSON.parse(data);

            if (message.type === ""ok"") {
              received = true;

              sockjs.close();
            }
          };

          sockjs.onclose = (event) => {
            if (opened && received && !errored) {
              resolve();
            } else if (event && event.reason === ""Cannot connect to server"") {
              resolve();
            }
          };
        }
      });

      const launched = await runBrowser();

      ({ browser } = launched);

      const { page } = launched;

      const consoleMessages = [];
      const pageErrors = [];

      let doneHotUpdate = false;
      let hasDisconnectedMessage = false;

      page
        .on(""console"", (message) => {
          if (!hasDisconnectedMessage) {
            const text = message.text();

            hasDisconnectedMessage = /Disconnected!/.test(text);
            consoleMessages.push(text);
          }
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (requestObj) => {
          if (/\.hot-update\.json$/.test(requestObj.url())) {
            doneHotUpdate = true;
          }
        });

      await page.goto(`http://localhost:${port}/${mode.query || """"}`, {
        waitUntil: ""networkidle0"",
      });

      const backgroundColorBefore = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      expect(backgroundColorBefore).toBe(""rgb(0, 0, 255)"");

      fs.writeFileSync(
        cssFilePath,
        ""body { background-color: rgb(255, 0, 0); }"",
      );

      let waitHot =
        typeof testDevServerOptions.hot !== ""undefined""
          ? testDevServerOptions.hot
          : true;
      let waitLiveReload =
        typeof testDevServerOptions.liveReload !== ""undefined""
          ? testDevServerOptions.liveReload
          : true;

      if (webSocketServerLaunched === false) {
        waitHot = false;
        waitLiveReload = false;
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (webpackOptions.entry.some((item) => item.includes(""hot=true""))) {
          waitHot = true;
        } else if (
          webpackOptions.entry.some((item) => item.includes(""hot=false""))
        ) {
          waitHot = false;
        }
      }

      if (Array.isArray(webpackOptions.entry)) {
        if (
          webpackOptions.entry.some((item) => item.includes(""live-reload=true""))
        ) {
          waitLiveReload = true;
        } else if (
          webpackOptions.entry.some((item) =>
            item.includes(""live-reload=false""),
          )
        ) {
          waitLiveReload = false;
        }
      }

      const query = mode.query || """";

      if (query.includes(""webpack-dev-server-hot=false"")) {
        waitHot = false;
      }

      if (query.includes(""webpack-dev-server-live-reload=false"")) {
        waitLiveReload = false;
      }

      if (waitHot) {
        await page.waitForFunction(
          () =>
            getComputedStyle(document.body)[""background-color""] ===
            ""rgb(255, 0, 0)"",
        );

        expect(doneHotUpdate).toBe(true);
      } else if (waitLiveReload) {
        await page.waitForNavigation({
          waitUntil: ""networkidle0"",
        });
      } else if (webSocketServerLaunched) {
        await new Promise((resolve) => {
          const interval = setInterval(() => {
            if (consoleMessages.includes(INVALID_MESSAGE)) {
              clearInterval(interval);

              resolve();
            }
          }, 100);
        });
      }

      const backgroundColorAfter = await page.evaluate(() => {
        const { body } = document;

        return getComputedStyle(body)[""background-color""];
      });

      if (!waitHot && !waitLiveReload) {
        expect(backgroundColorAfter).toBe(""rgb(0, 0, 255)"");
      } else {
        expect(backgroundColorAfter).toBe(""rgb(255, 0, 0)"");
      }

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 602, 'column': 8, 'index': 15841}","it(""should register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port }, compiler);

    await server.start();

    expect(pluginFound).toBe(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 668, 'column': 8, 'index': 17330}","it(""should register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port }, compiler);

    await server.start();

    expect(compiler.options.plugins).toHaveLength(2);
    expect(pluginFound).toBe(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 798, 'column': 8, 'index': 20539}","it(""should register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.compilers[0].hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port }, compiler);

    await server.start();

    expect(pluginFound).toBe(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/hot-and-live-reload.test.js,Conditional Test Logic,"{'line': 861, 'column': 8, 'index': 21901}","it(""should NOT register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port, hot: false }, compiler);

    await server.start();

    expect(pluginFound).toBe(false);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/hot-and-live-reload.test.js,Magic Number,"{'line': 680, 'column': 50, 'index': 17589}","it(""should register the HMR plugin before compilation is complete"", async () => {
    let pluginFound = false;

    compiler.hooks.compilation.intercept({
      register: (tapInfo) => {
        if (tapInfo.name === ""HotModuleReplacementPlugin"") {
          pluginFound = true;
        }

        return tapInfo;
      },
    });

    server = new Server({ port }, compiler);

    await server.start();

    expect(compiler.options.plugins).toHaveLength(2);
    expect(pluginFound).toBe(true);

    page
      .on(""console"", (message) => {
        consoleMessages.push(message);
      })
      .on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

    const response = await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    expect(response.status()).toMatchSnapshot(""response status"");

    expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
      ""console messages"",
    );

    expect(pageErrors).toMatchSnapshot(""page errors"");
  })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 16, 'column': 2, 'index': 441}",Unknown,steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 21, 'column': 9, 'index': 596}",Unknown,steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 23, 'column': 9, 'index': 656}",Unknown,steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 25, 'column': 9, 'index': 708}",Unknown,steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 41, 'column': 8, 'index': 1199}",Unknown,steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 49, 'column': 9, 'index': 1308}",Unknown,steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 73, 'column': 2, 'index': 1634}","describe(""host"", () => {
  const hosts = [
    ""<not-specified>"",

    undefined,
    ""0.0.0.0"",
    ""::"",
    ""::1"",
    ""localhost"",
    ""127.0.0.1"",
    ""local-ip"",
    ""local-ipv4"",
    ""local-ipv6"",
  ];

  for (const host of hosts) {
    it(`should work using ""${host}"" host and port as number`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work using ""${host}"" host and port as string`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port: `${port}` };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    });

    it(`should work using ""${host}"" host and ""auto"" port`, async () => {
      const compiler = webpack(config);

      process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;

      const devServerOptions = { port: ""auto"" };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const address = server.server.address();
      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;

        await browser.close();
        await server.stop();
      }
    });
  }

  // TODO need test on error
  // eslint-disable-next-line jest/no-commented-out-tests
  // it(`should throw an error on invalid host`, async () => {
  //   const compiler = webpack(config);
  //   const server = new Server({ port, host: ""unknown.unknown"" }, compiler);
  //   const runDevServer = async () => {
  //     await server.start();
  //   };
  //
  //   return expect(runDevServer()).toBeDefined();
  // });
})",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 78, 'column': 6, 'index': 1826}","it(`should work using ""${host}"" host and port as number`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 82, 'column': 6, 'index': 1913}","it(`should work using ""${host}"" host and port as number`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 96, 'column': 6, 'index': 2242}","it(`should work using ""${host}"" host and port as number`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 99, 'column': 13, 'index': 2554}","it(`should work using ""${host}"" host and port as number`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 101, 'column': 13, 'index': 2622}","it(`should work using ""${host}"" host and port as number`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 104, 'column': 13, 'index': 2874}","it(`should work using ""${host}"" host and port as number`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 106, 'column': 13, 'index': 2941}","it(`should work using ""${host}"" host and port as number`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 108, 'column': 13, 'index': 3039}","it(`should work using ""${host}"" host and port as number`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 152, 'column': 6, 'index': 4213}","it(`should work using ""${host}"" host and port as string`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port: `${port}` };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 156, 'column': 6, 'index': 4300}","it(`should work using ""${host}"" host and port as string`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port: `${port}` };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 170, 'column': 6, 'index': 4629}","it(`should work using ""${host}"" host and port as string`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port: `${port}` };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 173, 'column': 13, 'index': 4941}","it(`should work using ""${host}"" host and port as string`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port: `${port}` };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 175, 'column': 13, 'index': 5009}","it(`should work using ""${host}"" host and port as string`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port: `${port}` };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 178, 'column': 13, 'index': 5261}","it(`should work using ""${host}"" host and port as string`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port: `${port}` };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 180, 'column': 13, 'index': 5328}","it(`should work using ""${host}"" host and port as string`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port: `${port}` };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 182, 'column': 13, 'index': 5426}","it(`should work using ""${host}"" host and port as string`, async () => {
      const compiler = webpack(config);
      const devServerOptions = { port: `${port}` };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 229, 'column': 6, 'index': 6651}","it(`should work using ""${host}"" host and ""auto"" port`, async () => {
      const compiler = webpack(config);

      process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;

      const devServerOptions = { port: ""auto"" };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const address = server.server.address();
      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 233, 'column': 6, 'index': 6738}","it(`should work using ""${host}"" host and ""auto"" port`, async () => {
      const compiler = webpack(config);

      process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;

      const devServerOptions = { port: ""auto"" };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const address = server.server.address();
      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 247, 'column': 6, 'index': 7067}","it(`should work using ""${host}"" host and ""auto"" port`, async () => {
      const compiler = webpack(config);

      process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;

      const devServerOptions = { port: ""auto"" };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const address = server.server.address();
      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 250, 'column': 13, 'index': 7379}","it(`should work using ""${host}"" host and ""auto"" port`, async () => {
      const compiler = webpack(config);

      process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;

      const devServerOptions = { port: ""auto"" };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const address = server.server.address();
      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 252, 'column': 13, 'index': 7447}","it(`should work using ""${host}"" host and ""auto"" port`, async () => {
      const compiler = webpack(config);

      process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;

      const devServerOptions = { port: ""auto"" };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const address = server.server.address();
      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 255, 'column': 13, 'index': 7699}","it(`should work using ""${host}"" host and ""auto"" port`, async () => {
      const compiler = webpack(config);

      process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;

      const devServerOptions = { port: ""auto"" };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const address = server.server.address();
      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 257, 'column': 13, 'index': 7766}","it(`should work using ""${host}"" host and ""auto"" port`, async () => {
      const compiler = webpack(config);

      process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;

      const devServerOptions = { port: ""auto"" };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const address = server.server.address();
      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/host.test.js,Conditional Test Logic,"{'line': 259, 'column': 13, 'index': 7864}","it(`should work using ""${host}"" host and ""auto"" port`, async () => {
      const compiler = webpack(config);

      process.env.WEBPACK_DEV_SERVER_BASE_PORT = port;

      const devServerOptions = { port: ""auto"" };

      if (host !== ""<not-specified>"") {
        devServerOptions.host = host;
      }

      if (
        host === ""<not-specified>"" ||
        typeof host === ""undefined"" ||
        host === ""0.0.0.0"" ||
        host === ""::"" ||
        host === ""local-ipv6""
      ) {
        devServerOptions.allowedHosts = ""all"";
      }

      const server = new Server(devServerOptions, compiler);

      let hostname = host;

      if (hostname === ""<not-specified>"" || typeof hostname === ""undefined"") {
        // If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""0.0.0.0"") {
        hostname = ipv4;
      } else if (hostname === ""::"") {
        // In most operating systems, listening to the unspecified IPv6 address (::) may cause the net.Server to also listen on the unspecified IPv4 address (0.0.0.0).
        hostname = ipv6 ? `[${ipv6}]` : ipv4;
      } else if (hostname === ""::1"") {
        hostname = ""[::1]"";
      } else if (hostname === ""local-ip"" || hostname === ""local-ipv4"") {
        hostname = ipv4;
      } else if (hostname === ""local-ipv6"") {
        // For test env where network ipv6 doesn't work
        hostname = ipv6 ? `[${ipv6}]` : ""[::1]"";
      }

      await server.start();

      expect(server.server.address()).toMatchObject(
        await getAddress(host, hostname),
      );

      const address = server.server.address();
      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${hostname}:${address.port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");

        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;

        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/entry.test.js,Conditional Test Logic,"{'line': 16, 'column': 6, 'index': 601}",Unknown,steel
/test/e2e/entry.test.js,Exception Handling,"{'line': 46, 'column': 4, 'index': 1260}","it(""should work with single entry"", async () => {
    const compiler = webpack({ ...config, entry: entryFirst });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Exception Handling,"{'line': 83, 'column': 4, 'index': 2203}","it(""should work with single array entry"", async () => {
    const compiler = webpack({ ...config, entry: [entryFirst, entrySecond] });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Exception Handling,"{'line': 125, 'column': 4, 'index': 3179}","it(""should work with object entry"", async () => {
    const compiler = webpack({
      ...config,
      entry: {
        main: { import: entryFirst },
      },
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Exception Handling,"{'line': 162, 'column': 4, 'index': 4108}","it(""should work with dynamic entry"", async () => {
    const compiler = webpack({ ...config, entry: () => entryFirst });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Exception Handling,"{'line': 205, 'column': 4, 'index': 5128}","it(""should work with dynamic async entry"", async () => {
    const compiler = webpack({
      ...config,
      entry: () =>
        new Promise((resolve) => {
          resolve([entryFirst]);
        }),
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Exception Handling,"{'line': 253, 'column': 4, 'index': 6214}","it(""should work with multiple entries"", async () => {
    const compiler = webpack({
      ...config,
      entry: {
        foo: entryFirst,
        bar: entrySecond,
      },
      optimization: {
        runtimeChunk: {
          name: ""runtime"",
        },
      },
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test.html`, {
        waitUntil: ""networkidle0"",
      });
      await page.addScriptTag({ url: `http://localhost:${port}/runtime.js` });
      await page.addScriptTag({ url: `http://localhost:${port}/foo.js` });
      await waitForConsoleLogFinished(consoleMessages);

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Exception Handling,"{'line': 302, 'column': 4, 'index': 7479}","it(""should work with multiple entries #2"", async () => {
    const compiler = webpack({
      ...config,
      entry: {
        foo: entryFirst,
        bar: entrySecond,
      },
      optimization: {
        runtimeChunk: {
          name: ""runtime"",
        },
      },
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test.html`, {
        waitUntil: ""networkidle0"",
      });
      await page.addScriptTag({ url: `http://localhost:${port}/runtime.js` });
      await page.addScriptTag({ url: `http://localhost:${port}/bar.js` });
      await waitForConsoleLogFinished(consoleMessages);

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Exception Handling,"{'line': 349, 'column': 4, 'index': 8721}","it('should work with multiple entries and ""dependOn""', async () => {
    const compiler = webpack({
      ...config,
      entry: {
        foo: {
          import: entryFirst,
          dependOn: ""bar"",
        },
        bar: entrySecond,
      },
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test.html`, {
        waitUntil: ""networkidle0"",
      });
      await page.addScriptTag({ url: `http://localhost:${port}/bar.js` });
      await page.addScriptTag({ url: `http://localhost:${port}/foo.js` });
      await waitForConsoleLogFinished(consoleMessages);

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Exception Handling,"{'line': 395, 'column': 4, 'index': 9923}","it(""should work with empty"", async () => {
    const compiler = webpack({
      ...config,
      entry: {},
    });

    new webpack.EntryPlugin(compiler.context, entryFirst, {
      name: ""main"",
    }).apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Lazy Test,"{'line': 44, 'column': 36, 'index': 1241}","it(""should work with single entry"", async () => {
    const compiler = webpack({ ...config, entry: entryFirst });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Lazy Test,"{'line': 81, 'column': 36, 'index': 2184}","it(""should work with single array entry"", async () => {
    const compiler = webpack({ ...config, entry: [entryFirst, entrySecond] });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Lazy Test,"{'line': 123, 'column': 36, 'index': 3160}","it(""should work with object entry"", async () => {
    const compiler = webpack({
      ...config,
      entry: {
        main: { import: entryFirst },
      },
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Lazy Test,"{'line': 160, 'column': 36, 'index': 4089}","it(""should work with dynamic entry"", async () => {
    const compiler = webpack({ ...config, entry: () => entryFirst });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Lazy Test,"{'line': 203, 'column': 36, 'index': 5109}","it(""should work with dynamic async entry"", async () => {
    const compiler = webpack({
      ...config,
      entry: () =>
        new Promise((resolve) => {
          resolve([entryFirst]);
        }),
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Lazy Test,"{'line': 251, 'column': 36, 'index': 6195}","it(""should work with multiple entries"", async () => {
    const compiler = webpack({
      ...config,
      entry: {
        foo: entryFirst,
        bar: entrySecond,
      },
      optimization: {
        runtimeChunk: {
          name: ""runtime"",
        },
      },
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test.html`, {
        waitUntil: ""networkidle0"",
      });
      await page.addScriptTag({ url: `http://localhost:${port}/runtime.js` });
      await page.addScriptTag({ url: `http://localhost:${port}/foo.js` });
      await waitForConsoleLogFinished(consoleMessages);

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Lazy Test,"{'line': 300, 'column': 36, 'index': 7460}","it(""should work with multiple entries #2"", async () => {
    const compiler = webpack({
      ...config,
      entry: {
        foo: entryFirst,
        bar: entrySecond,
      },
      optimization: {
        runtimeChunk: {
          name: ""runtime"",
        },
      },
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test.html`, {
        waitUntil: ""networkidle0"",
      });
      await page.addScriptTag({ url: `http://localhost:${port}/runtime.js` });
      await page.addScriptTag({ url: `http://localhost:${port}/bar.js` });
      await waitForConsoleLogFinished(consoleMessages);

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Lazy Test,"{'line': 347, 'column': 36, 'index': 8702}","it('should work with multiple entries and ""dependOn""', async () => {
    const compiler = webpack({
      ...config,
      entry: {
        foo: {
          import: entryFirst,
          dependOn: ""bar"",
        },
        bar: entrySecond,
      },
    });
    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message.text());
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/test.html`, {
        waitUntil: ""networkidle0"",
      });
      await page.addScriptTag({ url: `http://localhost:${port}/bar.js` });
      await page.addScriptTag({ url: `http://localhost:${port}/foo.js` });
      await waitForConsoleLogFinished(consoleMessages);

      expect(consoleMessages).toMatchSnapshot(""console messages"");
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/entry.test.js,Lazy Test,"{'line': 393, 'column': 36, 'index': 9904}","it(""should work with empty"", async () => {
    const compiler = webpack({
      ...config,
      entry: {},
    });

    new webpack.EntryPlugin(compiler.context, entryFirst, {
      name: ""main"",
    }).apply(compiler);

    const devServerOptions = {
      port,
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];
      const consoleMessages = [];

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
      expect(pageErrors).toMatchSnapshot(""page errors"");
    } finally {
      await browser.close();
      await server.stop();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Exception Handling,"{'line': 42, 'column': 4, 'index': 1274}","it(""should return 403 for cross-origin no-cors non-module script tag requests"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: ""auto"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js""></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(403);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Exception Handling,"{'line': 96, 'column': 4, 'index': 2700}","it(""should return 200 for cross-origin cors non-module script tag requests"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: ""auto"",
      headers: {
        ""Access-Control-Allow-Origin"": ""*"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js"" crossorigin></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(200);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Exception Handling,"{'line': 147, 'column': 4, 'index': 4092}","it(""should return 200 for cross-origin no-cors non-module script tag requests with the 'allowedHost' option and 'all' value"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: ""all"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js""></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(200);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Exception Handling,"{'line': 198, 'column': 4, 'index': 5502}","it(""should return 200 for cross-origin no-cors non-module script tag requests with the `allowedHost` option and the `localhost` value"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: [""localhost""],
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js""></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(200);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Lazy Test,"{'line': 40, 'column': 36, 'index': 1255}","it(""should return 403 for cross-origin no-cors non-module script tag requests"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: ""auto"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js""></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(403);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Lazy Test,"{'line': 94, 'column': 36, 'index': 2681}","it(""should return 200 for cross-origin cors non-module script tag requests"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: ""auto"",
      headers: {
        ""Access-Control-Allow-Origin"": ""*"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js"" crossorigin></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(200);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Lazy Test,"{'line': 145, 'column': 36, 'index': 4073}","it(""should return 200 for cross-origin no-cors non-module script tag requests with the 'allowedHost' option and 'all' value"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: ""all"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js""></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(200);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Lazy Test,"{'line': 196, 'column': 36, 'index': 5483}","it(""should return 200 for cross-origin no-cors non-module script tag requests with the `allowedHost` option and the `localhost` value"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: [""localhost""],
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js""></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(200);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Magic Number,"{'line': 57, 'column': 37, 'index': 1664}","it(""should return 403 for cross-origin no-cors non-module script tag requests"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: ""auto"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js""></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(403);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Magic Number,"{'line': 111, 'column': 37, 'index': 3090}","it(""should return 200 for cross-origin cors non-module script tag requests"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: ""auto"",
      headers: {
        ""Access-Control-Allow-Origin"": ""*"",
      },
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js"" crossorigin></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(200);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Magic Number,"{'line': 162, 'column': 37, 'index': 4482}","it(""should return 200 for cross-origin no-cors non-module script tag requests with the 'allowedHost' option and 'all' value"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: ""all"",
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js""></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(200);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/cross-origin-request.test.js,Magic Number,"{'line': 213, 'column': 37, 'index': 5892}","it(""should return 200 for cross-origin no-cors non-module script tag requests with the `allowedHost` option and the `localhost` value"", async () => {
    const compiler = webpack(config);
    const devServerOptions = {
      port: devServerPort,
      allowedHosts: [""localhost""],
    };
    const server = new Server(devServerOptions, compiler);

    await server.start();

    // Start a separate server for serving the HTML file
    const http = require(""node:http"");

    const htmlServer = http.createServer((req, res) => {
      res.writeHead(200, { ""Content-Type"": ""text/html"" });
      res.end(`
        <html>
          <head>
            <script src=""http://localhost:${devServerPort}/main.js""></script>
          </head>
          <body></body>
        </html>
      `);
    });
    htmlServer.listen(htmlServerPort, htmlServerHost);

    const { page, browser } = await runBrowser();

    try {
      const pageErrors = [];

      page.on(""pageerror"", (error) => {
        pageErrors.push(error);
      });

      const scriptTagRequest = page.waitForResponse(
        `http://localhost:${devServerPort}/main.js`,
      );

      await page.goto(`http://${htmlServerHost}:${htmlServerPort}`);

      const response = await scriptTagRequest;

      expect(response.status()).toBe(200);
    } finally {
      await browser.close();
      await server.stop();
      htmlServer.close();
    }
  })",steel
/test/e2e/client.test.js,Conditional Test Logic,"{'line': 306, 'column': 6, 'index': 7092}","describe(""passed to server"", () => {
      for (const data of clientModes) {
        it(`${data.title} ${
          data.shouldThrow ? ""should throw"" : ""should not throw""
        }`, async () => {
          const compiler = webpack(config);

          const server = new Server(
            {
              client: data.client,
              port,
            },
            compiler,
          );

          let thrownError;

          try {
            await server.start();
          } catch (error) {
            thrownError = error;
          }

          if (data.shouldThrow) {
            expect(thrownError.message).toMatch(
              /client\.webSocketTransport must be a string/,
            );
          }

          await server.stop();
        });
      }
    })",steel
/test/e2e/client.test.js,Conditional Test Logic,"{'line': 328, 'column': 10, 'index': 7610}","it(`${data.title} ${
          data.shouldThrow ? ""should throw"" : ""should not throw""
        }`, async () => {
          const compiler = webpack(config);

          const server = new Server(
            {
              client: data.client,
              port,
            },
            compiler,
          );

          let thrownError;

          try {
            await server.start();
          } catch (error) {
            thrownError = error;
          }

          if (data.shouldThrow) {
            expect(thrownError.message).toMatch(
              /client\.webSocketTransport must be a string/,
            );
          }

          await server.stop();
        })",steel
/test/e2e/client.test.js,Duplicate Assert,"{'line': 244, 'column': 6, 'index': 5531}","it(""should disable client entry"", async () => {
      const response = await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      const content = await response.text();
      expect(content).toContain(""CustomClientEntry.js"");
      expect(content).toContain(""CustomClientHotEntry.js"");
    })",steel
/test/e2e/client.test.js,Duplicate Assert,"{'line': 245, 'column': 6, 'index': 5588}","it(""should disable client entry"", async () => {
      const response = await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      const content = await response.text();
      expect(content).toContain(""CustomClientEntry.js"");
      expect(content).toContain(""CustomClientHotEntry.js"");
    })",steel
/test/e2e/client-reconnect.test.js,Conditional Test Logic,"{'line': 62, 'column': 10, 'index': 1584}","it(""should try to reconnect unlimited times"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      try {
        expect(response.status()).toMatchSnapshot(""response status"");
      } finally {
        await server.stop();
      }

      let interval;

      await new Promise((resolve) => {
        interval = setInterval(() => {
          const retryingMessages = consoleMessages.filter((message) =>
            message.text().includes(""Trying to reconnect...""),
          );

          if (retryingMessages.length >= 5) {
            clearInterval(interval);

            resolve();
          }
        }, 1000);
      });

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/client-reconnect.test.js,Exception Handling,"{'line': 48, 'column': 6, 'index': 1195}","it(""should try to reconnect unlimited times"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      try {
        expect(response.status()).toMatchSnapshot(""response status"");
      } finally {
        await server.stop();
      }

      let interval;

      await new Promise((resolve) => {
        interval = setInterval(() => {
          const retryingMessages = consoleMessages.filter((message) =>
            message.text().includes(""Trying to reconnect...""),
          );

          if (retryingMessages.length >= 5) {
            clearInterval(interval);

            resolve();
          }
        }, 1000);
      });

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/client-reconnect.test.js,Exception Handling,"{'line': 112, 'column': 6, 'index': 2652}","it(""should not try to reconnect"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      try {
        expect(response.status()).toMatchSnapshot(""response status"");
      } finally {
        await server.stop();
      }

      // Can't wait to check for unlimited times so wait only for couple retries
      await new Promise((resolve) => {
        setTimeout(
          () => {
            resolve();
          },
          1000 * 2 ** 3,
        );
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/client-reconnect.test.js,Exception Handling,"{'line': 174, 'column': 6, 'index': 4074}","it(""should try to reconnect 2 times"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      try {
        expect(response.status()).toMatchSnapshot(""response status"");
      } finally {
        await server.stop();
      }

      // Can't wait to check for unlimited times so wait only for couple retries
      await new Promise((resolve) => {
        setTimeout(
          () => {
            resolve();
          },
          1000 * 2 ** 3,
        );
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/client-reconnect.test.js,Sleepy Test,"{'line': 120, 'column': 8, 'index': 2912}","it(""should not try to reconnect"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      try {
        expect(response.status()).toMatchSnapshot(""response status"");
      } finally {
        await server.stop();
      }

      // Can't wait to check for unlimited times so wait only for couple retries
      await new Promise((resolve) => {
        setTimeout(
          () => {
            resolve();
          },
          1000 * 2 ** 3,
        );
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/client-reconnect.test.js,Sleepy Test,"{'line': 182, 'column': 8, 'index': 4334}","it(""should try to reconnect 2 times"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      try {
        expect(response.status()).toMatchSnapshot(""response status"");
      } finally {
        await server.stop();
      }

      // Can't wait to check for unlimited times so wait only for couple retries
      await new Promise((resolve) => {
        setTimeout(
          () => {
            resolve();
          },
          1000 * 2 ** 3,
        );
      });

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/built-in-routes.test.js,Conditional Test Logic,"{'line': 74, 'column': 10, 'index': 1997}","it(""should handles HEAD request to sockjs bundle"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (interceptedRequest) => {
          if (interceptedRequest.isInterceptResolutionHandled()) return;

          interceptedRequest.continue({ method: ""HEAD"" }, 10);
        });

      const response = await page.goto(
        `http://localhost:${port}/__webpack_dev_server__/sockjs.bundle.js`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/built-in-routes.test.js,Conditional Test Logic,"{'line': 166, 'column': 10, 'index': 4660}","it(""should handle HEAD request to directory index"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (interceptedRequest) => {
          if (interceptedRequest.isInterceptResolutionHandled()) return;

          interceptedRequest.continue({ method: ""HEAD"" });
        });

      const response = await page.goto(
        `http://localhost:${port}/webpack-dev-server/`,
        {
          waitUntil: ""networkidle0"",
        },
      );

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(await response.text()).toMatchSnapshot(""directory list"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/built-in-routes.test.js,Conditional Test Logic,"{'line': 226, 'column': 10, 'index': 6409}","it(""should handle HEAD request to magic async chunk"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        })
        .on(""request"", (interceptedRequest) => {
          if (interceptedRequest.isInterceptResolutionHandled()) return;

          interceptedRequest.continue({ method: ""HEAD"" });
        });

      const response = await page.goto(`http://localhost:${port}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.headers()[""content-type""]).toMatchSnapshot(
        ""response headers content-type"",
      );

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );
    })",steel
/test/e2e/bonjour.test.js,Duplicate Assert,"{'line': 74, 'column': 6, 'index': 1752}","it(""should call bonjour with correct params"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(mockPublish).toHaveBeenCalledTimes(1);

      expect(mockPublish).toHaveBeenCalledWith({
        name: `Webpack Dev Server ${os.hostname()}:${port}`,
        port,
        type: ""http"",
        subtypes: [""webpack""],
      });

      expect(mockUnpublishAll).toHaveBeenCalledTimes(0);
      expect(mockDestroy).toHaveBeenCalledTimes(0);

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/bonjour.test.js,Duplicate Assert,"{'line': 76, 'column': 6, 'index': 1805}","it(""should call bonjour with correct params"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(mockPublish).toHaveBeenCalledTimes(1);

      expect(mockPublish).toHaveBeenCalledWith({
        name: `Webpack Dev Server ${os.hostname()}:${port}`,
        port,
        type: ""http"",
        subtypes: [""webpack""],
      });

      expect(mockUnpublishAll).toHaveBeenCalledTimes(0);
      expect(mockDestroy).toHaveBeenCalledTimes(0);

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/bonjour.test.js,Duplicate Assert,"{'line': 143, 'column': 6, 'index': 3486}","it(""should call bonjour with 'https' type"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`https://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(mockPublish).toHaveBeenCalledTimes(1);

      expect(mockPublish).toHaveBeenCalledWith({
        name: `Webpack Dev Server ${os.hostname()}:${port}`,
        port,
        type: ""https"",
        subtypes: [""webpack""],
      });

      expect(mockUnpublishAll).toHaveBeenCalledTimes(0);
      expect(mockDestroy).toHaveBeenCalledTimes(0);

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/bonjour.test.js,Duplicate Assert,"{'line': 145, 'column': 6, 'index': 3539}","it(""should call bonjour with 'https' type"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`https://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(mockPublish).toHaveBeenCalledTimes(1);

      expect(mockPublish).toHaveBeenCalledWith({
        name: `Webpack Dev Server ${os.hostname()}:${port}`,
        port,
        type: ""https"",
        subtypes: [""webpack""],
      });

      expect(mockUnpublishAll).toHaveBeenCalledTimes(0);
      expect(mockDestroy).toHaveBeenCalledTimes(0);

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/bonjour.test.js,Duplicate Assert,"{'line': 221, 'column': 6, 'index': 5302}","it(""should apply bonjour options"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(mockPublish).toHaveBeenCalledTimes(1);

      expect(mockPublish).toHaveBeenCalledWith({
        name: `Webpack Dev Server ${os.hostname()}:${port}`,
        port,
        type: ""https"",
        protocol: ""udp"",
        subtypes: [""webpack""],
      });

      expect(mockUnpublishAll).toHaveBeenCalledTimes(0);
      expect(mockDestroy).toHaveBeenCalledTimes(0);

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/bonjour.test.js,Duplicate Assert,"{'line': 223, 'column': 6, 'index': 5355}","it(""should apply bonjour options"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(mockPublish).toHaveBeenCalledTimes(1);

      expect(mockPublish).toHaveBeenCalledWith({
        name: `Webpack Dev Server ${os.hostname()}:${port}`,
        port,
        type: ""https"",
        protocol: ""udp"",
        subtypes: [""webpack""],
      });

      expect(mockUnpublishAll).toHaveBeenCalledTimes(0);
      expect(mockDestroy).toHaveBeenCalledTimes(0);

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/bonjour.test.js,Duplicate Assert,"{'line': 303, 'column': 6, 'index': 7228}","it(""should apply bonjour options"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`https://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(mockPublish).toHaveBeenCalledTimes(1);

      expect(mockPublish).toHaveBeenCalledWith({
        name: `Webpack Dev Server ${os.hostname()}:${port}`,
        port,
        type: ""http"",
        protocol: ""udp"",
        subtypes: [""webpack""],
      });

      expect(mockUnpublishAll).toHaveBeenCalledTimes(0);
      expect(mockDestroy).toHaveBeenCalledTimes(0);

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/bonjour.test.js,Duplicate Assert,"{'line': 305, 'column': 6, 'index': 7281}","it(""should apply bonjour options"", async () => {
      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`https://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(mockPublish).toHaveBeenCalledTimes(1);

      expect(mockPublish).toHaveBeenCalledWith({
        name: `Webpack Dev Server ${os.hostname()}:${port}`,
        port,
        type: ""http"",
        protocol: ""udp"",
        subtypes: [""webpack""],
      });

      expect(mockUnpublishAll).toHaveBeenCalledTimes(0);
      expect(mockDestroy).toHaveBeenCalledTimes(0);

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/app.test.js,Conditional Test Logic,"{'line': 92, 'column': 0, 'index': 2571}",Unknown,steel
/test/e2e/app.test.js,Conditional Test Logic,"{'line': 100, 'column': 2, 'index': 2749}","describe(""app option"", () => {
  for (const [appName, app, server, setupMiddlewares] of apps) {
    let compiler;
    let devServer;
    let page;
    let browser;
    let pageErrors;
    let consoleMessages;

    describe(`should work using ""${appName}"" application and ""${typeof server === ""function"" ? ""custom server"" : server}"" server`, () => {
      beforeEach(async () => {
        compiler = webpack(config);

        devServer = new Server(
          {
            static: {
              directory: staticDirectory,
              watch: false,
            },
            app,
            server,
            port,
            setupMiddlewares:
              typeof setupMiddlewares !== ""undefined""
                ? setupMiddlewares
                : undefined,
          },
          compiler,
        );

        await devServer.start();

        ({ page, browser } = await runBrowser());

        pageErrors = [];
        consoleMessages = [];
      });

      afterEach(async () => {
        await browser.close();
        await devServer.stop();
        await new Promise((resolve) => {
          compiler.close(() => {
            resolve();
          });
        });
      });

      it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const pageUrl = devServer.isTlsServer
          ? `https://localhost:${port}/`
          : `http://localhost:${port}/`;

        const response = await page.goto(pageUrl, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        if (
          server === ""spdy"" ||
          server === ""http2"" ||
          (server.options && server.options.allowHTTP1)
        ) {
          expect(HTTPVersion).toBe(""h2"");
        } else {
          expect(HTTPVersion).toBe(""http/1.1"");
        }

        expect(response.status()).toBe(200);

        const text = await response.text();

        expect(text).toContain(
          '<script type=""text/javascript"" charset=""utf-8"" src=""/main.js""></script>',
        );
        expect(consoleMessages.map((message) => message.text())).toEqual([
          ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
          ""[HMR] Waiting for update signal from WDS..."",
          ""Hey."",
        ]);
        expect(pageErrors).toHaveLength(0);
      });
    });
  }
})",steel
/test/e2e/app.test.js,Conditional Test Logic,"{'line': 168, 'column': 8, 'index': 4542}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const pageUrl = devServer.isTlsServer
          ? `https://localhost:${port}/`
          : `http://localhost:${port}/`;

        const response = await page.goto(pageUrl, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        if (
          server === ""spdy"" ||
          server === ""http2"" ||
          (server.options && server.options.allowHTTP1)
        ) {
          expect(HTTPVersion).toBe(""h2"");
        } else {
          expect(HTTPVersion).toBe(""http/1.1"");
        }

        expect(response.status()).toBe(200);

        const text = await response.text();

        expect(text).toContain(
          '<script type=""text/javascript"" charset=""utf-8"" src=""/main.js""></script>',
        );
        expect(consoleMessages.map((message) => message.text())).toEqual([
          ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
          ""[HMR] Waiting for update signal from WDS..."",
          ""Hey."",
        ]);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/app.test.js,Duplicate Assert,"{'line': 173, 'column': 10, 'index': 4688}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const pageUrl = devServer.isTlsServer
          ? `https://localhost:${port}/`
          : `http://localhost:${port}/`;

        const response = await page.goto(pageUrl, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        if (
          server === ""spdy"" ||
          server === ""http2"" ||
          (server.options && server.options.allowHTTP1)
        ) {
          expect(HTTPVersion).toBe(""h2"");
        } else {
          expect(HTTPVersion).toBe(""http/1.1"");
        }

        expect(response.status()).toBe(200);

        const text = await response.text();

        expect(text).toContain(
          '<script type=""text/javascript"" charset=""utf-8"" src=""/main.js""></script>',
        );
        expect(consoleMessages.map((message) => message.text())).toEqual([
          ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
          ""[HMR] Waiting for update signal from WDS..."",
          ""Hey."",
        ]);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/app.test.js,Duplicate Assert,"{'line': 175, 'column': 10, 'index': 4747}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const pageUrl = devServer.isTlsServer
          ? `https://localhost:${port}/`
          : `http://localhost:${port}/`;

        const response = await page.goto(pageUrl, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        if (
          server === ""spdy"" ||
          server === ""http2"" ||
          (server.options && server.options.allowHTTP1)
        ) {
          expect(HTTPVersion).toBe(""h2"");
        } else {
          expect(HTTPVersion).toBe(""http/1.1"");
        }

        expect(response.status()).toBe(200);

        const text = await response.text();

        expect(text).toContain(
          '<script type=""text/javascript"" charset=""utf-8"" src=""/main.js""></script>',
        );
        expect(consoleMessages.map((message) => message.text())).toEqual([
          ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
          ""[HMR] Waiting for update signal from WDS..."",
          ""Hey."",
        ]);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/app.test.js,Magic Number,"{'line': 178, 'column': 39, 'index': 4835}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const pageUrl = devServer.isTlsServer
          ? `https://localhost:${port}/`
          : `http://localhost:${port}/`;

        const response = await page.goto(pageUrl, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        if (
          server === ""spdy"" ||
          server === ""http2"" ||
          (server.options && server.options.allowHTTP1)
        ) {
          expect(HTTPVersion).toBe(""h2"");
        } else {
          expect(HTTPVersion).toBe(""http/1.1"");
        }

        expect(response.status()).toBe(200);

        const text = await response.text();

        expect(text).toContain(
          '<script type=""text/javascript"" charset=""utf-8"" src=""/main.js""></script>',
        );
        expect(consoleMessages.map((message) => message.text())).toEqual([
          ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
          ""[HMR] Waiting for update signal from WDS..."",
          ""Hey."",
        ]);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/app.test.js,Magic Number,"{'line': 190, 'column': 40, 'index': 5359}","it(""should handle GET request to index route (/)"", async () => {
        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const pageUrl = devServer.isTlsServer
          ? `https://localhost:${port}/`
          : `http://localhost:${port}/`;

        const response = await page.goto(pageUrl, {
          waitUntil: ""networkidle0"",
        });

        const HTTPVersion = await page.evaluate(
          () => performance.getEntries()[0].nextHopProtocol,
        );

        if (
          server === ""spdy"" ||
          server === ""http2"" ||
          (server.options && server.options.allowHTTP1)
        ) {
          expect(HTTPVersion).toBe(""h2"");
        } else {
          expect(HTTPVersion).toBe(""http/1.1"");
        }

        expect(response.status()).toBe(200);

        const text = await response.text();

        expect(text).toContain(
          '<script type=""text/javascript"" charset=""utf-8"" src=""/main.js""></script>',
        );
        expect(consoleMessages.map((message) => message.text())).toEqual([
          ""[webpack-dev-server] Server started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled."",
          ""[HMR] Waiting for update signal from WDS..."",
          ""Hey."",
        ]);
        expect(pageErrors).toHaveLength(0);
      })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 399, 'column': 18, 'index': 10759}","describe(""Server.getFreePort"", () => {
    let dummyServers = [];
    let devServerPort;

    afterEach(() => {
      delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      delete process.env.WEBPACK_DEV_SERVER_PORT_RETRY;

      return dummyServers
        .reduce(
          (p, server) =>
            p.then(
              () =>
                new Promise((resolve) => {
                  server.stopCallback(() => {
                    resolve();
                  });
                }),
            ),
          Promise.resolve(),
        )
        .then(() => {
          dummyServers = [];
        });
    });

    function createDummyServers(n) {
      const basePort = process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000;
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = basePort;

      return (Array.isArray(n) ? n : Array.from({ length: n })).reduce(
        (p, _, i) =>
          p.then(
            () =>
              new Promise((resolve) => {
                devServerPort = basePort + i;
                const compiler = webpack(config);
                const server = new Server(
                  { port: devServerPort, host: ""0.0.0.0"" },
                  compiler,
                );

                dummyServers.push(server);

                server.startCallback((err) => {
                  if (err) {
                    // If we get EACCES, try again with a higher port range
                    if (
                      err.code === ""EACCES"" &&
                      !process.env.WEBPACK_DEV_SERVER_TEST_RETRY
                    ) {
                      process.env.WEBPACK_DEV_SERVER_TEST_RETRY = true;
                      process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT = 40000;
                      // Resolve and let the test restart with the new port range
                      resolve();
                    } else {
                      Promise.reject(err);
                    }
                  } else {
                    resolve();
                  }
                });
              }),
          ),
        Promise.resolve(),
      );
    }

    it(""should return the port when the port is specified"", async () => {
      const retryCount = 1;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      const freePort = await Server.getFreePort(9082);

      expect(freePort).toBe(9082);
    });

    it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    });

    it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    });

    it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    });

    it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    });

    it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    });

    it(""should throw the error when the port isn't found"", async () => {
      expect.assertions(1);

      jest.mock(
        ""../../lib/getPort"",
        () => () => Promise.reject(new Error(""busy"")),
      );

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1;

      try {
        await Server.getFreePort();
      } catch (error) {
        expect(error.message).toMatchSnapshot();
      }
    });
  })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 401, 'column': 20, 'index': 10866}","describe(""Server.getFreePort"", () => {
    let dummyServers = [];
    let devServerPort;

    afterEach(() => {
      delete process.env.WEBPACK_DEV_SERVER_BASE_PORT;
      delete process.env.WEBPACK_DEV_SERVER_PORT_RETRY;

      return dummyServers
        .reduce(
          (p, server) =>
            p.then(
              () =>
                new Promise((resolve) => {
                  server.stopCallback(() => {
                    resolve();
                  });
                }),
            ),
          Promise.resolve(),
        )
        .then(() => {
          dummyServers = [];
        });
    });

    function createDummyServers(n) {
      const basePort = process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000;
      process.env.WEBPACK_DEV_SERVER_BASE_PORT = basePort;

      return (Array.isArray(n) ? n : Array.from({ length: n })).reduce(
        (p, _, i) =>
          p.then(
            () =>
              new Promise((resolve) => {
                devServerPort = basePort + i;
                const compiler = webpack(config);
                const server = new Server(
                  { port: devServerPort, host: ""0.0.0.0"" },
                  compiler,
                );

                dummyServers.push(server);

                server.startCallback((err) => {
                  if (err) {
                    // If we get EACCES, try again with a higher port range
                    if (
                      err.code === ""EACCES"" &&
                      !process.env.WEBPACK_DEV_SERVER_TEST_RETRY
                    ) {
                      process.env.WEBPACK_DEV_SERVER_TEST_RETRY = true;
                      process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT = 40000;
                      // Resolve and let the test restart with the new port range
                      resolve();
                    } else {
                      Promise.reject(err);
                    }
                  } else {
                    resolve();
                  }
                });
              }),
          ),
        Promise.resolve(),
      );
    }

    it(""should return the port when the port is specified"", async () => {
      const retryCount = 1;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      const freePort = await Server.getFreePort(9082);

      expect(freePort).toBe(9082);
    });

    it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    });

    it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    });

    it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    });

    it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    });

    it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    });

    it(""should throw the error when the port isn't found"", async () => {
      expect.assertions(1);

      jest.mock(
        ""../../lib/getPort"",
        () => () => Promise.reject(new Error(""busy"")),
      );

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1;

      try {
        await Server.getFreePort();
      } catch (error) {
        expect(error.message).toMatchSnapshot();
      }
    });
  })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 475, 'column': 10, 'index': 13091}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 484, 'column': 12, 'index': 13423}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 497, 'column': 8, 'index': 13849}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 551, 'column': 10, 'index': 15346}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 560, 'column': 12, 'index': 15678}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 573, 'column': 8, 'index': 16104}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 627, 'column': 10, 'index': 17614}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 636, 'column': 12, 'index': 17946}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 650, 'column': 8, 'index': 18467}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 704, 'column': 10, 'index': 19977}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 713, 'column': 12, 'index': 20309}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 727, 'column': 8, 'index': 20830}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 783, 'column': 10, 'index': 22457}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 792, 'column': 12, 'index': 22789}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 803, 'column': 8, 'index': 23164}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 812, 'column': 10, 'index': 23482}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 864, 'column': 6, 'index': 24790}","it(""should allow access for every requests using an IP"", () => {
      const options = {
        allowedHosts: ""all"",
      };

      const tests = [
        ""192.168.1.123"",
        ""192.168.1.2:8080"",
        ""[::1]"",
        ""[::1]:8080"",
        ""[ad42::1de2:54c2:c2fa:1234]"",
        ""[ad42::1de2:54c2:c2fa:1234]:8080"",
      ];

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      let isValidHost = true;

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          isValidHost = false;
        }
      }

      expect(isValidHost).toBe(true);
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 867, 'column': 8, 'index': 24867}","it(""should allow access for every requests using an IP"", () => {
      const options = {
        allowedHosts: ""all"",
      };

      const tests = [
        ""192.168.1.123"",
        ""192.168.1.2:8080"",
        ""[::1]"",
        ""[::1]:8080"",
        ""[ad42::1de2:54c2:c2fa:1234]"",
        ""[ad42::1de2:54c2:c2fa:1234]:8080"",
      ];

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      let isValidHost = true;

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          isValidHost = false;
        }
      }

      expect(isValidHost).toBe(true);
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 929, 'column': 10, 'index': 26427}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 939, 'column': 14, 'index': 26794}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 957, 'column': 10, 'index': 27398}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 966, 'column': 12, 'index': 27730}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 977, 'column': 8, 'index': 28105}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Conditional Test Logic,"{'line': 986, 'column': 10, 'index': 28423}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Duplicate Assert,"{'line': 41, 'column': 6, 'index': 1031}","it(""should be present"", async () => {
      expect(process.env.WEBPACK_SERVE).toBeUndefined();

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const WebpackDevServer = require(""../../lib/Server"");

      const compiler = webpack(config);
      server = new WebpackDevServer({ port }, compiler);

      await server.start();

      expect(process.env.WEBPACK_SERVE).toBe(""true"");

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/api.test.js,Duplicate Assert,"{'line': 58, 'column': 6, 'index': 1463}","it(""should be present"", async () => {
      expect(process.env.WEBPACK_SERVE).toBeUndefined();

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const WebpackDevServer = require(""../../lib/Server"");

      const compiler = webpack(config);
      server = new WebpackDevServer({ port }, compiler);

      await server.start();

      expect(process.env.WEBPACK_SERVE).toBe(""true"");

      const response = await page.goto(`http://localhost:${port}/`, {
        waitUntil: ""networkidle0"",
      });

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/api.test.js,Eager Test,"{'line': 895, 'column': 38, 'index': 25570}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Eager Test,"{'line': 922, 'column': 8, 'index': 26247}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 83, 'column': 6, 'index': 2159}","it(""should work with async API"", async () => {
      const compiler = webpack(config);
      const server = new Server({ port }, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 121, 'column': 6, 'index': 3142}","it(""should work with callback API"", async () => {
      const compiler = webpack(config);
      const server = new Server({ port }, compiler);

      await new Promise((resolve) => {
        server.startCallback(() => {
          resolve();
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await new Promise((resolve) => {
          server.stopCallback(() => {
            resolve();
          });
        });
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 192, 'column': 6, 'index': 5134}","it(""should work when using configured manually"", async () => {
      const compiler = webpack({
        ...config,
        entry: [
          ""webpack/hot/dev-server.js"",
          `${path.resolve(
            __dirname,
            ""../../client/index.js"",
          )}?hot=true&live-reload=true""`,
          path.resolve(__dirname, ""../fixtures/client-config/foo.js""),
        ],
        plugins: [...config.plugins, new webpack.HotModuleReplacementPlugin()],
      });
      const server = new Server({ port, hot: false, client: false }, compiler);

      await server.start();

      const { page, browser } = await runBrowser();
      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 226, 'column': 6, 'index': 6064}","it(""should work and allow to rerun dev server multiple times"", async () => {
      const compiler = webpack(config);
      const server = new Server({ port }, compiler);

      await server.start();

      const { page: firstPage, browser } = await runBrowser();

      try {
        const firstPageErrors = [];
        const firstConsoleMessages = [];

        firstPage
          .on(""console"", (message) => {
            firstConsoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            firstPageErrors.push(error);
          });

        await firstPage.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          firstConsoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(firstPageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await server.stop();
      }

      await server.start();

      const secondPage = await runBrowser.runPage(browser);

      try {
        const secondPageErrors = [];
        const secondConsoleMessages = [];

        secondPage
          .on(""console"", (message) => {
            secondConsoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            secondPageErrors.push(error);
          });

        await secondPage.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          secondConsoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(secondPageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 254, 'column': 6, 'index': 6817}","it(""should work and allow to rerun dev server multiple times"", async () => {
      const compiler = webpack(config);
      const server = new Server({ port }, compiler);

      await server.start();

      const { page: firstPage, browser } = await runBrowser();

      try {
        const firstPageErrors = [];
        const firstConsoleMessages = [];

        firstPage
          .on(""console"", (message) => {
            firstConsoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            firstPageErrors.push(error);
          });

        await firstPage.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          firstConsoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(firstPageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await server.stop();
      }

      await server.start();

      const secondPage = await runBrowser.runPage(browser);

      try {
        const secondPageErrors = [];
        const secondConsoleMessages = [];

        secondPage
          .on(""console"", (message) => {
            secondConsoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            secondPageErrors.push(error);
          });

        await secondPage.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          secondConsoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(secondPageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 436, 'column': 6, 'index': 11971}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 448, 'column': 8, 'index': 12321}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 492, 'column': 10, 'index': 13743}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 503, 'column': 8, 'index': 14021}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 511, 'column': 6, 'index': 14220}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 524, 'column': 8, 'index': 14576}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 568, 'column': 10, 'index': 15998}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 579, 'column': 8, 'index': 16276}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 588, 'column': 6, 'index': 16498}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 600, 'column': 8, 'index': 16844}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 644, 'column': 10, 'index': 18266}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 656, 'column': 8, 'index': 18639}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 665, 'column': 6, 'index': 18861}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 677, 'column': 8, 'index': 19207}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 721, 'column': 10, 'index': 20629}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 733, 'column': 8, 'index': 21002}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 755, 'column': 6, 'index': 21691}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 767, 'column': 8, 'index': 21973}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 800, 'column': 10, 'index': 23109}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 820, 'column': 8, 'index': 23786}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 836, 'column': 6, 'index': 24138}","it(""should throw the error when the port isn't found"", async () => {
      expect.assertions(1);

      jest.mock(
        ""../../lib/getPort"",
        () => () => Promise.reject(new Error(""busy"")),
      );

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1;

      try {
        await Server.getFreePort();
      } catch (error) {
        expect(error.message).toMatchSnapshot();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 897, 'column': 6, 'index': 25591}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 924, 'column': 8, 'index': 26283}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 930, 'column': 12, 'index': 26485}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 974, 'column': 10, 'index': 28050}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Exception Handling,"{'line': 994, 'column': 8, 'index': 28727}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 81, 'column': 38, 'index': 2138}","it(""should work with async API"", async () => {
      const compiler = webpack(config);
      const server = new Server({ port }, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 119, 'column': 38, 'index': 3121}","it(""should work with callback API"", async () => {
      const compiler = webpack(config);
      const server = new Server({ port }, compiler);

      await new Promise((resolve) => {
        server.startCallback(() => {
          resolve();
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await new Promise((resolve) => {
          server.stopCallback(() => {
            resolve();
          });
        });
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 191, 'column': 38, 'index': 5114}","it(""should work when using configured manually"", async () => {
      const compiler = webpack({
        ...config,
        entry: [
          ""webpack/hot/dev-server.js"",
          `${path.resolve(
            __dirname,
            ""../../client/index.js"",
          )}?hot=true&live-reload=true""`,
          path.resolve(__dirname, ""../fixtures/client-config/foo.js""),
        ],
        plugins: [...config.plugins, new webpack.HotModuleReplacementPlugin()],
      });
      const server = new Server({ port, hot: false, client: false }, compiler);

      await server.start();

      const { page, browser } = await runBrowser();
      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 224, 'column': 49, 'index': 6043}","it(""should work and allow to rerun dev server multiple times"", async () => {
      const compiler = webpack(config);
      const server = new Server({ port }, compiler);

      await server.start();

      const { page: firstPage, browser } = await runBrowser();

      try {
        const firstPageErrors = [];
        const firstConsoleMessages = [];

        firstPage
          .on(""console"", (message) => {
            firstConsoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            firstPageErrors.push(error);
          });

        await firstPage.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          firstConsoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(firstPageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await server.stop();
      }

      await server.start();

      const secondPage = await runBrowser.runPage(browser);

      try {
        const secondPageErrors = [];
        const secondConsoleMessages = [];

        secondPage
          .on(""console"", (message) => {
            secondConsoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            secondPageErrors.push(error);
          });

        await secondPage.goto(`http://localhost:${port}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          secondConsoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(secondPageErrors).toMatchSnapshot(""page errors"");
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 446, 'column': 40, 'index': 12298}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 522, 'column': 40, 'index': 14553}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 598, 'column': 40, 'index': 16821}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 675, 'column': 40, 'index': 19184}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 753, 'column': 38, 'index': 21670}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Lazy Test,"{'line': 895, 'column': 38, 'index': 25570}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Magic Number,"{'line': 429, 'column': 28, 'index': 11787}","it(""should return the port when the port is specified"", async () => {
      const retryCount = 1;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      const freePort = await Server.getFreePort(9082);

      expect(freePort).toBe(9082);
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 485, 'column': 14, 'index': 13474}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 498, 'column': 10, 'index': 13888}","it(""should return the port when the port is `null`"", async () => {
      const retryCount = 2;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort(null);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 561, 'column': 14, 'index': 15729}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 574, 'column': 10, 'index': 16143}","it(""should return the port when the port is undefined"", async () => {
      const retryCount = 3;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;
      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );

        const freePort = await Server.getFreePort(undefined);

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 637, 'column': 14, 'index': 17997}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 651, 'column': 10, 'index': 18506}","it(""should retry finding the port for up to defaultPortRetry times (number)"", async () => {
      const retryCount = 4;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 714, 'column': 14, 'index': 20360}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 728, 'column': 10, 'index': 20869}","it(""should retry finding the port for up to defaultPortRetry times (string)"", async () => {
      const retryCount = 5;

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = retryCount;

      try {
        await createDummyServers(retryCount);
        const basePort = Number.parseInt(
          process.env.WEBPACK_DEV_SERVER_BASE_PORT,
          10,
        );
        const freePort = await Server.getFreePort();

        expect(freePort).toEqual(basePort + retryCount);

        const { page, browser } = await runBrowser();

        try {
          const pageErrors = [];
          const consoleMessages = [];

          page
            .on(""console"", (message) => {
              consoleMessages.push(message);
            })
            .on(""pageerror"", (error) => {
              pageErrors.push(error);
            });

          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        } finally {
          await browser.close();
        }
      } catch (err) {
        // If it's a permission error on the port, mark the test as skipped rather than failed
        if (err.code === ""EACCES"") {
          console.warn(
            `Skipping test due to permission issues: ${err.message}`,
          );
          return;
        }
        throw err;
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 793, 'column': 14, 'index': 22840}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 813, 'column': 12, 'index': 23531}","it(""should retry finding the port when serial ports are busy"", async () => {
      const basePort = Number.parseInt(
        process.env.WEBPACK_DEV_SERVER_TEST_BASE_PORT || 30000,
        10,
      );
      const busyPorts = Array.from({ length: 6 }, (_, i) => basePort + i);

      process.env.WEBPACK_DEV_SERVER_PORT_RETRY = 1000;

      await createDummyServers(busyPorts);

      const freePort = await Server.getFreePort();
      // to use the last port in the busyPorts array
      const lastBusyPort = busyPorts[busyPorts.length - 1];
      expect(freePort).toBeGreaterThan(lastBusyPort);

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        try {
          const response = await page.goto(
            `http://localhost:${devServerPort}/`,
            {
              waitUntil: ""networkidle0"",
            },
          );

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            consoleMessages.map((message) => message.text()),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 967, 'column': 14, 'index': 27781}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/api.test.js,Redundant Print,"{'line': 987, 'column': 12, 'index': 28472}","it('should allow URLs with scheme for checking origin when the ""option.client.webSocketURL"" is object', async () => {
      const options = {
        port,
        client: {
          reconnect: false,
          webSocketURL: {
            hostname: ""test.host"",
          },
        },
        webSocketServer: ""ws"",
      };
      const headers = {
        origin: ""https://test.host"",
      };

      const compiler = webpack(config);
      const server = new Server(options, compiler);

      await server.start();

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        const webSocketRequests = [];
        const session = await page.target().createCDPSession();

        session.on(""Network.webSocketCreated"", (test) => {
          webSocketRequests.push(test);
        });

        await session.send(""Target.setAutoAttach"", {
          autoAttach: true,
          flatten: true,
          waitForDebuggerOnStart: true,
        });

        sessionSubscribe(session);

        try {
          const response = await page.goto(`http://localhost:${port}/`, {
            waitUntil: ""networkidle0"",
          });

          if (!server.isValidHost(headers, ""origin"")) {
            throw new Error(""Validation didn't fail"");
          }

          await new Promise((resolve) => {
            const interval = setInterval(() => {
              const needFinish = consoleMessages.filter((message) =>
                /Trying to reconnect/.test(message.text()),
              );

              if (needFinish.length > 0) {
                clearInterval(interval);
                resolve();
              }
            }, 100);
          });

          expect(webSocketRequests[0].url).toMatchSnapshot(""web socket URL"");

          expect(response.status()).toMatchSnapshot(""response status"");

          expect(
            // net::ERR_NAME_NOT_RESOLVED can be multiple times
            consoleMessages.map((message) => message.text()).slice(0, 7),
          ).toMatchSnapshot(""console messages"");

          expect(pageErrors).toMatchSnapshot(""page errors"");
        } catch (error) {
          if (error.code === ""EACCES"") {
            // Retry mechanism for EACCES errors
            const maxRetries = 3;
            const retryKey = `retry_${expect.getState().currentTestName}`;

            // Get current retry count or initialize to 0
            global[retryKey] ||= 0;
            global[retryKey] += 1;

            if (global[retryKey] < maxRetries) {
              console.warn(
                `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
              );
              // Re-run the current test
              return it.currentTest.fn();
            }
          }
          throw error;
        }
      } catch (error) {
        if (error.code === ""EACCES"") {
          // Retry mechanism for EACCES errors
          const maxRetries = 3;
          const retryKey = `retry_${expect.getState().currentTestName}`;

          // Get current retry count or initialize to 0
          global[retryKey] ||= 0;
          global[retryKey] += 1;

          if (global[retryKey] < maxRetries) {
            console.warn(
              `EACCES error encountered (attempt ${global[retryKey]}/${maxRetries}): ${error.message}. Retrying...`,
            );
            // Re-run the current test
            return it.currentTest.fn();
          }
        }
        throw error;
      } finally {
        await browser.close();
        await server.stop();
      }
    })",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 14, 'column': 2, 'index': 467}","describe(""allowed hosts"", () => {
  for (const webSocketServer of webSocketServers) {
    it(`should connect web socket client using localhost to web socket server with the ""auto"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();
      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using ""localhost"" host to web socket server by default (""${webSocketServer}"")`, async () => {
      const devServerHost = ""localhost"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using ""127.0.0.1"" host to web socket server by default (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using ""127.0.0.1"" host to web socket server with the ""auto"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using ""[::1] host to web socket server with the ""auto"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""::1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://[${devServerHost}]:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://[${proxyHost}]:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using ""0.0.0.0"" host to web socket server with the ""auto"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""0.0.0.0"";
      const IPv4 = Server.findIp(""v4"");
      const devServerPort = port1;
      const proxyHost = IPv4;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${IPv4}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using ""file:"" protocol to web socket server with the ""auto"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""file:///path/to/local/file.js"");
            },
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using ""chrome-extension:"" protocol to web socket server with the ""auto"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            target: `http://${devServerHost}:${devServerPort}`,
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""chrome-extension:///abcdef"");
            },
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using custom hostname to web socket server with the ""all"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""all"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""http://my-test-origin.com/"");
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using custom hostname to web socket server with the ""all"" value in array (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: [""all""],
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""http://my-test-origin.com/"");
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using custom hostname to web socket server with the custom hostname value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""my-test-origin.com"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""http://my-test-origin.com/"");
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using custom hostname to web socket server with the custom hostname value starting with dot (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: "".my-test-origin.com"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""http://my-test-origin.com/"");
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using custom sub hostname to web socket server with the custom hostname value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: "".my-test-origin.com"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(
                ""origin"",
                ""http://foo.bar.baz.my-test-origin.com/"",
              );
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using custom hostname to web socket server with the multiple custom hostname values (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: [""my-test-origin.com""],
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""http://my-test-origin.com/"");
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should connect web socket client using origin header containing an IP address with the custom hostname value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: [""192.168.1.1""],
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""http://192.168.1.1/"");
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""(work) console messages"");
        expect(pageErrors).toMatchSnapshot(""(work) page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should disconnect web socket client using custom hostname from web socket server with the ""auto"" value based on the ""host"" header (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""host"", ""my-test-host"");
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should disconnect web socket client using custom hostname from web socket server with the ""auto"" value based on the ""host"" header when ""server: 'https'"" is enabled (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
            protocol: ""ws"",
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
        server: ""https"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""host"", ""my-test-host"");
            },
            target: `https://${devServerHost}:${devServerPort}`,
            secure: false,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should disconnect web socket client using custom hostname from web socket server with the ""auto"" value based on the ""origin"" header (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""http://my-test-origin.com/"");
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should disconnect web client using localhost to web socket server with the ""auto"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: ""auto"",
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReq: (proxyReq, req, res) => {
              proxyReq.setHeader(""host"", ""unknown"");
              res.setHeader(""host"", devServerHost);
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        const html = await page.content();

        expect(html).toMatchSnapshot(""html"");
        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""console messages"");
        expect(pageErrors).toMatchSnapshot(""page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });

    it(`should disconnect web client using origin header containing an IP address with the ""auto"" value (""${webSocketServer}"")`, async () => {
      const devServerHost = ""127.0.0.1"";
      const devServerPort = port1;
      const proxyHost = devServerHost;
      const proxyPort = port2;

      const compiler = webpack(config);
      const devServerOptions = {
        client: {
          webSocketURL: {
            port: port2,
          },
        },
        webSocketServer,
        port: devServerPort,
        host: devServerHost,
        allowedHosts: [""192.168.1.1""],
      };
      const server = new Server(devServerOptions, compiler);

      await server.start();

      function startProxy(callback) {
        const app = express();

        app.use(
          ""/"",
          createProxyMiddleware({
            // Emulation
            onProxyReqWs: (proxyReq) => {
              proxyReq.setHeader(""origin"", ""http://192.168.0.1/"");
            },
            target: `http://${devServerHost}:${devServerPort}`,
            ws: true,
            changeOrigin: true,
            logLevel: ""warn"",
          }),
        );

        return app.listen(proxyPort, proxyHost, callback);
      }

      const proxy = await new Promise((resolve) => {
        const proxyCreated = startProxy(() => {
          resolve(proxyCreated);
        });
      });

      const { page, browser } = await runBrowser();

      try {
        const pageErrors = [];
        const consoleMessages = [];

        page
          .on(""console"", (message) => {
            consoleMessages.push(message);
          })
          .on(""pageerror"", (error) => {
            pageErrors.push(error);
          });

        await page.goto(`http://${proxyHost}:${proxyPort}/`, {
          waitUntil: ""networkidle0"",
        });

        expect(
          consoleMessages.map((message) => message.text()),
        ).toMatchSnapshot(""(work) console messages"");
        expect(pageErrors).toMatchSnapshot(""(work) page errors"");
      } finally {
        proxy.close();

        await browser.close();
        await server.stop();
      }
    });
  }

  describe(""check host headers"", () => {
    let compiler;
    let server;
    let page;
    let browser;
    let pageErrors;
    let consoleMessages;

    beforeEach(() => {
      compiler = webpack(config);
      pageErrors = [];
      consoleMessages = [];
    });

    afterEach(async () => {
      await browser.close();
      await server.stop();
    });

    it(""should always allow `localhost` if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    });

    it(""should always allow `localhost` subdomain if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""app.localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    });

    it(""should always allow value from the `host` options if options.allowedHosts is auto"", async () => {
      const networkIP = Server.internalIPSync(""v4"");
      const options = {
        host: networkIP,
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: networkIP,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://${networkIP}:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    });

    it(""should always allow value of the `host` option from the `client.webSocketURL` option if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
        client: {
          webSocketURL: ""ws://test.host:80"",
        },
      };

      const headers = {
        host: ""test.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    });

    it(""should always allow any host if options.allowedHosts is all"", async () => {
      const options = {
        allowedHosts: ""all"",
        port: port1,
      };
      const headers = {
        host: ""bad.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    });

    it(""should allow hosts in allowedHosts"", async () => {
      const tests = [""test.host"", ""test2.host"", ""test3.host""];
      const options = {
        allowedHosts: tests,
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    });

    it(""should allow hosts that pass a wildcard in allowedHosts"", async () => {
      const options = {
        allowedHosts: ["".example.com""],
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const tests = [
        ""www.example.com"",
        ""subdomain.example.com"",
        ""example.com"",
        ""subsubcomain.subdomain.example.com"",
        ""example.com:80"",
        ""subdomain.example.com:80"",
      ];

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    });
  });
})",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 1605, 'column': 6, 'index': 43233}","it(""should always allow `localhost` if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 1646, 'column': 6, 'index': 44279}","it(""should always allow `localhost` subdomain if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""app.localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 1689, 'column': 6, 'index': 45408}","it(""should always allow value from the `host` options if options.allowedHosts is auto"", async () => {
      const networkIP = Server.internalIPSync(""v4"");
      const options = {
        host: networkIP,
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: networkIP,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://${networkIP}:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 1733, 'column': 6, 'index': 46567}","it(""should always allow value of the `host` option from the `client.webSocketURL` option if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
        client: {
          webSocketURL: ""ws://test.host:80"",
        },
      };

      const headers = {
        host: ""test.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 1773, 'column': 6, 'index': 47592}","it(""should always allow any host if options.allowedHosts is all"", async () => {
      const options = {
        allowedHosts: ""all"",
        port: port1,
      };
      const headers = {
        host: ""bad.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 1811, 'column': 6, 'index': 48596}","it(""should allow hosts in allowedHosts"", async () => {
      const tests = [""test.host"", ""test2.host"", ""test3.host""];
      const options = {
        allowedHosts: tests,
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 1814, 'column': 8, 'index': 48673}","it(""should allow hosts in allowedHosts"", async () => {
      const tests = [""test.host"", ""test2.host"", ""test3.host""];
      const options = {
        allowedHosts: tests,
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 1861, 'column': 6, 'index': 49881}","it(""should allow hosts that pass a wildcard in allowedHosts"", async () => {
      const options = {
        allowedHosts: ["".example.com""],
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const tests = [
        ""www.example.com"",
        ""subdomain.example.com"",
        ""example.com"",
        ""subsubcomain.subdomain.example.com"",
        ""example.com:80"",
        ""subdomain.example.com:80"",
      ];

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Conditional Test Logic,"{'line': 1864, 'column': 8, 'index': 49958}","it(""should allow hosts that pass a wildcard in allowedHosts"", async () => {
      const options = {
        allowedHosts: ["".example.com""],
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const tests = [
        ""www.example.com"",
        ""subdomain.example.com"",
        ""example.com"",
        ""subsubcomain.subdomain.example.com"",
        ""example.com:80"",
        ""subdomain.example.com:80"",
      ];

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Exception Handling,"{'line': 1606, 'column': 8, 'index': 43285}","it(""should always allow `localhost` if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Exception Handling,"{'line': 1647, 'column': 8, 'index': 44331}","it(""should always allow `localhost` subdomain if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""app.localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Exception Handling,"{'line': 1690, 'column': 8, 'index': 45460}","it(""should always allow value from the `host` options if options.allowedHosts is auto"", async () => {
      const networkIP = Server.internalIPSync(""v4"");
      const options = {
        host: networkIP,
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: networkIP,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://${networkIP}:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Exception Handling,"{'line': 1734, 'column': 8, 'index': 46619}","it(""should always allow value of the `host` option from the `client.webSocketURL` option if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
        client: {
          webSocketURL: ""ws://test.host:80"",
        },
      };

      const headers = {
        host: ""test.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Exception Handling,"{'line': 1774, 'column': 8, 'index': 47644}","it(""should always allow any host if options.allowedHosts is all"", async () => {
      const options = {
        allowedHosts: ""all"",
        port: port1,
      };
      const headers = {
        host: ""bad.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Exception Handling,"{'line': 1815, 'column': 10, 'index': 48727}","it(""should allow hosts in allowedHosts"", async () => {
      const tests = [""test.host"", ""test2.host"", ""test3.host""];
      const options = {
        allowedHosts: tests,
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Exception Handling,"{'line': 1865, 'column': 10, 'index': 50012}","it(""should allow hosts that pass a wildcard in allowedHosts"", async () => {
      const options = {
        allowedHosts: ["".example.com""],
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const tests = [
        ""www.example.com"",
        ""subdomain.example.com"",
        ""example.com"",
        ""subsubcomain.subdomain.example.com"",
        ""example.com:80"",
        ""subdomain.example.com:80"",
      ];

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Lazy Test,"{'line': 1591, 'column': 33, 'index': 42901}","it(""should always allow `localhost` if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Lazy Test,"{'line': 1632, 'column': 33, 'index': 43947}","it(""should always allow `localhost` subdomain if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: ""app.localhost"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Lazy Test,"{'line': 1675, 'column': 33, 'index': 45073}","it(""should always allow value from the `host` options if options.allowedHosts is auto"", async () => {
      const networkIP = Server.internalIPSync(""v4"");
      const options = {
        host: networkIP,
        allowedHosts: ""auto"",
        port: port1,
      };

      const headers = {
        host: networkIP,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://${networkIP}:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Lazy Test,"{'line': 1719, 'column': 33, 'index': 46235}","it(""should always allow value of the `host` option from the `client.webSocketURL` option if options.allowedHosts is auto"", async () => {
      const options = {
        allowedHosts: ""auto"",
        port: port1,
        client: {
          webSocketURL: ""ws://test.host:80"",
        },
      };

      const headers = {
        host: ""test.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Lazy Test,"{'line': 1759, 'column': 33, 'index': 47260}","it(""should always allow any host if options.allowedHosts is all"", async () => {
      const options = {
        allowedHosts: ""all"",
        port: port1,
      };
      const headers = {
        host: ""bad.host"",
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      if (!server.isValidHost(headers, ""host"")) {
        throw new Error(""Validation didn't fail"");
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Lazy Test,"{'line': 1797, 'column': 33, 'index': 48264}","it(""should allow hosts in allowedHosts"", async () => {
      const tests = [""test.host"", ""test2.host"", ""test3.host""];
      const options = {
        allowedHosts: tests,
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/e2e/allowed-hosts.test.js,Lazy Test,"{'line': 1838, 'column': 33, 'index': 49326}","it(""should allow hosts that pass a wildcard in allowedHosts"", async () => {
      const options = {
        allowedHosts: ["".example.com""],
        port: port1,
      };

      server = new Server(options, compiler);

      await server.start();

      ({ page, browser } = await runBrowser());

      page
        .on(""console"", (message) => {
          consoleMessages.push(message);
        })
        .on(""pageerror"", (error) => {
          pageErrors.push(error);
        });

      const response = await page.goto(`http://127.0.0.1:${port1}/main.js`, {
        waitUntil: ""networkidle0"",
      });

      const tests = [
        ""www.example.com"",
        ""subdomain.example.com"",
        ""example.com"",
        ""subsubcomain.subdomain.example.com"",
        ""example.com:80"",
        ""subdomain.example.com:80"",
      ];

      for (const test of tests) {
        const headers = { host: test };

        if (!server.isValidHost(headers, ""host"")) {
          throw new Error(""Validation didn't fail"");
        }
      }

      expect(response.status()).toMatchSnapshot(""response status"");

      expect(consoleMessages.map((message) => message.text())).toMatchSnapshot(
        ""console messages"",
      );

      expect(pageErrors).toMatchSnapshot(""page errors"");
    })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2057}","it(""should run onSocketMessage['still-ok']"", () => {
    onSocketMessage[""still-ok""]();

    expect(log.log.info.mock.calls[1][0]).toMatchSnapshot();
    expect(sendMessage.mock.calls[0][0]).toMatchSnapshot();
    expect(overlay.send).not.toHaveBeenCalledWith({ type: ""DISMISS"" });

    // change flags
    onSocketMessage.overlay(true);
    onSocketMessage[""still-ok""]();

    expect(overlay.send).toHaveBeenCalledWith({ type: ""DISMISS"" });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 89, 'column': 4, 'index': 2221}","it(""should run onSocketMessage['still-ok']"", () => {
    onSocketMessage[""still-ok""]();

    expect(log.log.info.mock.calls[1][0]).toMatchSnapshot();
    expect(sendMessage.mock.calls[0][0]).toMatchSnapshot();
    expect(overlay.send).not.toHaveBeenCalledWith({ type: ""DISMISS"" });

    // change flags
    onSocketMessage.overlay(true);
    onSocketMessage[""still-ok""]();

    expect(overlay.send).toHaveBeenCalledWith({ type: ""DISMISS"" });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 168, 'column': 4, 'index': 4548}","it(""should run onSocketMessage.warnings"", () => {
    onSocketMessage.warnings([""warn1"", ""\u001B[4mwarn2\u001B[0m"", ""warn3""]);

    expect(log.log.warn.mock.calls[0][0]).toMatchSnapshot();
    expect(sendMessage.mock.calls[0][0]).toMatchSnapshot();
    expect(log.log.warn.mock.calls.splice(1)).toMatchSnapshot();

    // change flags
    onSocketMessage.overlay({ warnings: true });
    onSocketMessage.warnings([""warning message""]);

    expect(overlay.send).toHaveBeenCalledTimes(1);
    expect(overlay.send).toHaveBeenCalledWith({
      type: ""BUILD_ERROR"",
      level: ""warning"",
      messages: [""warning message""],
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 169, 'column': 4, 'index': 4599}","it(""should run onSocketMessage.warnings"", () => {
    onSocketMessage.warnings([""warn1"", ""\u001B[4mwarn2\u001B[0m"", ""warn3""]);

    expect(log.log.warn.mock.calls[0][0]).toMatchSnapshot();
    expect(sendMessage.mock.calls[0][0]).toMatchSnapshot();
    expect(log.log.warn.mock.calls.splice(1)).toMatchSnapshot();

    // change flags
    onSocketMessage.overlay({ warnings: true });
    onSocketMessage.warnings([""warning message""]);

    expect(overlay.send).toHaveBeenCalledTimes(1);
    expect(overlay.send).toHaveBeenCalledWith({
      type: ""BUILD_ERROR"",
      level: ""warning"",
      messages: [""warning message""],
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 188, 'column': 6, 'index': 5193}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 188, 'column': 6, 'index': 5193}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 191, 'column': 6, 'index': 5287}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 192, 'column': 6, 'index': 5340}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 210, 'column': 6, 'index': 5863}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 210, 'column': 6, 'index': 5863}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 213, 'column': 6, 'index': 5958}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 214, 'column': 6, 'index': 6011}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 230, 'column': 6, 'index': 6462}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 231, 'column': 6, 'index': 6515}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 238, 'column': 6, 'index': 6706}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/index.test.js,Duplicate Assert,"{'line': 239, 'column': 6, 'index': 6759}","it(""should parse overlay options from resource query"", () => {
    jest.isolateModules(() => {
      // Pass JSON config with warnings disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""warnings"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error1""],
      });
    });

    jest.isolateModules(() => {
      // Pass JSON config with errors disabled
      globalThis.__resourceQuery = `?overlay=${encodeURIComponent(
        '{""errors"": false}',
      )}`;
      overlay.send.mockReset();
      socket.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.errors([""error1""]);
      expect(overlay.send).not.toHaveBeenCalled();

      onSocketMessage.warnings([""warn1""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn1""],
      });
    });

    jest.isolateModules(() => {
      // Use simple boolean
      globalThis.__resourceQuery = ""?overlay=true"";
      socket.mockReset();
      overlay.send.mockReset();
      require(""../../client-src"");
      [[, onSocketMessage]] = socket.mock.calls;

      onSocketMessage.warnings([""warn2""]);
      expect(overlay.send).toHaveBeenCalledTimes(1);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""warning"",
        messages: [""warn2""],
      });

      onSocketMessage.errors([""error2""]);
      expect(overlay.send).toHaveBeenCalledTimes(2);
      expect(overlay.send).toHaveBeenLastCalledWith({
        type: ""BUILD_ERROR"",
        level: ""error"",
        messages: [""error2""],
      });
    });
  })",steel
/test/client/bundle.test.js,Conditional Test Logic,"{'line': 52, 'column': 12, 'index': 1494}","it(""should get full user bundle and parse with ES5"", async () => {
      const { text } = await req
        .get(""/main.js"")
        .expect(""Content-Type"", ""text/javascript; charset=utf-8"")
        .expect(200);

      expect(() => {
        let evalStep = 0;

        acorn.parse(text, {
          ecmaVersion: 5,
          onToken: (token) => {
            // a webpack bundle is a series of evaluated JavaScript
            // strings like this: eval('...')
            // if we want the bundle to work using ES5, we need to
            // check that these strings are good with ES5 as well

            // this can be done by waiting for tokens during the main parse
            // then when we hit a string in an 'eval' function we also try
            // to parse that string with ES5
            if (token.type.label === ""name"" && token.value === ""eval"") {
              evalStep += 1;
            } else if (token.type.label === ""("" && evalStep === 1) {
              evalStep += 1;
            } else if (token.type.label === ""string"" && evalStep === 2) {
              const program = token.value;
              acorn.parse(program, {
                ecmaVersion: 5,
              });

              evalStep = 0;
            }
          },
        });
      }).not.toThrow();
    })",steel
/test/client/bundle.test.js,Conditional Test Logic,"{'line': 54, 'column': 19, 'index': 1603}","it(""should get full user bundle and parse with ES5"", async () => {
      const { text } = await req
        .get(""/main.js"")
        .expect(""Content-Type"", ""text/javascript; charset=utf-8"")
        .expect(200);

      expect(() => {
        let evalStep = 0;

        acorn.parse(text, {
          ecmaVersion: 5,
          onToken: (token) => {
            // a webpack bundle is a series of evaluated JavaScript
            // strings like this: eval('...')
            // if we want the bundle to work using ES5, we need to
            // check that these strings are good with ES5 as well

            // this can be done by waiting for tokens during the main parse
            // then when we hit a string in an 'eval' function we also try
            // to parse that string with ES5
            if (token.type.label === ""name"" && token.value === ""eval"") {
              evalStep += 1;
            } else if (token.type.label === ""("" && evalStep === 1) {
              evalStep += 1;
            } else if (token.type.label === ""string"" && evalStep === 2) {
              const program = token.value;
              acorn.parse(program, {
                ecmaVersion: 5,
              });

              evalStep = 0;
            }
          },
        });
      }).not.toThrow();
    })",steel
/test/client/bundle.test.js,Conditional Test Logic,"{'line': 56, 'column': 19, 'index': 1701}","it(""should get full user bundle and parse with ES5"", async () => {
      const { text } = await req
        .get(""/main.js"")
        .expect(""Content-Type"", ""text/javascript; charset=utf-8"")
        .expect(200);

      expect(() => {
        let evalStep = 0;

        acorn.parse(text, {
          ecmaVersion: 5,
          onToken: (token) => {
            // a webpack bundle is a series of evaluated JavaScript
            // strings like this: eval('...')
            // if we want the bundle to work using ES5, we need to
            // check that these strings are good with ES5 as well

            // this can be done by waiting for tokens during the main parse
            // then when we hit a string in an 'eval' function we also try
            // to parse that string with ES5
            if (token.type.label === ""name"" && token.value === ""eval"") {
              evalStep += 1;
            } else if (token.type.label === ""("" && evalStep === 1) {
              evalStep += 1;
            } else if (token.type.label === ""string"" && evalStep === 2) {
              const program = token.value;
              acorn.parse(program, {
                ecmaVersion: 5,
              });

              evalStep = 0;
            }
          },
        });
      }).not.toThrow();
    })",steel
/test/client/ReactErrorBoundary.test.js,Lazy Test,"{'line': 47, 'column': 20, 'index': 1323}","it(""should not show overlay for errors caught by React error boundaries"", () => {
    const options = { trustedTypesPolicyName: null, catchRuntimeError: true };
    const overlay = createOverlay(options);
    const showOverlayMock = jest.spyOn(overlay, ""send"");

    const reactError = new Error(
      ""Error inside React render\n"" +
        ""    at Boom (webpack:///./src/index.jsx?:41:11)\n"" +
        ""    at renderWithHooks (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:16305:18)\n"" +
        ""    at mountIndeterminateComponent (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:20069:13)\n"" +
        ""    at beginWork (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:21582:16)\n"" +
        ""    at HTMLUnknownElement.callCallback (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:4164:14)\n"" +
        ""    at Object.invokeGuardedCallbackDev (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:4213:16)\n"" +
        ""    at invokeGuardedCallback (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:4277:31)\n"" +
        ""    at beginWork$1 (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:27446:7)\n"" +
        ""    at performUnitOfWork (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:26555:12)\n"" +
        ""    at workLoopSync (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:26461:5)"",
    );
    reactError._suppressLogging = true;

    const errorEvent = new ErrorEvent(""error"", {
      error: reactError,
      message: reactError.message,
    });
    globalThis.dispatchEvent(errorEvent);

    expect(showOverlayMock).not.toHaveBeenCalled();
    showOverlayMock.mockRestore();
  })",steel
/test/client/ReactErrorBoundary.test.js,Lazy Test,"{'line': 77, 'column': 20, 'index': 3060}","it(""should show overlay for normal uncaught errors"", () => {
    const options = { trustedTypesPolicyName: null, catchRuntimeError: true };
    const overlay = createOverlay(options);
    const showOverlayMock = jest.spyOn(overlay, ""send"");

    const regularError = new Error(
      ""Error inside React render\n"" +
        ""    at Boom (webpack:///./src/index.jsx?:41:11)\n"" +
        ""    at renderWithHooks (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:16305:18)\n"" +
        ""    at mountIndeterminateComponent (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:20069:13)\n"" +
        ""    at beginWork (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:21582:16)\n"" +
        ""    at HTMLUnknownElement.callCallback (webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:4164:14)\n"",
    );

    const errorEvent = new ErrorEvent(""error"", {
      error: regularError,
      message: ""Regular test error message"",
    });
    globalThis.dispatchEvent(errorEvent);

    expect(showOverlayMock).toHaveBeenCalledWith({
      type: ""RUNTIME_ERROR"",
      messages: [
        {
          message: regularError.message,
          stack: expect.anything(),
        },
      ],
    });
    showOverlayMock.mockRestore();
  })",steel
/test/client/ReactErrorBoundary.test.js,Lazy Test,"{'line': 109, 'column': 20, 'index': 4373}","it(""should show overlay for normal uncaught errors (when null is thrown)"", () => {
    const options = { trustedTypesPolicyName: null, catchRuntimeError: true };
    const overlay = createOverlay(options);
    const showOverlayMock = jest.spyOn(overlay, ""send"");

    const errorEvent = new ErrorEvent(""error"", {
      error: null,
      message: ""error"",
    });
    globalThis.dispatchEvent(errorEvent);

    expect(showOverlayMock).toHaveBeenCalledWith({
      type: ""RUNTIME_ERROR"",
      messages: [
        {
          message: ""error"",
          stack: expect.anything(),
        },
      ],
    });
    showOverlayMock.mockRestore();
  })",steel
/test/client/ReactErrorBoundary.test.js,Lazy Test,"{'line': 135, 'column': 20, 'index': 5079}","it(""should show overlay for normal uncaught errors when catchRuntimeError is a function that return true"", () => {
    const options = {
      trustedTypesPolicyName: null,
      catchRuntimeError: () => true,
    };
    const overlay = createOverlay(options);
    const showOverlayMock = jest.spyOn(overlay, ""send"");

    const regularError = new Error(""Regular test error"");
    const errorEvent = new ErrorEvent(""error"", {
      error: regularError,
      message: ""Regular test error message"",
    });
    globalThis.dispatchEvent(errorEvent);

    expect(showOverlayMock).toHaveBeenCalledWith({
      type: ""RUNTIME_ERROR"",
      messages: [
        {
          message: regularError.message,
          stack: expect.anything(),
        },
      ],
    });
    showOverlayMock.mockRestore();
  })",steel
/test/client/ReactErrorBoundary.test.js,Lazy Test,"{'line': 162, 'column': 20, 'index': 5891}","it(""should not show overlay for normal uncaught errors when catchRuntimeError is a function that return false"", () => {
    const options = {
      trustedTypesPolicyName: null,
      catchRuntimeError: () => false,
    };
    const overlay = createOverlay(options);
    const showOverlayMock = jest.spyOn(overlay, ""send"");

    const regularError = new Error(""Regular test error"");
    const errorEvent = new ErrorEvent(""error"", {
      error: regularError,
      message: ""Regular test error message"",
    });
    globalThis.dispatchEvent(errorEvent);

    expect(showOverlayMock).not.toHaveBeenCalled();
    showOverlayMock.mockRestore();
  })",steel
/test/client/ReactErrorBoundary.test.js,Lazy Test,"{'line': 178, 'column': 20, 'index': 6500}","it(""should not show the overlay for errors with stack containing 'invokeGuardedCallbackDev'"", () => {
    const options = { trustedTypesPolicyName: null, catchRuntimeError: true };
    const overlay = createOverlay(options);
    const showOverlayMock = jest.spyOn(overlay, ""send"");

    const reactInternalError = new Error(""React internal error"");
    reactInternalError.stack = ""invokeGuardedCallbackDev\n at somefile.js"";
    const errorEvent = new ErrorEvent(""error"", {
      error: reactInternalError,
      message: ""React internal error"",
    });
    globalThis.dispatchEvent(errorEvent);

    expect(showOverlayMock).not.toHaveBeenCalled();
    showOverlayMock.mockRestore();
  })",steel
/test/client/ReactErrorBoundary.test.js,Lazy Test,"{'line': 195, 'column': 20, 'index': 7150}","it(""should show overlay for unhandled rejections"", () => {
    const options = { trustedTypesPolicyName: null, catchRuntimeError: true };
    const overlay = createOverlay(options);
    const showOverlayMock = jest.spyOn(overlay, ""send"");

    const rejectionReason = new Error(""Promise rejection reason"");
    const rejectionEvent = new Event(""unhandledrejection"");
    rejectionEvent.reason = rejectionReason;

    globalThis.dispatchEvent(rejectionEvent);

    expect(showOverlayMock).toHaveBeenCalledWith({
      type: ""RUNTIME_ERROR"",
      messages: [
        {
          message: rejectionReason.message,
          stack: expect.anything(),
        },
      ],
    });
    showOverlayMock.mockRestore();
  })",steel
/test/client/ReactErrorBoundary.test.js,Lazy Test,"{'line': 218, 'column': 20, 'index': 7889}","it(""should show overlay for unhandled rejections with string reason"", () => {
    const options = { trustedTypesPolicyName: null, catchRuntimeError: true };
    const overlay = createOverlay(options);
    const showOverlayMock = jest.spyOn(overlay, ""send"");
    const rejectionEvent = new Event(""unhandledrejection"");
    rejectionEvent.reason = ""some reason"";
    globalThis.dispatchEvent(rejectionEvent);

    expect(showOverlayMock).toHaveBeenCalledWith({
      type: ""RUNTIME_ERROR"",
      messages: [
        {
          message: ""some reason"",
          stack: expect.anything(),
        },
      ],
    });
    showOverlayMock.mockRestore();
  })",steel
/test/client/utils/log.test.js,Conditional Test Logic,"{'line': 40, 'column': 4, 'index': 988}","it(""should set log level via setLogLevel"", () => {
    for (const level of [""none"", ""error"", ""warn"", ""info"", ""log"", ""verbose""]) {
      setLogLevel(level);
    }

    expect(logMock.configureDefaultLogger.mock.calls).toMatchSnapshot();
  })",steel
/test/client/utils/getCurrentScriptSource.test.js,Exception Handling,"{'line': 30, 'column': 4, 'index': 703}","it(""should fail when 'document.currentScript' doesn't exist and no 'script' tags"", () => {
    try {
      getCurrentScriptSource();
    } catch (error) {
      expect(error).toMatchSnapshot();
    }
  })",steel
/test/client/utils/getCurrentScriptSource.test.js,Exception Handling,"{'line': 55, 'column': 4, 'index': 1302}","it(""should fail when 'document.scripts' doesn't exist and no scripts"", () => {
    Object.defineProperty(document, ""scripts"", {
      value: undefined,
      writable: true,
    });

    try {
      getCurrentScriptSource();
    } catch (error) {
      expect(error).toMatchSnapshot();
    }
  })",steel
/test/client/utils/getCurrentScriptSource.test.js,Exception Handling,"{'line': 85, 'column': 4, 'index': 2043}","it(""should fail when no scripts with the 'scr' attribute"", () => {
    const elements = [""foo"", ""bar""].map(() => document.createElement(""script""));

    Object.defineProperty(document, ""scripts"", {
      value: elements,
    });

    try {
      getCurrentScriptSource();
    } catch (error) {
      expect(error).toMatchSnapshot();
    }
  })",steel
/test/client/utils/createSocketURL.test.js,Conditional Test Logic,"{'line': 107, 'column': 2, 'index': 3850}","describe(""'createSocketURL' function"", () => {
  globalThis.__webpack_hash__ = ""hash"";

  const samples = [
    // // __resourceQuery, location and socket URL
    [
      ""?hostname=example.com&pathname=/ws"",
      ""http://example.com"",
      ""ws://example.com/ws"",
    ],
    [""?protocol=auto:"", ""http://example.com"", ""ws://example.com/ws""],
    [""?protocol=auto:"", ""https://example.com"", ""wss://example.com/ws""],
    [""?protocol=wss:"", ""http://example.com"", ""wss://example.com/ws""],
    [""?protocol=https:"", ""https://example.com"", ""wss://example.com/ws""],
    [""?protocol=http:"", ""https://example.com"", ""ws://example.com/ws""],
    [""?hostname=example.com"", ""http://example.com"", ""ws://example.com/ws""],
    [
      ""?username=username&password=password"",
      ""http://example.com"",
      ""ws://username:password@example.com/ws"",
    ],
    [
      ""?hostname=example.com&port=80"",
      ""http://example.com"",
      ""ws://example.com:80/ws"",
    ],
    [""?port=0"", ""http://example.com:8080"", ""ws://example.com:8080/ws""],
    [""?port=80"", ""http://example.com:8080"", ""ws://example.com:80/ws""],
    [""?hostname=0.0.0.0"", ""http://127.0.0.1"", ""ws://127.0.0.1/ws""],
    [""?hostname=0.0.0.0"", ""http://192.168.0.1"", ""ws://192.168.0.1/ws""],
    [""?hostname=0.0.0.0"", ""https://192.168.0.1"", ""wss://192.168.0.1/ws""],
    [""?hostname=0.0.0.0"", ""https://example.com"", ""wss://example.com/ws""],
    [
      ""?hostname=0.0.0.0"",
      ""http://example.com:8080"",
      ""ws://example.com:8080/ws"",
    ],
    [
      ""?hostname=0.0.0.0"",
      ""http://example.com:8080"",
      ""ws://example.com:8080/ws"",
    ],
    [
      ""?hostname=0.0.0.0"",
      ""https://example.com:8080"",
      ""wss://example.com:8080/ws"",
    ],
    [""?hostname=::"", ""http://example.com:8080"", ""ws://example.com:8080/ws""],
    [""?hostname=[::]"", ""http://example.com:8080"", ""ws://example.com:8080/ws""],
    [""?hostname=[::]"", ""http://example.com:8080"", ""ws://example.com:8080/ws""],

    [""?hostname=%3A%3A"", ""http://example.com:8080"", ""ws://example.com:8080/ws""],
    [""?hostname=%3A%3A1"", ""http://example.com:8080"", ""ws://[::1]:8080/ws""],
    [""?hostname=%3A%3A1"", ""https://example.com:8080"", ""wss://[::1]:8080/ws""],
    [
      ""?hostname=%3A%3A"",
      ""https://example.com:8080"",
      ""wss://example.com:8080/ws"",
    ],
    [
      ""?hostname=%3A%3A"",
      ""https://example.com:8080"",
      ""wss://example.com:8080/ws"",
    ],
    [
      ""?pathname=/custom-ws"",
      ""http://example.com"",
      ""ws://example.com/custom-ws"",
    ],
    [
      ""?protocol=wss:&username=user&password=password&hostname=localhost&port=8080&pathname=/ws"",
      ""http://user:password@localhost/"",
      ""wss://user:password@localhost:8080/ws"",
    ],
    [null, ""http://example.com"", ""ws://example.com/ws""],
    [null, ""https://example.com"", ""wss://example.com/ws""],
    [null, ""http://example.com:8080"", ""ws://example.com:8080/ws""],
    [null, ""http://example.com/foo/bar"", ""ws://example.com/ws""],
    [
      null,
      ""http://user:password@localhost/"",
      ""ws://user:password@localhost/ws"",
    ],
    [null, ""http://user@localhost:8080/"", ""ws://user@localhost:8080/ws""],
    [
      null,
      ""http://user:password@localhost:8080/"",
      ""ws://user:password@localhost:8080/ws"",
    ],
    [null, ""https://localhost:8080"", ""wss://localhost:8080/ws""],
    [null, ""http://127.0.0.1"", ""ws://127.0.0.1/ws""],
    [null, ""http://127.0.0.1:8080"", ""ws://127.0.0.1:8080/ws""],
    [null, ""https://127.0.0.1"", ""wss://127.0.0.1/ws""],
    [null, ""http://[::1]:8080/ws"", ""ws://[::1]:8080/ws""],
    [null, ""https://[::1]:8080/ws"", ""wss://[::1]:8080/ws""],
    [null, ""file:///home/user/project/index.html"", ""ws://localhost/ws""],
    [null, ""chrome-extension://localhost/"", ""ws://localhost/ws""],
    [null, ""file://localhost/"", ""ws://localhost/ws""],
  ];

  for (const [__resourceQuery, location, expected] of samples) {
    it(`should return '${expected}' socket URL when '__resourceQuery' is '${__resourceQuery}' and 'self.location' is '${location}'`, () => {
      globalThis.__resourceQuery = __resourceQuery;

      if (__resourceQuery === null) {
        Object.defineProperty(document, ""currentScript"", {
          value: document.createElement(""script""),
          configurable: true,
        });
      }

      const client = require(""../../../client-src/index"");

      const { createSocketURL } = client;
      const { parseURL } = client;

      const selfLocation = new URL(location);

      delete globalThis.location;

      globalThis.location = selfLocation;

      const parsedURL = parseURL(__resourceQuery);

      if (__resourceQuery === null) {
        Object.defineProperty(document, ""currentScript"", {
          value: null,
          configurable: true,
        });
      }

      expect(createSocketURL(parsedURL)).toBe(expected);
    });

    jest.resetModules();
  }
})",steel
/test/client/utils/createSocketURL.test.js,Conditional Test Logic,"{'line': 111, 'column': 6, 'index': 4113}","it(`should return '${expected}' socket URL when '__resourceQuery' is '${__resourceQuery}' and 'self.location' is '${location}'`, () => {
      globalThis.__resourceQuery = __resourceQuery;

      if (__resourceQuery === null) {
        Object.defineProperty(document, ""currentScript"", {
          value: document.createElement(""script""),
          configurable: true,
        });
      }

      const client = require(""../../../client-src/index"");

      const { createSocketURL } = client;
      const { parseURL } = client;

      const selfLocation = new URL(location);

      delete globalThis.location;

      globalThis.location = selfLocation;

      const parsedURL = parseURL(__resourceQuery);

      if (__resourceQuery === null) {
        Object.defineProperty(document, ""currentScript"", {
          value: null,
          configurable: true,
        });
      }

      expect(createSocketURL(parsedURL)).toBe(expected);
    })",steel
/test/client/utils/createSocketURL.test.js,Conditional Test Logic,"{'line': 131, 'column': 6, 'index': 4627}","it(`should return '${expected}' socket URL when '__resourceQuery' is '${__resourceQuery}' and 'self.location' is '${location}'`, () => {
      globalThis.__resourceQuery = __resourceQuery;

      if (__resourceQuery === null) {
        Object.defineProperty(document, ""currentScript"", {
          value: document.createElement(""script""),
          configurable: true,
        });
      }

      const client = require(""../../../client-src/index"");

      const { createSocketURL } = client;
      const { parseURL } = client;

      const selfLocation = new URL(location);

      delete globalThis.location;

      globalThis.location = selfLocation;

      const parsedURL = parseURL(__resourceQuery);

      if (__resourceQuery === null) {
        Object.defineProperty(document, ""currentScript"", {
          value: null,
          configurable: true,
        });
      }

      expect(createSocketURL(parsedURL)).toBe(expected);
    })",steel
/test/client/clients/WebsocketClient.test.js,Magic Number,"{'line': 68, 'column': 48, 'index': 1600}","it(""should open, receive message, and close"", (done) => {
      socketServer.on(""connection"", (connection) => {
        connection.send(""hello world"");

        setTimeout(() => {
          connection.close();
        }, 1000);
      });

      const client = new WebSocketClient(`ws://localhost:${port}/ws-server`);
      const data = [];

      client.onOpen(() => {
        data.push(""open"");
      });
      client.onClose(() => {
        data.push(""close"");
      });
      client.onMessage((msg) => {
        data.push(msg);
      });

      const testError = new Error(""test"");

      client.client.onerror(testError);

      expect(log.error.mock.calls).toHaveLength(1);
      expect(log.error.mock.calls[0]).toEqual([testError]);

      setTimeout(() => {
        expect(data).toMatchSnapshot();

        done();
      }, 3000);
    })",steel
/test/client/clients/WebsocketClient.test.js,Sleepy Test,"{'line': 46, 'column': 8, 'index': 1086}","it(""should open, receive message, and close"", (done) => {
      socketServer.on(""connection"", (connection) => {
        connection.send(""hello world"");

        setTimeout(() => {
          connection.close();
        }, 1000);
      });

      const client = new WebSocketClient(`ws://localhost:${port}/ws-server`);
      const data = [];

      client.onOpen(() => {
        data.push(""open"");
      });
      client.onClose(() => {
        data.push(""close"");
      });
      client.onMessage((msg) => {
        data.push(msg);
      });

      const testError = new Error(""test"");

      client.client.onerror(testError);

      expect(log.error.mock.calls).toHaveLength(1);
      expect(log.error.mock.calls[0]).toEqual([testError]);

      setTimeout(() => {
        expect(data).toMatchSnapshot();

        done();
      }, 3000);
    })",steel
/test/client/clients/WebsocketClient.test.js,Sleepy Test,"{'line': 71, 'column': 6, 'index': 1671}","it(""should open, receive message, and close"", (done) => {
      socketServer.on(""connection"", (connection) => {
        connection.send(""hello world"");

        setTimeout(() => {
          connection.close();
        }, 1000);
      });

      const client = new WebSocketClient(`ws://localhost:${port}/ws-server`);
      const data = [];

      client.onOpen(() => {
        data.push(""open"");
      });
      client.onClose(() => {
        data.push(""close"");
      });
      client.onMessage((msg) => {
        data.push(msg);
      });

      const testError = new Error(""test"");

      client.client.onerror(testError);

      expect(log.error.mock.calls).toHaveLength(1);
      expect(log.error.mock.calls[0]).toEqual([testError]);

      setTimeout(() => {
        expect(data).toMatchSnapshot();

        done();
      }, 3000);
    })",steel
/test/client/clients/SockJSClient.test.js,Magic Number,"{'line': 77, 'column': 48, 'index': 1744}","it(""should open, receive message, and close"", (done) => {
      socketServer.on(""connection"", (connection) => {
        connection.write(""hello world"");

        setTimeout(() => {
          connection.close();
        }, 1000);
      });

      const client = new SockJSClient(`http://localhost:${port}/ws`);
      const data = [];

      client.onOpen(() => {
        data.push(""open"");
      });
      client.onClose(() => {
        data.push(""close"");
      });
      client.onMessage((msg) => {
        data.push(msg);
      });

      const testError = new Error(""test"");

      client.sock.onerror(testError);

      expect(log.error.mock.calls).toHaveLength(1);
      expect(log.error.mock.calls[0]).toEqual([testError]);

      setTimeout(() => {
        expect(data).toMatchSnapshot();

        done();
      }, 3000);
    })",steel
/test/client/clients/SockJSClient.test.js,Sleepy Test,"{'line': 55, 'column': 8, 'index': 1240}","it(""should open, receive message, and close"", (done) => {
      socketServer.on(""connection"", (connection) => {
        connection.write(""hello world"");

        setTimeout(() => {
          connection.close();
        }, 1000);
      });

      const client = new SockJSClient(`http://localhost:${port}/ws`);
      const data = [];

      client.onOpen(() => {
        data.push(""open"");
      });
      client.onClose(() => {
        data.push(""close"");
      });
      client.onMessage((msg) => {
        data.push(msg);
      });

      const testError = new Error(""test"");

      client.sock.onerror(testError);

      expect(log.error.mock.calls).toHaveLength(1);
      expect(log.error.mock.calls[0]).toEqual([testError]);

      setTimeout(() => {
        expect(data).toMatchSnapshot();

        done();
      }, 3000);
    })",steel
/test/client/clients/SockJSClient.test.js,Sleepy Test,"{'line': 80, 'column': 6, 'index': 1815}","it(""should open, receive message, and close"", (done) => {
      socketServer.on(""connection"", (connection) => {
        connection.write(""hello world"");

        setTimeout(() => {
          connection.close();
        }, 1000);
      });

      const client = new SockJSClient(`http://localhost:${port}/ws`);
      const data = [];

      client.onOpen(() => {
        data.push(""open"");
      });
      client.onClose(() => {
        data.push(""close"");
      });
      client.onMessage((msg) => {
        data.push(msg);
      });

      const testError = new Error(""test"");

      client.sock.onerror(testError);

      expect(log.error.mock.calls).toHaveLength(1);
      expect(log.error.mock.calls[0]).toEqual([testError]);

      setTimeout(() => {
        expect(data).toMatchSnapshot();

        done();
      }, 3000);
    })",steel
/test/cli/webSocketServer-option.test.js,Magic Number,"{'line': 15, 'column': 26, 'index': 400}","it('should work using ""--web-socket-server-type ws""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--web-socket-server-type"",
      ""ws"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/webSocketServer-option.test.js,Magic Number,"{'line': 26, 'column': 26, 'index': 639}","it('should work using ""--web-socket-server-type sockjs""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--web-socket-server-type"",
      ""sockjs"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/webSocketServer-option.test.js,Magic Number,"{'line': 36, 'column': 26, 'index': 851}","it('should work using ""--no-web-socket-server""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--no-web-socket-server"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/watchFiles-option.test.js,Magic Number,"{'line': 18, 'column': 26, 'index': 524}","it('should work using ""--watch-files <value>""', async () => {
    const watchDirectory = path.resolve(__dirname, ""../fixtures/static/static"");

    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--watch-files"",
      watchDirectory,
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/watchFiles-option.test.js,Magic Number,"{'line': 38, 'column': 26, 'index': 1107}","it('should work using ""--watch-files <value> --watch-files <other-value>""', async () => {
    const watchDirectory = path.resolve(__dirname, ""../fixtures/static/static"");
    const watchOtherDirectory = path.resolve(
      __dirname,
      ""../fixtures/static/simple-config"",
    );

    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--watch-files"",
      watchDirectory,
      ""--watch-files"",
      watchOtherDirectory,
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/watchFiles-option.test.js,Magic Number,"{'line': 53, 'column': 26, 'index': 1550}","it('should work using ""--watch-files-reset --watch-files <static>""', async () => {
    const watchDirectory = path.resolve(__dirname, ""../fixtures/static/static"");

    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--watch-files-reset"",
      ""--watch-files"",
      watchDirectory,
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 10, 'column': 26, 'index': 333}","it('should work using ""--static""', async () => {
    const { exitCode, stderr } = await testBin([""--port"", port, ""--static""]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 22, 'column': 26, 'index': 635}","it('should work using ""--static new-static""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--static"",
      ""new-static"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 36, 'column': 26, 'index': 999}","it('should work using ""--static new-static --static other-static""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--static"",
      ""new-static"",
      ""--static"",
      ""other-static"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 49, 'column': 26, 'index': 1332}","it('should work using ""--static-reset""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--static-reset"",
      ""--static"",
      ""new-static-after-reset"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 62, 'column': 26, 'index': 1713}","it('should work using ""--static-reset --static-directory new-static-directory""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--static-reset"",
      ""--static-directory"",
      ""new-static-directory"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 74, 'column': 26, 'index': 2035}","it('should work using ""--static-directory static-dir""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--static-directory"",
      ""static-dir"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 86, 'column': 26, 'index': 2355}","it('should work using ""--static-public-path /public""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--static-public-path"",
      ""/public"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 99, 'column': 26, 'index': 2713}","it('should work using ""--static-public-path-reset""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--static-public-path-reset"",
      ""--static-public-path"",
      ""/new-public"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 110, 'column': 26, 'index': 3008}","it('should work using ""--static-serve-index""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--static-serve-index"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 121, 'column': 26, 'index': 3309}","it('should work using ""--no-static-serve-index""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--no-static-serve-index"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 132, 'column': 26, 'index': 3592}","it('should work using ""--static-watch""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--static-watch"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/static-option.test.js,Magic Number,"{'line': 143, 'column': 26, 'index': 3881}","it('should work using ""--no-static-watch""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--no-static-watch"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/server-option.test.js,Magic Number,"{'line': 29, 'column': 26, 'index': 734}","it('should work using ""--server-type http""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--server-type"",
      ""http"",
    ]);

    expect(exitCode).toBe(0);
    expect(
      normalizeStderr(stderr, { ipv6: true, https: false }),
    ).toMatchSnapshot();
  })",steel
/test/cli/server-option.test.js,Magic Number,"{'line': 43, 'column': 26, 'index': 1055}","it('should work using ""--server-type https""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--server-type"",
      ""https"",
    ]);

    expect(exitCode).toBe(0);
    expect(
      normalizeStderr(stderr, { ipv6: true, https: true }),
    ).toMatchSnapshot();
  })",steel
/test/cli/server-option.test.js,Magic Number,"{'line': 94, 'column': 26, 'index': 2619}","it('should work using ""--server-options-key <path> --server-options-pfx <path> --server-options-passphrase webpack-dev-server --server-options-cert <path> --server-options-ca <path>""', async () => {
    const pfxFile = path.join(httpsCertificateDirectory, ""server.pfx"");
    const key = path.join(httpsCertificateDirectory, ""server.key"");
    const cert = path.join(httpsCertificateDirectory, ""server.crt"");
    const ca = path.join(httpsCertificateDirectory, ""ca.pem"");
    const passphrase = ""webpack-dev-server"";

    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--server-type"",
      ""https"",
      ""--server-options-key"",
      key,
      ""--server-options-pfx"",
      pfxFile,
      ""--server-options-passphrase"",
      passphrase,
      ""--server-options-cert"",
      cert,
      ""--server-options-ca"",
      ca,
    ]);

    expect(exitCode).toBe(0);
    expect(
      normalizeStderr(stderr, { ipv6: true, https: true }),
    ).toMatchSnapshot();
  })",steel
/test/cli/server-option.test.js,Magic Number,"{'line': 128, 'column': 26, 'index': 3872}","it('should work using ""--server-options-key-reset --server-options-key <path> --server-options-pfx-reset --server-options-pfx <path> --server-options-passphrase webpack-dev-server --server-options-cert-reset  --server-options-cert <path> --server-options-ca-reset --server-options-ca <path>""', async () => {
    const pfxFile = path.join(httpsCertificateDirectory, ""server.pfx"");
    const key = path.join(httpsCertificateDirectory, ""server.key"");
    const cert = path.join(httpsCertificateDirectory, ""server.crt"");
    const ca = path.join(httpsCertificateDirectory, ""ca.pem"");
    const passphrase = ""webpack-dev-server"";

    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--server-type"",
      ""https"",
      ""--server-options-key-reset"",
      ""--server-options-key"",
      key,
      ""--server-options-pfx-reset"",
      ""--server-options-pfx"",
      pfxFile,
      ""--server-options-passphrase"",
      passphrase,
      ""--server-options-cert-reset"",
      ""--server-options-cert"",
      cert,
      ""--server-options-ca-reset"",
      ""--server-options-ca"",
      ca,
    ]);

    expect(exitCode).toBe(0);
    expect(
      normalizeStderr(stderr, { ipv6: true, https: true }),
    ).toMatchSnapshot();
  })",steel
/test/cli/server-option.test.js,Magic Number,"{'line': 156, 'column': 26, 'index': 4810}","it('should work using ""--server-options-key <path> --server-options-pfx <path> --server-options-passphrase webpack-dev-server --server-options-cert <path>""', async () => {
    const pfxFile = path.join(httpsCertificateDirectory, ""server.pfx"");
    const key = path.join(httpsCertificateDirectory, ""server.key"");
    const cert = path.join(httpsCertificateDirectory, ""server.crt"");
    const passphrase = ""webpack-dev-server"";

    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--server-type"",
      ""https"",
      ""--server-options-key"",
      key,
      ""--server-options-pfx"",
      pfxFile,
      ""--server-options-passphrase"",
      passphrase,
      ""--server-options-cert"",
      cert,
    ]);

    expect(exitCode).toBe(0);
    expect(
      normalizeStderr(stderr, { ipv6: true, https: true }),
    ).toMatchSnapshot();
  })",steel
/test/cli/server-option.test.js,Magic Number,"{'line': 171, 'column': 26, 'index': 5179}","it('should work using ""--server-options-request-cert""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--server-type"",
      ""https"",
      ""--server-options-request-cert"",
    ]);

    expect(exitCode).toBe(0);
    expect(
      normalizeStderr(stderr, { ipv6: true, https: true }),
    ).toMatchSnapshot();
  })",steel
/test/cli/server-option.test.js,Magic Number,"{'line': 186, 'column': 26, 'index': 5554}","it('should work using ""--no-server-options-request-cert""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--server-type"",
      ""https"",
      ""--no-server-options-request-cert"",
    ]);

    expect(exitCode).toBe(0);
    expect(
      normalizeStderr(stderr, { ipv6: true, https: true }),
    ).toMatchSnapshot();
  })",steel
/test/cli/port-option.test.js,Magic Number,"{'line': 10, 'column': 26, 'index': 331}","it('should work using ""--port <string>""', async () => {
    const { exitCode, stderr } = await testBin([""--port"", port]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/port-option.test.js,Magic Number,"{'line': 17, 'column': 26, 'index': 570}","it('should work using ""--port auto""', async () => {
    const { exitCode, stderr } = await testBin([""--port"", ""auto""]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 10, 'column': 26, 'index': 300}","it('should work using ""--open""', async () => {
    const { exitCode } = await testBin([""--port"", port, ""--open""]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 21, 'column': 26, 'index': 513}","it('should work using ""--open /index.html""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open"",
      ""/index.html"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 33, 'column': 26, 'index': 759}","it('should work using ""--open /first.html second.html""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open"",
      ""/first.html"",
      ""second.html"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 39, 'column': 26, 'index': 920}","it('should work using ""--no-open""', async () => {
    const { exitCode } = await testBin([""--no-open"", ""--port"", port]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 51, 'column': 26, 'index': 1168}","it('should work using ""--open-reset --open /third.html""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open-reset"",
      ""--open"",
      ""/third.html"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 63, 'column': 26, 'index': 1418}","it('should work using ""--open-reset --open-target <url>""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open-reset"",
      ""--open-target"",
      ""<url>"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 75, 'column': 26, 'index': 1680}","it('should work using ""--open-reset --open-target /third.html""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open-reset"",
      ""--open-target"",
      ""/third.html"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 86, 'column': 26, 'index': 1915}","it('should work using ""--open-app-name google-chrome""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open-app-name"",
      ""google-chrome"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 98, 'column': 26, 'index': 2191}","it('should work using ""--open-app-name-reset --open-app-name firefox""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open-app-name-reset"",
      ""--open-app-name"",
      ""firefox"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 109, 'column': 26, 'index': 2416}","it('should work using ""--open-target index.html""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open-target"",
      ""index.html"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 121, 'column': 26, 'index': 2690}","it('should work using ""--open-target-reset --open-target first.html""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open-target-reset"",
      ""--open-target"",
      ""first.html"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 133, 'column': 26, 'index': 2950}","it('should work using ""--open-target /first.html second.html""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open-target"",
      ""/first.html"",
      ""second.html"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/open-option.test.js,Magic Number,"{'line': 146, 'column': 26, 'index': 3255}","it('should work using ""--open-target /index.html --open-app-name google-chrome""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--open-target"",
      ""/index.html"",
      ""--open-app-name"",
      ""google-chrome"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/liveReload-option.test.js,Magic Number,"{'line': 10, 'column': 26, 'index': 327}","it('should work using ""--live-reload""', async () => {
    const { exitCode } = await testBin([""--port"", port, ""--live-reload""]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/liveReload-option.test.js,Magic Number,"{'line': 16, 'column': 26, 'index': 502}","it('should work using ""--no-live-reload""', async () => {
    const { exitCode } = await testBin([""--port"", port, ""--no-live-reload""]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/ipc-option.test.js,Magic Number,"{'line': 11, 'column': 26, 'index': 322}","it('should work using ""--ipc""', async () => {
    const { exitCode, stderr } = await testBin([""--ipc""]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/ipc-option.test.js,Magic Number,"{'line': 23, 'column': 26, 'index': 764}","it('should work using ""--ipc=<string>""', async () => {
    const isWindows = process.platform === ""win32"";
    const pipePrefix = isWindows ? ""\\\\.\\pipe\\"" : os.tmpdir();
    const pipeName = ""webpack-dev-server.cli.sock"";
    const ipc = path.join(pipePrefix, pipeName);

    const { exitCode, stderr } = await testBin([""--ipc"", ipc]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/hot-option.test.js,Magic Number,"{'line': 15, 'column': 26, 'index': 402}","it('should work using ""--hot""', async () => {
    const { exitCode, stdout } = await testBin(
      [""--port"", port, ""--hot"", ""--stats=detailed""],
      {
        outputKillStr: /compiled successfully/,
      },
    );

    expect(exitCode).toBe(0);
    expect(stdout).toContain(""webpack/hot/dev-server.js"");
  })",steel
/test/cli/hot-option.test.js,Magic Number,"{'line': 27, 'column': 26, 'index': 726}","it('should work using ""--no-hot""', async () => {
    const { exitCode, stdout } = await testBin(
      [""--port"", port, ""--no-hot"", ""--stats=detailed""],
      {
        outputKillStr: /compiled successfully/,
      },
    );

    expect(exitCode).toBe(0);
    expect(stdout).not.toContain(""webpack/hot/dev-server.js"");
  })",steel
/test/cli/hot-option.test.js,Magic Number,"{'line': 39, 'column': 26, 'index': 1041}","it('should work using ""--hot only""', async () => {
    const { exitCode, stdout } = await testBin(
      [""--port"", port, ""--hot"", ""only""],
      {
        outputKillStr: /compiled successfully/,
      },
    );

    expect(exitCode).toBe(0);
    expect(stdout).toContain(""/hot/only-dev-server.js"");
  })",steel
/test/cli/host-option.test.js,Ignored Test,"{'line': 85, 'column': 5, 'index': 2104}","it.skip('should work using ""--host <IPv6>""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      localIPv6,
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/host-option.test.js,Ignored Test,"{'line': 110, 'column': 5, 'index': 2715}","it.skip('should work using ""--host local-ip"" take the first network found', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      ""local-ip"",
    ]);

    expect(exitCode).toBe(0);
    jest.spyOn(os, ""networkInterfaces"").mockImplementation(() => ({
      lo: [
        {
          address: ""127.0.0.1"",
          netmask: ""255.0.0.0"",
          family: ""IPv4"",
          mac: ""00:00:00:00:00:00"",
          internal: true,
          cidr: ""127.0.0.1/8"",
        },
        {
          address: ""::1"",
          netmask: ""ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"",
          family: ""IPv6"",
          mac: ""00:00:00:00:00:00"",
          internal: true,
          cidr: ""::1/128"",
          scopeid: 0,
        },
      ],
      enp6s0: [
        {
          address: ""192.168.1.15"",
          netmask: ""255.255.255.0"",
          family: ""IPv4"",
          mac: ""50:eb:f6:97:9f:6f"",
          internal: false,
          cidr: ""192.168.1.15/24"",
        },
        {
          address: ""2a01:cb0c:1623:6800:4ff8:723c:1a4b:fe5d"",
          netmask: ""ffff:ffff:ffff:ffff::"",
          family: ""IPv6"",
          mac: ""50:eb:f6:97:9f:6f"",
          internal: false,
          cidr: ""2a01:cb0c:1623:6800:4ff8:723c:1a4b:fe5d/64"",
          scopeid: 0,
        },
        {
          address: ""2a01:cb0c:1623:6800:9acc:408c:ee87:27cf"",
          netmask: ""ffff:ffff:ffff:ffff::"",
          family: ""IPv6"",
          mac: ""50:eb:f6:97:9f:6f"",
          internal: false,
          cidr: ""2a01:cb0c:1623:6800:9acc:408c:ee87:27cf/64"",
          scopeid: 0,
        },
        {
          address: ""fe80::bf2a:e5e2:8f9:4336"",
          netmask: ""ffff:ffff:ffff:ffff::"",
          family: ""IPv6"",
          mac: ""50:eb:f6:97:9f:6f"",
          internal: false,
          cidr: ""fe80::bf2a:e5e2:8f9:4336/64"",
          scopeid: 2,
        },
      ],
      ""br-9bb0264f9b1c"": [
        {
          address: ""172.19.0.1"",
          netmask: ""255.255.0.0"",
          family: ""IPv4"",
          mac: ""02:42:e4:c8:6e:5f"",
          internal: false,
          cidr: ""172.19.0.1/16"",
        },
        {
          address: ""fe80::42:e4ff:fec8:6e5f"",
          netmask: ""ffff:ffff:ffff:ffff::"",
          family: ""IPv6"",
          mac: ""02:42:e4:c8:6e:5f"",
          internal: false,
          cidr: ""fe80::42:e4ff:fec8:6e5f/64"",
          scopeid: 4,
        },
      ],
      ""br-a52e5d90701f"": [
        {
          address: ""172.18.0.1"",
          netmask: ""255.255.0.0"",
          family: ""IPv4"",
          mac: ""02:42:f6:7e:a2:45"",
          internal: false,
          cidr: ""172.18.0.1/16"",
        },
        {
          address: ""fe80::42:f6ff:fe7e:a245"",
          netmask: ""ffff:ffff:ffff:ffff::"",
          family: ""IPv6"",
          mac: ""02:42:f6:7e:a2:45"",
          internal: false,
          cidr: ""fe80::42:f6ff:fe7e:a245/64"",
          scopeid: 5,
        },
      ],
      docker0: [
        {
          address: ""172.17.0.1"",
          netmask: ""255.255.0.0"",
          family: ""IPv4"",
          mac: ""02:42:3e:89:61:cf"",
          internal: false,
          cidr: ""172.17.0.1/16"",
        },
      ],
    }));
    expect(stderr).not.toContain(""172.17.0.1"");
    expect(stderr).toContain(""192.168.1.15"");
  })",steel
/test/cli/host-option.test.js,Magic Number,"{'line': 20, 'column': 26, 'index': 550}","it('should work using ""--host 0.0.0.0"" (IPv4)', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      ""0.0.0.0"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/host-option.test.js,Magic Number,"{'line': 32, 'column': 26, 'index': 839}","it('should work using ""--host ::"" (IPv6)', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      ""::"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/host-option.test.js,Magic Number,"{'line': 44, 'column': 26, 'index': 1130}","it('should work using ""--host ::1"" (IPv6)', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      ""::1"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/host-option.test.js,Magic Number,"{'line': 56, 'column': 26, 'index': 1410}","it('should work using ""--host localhost""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      ""localhost"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/host-option.test.js,Magic Number,"{'line': 68, 'column': 26, 'index': 1697}","it('should work using ""--host 127.0.0.1"" (IPv4)', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      ""127.0.0.1"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/host-option.test.js,Magic Number,"{'line': 80, 'column': 26, 'index': 1972}","it('should work using ""--host <IPv4>""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      localIPv4,
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/host-option.test.js,Magic Number,"{'line': 105, 'column': 26, 'index': 2583}","it('should work using ""--host local-ip""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      ""local-ip"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/host-option.test.js,Magic Number,"{'line': 237, 'column': 26, 'index': 6184}","it('should work using ""--host local-ipv4""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--host"",
      ""local-ipv4"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
  })",steel
/test/cli/historyApiFallback-option.test.js,Magic Number,"{'line': 15, 'column': 26, 'index': 462}","it('should work using ""--history-api-fallback""', async () => {
    const { exitCode, stderr } = await testBin(
      [""--port"", port, ""--history-api-fallback""],
      {
        outputKillStr: /404s will fallback/,
      },
    );

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot();
  })",steel
/test/cli/historyApiFallback-option.test.js,Magic Number,"{'line': 26, 'column': 26, 'index': 759}","it('should work using ""--no-history-api-fallback""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--no-history-api-fallback"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot();
  })",steel
/test/cli/compress-option.test.js,Magic Number,"{'line': 10, 'column': 26, 'index': 316}","it('should work using ""--compress""', async () => {
    const { exitCode } = await testBin([""--port"", port, ""--compress""]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/compress-option.test.js,Magic Number,"{'line': 16, 'column': 26, 'index': 485}","it('should work using ""--no-compress""', async () => {
    const { exitCode } = await testBin([""--port"", port, ""--no-compress""]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/colors.test.js,Magic Number,"{'line': 25, 'column': 26, 'index': 668}","it(""should work use colors by default"", async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--color"",
      colorsDefaultStats,
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
    expect(stderr).toContain(""\u001B["");
  })",steel
/test/cli/colors.test.js,Magic Number,"{'line': 33, 'column': 26, 'index': 964}","it('should work use colors using ""--color""', async () => {
    const { exitCode, stderr } = await testBin([""--port"", port, ""--color""]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
    expect(stderr).toContain(""\u001B["");
  })",steel
/test/cli/colors.test.js,Magic Number,"{'line': 41, 'column': 26, 'index': 1273}","it('should work do not use colors using ""--no-color""', async () => {
    const { exitCode, stderr } = await testBin([""--port"", port, ""--no-color""]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
    expect(stderr).not.toContain(""\u001B["");
  })",steel
/test/cli/colors.test.js,Magic Number,"{'line': 54, 'column': 26, 'index': 1644}","it(""should work use colors using configuration with enabled colors"", async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--config"",
      colorsEnabled,
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
    expect(stderr).toContain(""\u001B["");
  })",steel
/test/cli/colors.test.js,Magic Number,"{'line': 67, 'column': 26, 'index': 2024}","it(""should work and do not use colors using configuration with disabled colors"", async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--config"",
      colorsDisabled,
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
    expect(stderr).not.toContain(""\u001B["");
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 15, 'column': 26, 'index': 398}","it('should work using ""--client-web-socket-transport sockjs""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-web-socket-transport"",
      ""sockjs"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 26, 'column': 26, 'index': 639}","it('should work using ""--client-web-socket-transport ws""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-web-socket-transport"",
      ""ws"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 32, 'column': 26, 'index': 814}","it('should work using ""--client-overlay""', async () => {
    const { exitCode } = await testBin([""--port"", port, ""--client-overlay""]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 38, 'column': 26, 'index': 995}","it('should work using ""--no-client-overlay""', async () => {
    const { exitCode } = await testBin([""--port"", port, ""--no-client-overlay""]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 48, 'column': 26, 'index': 1209}","it('should work using ""--client-overlay-errors""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-overlay-errors"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 58, 'column': 26, 'index': 1429}","it('should work using ""--no-client-overlay-errors""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--no-client-overlay-errors"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 68, 'column': 26, 'index': 1647}","it('should work using ""--client-overlay-warnings""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-overlay-warnings"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 78, 'column': 26, 'index': 1871}","it('should work using ""--no-client-overlay-warnings""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--no-client-overlay-warnings"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 89, 'column': 26, 'index': 2088}","it('should work using ""--client-logging""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-logging"",
      ""verbose"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 95, 'column': 26, 'index': 2265}","it('should work using ""--client-progress""', async () => {
    const { exitCode } = await testBin([""--port"", port, ""--client-progress""]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 105, 'column': 26, 'index': 2473}","it('should work using ""--no-client-progress""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--no-client-progress"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 111, 'column': 26, 'index': 2652}","it('should work using ""--client-reconnect""', async () => {
    const { exitCode } = await testBin([""--port"", port, ""--client-reconnect""]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 122, 'column': 26, 'index': 2873}","it('should work using ""--client-reconnect <value>""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-reconnect"",
      5,
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 132, 'column': 26, 'index': 3083}","it('should work using ""--no-client-reconnect""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--no-client-reconnect"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 143, 'column': 26, 'index': 3336}","it('should work using ""--client-web-socket-url""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-web-socket-url"",
      ""ws://myhost.com:8080/foo/test"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 154, 'column': 26, 'index': 3581}","it('should work using ""--client-web-socket-url-protocol""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-web-socket-url-protocol"",
      ""ws:"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 165, 'column': 26, 'index': 3830}","it('should work using ""--client-web-socket-url-hostname""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-web-socket-url-hostname"",
      ""0.0.0.0"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 176, 'column': 26, 'index': 4075}","it('should work using ""--client-web-socket-url-pathname""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-web-socket-url-pathname"",
      ""/ws"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/client-option.test.js,Magic Number,"{'line': 187, 'column': 26, 'index': 4311}","it('should work using ""--client-web-socket-url-port""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--client-web-socket-url-port"",
      8080,
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/bonjour-option.test.js,Magic Number,"{'line': 20, 'column': 26, 'index': 618}","it('should work using ""--bonjour""', async () => {
    const { exitCode, stderr } = await testBin([""--port"", port, ""--bonjour""], {
      outputKillStr: /Broadcasting/,
    });

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot();
  })",steel
/test/cli/bonjour-option.test.js,Magic Number,"{'line': 32, 'column': 26, 'index': 974}","it('should work using ""--bonjour and --server-type=https""', async () => {
    const { exitCode, stderr } = await testBin(
      [""--port"", port, ""--bonjour"", ""--server-type=https""],
      {
        outputKillStr: /Broadcasting/,
      },
    );

    expect(exitCode).toBe(0);
    expect(
      normalizeStderr(stderr, { ipv6: true, https: true }),
    ).toMatchSnapshot();
  })",steel
/test/cli/bonjour-option.test.js,Magic Number,"{'line': 45, 'column': 26, 'index': 1271}","it('should work using ""--no-bonjour""', async () => {
    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--no-bonjour"",
    ]);

    expect(exitCode).toBe(0);
    expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot();
  })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 91, 'column': 8, 'index': 2770}","it(""should exit the process when SIGINT is detected"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const examplePath = path.resolve(
        __dirname,
        ""../../examples/client/web-socket-url"",
      );
      const cp = execa(""node"", [""--port"", port, cliPath], { cwd: examplePath });

      cp.stdout.on(""data"", (data) => {
        const bits = data.toString();

        if (/main.js/.test(bits)) {
          expect(cp.pid).not.toBe(0);

          cp.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        done();
      });
    })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 114, 'column': 8, 'index': 3365}","it(""should exit the process when SIGINT is detected, even before the compilation is done"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");
      const cp = execa(""node"", [""--port"", port, cliPath], { cwd });

      let killed = false;

      cp.stdout.on(""data"", () => {
        if (!killed) {
          expect(cp.pid).not.toBe(0);

          cp.kill(""SIGINT"");
        }

        killed = true;
      });

      cp.on(""exit"", () => {
        done();
      });
    })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 148, 'column': 8, 'index': 4111}","it(""should exit the process when stdin ends if --watch-options-stdin"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const examplePath = path.resolve(
        __dirname,
        ""../../examples/client/web-socket-url"",
      );
      const cp = execa(
        ""node"",
        [cliPath, ""--port"", port, ""--watch-options-stdin""],
        {
          cwd: examplePath,
        },
      );

      cp.stdout.on(""data"", (data) => {
        const bits = data.toString();

        if (/main.js/.test(bits)) {
          expect(cp.pid).not.toBe(0);

          cp.stdin.write(""hello"");
          cp.stdin.end(""world"");
        }
      });

      cp.on(""exit"", () => {
        done();
      });
    })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 184, 'column': 8, 'index': 4958}","it(""should exit the process when stdin ends if --watch-options-stdin, even before the compilation is done"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");
      const cp = execa(
        ""node"",
        [cliPath, ""--port"", port, ""--watch-options-stdin""],
        { cwd },
      );

      let killed = false;

      cp.on(""error"", (error) => {
        done(error);
      });

      cp.stdin.on(""error"", (error) => {
        done(error);
      });

      cp.stdout.on(""data"", () => {
        if (!killed) {
          expect(cp.pid).not.toBe(0);

          cp.stdin.write(""hello"");
          cp.stdin.end(""world"");
        }

        killed = true;
      });

      cp.on(""exit"", () => {
        done();
      });
    })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 354, 'column': 8, 'index': 9500}","it.skip(""should use different random port when multiple instances are started on different processes"", async () => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");

      const cp = execa(""node"", [cliPath, ""--colors=false""], { cwd });
      const cp2 = execa(""node"", [cliPath, ""--colors=false""], { cwd });

      const runtime = {
        cp: {
          port: null,
          done: false,
        },
        cp2: {
          port: null,
          done: false,
        },
      };

      cp.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp.kill(""SIGINT"");
        }
      });

      cp2.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp2.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp2.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        runtime.cp.done = true;
        if (runtime.cp2.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });

      cp2.on(""exit"", () => {
        runtime.cp2.done = true;

        if (runtime.cp.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });
    })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 358, 'column': 8, 'index': 9579}","it.skip(""should use different random port when multiple instances are started on different processes"", async () => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");

      const cp = execa(""node"", [cliPath, ""--colors=false""], { cwd });
      const cp2 = execa(""node"", [cliPath, ""--colors=false""], { cwd });

      const runtime = {
        cp: {
          port: null,
          done: false,
        },
        cp2: {
          port: null,
          done: false,
        },
      };

      cp.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp.kill(""SIGINT"");
        }
      });

      cp2.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp2.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp2.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        runtime.cp.done = true;
        if (runtime.cp2.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });

      cp2.on(""exit"", () => {
        runtime.cp2.done = true;

        if (runtime.cp.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });
    })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 369, 'column': 8, 'index': 9895}","it.skip(""should use different random port when multiple instances are started on different processes"", async () => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");

      const cp = execa(""node"", [cliPath, ""--colors=false""], { cwd });
      const cp2 = execa(""node"", [cliPath, ""--colors=false""], { cwd });

      const runtime = {
        cp: {
          port: null,
          done: false,
        },
        cp2: {
          port: null,
          done: false,
        },
      };

      cp.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp.kill(""SIGINT"");
        }
      });

      cp2.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp2.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp2.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        runtime.cp.done = true;
        if (runtime.cp2.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });

      cp2.on(""exit"", () => {
        runtime.cp2.done = true;

        if (runtime.cp.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });
    })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 373, 'column': 8, 'index': 9975}","it.skip(""should use different random port when multiple instances are started on different processes"", async () => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");

      const cp = execa(""node"", [cliPath, ""--colors=false""], { cwd });
      const cp2 = execa(""node"", [cliPath, ""--colors=false""], { cwd });

      const runtime = {
        cp: {
          port: null,
          done: false,
        },
        cp2: {
          port: null,
          done: false,
        },
      };

      cp.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp.kill(""SIGINT"");
        }
      });

      cp2.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp2.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp2.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        runtime.cp.done = true;
        if (runtime.cp2.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });

      cp2.on(""exit"", () => {
        runtime.cp2.done = true;

        if (runtime.cp.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });
    })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 381, 'column': 8, 'index': 10174}","it.skip(""should use different random port when multiple instances are started on different processes"", async () => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");

      const cp = execa(""node"", [cliPath, ""--colors=false""], { cwd });
      const cp2 = execa(""node"", [cliPath, ""--colors=false""], { cwd });

      const runtime = {
        cp: {
          port: null,
          done: false,
        },
        cp2: {
          port: null,
          done: false,
        },
      };

      cp.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp.kill(""SIGINT"");
        }
      });

      cp2.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp2.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp2.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        runtime.cp.done = true;
        if (runtime.cp2.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });

      cp2.on(""exit"", () => {
        runtime.cp2.done = true;

        if (runtime.cp.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });
    })",steel
/test/cli/basic.test.js,Conditional Test Logic,"{'line': 389, 'column': 8, 'index': 10352}","it.skip(""should use different random port when multiple instances are started on different processes"", async () => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");

      const cp = execa(""node"", [cliPath, ""--colors=false""], { cwd });
      const cp2 = execa(""node"", [cliPath, ""--colors=false""], { cwd });

      const runtime = {
        cp: {
          port: null,
          done: false,
        },
        cp2: {
          port: null,
          done: false,
        },
      };

      cp.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp.kill(""SIGINT"");
        }
      });

      cp2.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp2.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp2.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        runtime.cp.done = true;
        if (runtime.cp2.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });

      cp2.on(""exit"", () => {
        runtime.cp2.done = true;

        if (runtime.cp.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });
    })",steel
/test/cli/basic.test.js,Duplicate Assert,"{'line': 232, 'column': 6, 'index': 6064}","it(""should add dev server entry points to a multi entry point object"", async () => {
      const { exitCode, stdout } = await testBin(
        [
          ""--port"",
          port,
          ""--config"",
          ""./test/fixtures/cli-multi-entry/webpack.config.js"",
          ""--stats"",
          ""verbose"",
        ],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""client/index.js?"");
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Duplicate Assert,"{'line': 233, 'column': 6, 'index': 6116}","it(""should add dev server entry points to a multi entry point object"", async () => {
      const { exitCode, stdout } = await testBin(
        [
          ""--port"",
          port,
          ""--config"",
          ""./test/fixtures/cli-multi-entry/webpack.config.js"",
          ""--stats"",
          ""verbose"",
        ],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""client/index.js?"");
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Duplicate Assert,"{'line': 281, 'column': 6, 'index': 7344}","it('should only prepends dev server entry points to ""web"" target', async () => {
      const { exitCode, stdout } = await testBin(
        [""--port"", port, ""--target"", ""web""],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""client/index.js?"");
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Duplicate Assert,"{'line': 282, 'column': 6, 'index': 7396}","it('should only prepends dev server entry points to ""web"" target', async () => {
      const { exitCode, stdout } = await testBin(
        [""--port"", port, ""--target"", ""web""],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""client/index.js?"");
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Duplicate Assert,"{'line': 294, 'column': 6, 'index': 7726}","it('should not prepend dev server entry points to ""node"" target', async () => {
      const { exitCode, stdout } = await testBin(
        [""--port"", port, ""--target"", ""node""],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).not.toContain(""client/index.js?"");
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Duplicate Assert,"{'line': 295, 'column': 6, 'index': 7782}","it('should not prepend dev server entry points to ""node"" target', async () => {
      const { exitCode, stdout } = await testBin(
        [""--port"", port, ""--target"", ""node""],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).not.toContain(""client/index.js?"");
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Ignored Test,"{'line': 328, 'column': 7, 'index': 8714}","it.skip(""should use different random port when multiple instances are started on different processes"", async () => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");

      const cp = execa(""node"", [cliPath, ""--colors=false""], { cwd });
      const cp2 = execa(""node"", [cliPath, ""--colors=false""], { cwd });

      const runtime = {
        cp: {
          port: null,
          done: false,
        },
        cp2: {
          port: null,
          done: false,
        },
      };

      cp.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp.kill(""SIGINT"");
        }
      });

      cp2.stderr.on(""data"", (data) => {
        const bits = data.toString();
        const portMatch =
          /Project is running at http:\/\/localhost:(\d*)\//.exec(bits);

        if (portMatch) {
          [, runtime.cp2.port] = portMatch;
        }

        if (/Compiled successfully/.test(bits)) {
          expect(cp.pid).not.toBe(0);
          cp2.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        runtime.cp.done = true;
        if (runtime.cp2.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });

      cp2.on(""exit"", () => {
        runtime.cp2.done = true;

        if (runtime.cp.done) {
          expect(runtime.cp.port).not.toBe(runtime.cp2.port);
        }
      });
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 31, 'column': 28, 'index': 1044}","it(""should work"", async () => {
      const { exitCode, stderr } = await testBin([
        // Ideally it should be empty to test without arguments, unfortunately it takes 8080 port and other test can failed
        ""--port"",
        port,
      ]);

      expect(exitCode).toBe(0);
      expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 43, 'column': 28, 'index': 1374}","it('should work using ""--host localhost --port <port>""', async () => {
      const { exitCode, stderr } = await testBin([
        ""--port"",
        port,
        ""--host"",
        ""localhost"",
      ]);

      expect(exitCode).toBe(0);
      expect(normalizeStderr(stderr)).toMatchSnapshot(""stderr"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 58, 'column': 28, 'index': 1790}","it(""should accept the promise function of webpack.config.js"", async () => {
      const { exitCode, stderr } = await testBin([
        ""--config"",
        path.resolve(
          __dirname,
          ""../fixtures/cli-promise-config/webpack.config.js"",
        ),
        ""--port"",
        port,
      ]);

      expect(exitCode).toBe(0);
      expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 73, 'column': 28, 'index': 2215}","it(""should work using multi compiler mode"", async () => {
      const { exitCode, stderr } = await testBin([
        ""--config"",
        path.resolve(
          __dirname,
          ""../fixtures/cli-universal-compiler-config/webpack.config.js"",
        ),
        ""--port"",
        port,
      ]);

      expect(exitCode).toBe(0);
      expect(normalizeStderr(stderr, { ipv6: true })).toMatchSnapshot(""stderr"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 92, 'column': 34, 'index': 2832}","it(""should exit the process when SIGINT is detected"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const examplePath = path.resolve(
        __dirname,
        ""../../examples/client/web-socket-url"",
      );
      const cp = execa(""node"", [""--port"", port, cliPath], { cwd: examplePath });

      cp.stdout.on(""data"", (data) => {
        const bits = data.toString();

        if (/main.js/.test(bits)) {
          expect(cp.pid).not.toBe(0);

          cp.kill(""SIGINT"");
        }
      });

      cp.on(""exit"", () => {
        done();
      });
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 115, 'column': 34, 'index': 3414}","it(""should exit the process when SIGINT is detected, even before the compilation is done"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");
      const cp = execa(""node"", [""--port"", port, cliPath], { cwd });

      let killed = false;

      cp.stdout.on(""data"", () => {
        if (!killed) {
          expect(cp.pid).not.toBe(0);

          cp.kill(""SIGINT"");
        }

        killed = true;
      });

      cp.on(""exit"", () => {
        done();
      });
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 149, 'column': 34, 'index': 4173}","it(""should exit the process when stdin ends if --watch-options-stdin"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const examplePath = path.resolve(
        __dirname,
        ""../../examples/client/web-socket-url"",
      );
      const cp = execa(
        ""node"",
        [cliPath, ""--port"", port, ""--watch-options-stdin""],
        {
          cwd: examplePath,
        },
      );

      cp.stdout.on(""data"", (data) => {
        const bits = data.toString();

        if (/main.js/.test(bits)) {
          expect(cp.pid).not.toBe(0);

          cp.stdin.write(""hello"");
          cp.stdin.end(""world"");
        }
      });

      cp.on(""exit"", () => {
        done();
      });
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 185, 'column': 34, 'index': 5007}","it(""should exit the process when stdin ends if --watch-options-stdin, even before the compilation is done"", (done) => {
      const cliPath = path.resolve(
        __dirname,
        ""../../bin/webpack-dev-server.js"",
      );
      const cwd = path.resolve(__dirname, ""../fixtures/cli"");
      const cp = execa(
        ""node"",
        [cliPath, ""--port"", port, ""--watch-options-stdin""],
        { cwd },
      );

      let killed = false;

      cp.on(""error"", (error) => {
        done(error);
      });

      cp.stdin.on(""error"", (error) => {
        done(error);
      });

      cp.stdout.on(""data"", () => {
        if (!killed) {
          expect(cp.pid).not.toBe(0);

          cp.stdin.write(""hello"");
          cp.stdin.end(""world"");
        }

        killed = true;
      });

      cp.on(""exit"", () => {
        done();
      });
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 212, 'column': 28, 'index': 5571}","it(""should add dev server entry points to a single entry point"", async () => {
      const { exitCode, stdout } = await testBin(
        [
          ""--port"",
          port,
          ""--config"",
          ""./test/fixtures/cli-single-entry/webpack.config.js"",
        ],
        {
          outputKillStr: /client\/index\.js\?/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""client/index.js?"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 231, 'column': 28, 'index': 6054}","it(""should add dev server entry points to a multi entry point object"", async () => {
      const { exitCode, stdout } = await testBin(
        [
          ""--port"",
          port,
          ""--config"",
          ""./test/fixtures/cli-multi-entry/webpack.config.js"",
          ""--stats"",
          ""verbose"",
        ],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""client/index.js?"");
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 249, 'column': 28, 'index': 6544}","it(""should add dev server entry points to an empty entry object"", async () => {
      const { exitCode, stdout } = await testBin(
        [
          ""--port"",
          port,
          ""--config"",
          ""./test/fixtures/cli-empty-entry/webpack.config.js"",
        ],
        {
          outputKillStr: /client\/index\.js\?/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""client/index.js?"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 268, 'column': 28, 'index': 7004}","it(""should supports entry as descriptor"", async () => {
      const { exitCode, stdout } = await testBin(
        [
          ""--port"",
          port,
          ""--config"",
          ""./test/fixtures/cli-entry-as-descriptor/webpack.config"",
          ""--stats"",
          ""detailed"",
        ],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 280, 'column': 28, 'index': 7334}","it('should only prepends dev server entry points to ""web"" target', async () => {
      const { exitCode, stdout } = await testBin(
        [""--port"", port, ""--target"", ""web""],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""client/index.js?"");
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 293, 'column': 28, 'index': 7716}","it('should not prepend dev server entry points to ""node"" target', async () => {
      const { exitCode, stdout } = await testBin(
        [""--port"", port, ""--target"", ""node""],
        {
          outputKillStr: /foo\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).not.toContain(""client/index.js?"");
      expect(stdout).toContain(""foo.js"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 306, 'column': 28, 'index': 8125}","it('should prepends the hot runtime to ""node"" target as well', async () => {
      const { exitCode, stdout } = await testBin(
        [""--port"", port, ""--target"", ""node"", ""--hot""],
        {
          outputKillStr: /webpack\/hot\/dev-server/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""webpack/hot/dev-server"");
    })",steel
/test/cli/basic.test.js,Magic Number,"{'line': 323, 'column': 28, 'index': 8588}","it(""should prepend dev server entry points depending on targetProperties"", async () => {
      const { exitCode, stdout } = await testBin(
        [
          ""--port"",
          port,
          ""--config"",
          ""./test/fixtures/cli-target-config/webpack.config.js"",
        ],
        {
          outputKillStr: /client\/index\.js/,
        },
      );

      expect(exitCode).toBe(0);
      expect(stdout).toContain(""client/index.js"");
    })",steel
/test/cli/allowedHosts-option.test.js,Magic Number,"{'line': 15, 'column': 26, 'index': 379}","it('should work using ""--allowed-hosts auto""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--allowed-hosts"",
      ""auto"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/allowedHosts-option.test.js,Magic Number,"{'line': 26, 'column': 26, 'index': 594}","it('should work using ""--allowed-hosts all""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--allowed-hosts"",
      ""all"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/allowedHosts-option.test.js,Magic Number,"{'line': 37, 'column': 26, 'index': 829}","it('should work using ""--allowed-hosts testhouse.com""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--allowed-hosts"",
      ""testhouse.com"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
/test/cli/allowedHosts-option.test.js,Magic Number,"{'line': 50, 'column': 26, 'index': 1140}","it('should work using ""--allowed-hosts testhost.com --allowed-hosts testhost1.com""', async () => {
    const { exitCode } = await testBin([
      ""--port"",
      port,
      ""--allowed-hosts"",
      ""testhost.com"",
      ""--allowed-hosts"",
      ""testhost1.com"",
    ]);

    expect(exitCode).toBe(0);
  })",steel
