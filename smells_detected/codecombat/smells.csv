file,type,line,method,source
/test/app/models/SuperModel.spec.js,SubOptimalAssert,"{'startLine':89,'endLine':89}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",snuts
/test/app/models/SuperModel.spec.js,SubOptimalAssert,"{'startLine':96,'endLine':96}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",snuts
/test/app/models/SuperModel.spec.js,SubOptimalAssert,"{'startLine':109,'endLine':109}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",snuts
/test/app/models/SuperModel.spec.js,SubOptimalAssert,"{'startLine':126,'endLine':126}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",snuts
/test/app/models/SuperModel.spec.js,SubOptimalAssert,"{'startLine':129,'endLine':129}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",snuts
/test/app/models/InteractiveSession.spec.js,AnonymousTest,"{'startLine':8,'endLine':13}","it('compiles successfully', () => {
    const ajv = new Ajv(getAjvOptions())
    const validate = ajv.compile(schemaObject)
    expect(typeof validate).toBe('function')
    expect(ajv.errors).toBe(null)
  })",snuts
/test/app/models/InteractiveSession.spec.js,SubOptimalAssert,"{'startLine':12,'endLine':12}","it('compiles successfully', () => {
    const ajv = new Ajv(getAjvOptions())
    const validate = ajv.compile(schemaObject)
    expect(typeof validate).toBe('function')
    expect(ajv.errors).toBe(null)
  })",snuts
/test/app/models/InteractiveSession.spec.js,SubOptimalAssert,"{'startLine':21,'endLine':21}","it('validates a correct object', () => {
    const ajv = new Ajv(getAjvOptions())
    const valid = ajv.validate(schemaObject, testObject)
    expect(valid).toBe(true)
    expect(ajv.errors).toBe(null)
  })",snuts
/test/app/models/Interactive.spec.js,AnonymousTest,"{'startLine':21,'endLine':26}","it('compiles successfully', () => {
    const ajv = new Ajv(getAjvOptions())
    const validate = ajv.compile(schemaObject)
    expect(typeof validate).toBe('function')
    expect(ajv.errors).toBe(null)
  })",snuts
/test/app/models/Interactive.spec.js,SubOptimalAssert,"{'startLine':25,'endLine':25}","it('compiles successfully', () => {
    const ajv = new Ajv(getAjvOptions())
    const validate = ajv.compile(schemaObject)
    expect(typeof validate).toBe('function')
    expect(ajv.errors).toBe(null)
  })",snuts
/test/app/models/Interactive.spec.js,SubOptimalAssert,"{'startLine':34,'endLine':34}","it('validates a correct object', () => {
    const ajv = new Ajv(getAjvOptions())
    const valid = ajv.validate(schemaObject, testObject)
    expect(valid).toBe(true)
    expect(ajv.errors).toBe(null)
  })",snuts
/test/app/models/CourseInstance.spec.js,IdenticalTestDescription,"{'startLine':20,'endLine':23}","it('returns a jqxhr', function() {
    const res = this.courseInstance.addMembers(['1234']);
    return expect(res.readyState).toBe(1);
  })",snuts
/test/app/models/CourseInstance.spec.js,IdenticalTestDescription,"{'startLine':25,'endLine':28}","it('returns a jqxhr', function() {
    const res = this.courseInstance.removeMember('1234');
    return expect(res.readyState).toBe(1);
  })",snuts
/test/app/models/CocoModel.spec.js,ConditionalTestLogic,"{'startLine':159,'endLine':161}","it('achievements are polled upon saving a model', function(done) {
    //spyOn(CocoModel, 'pollAchievements')
    Backbone.Mediator.subscribe('achievements:new', function(collection) {
      Backbone.Mediator.unsubscribe('achievements:new');
      expect(collection.constructor.name).toBe('NewAchievementCollection');
      return done();
    });

    const b = new BlandClass({});
    const res = b.save();
    let request = jasmine.Ajax.requests.mostRecent();
    request.respondWith({status: 200, responseText: '{}'});

    const collection = [];
    const model = {
      _id: ""5390f7637b4d6f2a074a7bb4"",
      achievement: ""537ce4855c91b8d1dda7fda8""
    };
    collection.push(model);

    return utils.keepDoingUntil(function(ready) {
      request = jasmine.Ajax.requests.mostRecent();
      const achievementURLMatch = (/.*achievements\?notified=false$/).exec(request.url);
      if (achievementURLMatch) {
        ready(true);
      } else { return ready(false); }

      request.respondWith({status: 200, responseText: JSON.stringify(collection)});

      return utils.keepDoingUntil(function(ready) {
        request = jasmine.Ajax.requests.mostRecent();
        const userURLMatch = (/^\/db\/user\/[a-zA-Z0-9]*$/).exec(request.url);
        if (userURLMatch) {
          ready(true);
        } else { return ready(false); }

        return request.respondWith({status:200, responseText: JSON.stringify(me)});});});
})",snuts
/test/app/models/CocoModel.spec.js,ConditionalTestLogic,"{'startLine':168,'endLine':170}","it('achievements are polled upon saving a model', function(done) {
    //spyOn(CocoModel, 'pollAchievements')
    Backbone.Mediator.subscribe('achievements:new', function(collection) {
      Backbone.Mediator.unsubscribe('achievements:new');
      expect(collection.constructor.name).toBe('NewAchievementCollection');
      return done();
    });

    const b = new BlandClass({});
    const res = b.save();
    let request = jasmine.Ajax.requests.mostRecent();
    request.respondWith({status: 200, responseText: '{}'});

    const collection = [];
    const model = {
      _id: ""5390f7637b4d6f2a074a7bb4"",
      achievement: ""537ce4855c91b8d1dda7fda8""
    };
    collection.push(model);

    return utils.keepDoingUntil(function(ready) {
      request = jasmine.Ajax.requests.mostRecent();
      const achievementURLMatch = (/.*achievements\?notified=false$/).exec(request.url);
      if (achievementURLMatch) {
        ready(true);
      } else { return ready(false); }

      request.respondWith({status: 200, responseText: JSON.stringify(collection)});

      return utils.keepDoingUntil(function(ready) {
        request = jasmine.Ajax.requests.mostRecent();
        const userURLMatch = (/^\/db\/user\/[a-zA-Z0-9]*$/).exec(request.url);
        if (userURLMatch) {
          ready(true);
        } else { return ready(false); }

        return request.respondWith({status:200, responseText: JSON.stringify(me)});});});
})",snuts
/test/app/models/CocoModel.spec.js,VerboseStatement,"{'startLine':38,'endLine':54}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",snuts
/test/app/models/ClassroomLib.spec.js,IdenticalTestDescription,"{'startLine':62,'endLine':71}","it('no lock is always false', () => {
    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: undefined
      },
      'StudentIdExample',
      courseId,
      'levelOriginal')).toEqual(false)
    }
  })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':80,'endLine':86}","it('getLeftCharacterThangTypeSlug', () => {
      const result = getLeftCharacterThangTypeSlug(shotFixture1)
      expect(result).toBeUndefined()

      const result2 = getLeftCharacterThangTypeSlug(shotFixture2)
      expect(result2).toEqual({ slug: 'fake-slug-thangtype', enterOnStart: false, thang: { scaleX: 1.2, scaleY: 1.2, pos: { x: -37, y: -73 } } })
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':88,'endLine':94}","it('getRightCharacterThangTypeSlug', () => {
      const result = getRightCharacterThangTypeSlug(shotFixture2)
      expect(result).toBeUndefined()

      const result2 = getRightCharacterThangTypeSlug(shotFixture1)
      expect(result2).toEqual({ slug: 'fake-slug-thangtype', enterOnStart: false, thang: { scaleX: 1.2, scaleY: 1.2, pos: { x: 37, y: -73 } } })
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':96,'endLine':102}","it('getLeftHero', () => {
      const result = getLeftHero(shotFixture1)
      expect(result).toEqual({ enterOnStart: true, thang: { scaleX: 1, scaleY: 13, pos: { x: 3, y: 10 } }, type: 'hero' })

      const result2 = getLeftHero(shotFixture2)
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':104,'endLine':110}","it('getRightHero', () => {
      const result = getRightHero(shotFixture2)
      expect(result).toEqual({ enterOnStart: true, thang: { scaleX: 1, scaleY: 13, pos: { x: 3, y: 10 } }, type: 'hero' })

      const result2 = getRightHero(shotFixture1)
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':112,'endLine':118}","it('getClearBackgroundObject', () => {
      const result = getClearBackgroundObject(shotFixture1.dialogNodes[0])
      expect(result).toEqual(7331)

      const result2 = getClearBackgroundObject(shotFixture2.dialogNodes[0])
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':120,'endLine':126}","it('getBackgroundObject', () => {
      const result = getBackgroundObject(shotFixture1.dialogNodes[0])
      expect(result).toEqual({ scaleX: 1, scaleY: 1, pos: { x: 0, y: 0 }, type: { slug: 'background-obj-fixture' } })

      const result2 = getBackgroundObject(shotFixture2.dialogNodes[0])
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':128,'endLine':134}","it('getBackgroundObjectDelay', () => {
      const result = getBackgroundObjectDelay(shotFixture1.dialogNodes[0])
      expect(result).toEqual(1337)

      const result2 = getBackgroundObjectDelay(shotFixture2.dialogNodes[0])
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':136,'endLine':142}","it('getBackground', () => {
      const result = getBackground(shotFixture1)
      expect(result).toEqual({ slug: 'background-fixture-slug', thang: { scaleX: 0.3, scaleY: 0.2, pos: { x: 17, y: 18 } } })

      const result2 = getBackground(shotFixture2)
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':144,'endLine':150}","it('getClearText', () => {
      const result = getClearText(shotFixture1.dialogNodes[0])
      expect(result).toEqual(false)

      const result2 = getClearText(shotFixture2.dialogNodes[0])
      expect(result2).toEqual(true)
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':152,'endLine':158}","it('getSpeaker', () => {
      const result = getSpeaker(shotFixture1.dialogNodes[0])
      expect(result).toEqual('left')

      const result2 = getSpeaker(shotFixture2.dialogNodes[0])
      expect(result2).toEqual('right')
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':160,'endLine':166}","it('getBackgroundSlug', () => {
      const result = getBackgroundSlug(shotFixture1)
      expect(result).toEqual('background-fixture-slug')

      const result2 = getBackgroundSlug(shotFixture2)
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':168,'endLine':174}","it('getExitCharacter', () => {
      const result = getExitCharacter(shotFixture1.dialogNodes[0])
      expect(result).toEqual('both')

      const result2 = getExitCharacter(shotFixture2.dialogNodes[0])
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':176,'endLine':185}","it('getTextPosition', () => {
      const result = getTextPosition(shotFixture1.dialogNodes[0])
      expect(result).toBeUndefined()

      const result2 = getTextPosition(shotFixture2.dialogNodes[0])
      expect(result2).toEqual({
        x: 40,
        y: 10
      })
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':187,'endLine':193}","it('getText', () => {
      const result = getText(shotFixture1.dialogNodes[0])
      expect(result).toEqual('hello, world')

      const result2 = getText(shotFixture2.dialogNodes[0])
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':195,'endLine':203}","it('getCamera', () => {
      const result = getCamera(shotFixture1)
      expect(result).toEqual({ pos: { x: 2, y: 0 }, zoom: 2 })

      const result2 = getCamera(shotFixture2)
      expect(result2).toBeUndefined()

      expect(getCamera(undefined)).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':205,'endLine':211}","it('getTextAnimationLength', () => {
      const result = getTextAnimationLength(shotFixture1.dialogNodes[1])
      expect(result).toEqual(42)

      const result2 = getTextAnimationLength(shotFixture2.dialogNodes[0])
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':213,'endLine':219}","it('getSpeakingAnimationAction', () => {
      const result = getSpeakingAnimationAction(shotFixture1.dialogNodes[1])
      expect(result).toEqual('talkyAnimation')

      const result2 = getSpeakingAnimationAction(shotFixture2.dialogNodes[0])
      expect(result2).toEqual('talkNeutral')
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':221,'endLine':227}","it('getSoundEffects', () => {
      const result = getSoundEffects(shotFixture1.dialogNodes[0])
      expect(result).toEqual([ { sound: { mp3: 'path/music' }, triggerStart: 0 } ])

      const result2 = getSoundEffects(shotFixture2.dialogNodes[0])
      expect(result2).toEqual([ { sound: { mp3: 'path/music' }, triggerStart: 30 } ])
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':229,'endLine':235}","it('getSetupMusic', () => {
      const result = getSetupMusic(shotFixture1)
      expect(result).toEqual({ files: { ogg: 'path/music', mp3: 'path/music/mp3' }, loop: false })

      const result2 = getSetupMusic(shotFixture2)
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':237,'endLine':240}","it('getFadeFromBlack', () => {
      expect(getFadeFromBlack(shotFixture2.dialogNodes[1])).toEqual({ duration: 1500 })
      expect(getFadeFromBlack(shotFixture2.dialogNodes[0])).toEqual(undefined)
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':242,'endLine':245}","it('getFadeToBlack', () => {
      expect(getFadeToBlack(shotFixture2.dialogNodes[0])).toEqual({ duration: 2000 })
      expect(getFadeToBlack(shotFixture1.dialogNodes[0])).toEqual(undefined)
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':247,'endLine':252}","it('getWaitUserInput', () => {
      expect(getWaitUserInput({ waitUserInput: false })).toEqual(false)
      expect(getWaitUserInput({})).toEqual(true)
      expect(getWaitUserInput()).toEqual(true)
      expect(getWaitUserInput({ waitUserInput: true })).toEqual(true)
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':254,'endLine':259}","it('getLanguageFilter', () => {
      expect(getLanguageFilter({})).toBeUndefined()
      expect(getLanguageFilter()).toBeUndefined()
      expect(getLanguageFilter({ programmingLanguageFilter: 'python' })).toEqual('python')
      expect(getLanguageFilter({ programmingLanguageFilter: 'javascript' })).toEqual('javascript')
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':261,'endLine':267}","it('getHeroPet', () => {
      const result = getHeroPet(shotFixture1)
      expect(result).toEqual({ slug: 'hero-dog-slug', thang: { scaleX: 1, scaleY: 2, pos: { x: 2, y: 0 } } })

      const result2 = getHeroPet(shotFixture2)
      expect(result2).toBeUndefined()
    })",snuts
/test/app/models/Cinematic.spec.js,AnonymousTest,"{'startLine':269,'endLine':282}","it('getPlayThangAnimations', () => {
      const result = getPlayThangAnimations(shotFixture1.dialogNodes[0])
      expect(result).toEqual([
        {
          delay: 0,
          duration: 1000,
          animation: 'test',
          lankTarget: 'left'
        }
      ])

      const result2 = getPlayThangAnimations(shotFixture1.dialogNodes[1])
      expect(result2).toEqual([])
    })",snuts
/test/app/lib/translate_utils.spec.js,IdenticalTestDescription,"{'startLine':1064,'endLine':1065}","it('if there is no pattern needing translation', () =>
        expect(translateUtils.translateJS('hero.moveRight();'), 'cpp').toBe('int main() {\n    hero.moveRight();\n    return 0;\n}'))",snuts
/test/app/lib/translate_utils.spec.js,IdenticalTestDescription,"{'startLine':1067,'endLine':1068}","it('if there is var x or var y', () =>
        expect(translateUtils.translateJS('var x = 2;\nvar y = 3;', 'cpp')).toBe('int main() {\n    float x = 2;\n    float y = 3;\n    return 0;\n}'))",snuts
/test/app/lib/translate_utils.spec.js,IdenticalTestDescription,"{'startLine':1070,'endLine':1071}","it('if there is ===/!==', () =>
        expect(translateUtils.translateJS('while (a === 2 && b !== 1) {}', 'cpp')).toBe('int main() {\n    while (a == 2 && b != 1) {}\n    return 0;\n}'))",snuts
/test/app/lib/translate_utils.spec.js,IdenticalTestDescription,"{'startLine':1073,'endLine':1074}","it('if there is other var', () =>
        expect(translateUtils.translateJS('var enemy = hero;', 'cpp')).toBe('int main() {\n    auto enemy = hero;\n    return 0;\n}'))",snuts
/test/app/lib/translate_utils.spec.js,IdenticalTestDescription,"{'startLine':1076,'endLine':1077}","it('if there is a function definition', () =>
        expect(translateUtils.translateJS('function a() {}\n', 'cpp')).toBe('auto a() {}\n\nint main() {\n    \n    return 0;\n}'))",snuts
/test/app/lib/translate_utils.spec.js,IdenticalTestDescription,"{'startLine':1087,'endLine':1088}","it('if there is no code', () =>
        expect(translateUtils.translateJS('//abc\n//def\n\n', 'cpp')).toBe('//abc\n//def\n\nint main() {\n    \n    return 0;\n}'))",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':37,'endLine':44}","it('nested match', function() {
    expect(LocalMongo.matchesQuery(this.fixture2, {'this.is.so': 'deep'})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture2, {this:{is:{so: 'deep'}}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture2, {'this.is':{so: 'deep'}})).toBeTruthy();
    const mixedQuery = { nested: {str:'ing'}, worth: {$gt:3} };
    expect(LocalMongo.matchesQuery(this.fixture1, mixedQuery)).toBeTruthy();
    return expect(LocalMongo.matchesQuery(this.fixture2, mixedQuery)).toBeFalsy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':46,'endLine':52}","it('$gt selector', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$gt': 8000}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$gt': [8000, 10000]}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'levels': {'$gt': [10, 20, 30]}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$gt': 9000}})).toBeFalsy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$gt': 8000}, 'worth': {'$gt': 5}})).toBeTruthy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':54,'endLine':59}","it('$gte selector', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$gte': 9001}})).toBeFalsy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$gte': 9000}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$gte': [9000, 10000]}})).toBeTruthy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {'levels': {'$gte': [21, 30]}})).toBeTruthy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':61,'endLine':67}","it('$lt selector', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$lt': 9001}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$lt': 9000}})).toBeFalsy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$lt': [9001, 9000]}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'levels': {'$lt': [10, 20, 30]}})).toBeTruthy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$lt': 9001}, 'worth': {'$lt': 7}})).toBeTruthy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':69,'endLine':73}","it('$lte selector', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$lte': 9000}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$lte': 8000}})).toBeFalsy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$lte': 9000}, 'worth': {'$lte': [6, 5]}})).toBeTruthy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':75,'endLine':80}","it('$ne selector', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {'value': {'$ne': 9000}})).toBeFalsy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'id': {'$ne': 'otherstring'}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'id': {'$ne': ['otherstring', 'somestring']}})).toBeFalsy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {'likes': {'$ne': ['popcorn', 'chicken']}})).toBeFalsy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':82,'endLine':86}","it('$in selector', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {'type': {'$in': ['unicorn', 'zebra']}})).toBeTruthy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'type': {'$in': ['cats', 'dogs']}})).toBeFalsy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {'likes': {'$in': ['popcorn', 'chicken']}})).toBeTruthy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':88,'endLine':92}","it('$nin selector', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {'type': {'$nin': ['unicorn', 'zebra']}})).toBeFalsy();
    expect(LocalMongo.matchesQuery(this.fixture1, {'type': {'$nin': ['cats', 'dogs']}})).toBeTruthy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {'likes': {'$nin': ['popcorn', 'chicken']}})).toBeFalsy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':94,'endLine':97}","it('$or operator', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {$or: [{value: 9000}, {type: 'zebra'}]})).toBeTruthy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {$or: [{value: 9001}, {worth: {'$lt': 10}}]})).toBeTruthy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':99,'endLine':103}","it('$and operator', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {$and: [{value: 9000}, {type: 'zebra'}]})).toBeFalsy();
    expect(LocalMongo.matchesQuery(this.fixture1, {$and: [{value: 9000}, {type: 'unicorn'}]})).toBeTruthy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {$and: [{value: {'$gte': 9000}}, {worth: {'$lt': 10}}]})).toBeTruthy();
  })",snuts
/test/app/lib/local_mongo.spec.js,AnonymousTest,"{'startLine':105,'endLine':108}","it('$exists operator', function() {
    expect(LocalMongo.matchesQuery(this.fixture1, {type: {$exists: true}})).toBeTruthy();
    return expect(LocalMongo.matchesQuery(this.fixture1, {interesting: {$exists: false}})).toBeTruthy();
  })",snuts
/test/app/lib/ScriptManager.spec.js,SubOptimalAssert,"{'startLine':65,'endLine':65}","xit('makes no subscriptions when something is invalid', function() {
    const note = {event: {1: 1}}; // channel is required
    const noteGroup = {notes: [note]};
    const script = {channel: 'pbs', noteChain: [noteGroup]};
    const sm = new ScriptManager([script]);
    expect(sm.subscriptions['pbs']).toBe(undefined);
    return sm.destroy();
  })",snuts
/test/app/lib/ScriptManager.spec.js,SubOptimalAssert,"{'startLine':89,'endLine':89}","xit('fills out lots of notes based on note group properties', function() {
    let note;
    note = {channel: 'cnn', event: {1: 1}};

    const noteGroup = {
      duration: 0,
      botPos: [1, 2],
      botMessage: 'testers',
      domHighlight: '#code-area',
      surfaceHighlights: ['Guy0', 'Guy1'],
      scrubToTime: 20,
      notes: [note]
    };

    const script = {channel: 'pbs', noteChain: [noteGroup]};

    const sm = new ScriptManager([script]);
    sm.paused = false;

    Backbone.Mediator.publish('pbs');
    expect(sm.lastNoteGroup.notes.length).toBe(7);
    const channels = ((() => {
      const result = [];
      for (note of Array.from(sm.lastNoteGroup.notes)) {         result.push(note.channel);
      }
      return result;
    })());
    expect(channels).toContain('cnn');
    expect(channels).toContain('level-bot-move');
    expect(channels).toContain('level-bot-say');
    expect(channels).toContain('level-highlight-dom');
    expect(channels).toContain('level-highlight-sprites');
    expect(channels).toContain('level-set-time');
    expect(channels).toContain('level-disable-controls');
    return sm.destroy();
  })",snuts
/test/app/lib/CoursesHelper.spec.js,IdenticalTestDescription,"{'startLine':57,'endLine':68}","it('returns object with .completed=true and .started=true', function() {
        return (() => {
          const result = [];
          for (var student of Array.from(this.members.models)) {
            var progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
            var progress = progressData.get({classroom: this.classroom, course: this.course, user: student});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",snuts
/test/app/lib/CoursesHelper.spec.js,IdenticalTestDescription,"{'startLine':70,'endLine':82}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",snuts
/test/app/lib/CoursesHelper.spec.js,IdenticalTestDescription,"{'startLine':84,'endLine':102}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            result.push((() => {
              const result1 = [];
              for (var user of Array.from(this.members.models)) {
                var progress = progressData.get({classroom: this.classroom, course: this.course, level, user});
                expect(progress.completed).toBe(true);
                result1.push(expect(progress.started).toBe(true));
              }
              return result1;
            })());
          }
          return result;
        })();
      })",snuts
/test/app/lib/CoursesHelper.spec.js,IdenticalTestDescription,"{'startLine':173,'endLine':179}","it('progressData.get({classroom, course, level, user}) returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        const level = this.levels.first();
        const progress = progressData.get({classroom: this.classroom, course: this.course, level, user: this.unfinishedMember});
        expect(progress.completed).toBe(false);
        return expect(progress.started).toBe(true);
      })",snuts
/test/app/lib/CoursesHelper.spec.js,ConditionalTestLogic,"{'startLine':75,'endLine':75}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",snuts
/test/app/lib/CoursesHelper.spec.js,ConditionalTestLogic,"{'startLine':89,'endLine':89}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            result.push((() => {
              const result1 = [];
              for (var user of Array.from(this.members.models)) {
                var progress = progressData.get({classroom: this.classroom, course: this.course, level, user});
                expect(progress.completed).toBe(true);
                result1.push(expect(progress.started).toBe(true));
              }
              return result1;
            })());
          }
          return result;
        })();
      })",snuts
/test/app/lib/CoursesHelper.spec.js,ConditionalTestLogic,"{'startLine':137,'endLine':137}","it('progressData.get({classroom, course, level}) returns object with .completed=false and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            result.push(expect(progress.completed).toBe(false));
          }
          return result;
        })();
      })",snuts
/test/app/lib/CoursesHelper.spec.js,ConditionalTestLogic,"{'startLine':164,'endLine':164}","it('progressData.get({classroom, course, level, user}) returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level, user: this.finishedMember});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",snuts
/test/app/lib/CoursesHelper.spec.js,VerboseStatement,"{'startLine':190,'endLine':215}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",snuts
/test/app/collections/Products.spec.js,ConditionalTestLogic,"{'startLine':15,'endLine':15}","it('basic_subscription products have payPalBillingPlanID set', done => $.ajax(""/db/products"")
  .done((data, textStatus, jqXHR) => {
    for (var product of Array.from(data)) {
      if (!/basic_subscription/.test(product.name)) { continue; }
      expect(product.payPalBillingPlanID).toBeDefined();
    }
    return done();
}).fail((jqXHR, textStatus, errorThrown) => {
    console.error(jqXHR, textStatus, errorThrown);
    return done(textStatus);
  }))",snuts
/test/app/views/teachers/TeacherClassView.spec.js,AnonymousTest,"{'startLine':103,'endLine':105}","it('has contents', function() {
      return expect(this.view.$el.children().length).toBeGreaterThan(0);
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,AnonymousTest,"{'startLine':426,'endLine':428}","it('shows CoursesNotAssignedModal', function() {
        return expect(this.view.openModalView).toHaveBeenCalled();
      })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,IdenticalTestDescription,"{'startLine':248,'endLine':274}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,ConditionalTestLogic,"{'startLine':189,'endLine':197}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,ConditionalTestLogic,"{'startLine':191,'endLine':197}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,ConditionalTestLogic,"{'startLine':193,'endLine':197}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,ConditionalTestLogic,"{'startLine':195,'endLine':197}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,ConditionalTestLogic,"{'startLine':260,'endLine':266}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,ConditionalTestLogic,"{'startLine':262,'endLine':266}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,ConditionalTestLogic,"{'startLine':264,'endLine':266}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,NonFunctionalStatement,"{'startLine':20,'endLine':20}","describe('/teachers/classes/:handle', function() {})",snuts
/test/app/views/teachers/TeacherClassView.spec.js,SubOptimalAssert,"{'startLine':184,'endLine':184}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,SubOptimalAssert,"{'startLine':188,'endLine':188}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,SubOptimalAssert,"{'startLine':255,'endLine':255}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,SubOptimalAssert,"{'startLine':259,'endLine':259}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,SubOptimalAssert,"{'startLine':442,'endLine':442}","it('adds students to the course instances', function() {
        expect(this.courseInstance.fakeRequests.length).toBe(1);
        const request = this.courseInstance.fakeRequests[0];
        expect(request.url).toBe(`/db/course_instance/${this.courseInstance.id}/members`);
        return expect(request.method).toBe('POST');
      })",snuts
/test/app/views/teachers/TeacherClassView.spec.js,SubOptimalAssert,"{'startLine':450,'endLine':450}","it('shows a noty if POSTing students fails', function(done) {
        this.notySpy.and.callFake(done);
        expect(this.courseInstance.fakeRequests.length).toBe(1);
        const request = this.courseInstance.fakeRequests[0];
        return request.respondWith({
          status: 500,
          responseText: JSON.stringify({ message: ""Internal Server Error"" })
        });
      })",snuts
/test/app/views/teachers/RequestQuoteView.spec.js,IdenticalTestDescription,"{'startLine':95,'endLine':95}","it('does not prevent navigating away', () => expect(_.result(view, 'onLeaveMessage')).toBeFalsy())",snuts
/test/app/views/teachers/RequestQuoteView.spec.js,SubOptimalAssert,"{'startLine':170,'endLine':170}","it('shows an error that the email already exists', function() {
        expect(view.$('#email-form-group').hasClass('has-error')).toBe(true);
        return expect(view.$('#email-form-group .error-help-block').length).toBe(1);
      })",snuts
/test/app/views/teachers/RequestQuoteView.spec.js,SubOptimalAssert,"{'startLine':265,'endLine':265}","it('shows a conversion warning', () => expect(view.$('#conversion-warning').length).toBe(1))",snuts
/test/app/views/teachers/InviteToClassroomModal.spec.js,GeneralFixture,"{'startLine':18,'endLine':18}","beforeEach(function(done) {
    window.me = (this.teacher = factories.makeUser());
    this.classroom = factories.makeClassroom({ code: ""wordsouphere"", codeCamel: ""WordSoupHere"", ownerID: this.teacher.id });
    this.recaptchaResponseToken = '1234';
    modal = new InviteToClassroomModal({ classroom: this.classroom });
    modal.recaptchaResponseToken = this.recaptchaResponseToken;
    jasmine.demoModal(modal);
    modal.render();
    return _.defer(done);
  })",snuts
/test/app/views/teachers/EditStudentModal.spec.js,GeneralFixture,"{'startLine':45,'endLine':45}","beforeEach(function(done) {
      user = factories.makeUser({ email , emailVerified: false });
      const classroom = factories.makeClassroom();
      modal = new EditStudentModal({ user, classroom });
      const request = jasmine.Ajax.requests.mostRecent();
      request.respondWith({ status: 200, responseText: JSON.stringify(user) });
      jasmine.demoModal(modal);
      modal.render();
      return _.defer(done);
    })",snuts
/test/app/views/teachers/EditStudentModal.spec.js,IdenticalTestDescription,"{'startLine':55,'endLine':59}","it(""has a new password field"", function() {
      if (modal.$('.new-password-input').length < 1) {
        return fail(""Expected there to be a new password input field"");
      }
    })",snuts
/test/app/views/teachers/EditStudentModal.spec.js,IdenticalTestDescription,"{'startLine':61,'endLine':65}","it(""has a change password button"", function() {
      if (modal.$('.change-password-btn').length < 1) {
        return fail(""Expected there to be a Change Password button"");
      }
    })",snuts
/test/app/views/teachers/EditStudentModal.spec.js,ConditionalTestLogic,"{'startLine':31,'endLine':33}","it(""has a new password field"", function() {
      if (modal.$('.new-password-input').length < 1) {
        return fail(""Expected there to be a new password input field"");
      }
    })",snuts
/test/app/views/teachers/EditStudentModal.spec.js,ConditionalTestLogic,"{'startLine':37,'endLine':39}","it(""has a change password button"", function() {
      if (modal.$('.change-password-btn').length < 1) {
        return fail(""Expected there to be a Change Password button"");
      }
    })",snuts
/test/app/views/teachers/EditStudentModal.spec.js,ConditionalTestLogic,"{'startLine':56,'endLine':58}","it(""has a new password field"", function() {
      if (modal.$('.new-password-input').length < 1) {
        return fail(""Expected there to be a new password input field"");
      }
    })",snuts
/test/app/views/teachers/EditStudentModal.spec.js,ConditionalTestLogic,"{'startLine':62,'endLine':64}","it(""has a change password button"", function() {
      if (modal.$('.change-password-btn').length < 1) {
        return fail(""Expected there to be a Change Password button"");
      }
    })",snuts
/test/app/views/teachers/CreateTeacherAccountView.spec.js,AnonymousTest,"{'startLine':12,'endLine':19}","it('displays CreateTeacherAccountView', function() {
    spyOn(me, 'isAnonymous').and.returnValue(true);
    spyOn(application.router, 'routeDirectly');
    Backbone.history.loadUrl('/teachers/signup');
    expect(application.router.routeDirectly.calls.count()).toBe(1);
    const args = application.router.routeDirectly.calls.argsFor(0);
    return expect(args[0]).toBe('teachers/CreateTeacherAccountView');
  })",snuts
/test/app/views/teachers/CreateTeacherAccountView.spec.js,IdenticalTestDescription,"{'startLine':193,'endLine':196}","it('logs them in and redirects them to the ConvertToTeacherAccountView', function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return expect(request.url).toBe('/auth/login-gplus');
        })",snuts
/test/app/views/teachers/CreateTeacherAccountView.spec.js,IdenticalTestDescription,"{'startLine':205,'endLine':206}","it('disables and fills in the email, first name, last name and password fields', () => ['email', 'firstName', 'lastName', 'password1', 'password2'].map((field) =>
          expect(view.$(`input[name='${field}']`).attr('disabled')).toBeTruthy()))",snuts
/test/app/views/teachers/CreateTeacherAccountView.spec.js,IdenticalTestDescription,"{'startLine':208,'endLine':211}","it('hides the social login buttons and shows a success message', function() {
          expect(view.$('#gplus-logged-in-row').hasClass('hide')).toBe(false);
          return expect(view.$('#social-network-signups').hasClass('hide')).toBe(true);
        })",snuts
/test/app/views/teachers/CreateTeacherAccountView.spec.js,IdenticalTestDescription,"{'startLine':262,'endLine':262}","it('does not prevent navigating away', () => expect(_.result(view, 'onLeaveMessage')).toBeFalsy())",snuts
/test/app/views/teachers/CreateTeacherAccountView.spec.js,SubOptimalAssert,"{'startLine':90,'endLine':90}","it('opens the log in modal', function() {
    spyOn(view, 'openModalView');
    view.$('.alert .login-link').click();
    expect(view.openModalView.calls.count()).toBe(1);
    const AuthModal = require('views/core/AuthModal');
    return expect(view.openModalView.calls.argsFor(0)[0] instanceof AuthModal).toBe(true);
  })",snuts
/test/app/views/teachers/CreateTeacherAccountView.spec.js,VerifyInSetup,"{'startLine':96,'endLine':102}","beforeEach(function() {
        application.facebookHandler.fakeAPI();
        view.$('#facebook-signup-btn').click();
        const request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user?facebookID=abcd&facebookAccessToken=1234');
        return expect(request.method).toBe('GET');
      })",snuts
/test/app/views/teachers/CreateTeacherAccountView.spec.js,VerifyInSetup,"{'startLine':176,'endLine':182}","beforeEach(function() {
        application.gplusHandler.fakeAPI();
        view.$('#gplus-signup-btn').click();
        const request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user?gplusID=abcd&gplusAccessToken=1234&email=some%40email.com');
        return expect(request.method).toBe('GET');
      })",snuts
/test/app/views/teachers/CreateTeacherAccountView.spec.js,VerifyInSetup,"{'startLine':310,'endLine':325}","beforeEach(function(done) {
          spyOn(application.router, 'navigate');
          spyOn(application.router, 'reload');
          let request = jasmine.Ajax.requests.mostRecent();
          request.respondWith({
            status: 201,
            responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
          });
          expect(request.url).toBe('/db/user/1234');
          return view.once('signup', () => {
            request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/user/1234/signup-with-password');
            request.respondWith({ status: 201, responseText: '{}' });
            return view.once('on-trial-request-submit-complete', done);
          });
        })",snuts
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,AnonymousTest,"{'startLine':21,'endLine':29}","it('displays ConvertToTeacherAccountView', function() {
    spyOn(me, 'isAnonymous').and.returnValue(false);
    spyOn(me, 'isTeacher').and.returnValue(false);
    spyOn(application.router, 'routeDirectly');
    Backbone.history.loadUrl('/teachers/update-account');
    expect(application.router.routeDirectly.calls.count()).toBe(1);
    const args = application.router.routeDirectly.calls.argsFor(0);
    return expect(args[0]).toBe('teachers/ConvertToTeacherAccountView');
  })",snuts
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,AnonymousTest,"{'startLine':126,'endLine':133}","it('requires confirmation', function() {
        expect(view.trialRequest.fakeRequests.length).toBe(0);
        const confirmModal = view.openModalView.calls.argsFor(0)[0];
        confirmModal.trigger('confirm');
        const request = _.last(view.trialRequest.fakeRequests);
        expect(request.url).toBe('/db/trial.request');
        return expect(request.method).toBe('POST');
      })",snuts
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,AnonymousTest,"{'startLine':189,'endLine':196}","it('unsubscribes user', function() {
      const request = _.last(view.trialRequest.fakeRequests);
      request.respondWith({
        status: 201,
        responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
      });
      return expect(me.unsubscribe).toHaveBeenCalled();
    })",snuts
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,IdenticalTestDescription,"{'startLine':157,'endLine':157}","it('does not prevent navigating away', () => expect(_.result(view, 'onLeaveMessage')).toBeFalsy())",snuts
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,SubOptimalAssert,"{'startLine':112,'endLine':112}","it('shows a warning that they will convert to a teacher account', () => expect(view.$('#conversion-warning').length).toBe(1))",snuts
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,SubOptimalAssert,"{'startLine':127,'endLine':127}","it('requires confirmation', function() {
        expect(view.trialRequest.fakeRequests.length).toBe(0);
        const confirmModal = view.openModalView.calls.argsFor(0)[0];
        confirmModal.trigger('confirm');
        const request = _.last(view.trialRequest.fakeRequests);
        expect(request.url).toBe('/db/trial.request');
        return expect(request.method).toBe('POST');
      })",snuts
/test/app/views/teachers/ActivateLicensesModal.spec.js,ConditionalTestLogic,"{'startLine':115,'endLine':117}","it('enrolls the selected students with the selected prepaid', function() {
          const request = jasmine.Ajax.requests.mostRecent();
          if (request.url.indexOf(this.prepaidThatExpiresSooner.id) === -1) {
            fail('The first prepaid should be the prepaid that expires sooner');
          }
          return request.respondWith({ status: 200, responseText: '{ ""redeemers"": [{}] }' });
        })",snuts
/test/app/views/teachers/ActivateLicensesModal.spec.js,SubOptimalAssert,"{'startLine':73,'endLine':73}","it('contains all of the teacher\'s classes', function() {
      return expect(this.modal.$('select option').length).toBe(3);
    })",snuts
/test/app/views/core/CreateAccountModal.spec.js,AnonymousTest,"{'startLine':118,'endLine':124}","it('is memoized', function() {
        const promise1 = segmentCheckView.fetchClassByCode('testA');
        const promise2 = segmentCheckView.fetchClassByCode('testA');
        const promise3 = segmentCheckView.fetchClassByCode('testB');
        expect(promise1).toBe(promise2);
        return expect(promise1).not.toBe(promise3);
      })",snuts
/test/app/views/core/CreateAccountModal.spec.js,AnonymousTest,"{'startLine':234,'endLine':234}","it('shows checking', () => expect(basicInfoView.$('[data-i18n=""signup.checking""]').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,AnonymousTest,"{'startLine':270,'endLine':270}","it('shows checking', () => expect(basicInfoView.$('[data-i18n=""signup.checking""]').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,AnonymousTest,"{'startLine':428,'endLine':428}","it('calls finishSignup()', () => expect(basicInfoView.finishSignup).toHaveBeenCalled())",snuts
/test/app/views/core/CreateAccountModal.spec.js,CommentsOnlyTest,"{'startLine':345,'endLine':345}","it('re-enables the form and shows which field failed', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,CommentsOnlyTest,"{'startLine':488,'endLine':488}","it('(for demo testing)', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,GeneralFixture,"{'startLine':151,'endLine':151}","beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          expect(_.string.startsWith(request.url, '/db/classroom')).toBe(false);
          modal.$('.class-code-input').val('test').trigger('input');
          modal.$('form.segment-check').submit();
          classCodeRequest = jasmine.Ajax.requests.mostRecent();
          return expect(_.string.startsWith(classCodeRequest.url, '/db/classroom')).toBe(true);
        })",snuts
/test/app/views/core/CreateAccountModal.spec.js,IdenticalTestDescription,"{'startLine':270,'endLine':270}","it('shows checking', () => expect(basicInfoView.$('[data-i18n=""signup.checking""]').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,IdenticalTestDescription,"{'startLine':468,'endLine':472}","it('(for demo testing)', function() {
      me.set('name', 'A Sweet New Username');
      me.set('email', 'some@email.com');
      return singleSignOnConfirmView.signupState.set('ssoUsed', 'facebook');
    })",snuts
/test/app/views/core/CreateAccountModal.spec.js,IdenticalTestDescription,"{'startLine':488,'endLine':488}","it('(for demo testing)', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':169,'endLine':169}","describe('on the BasicInfoView for students', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':345,'endLine':345}","it('re-enables the form and shows which field failed', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':488,'endLine':488}","it('(for demo testing)', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':547,'endLine':547}","describe('clearDistrictNcesValues', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':549,'endLine':549}","describe('clearSchoolNcesValues', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':658,'endLine':658}","describe('clickContinue', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':660,'endLine':660}","describe('clickBack', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':663,'endLine':663}","describe('NcesSearchInput', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':665,'endLine':665}","describe('SetupAccountPanel', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,NonFunctionalStatement,"{'startLine':667,'endLine':667}","describe('TeacherRolePanel', function() {})",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':97,'endLine':97}","it('has a birthdate form', () => expect(modal.$('.birthday-form-group').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':111,'endLine':111}","it('has a classCode input', () => expect(modal.$('.class-code-input').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':182,'endLine':182}","it('shows an error', () => expect(modal.$('[data-i18n=""signup.classroom_not_found""]').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':203,'endLine':203}","it('shows an input for a parent\'s email address to sign up their child', () => expect(modal.$('#parent-email-input').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':234,'endLine':234}","it('shows checking', () => expect(basicInfoView.$('[data-i18n=""signup.checking""]').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':246,'endLine':246}","it('says an account already exists and encourages to sign in', function() {
          expect(basicInfoView.$('[data-i18n=""signup.account_exists""]').length).toBe(1);
          return expect(basicInfoView.$('.login-link[data-i18n=""signup.sign_in""]').length).toBe(1);
        })",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':247,'endLine':247}","it('says an account already exists and encourages to sign in', function() {
          expect(basicInfoView.$('[data-i18n=""signup.account_exists""]').length).toBe(1);
          return expect(basicInfoView.$('.login-link[data-i18n=""signup.sign_in""]').length).toBe(1);
        })",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':260,'endLine':260}","it('says email looks good', () => expect(basicInfoView.$('[data-i18n=""signup.email_good""]').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':270,'endLine':270}","it('shows checking', () => expect(basicInfoView.$('[data-i18n=""signup.checking""]').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':293,'endLine':293}","it('says name looks good', () => expect(basicInfoView.$('[data-i18n=""signup.name_available""]').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':302,'endLine':302}","it('shows required errors for empty fields when on INDIVIDUAL path', function() {
        modal.signupState.set('path', 'individual');
        basicInfoView.$('input').val('');
        basicInfoView.$('#basic-info-form').submit();
        return expect(basicInfoView.$('.form-group.has-error').length).toBe(3);
      })",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':309,'endLine':309}","it('shows required errors for empty fields when on STUDENT path', function() {
        modal.signupState.set('path', 'student');
        modal.render();
        basicInfoView.$('#basic-info-form').submit();
        return expect(basicInfoView.$('.form-group.has-error').length).toBe(4);
      })",snuts
/test/app/views/core/CreateAccountModal.spec.js,SubOptimalAssert,"{'startLine':384,'endLine':384}","it('displays the server error', () => expect(basicInfoView.$('.alert-danger').length).toBe(1))",snuts
/test/app/views/core/CreateAccountModal.spec.js,VerboseStatement,"{'startLine':639,'endLine':655}","it('Commits all of the important values', function() {
        this.schoolInfoPanel.commitValues();
        const [storeName, attrs] = Array.from(this.store.commit.calls.argsFor(0));
        expect(storeName).toBe('modal/updateTrialRequestProperties');
        expect(attrs.organization).toBe('some name');
        expect(attrs.district).toBe('some district');
        expect(attrs.city).toBe('some city');
        expect(attrs.state).toBe('some state');
        expect(attrs.country).toBe('some country');
        expect(attrs.nces_id).toBe('some nces_id');
        expect(attrs.nces_name).toBe('some name');
        expect(attrs.nces_students).toBe('some students');
        expect(attrs.nces_phone).toBe('some nces_phone');
        expect(attrs.nces_district_id).toBe('some nces_district_id');
        expect(attrs.nces_district_schools).toBe('some nces_district_schools');
        return expect(attrs.nces_district_students).toBe('some nces_district_students');
      })",snuts
/test/app/views/core/CreateAccountModal.spec.js,VerifyInSetup,"{'startLine':146,'endLine':153}","beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          expect(_.string.startsWith(request.url, '/db/classroom')).toBe(false);
          modal.$('.class-code-input').val('test').trigger('input');
          modal.$('form.segment-check').submit();
          classCodeRequest = jasmine.Ajax.requests.mostRecent();
          return expect(_.string.startsWith(classCodeRequest.url, '/db/classroom')).toBe(true);
        })",snuts
/test/app/views/core/CocoView.spec.js,AnonymousTest,"{'startLine':65,'endLine':65}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,AnonymousTest,"{'startLine':99,'endLine':99}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,AnonymousTest,"{'startLine':127,'endLine':127}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,AnonymousTest,"{'startLine':140,'endLine':140}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,AnonymousTest,"{'startLine':152,'endLine':152}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,AnonymousTest,"{'startLine':162,'endLine':162}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,AnonymousTest,"{'startLine':174,'endLine':174}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,IdenticalTestDescription,"{'startLine':99,'endLine':99}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,IdenticalTestDescription,"{'startLine':127,'endLine':127}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,IdenticalTestDescription,"{'startLine':140,'endLine':140}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,IdenticalTestDescription,"{'startLine':152,'endLine':152}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,IdenticalTestDescription,"{'startLine':162,'endLine':162}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,IdenticalTestDescription,"{'startLine':172,'endLine':172}","it('shows a message encouraging refreshing the page or following links', () => expect(view.$('[data-i18n=""loading_error.general_desc""]').length).toBeTruthy())",snuts
/test/app/views/core/CocoView.spec.js,IdenticalTestDescription,"{'startLine':174,'endLine':174}","it('(demo)', () => jasmine.demoEl(view.$el))",snuts
/test/app/views/core/CocoView.spec.js,SubOptimalAssert,"{'startLine':77,'endLine':77}","it('shows a login button which opens the AuthModal', function() {
      const button = view.$el.find('.login-btn');
      expect(button.length).toBe(1);
      spyOn(view, 'openModalView').and.callFake(function(modal) {
        expect(modal instanceof AuthModal).toBe(true);
        return modal.stopListening();
      });
      button.click();
      return expect(view.openModalView).toHaveBeenCalled();
    })",snuts
/test/app/views/core/CocoView.spec.js,SubOptimalAssert,"{'startLine':79,'endLine':79}","it('shows a login button which opens the AuthModal', function() {
      const button = view.$el.find('.login-btn');
      expect(button.length).toBe(1);
      spyOn(view, 'openModalView').and.callFake(function(modal) {
        expect(modal instanceof AuthModal).toBe(true);
        return modal.stopListening();
      });
      button.click();
      return expect(view.openModalView).toHaveBeenCalled();
    })",snuts
/test/app/views/core/CocoView.spec.js,SubOptimalAssert,"{'startLine':88,'endLine':88}","it('shows a create account button which opens the CreateAccountModal', function() {
      const button = view.$el.find('#create-account-btn');
      expect(button.length).toBe(1);
      spyOn(view, 'openModalView').and.callFake(function(modal) {
        expect(modal instanceof CreateAccountModal).toBe(true);
        return modal.stopListening();
      });
      button.click();
      return expect(view.openModalView).toHaveBeenCalled();
    })",snuts
/test/app/views/core/CocoView.spec.js,SubOptimalAssert,"{'startLine':90,'endLine':90}","it('shows a create account button which opens the CreateAccountModal', function() {
      const button = view.$el.find('#create-account-btn');
      expect(button.length).toBe(1);
      spyOn(view, 'openModalView').and.callFake(function(modal) {
        expect(modal instanceof CreateAccountModal).toBe(true);
        return modal.stopListening();
      });
      button.click();
      return expect(view.openModalView).toHaveBeenCalled();
    })",snuts
/test/app/views/core/CocoView.spec.js,SubOptimalAssert,"{'startLine':121,'endLine':121}","it('includes a logout button which logs out the account', function() {
      const button = view.$el.find('#logout-btn');
      expect(button.length).toBe(1);
      button.click();
      const request = jasmine.Ajax.requests.mostRecent();
      return expect(request.url).toBe('/auth/logout');
    })",snuts
/test/app/views/core/CocoView.spec.js,SubOptimalAssert,"{'startLine':137,'endLine':137}","it('includes one of the 404 images', function() {
      const img = view.$el.find('#not-found-img');
      return expect(img.length).toBe(1);
    })",snuts
/test/app/views/core/CocoView.spec.js,VerifyInSetup,"{'startLine':51,'endLine':55}","beforeEach(function() {
      view.render();
      expect(view.$('#content').hasClass('hidden')).toBe(true);
      return respond(400);
    })",snuts
/test/app/views/core/AuthModal.spec.js,AnonymousTest,"{'startLine':32,'endLine':32}","it('(demo)', () => jasmine.demoModal(modal))",snuts
/test/app/views/core/AuthModal.spec.js,SubOptimalAssert,"{'startLine':29,'endLine':29}","it('opens the recover modal when you click the recover link', function() {
    spyOn(modal, 'openModalView');
    modal.$el.find('#link-to-recover').click();
    expect(modal.openModalView.calls.count()).toEqual(1);
    const args = modal.openModalView.calls.argsFor(0);
    return expect(args[0] instanceof RecoverModal).toBeTruthy();
  })",snuts
/test/app/views/courses/TeachersContactModal.spec.js,AnonymousTest,"{'startLine':51,'endLine':54}","it('disables inputs', function() {
      return Array.from(this.modal.$('button, input, textarea')).map((el) =>
        expect($(el).is(':disabled')).toBe(true));
    })",snuts
/test/app/views/courses/TeachersContactModal.spec.js,SubOptimalAssert,"{'startLine':63,'endLine':63}","it('shows an error', function() {
        return expect(this.modal.$('.alert-danger').length).toBe(1);
      })",snuts
/test/app/views/courses/TeachersContactModal.spec.js,SubOptimalAssert,"{'startLine':74,'endLine':74}","it('shows a success message', function() {
        return expect(this.modal.$('.alert-success').length).toBe(1);
      })",snuts
/test/app/views/courses/TeacherCoursesView.spec.js,SubOptimalAssert,"{'startLine':43,'endLine':43}","it('opens HeroSelectModal for the first level of the first course', function(done) {
      spyOn(view, 'openModalView').and.callFake(modal => modal);
      spyOn(application.router, 'navigate');
      view.$('.play-level-button').first().click();
      expect(view.openModalView).toHaveBeenCalled();
      expect(application.router.navigate).not.toHaveBeenCalled();
      const args = view.openModalView.calls.argsFor(0);
      const modalView = args[0];
      expect(modalView instanceof HeroSelectModal).toBe(true);
      modalView.trigger('hero-select:success');
      expect(application.router.navigate).not.toHaveBeenCalled();
      modalView.trigger('hide');
      modalView.trigger('hidden');
      return _.defer(function() {
        expect(application.router.navigate).toHaveBeenCalled();
        return done();
      });
    })",snuts
/test/app/views/courses/HeroSelectModal.spec.js,SubOptimalAssert,"{'startLine':42,'endLine':42}","it('saves when you change heroes', function(done) {
    modal.$(`.hero-option[data-hero-original='${hero2.get('original')}']`).click();
    return setTimeout(function() { // TODO Webpack: Figure out how to not need this race condition
      expect(user.fakeRequests.length).toBe(1);
      const request = user.fakeRequests[0];
      expect(request != null ? request.method : undefined).toBe(""PUT"");
      expect(__guard__(JSON.parse(request != null ? request.params : undefined).heroConfig, x => x.thangType)).toBe(hero2.get('original'));
      return done();
    }
    , 500);
  })",snuts
/test/app/views/courses/EnrollmentsView.spec.js,IdenticalTestDescription,"{'startLine':169,'endLine':171}","it(""doesn't show the Starter License upsell"", function() {
      return expect(this.view.$('a[href=""/teachers/starter-licenses""]').length).toBe(0);
    })",snuts
/test/app/views/courses/EnrollmentsView.spec.js,ConditionalTestLogic,"{'startLine':180,'endLine':182}","it('shows confirmation and a mailto link to schools@codecombat.com', function() {
        if (!this.view.$('#request-sent-btn').length) {
          fail('Request button not found.');
        }
        if (!this.view.$('#enrollment-request-sent-blurb').length) {
          return fail('License request sent blurb not found.');
        }
      })",snuts
/test/app/views/courses/EnrollmentsView.spec.js,ConditionalTestLogic,"{'startLine':183,'endLine':185}","it('shows confirmation and a mailto link to schools@codecombat.com', function() {
        if (!this.view.$('#request-sent-btn').length) {
          fail('Request button not found.');
        }
        if (!this.view.$('#enrollment-request-sent-blurb').length) {
          return fail('License request sent blurb not found.');
        }
      })",snuts
/test/app/views/courses/EnrollmentsView.spec.js,SubOptimalAssert,"{'startLine':134,'endLine':134}","it('when full licenses have existed', function() {
        this.view.prepaids.set([]);
        this.view.prepaids.add(factories.makePrepaid({
          startDate: moment().subtract(2, 'month').toISOString(),
          endDate: moment().subtract(1, 'month').toISOString()
        }));

        this.view.render();
        return expect(this.view.$('a[href=""/teachers/starter-licenses""]').length).toBe(0);
      })",snuts
/test/app/views/courses/EnrollmentsView.spec.js,SubOptimalAssert,"{'startLine':145,'endLine':145}","it('when full licenses currently exist', function() {
        this.view.prepaids.set([]);
        this.view.prepaids.add(factories.makePrepaid({
          startDate: moment().subtract(2, 'month').toISOString(),
          endDate: moment().add(1, 'month').toISOString()
        }));

        this.view.render();
        return expect(this.view.$('a[href=""/teachers/starter-licenses""]').length).toBe(0);
      })",snuts
/test/app/views/courses/EnrollmentsView.spec.js,SubOptimalAssert,"{'startLine':158,'endLine':158}","it(""doesn't show the Starter License upsell"", function() {
      return expect(this.view.$('a[href=""/teachers/starter-licenses""]').length).toBe(0);
    })",snuts
/test/app/views/courses/EnrollmentsView.spec.js,SubOptimalAssert,"{'startLine':170,'endLine':170}","it(""doesn't show the Starter License upsell"", function() {
      return expect(this.view.$('a[href=""/teachers/starter-licenses""]').length).toBe(0);
    })",snuts
/test/app/views/courses/EnrollmentsView.spec.js,SubOptimalAssert,"{'startLine':200,'endLine':200}","it('fills the void with the rest of the page content', function() {
        return expect(this.view.$('#actions-col').length).toBe(0);
      })",snuts
/test/app/views/courses/CoursesView.spec.js,SubOptimalAssert,"{'startLine':38,'endLine':38}","it('opens the modal when you click Change Hero', function() {
      spyOn(view, 'openModalView');
      view.$('.change-hero-btn').click();
      expect(view.openModalView).toHaveBeenCalled();
      const args = view.openModalView.calls.argsFor(0);
      return expect(args[0] instanceof HeroSelectModal).toBe(true);
    })",snuts
/test/app/views/courses/CoursesUpdateAccountView.spec.js,IdenticalTestDescription,"{'startLine':59,'endLine':61}","it('shows update to teacher button', function() {
      return expect(this.view.$el.find('.update-teacher-btn').length).toEqual(1);
    })",snuts
/test/app/views/courses/CoursesUpdateAccountView.spec.js,VerifyInSetup,"{'startLine':25,'endLine':31}","beforeEach(function(done) {
      me.set(factories.makeUser({}).attributes);
      this.view = new CoursesUpdateAccountView();
      this.view.render();
      expect(this.view.$el.find('.login-btn').length).toEqual(0);
      return done();
    })",snuts
/test/app/views/courses/CoursesUpdateAccountView.spec.js,VerifyInSetup,"{'startLine':44,'endLine':52}","beforeEach(function(done) {
      me.set(factories.makeUser({role: 'student'}).attributes);
      this.view = new CoursesUpdateAccountView();
      this.view.render();
      expect(this.view.$el.find('.login-btn').length).toEqual(0);
      expect(this.view.$el.find('.remain-teacher-btn').length).toEqual(0);
      expect(this.view.$el.find('.logout-btn').length).toEqual(1);
      return done();
    })",snuts
/test/app/views/courses/CoursesUpdateAccountView.spec.js,VerifyInSetup,"{'startLine':65,'endLine':72}","beforeEach(function(done) {
      me.set(factories.makeUser({role: 'teacher'}).attributes);
      this.view = new CoursesUpdateAccountView();
      this.view.render();
      expect(this.view.$el.find('.login-btn').length).toEqual(0);
      expect(this.view.$el.find('.remain-student-btn').length).toEqual(0);
      return done();
    })",snuts
/test/app/views/courses/CourseVideosComponent.spec.js,ConditionalTestLogic,"{'startLine':39,'endLine':45}","it('shows the videos and concept text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').length).toBe(3)
    const me = factories.makeUser({})
    if (me.showChinaVideo()) {
      expect(wrapper.findAll('video').exists()).toBe(true)
      expect(wrapper.findAll('video').length).toBe(3)
    } else {
      expect(wrapper.findAll('.video').exists()).toBe(true)
      expect(wrapper.findAll('.video').length).toBe(3)
    }
  })",snuts
/test/app/views/courses/CourseVideosComponent.spec.js,SubOptimalAssert,"{'startLine':37,'endLine':37}","it('shows the videos and concept text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').length).toBe(3)
    const me = factories.makeUser({})
    if (me.showChinaVideo()) {
      expect(wrapper.findAll('video').exists()).toBe(true)
      expect(wrapper.findAll('video').length).toBe(3)
    } else {
      expect(wrapper.findAll('.video').exists()).toBe(true)
      expect(wrapper.findAll('.video').length).toBe(3)
    }
  })",snuts
/test/app/views/courses/CourseVideosComponent.spec.js,SubOptimalAssert,"{'startLine':41,'endLine':41}","it('shows the videos and concept text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').length).toBe(3)
    const me = factories.makeUser({})
    if (me.showChinaVideo()) {
      expect(wrapper.findAll('video').exists()).toBe(true)
      expect(wrapper.findAll('video').length).toBe(3)
    } else {
      expect(wrapper.findAll('.video').exists()).toBe(true)
      expect(wrapper.findAll('.video').length).toBe(3)
    }
  })",snuts
/test/app/views/courses/CourseVideosComponent.spec.js,SubOptimalAssert,"{'startLine':44,'endLine':44}","it('shows the videos and concept text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').length).toBe(3)
    const me = factories.makeUser({})
    if (me.showChinaVideo()) {
      expect(wrapper.findAll('video').exists()).toBe(true)
      expect(wrapper.findAll('video').length).toBe(3)
    } else {
      expect(wrapper.findAll('.video').exists()).toBe(true)
      expect(wrapper.findAll('.video').length).toBe(3)
    }
  })",snuts
/test/app/views/account/IsraelSignupView.spec.js,SubOptimalAssert,"{'startLine':31,'endLine':31}","it('sets state.fatalError to ""missing-input"" if the proper query parameters are not provided', function() {
    let queryVariables = null;
    spyOn(me, 'isAnonymous').and.returnValue(true);
    spyOn(utils, 'getQueryVariables').and.callFake(() => queryVariables);

    // no inputs
    queryVariables = {};
    expect(new IsraelSignupView().state.get('fatalError')).toBe('missing-input');
    
    // id and email but email is not valid
    queryVariables = { email: 'notanemail', israelId: '...' };
    expect(new IsraelSignupView().state.get('fatalError')).toBe('invalid-email');

    // valid inputs
    queryVariables = { email: 'test@email.com', israelId: '...' };
    return expect(new IsraelSignupView().state.get('fatalError')).toBe(null);
  })",snuts
/test/app/lib/surface/SingularSprite.spec.js,VerboseStatement,"{'startLine':147,'endLine':165}","it('scales placeholder animations like a MovieClip, taking into account ThangType scaling', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      singularSprite.usePlaceholders = true;
      singularSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.71);
      return $('canvas').remove();
    })",snuts
/test/app/lib/surface/SegmentedSprite.spec.js,SubOptimalAssert,"{'startLine':240,'endLine':240}","it('maintains the right number of shapes', function() {
      segmentedSprite.gotoAndPlay('idle');
      const lengths = [];
      return (() => {
        const result = [];
        for (var i of Array.from(_.range(10))) {
          segmentedSprite.tick(10);
          result.push(expect(segmentedSprite.children.length).toBe(20));
        }
        return result;
      })();
    })",snuts
/test/app/lib/surface/SegmentedSprite.spec.js,VerboseStatement,"{'startLine':160,'endLine':180}","it('scales rendered animations like a MovieClip', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);

      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.91);
      expect(segmentedSprite.baseScaleX).toBe(0.3);
      expect(segmentedSprite.baseScaleY).toBe(0.3);
      return $('canvas').remove();
    })",snuts
/test/app/lib/surface/SegmentedSprite.spec.js,VerboseStatement,"{'startLine':182,'endLine':197}","it('scales placeholder animations like a MovieClip', function() {
      segmentedSprite.usePlaceholders = true;
      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.96);
      return $('canvas').remove();
    })",snuts
/test/app/lib/surface/LayerAdapter.spec.js,SubOptimalAssert,"{'startLine':76,'endLine':76}","it('only renders frames used by actions when spriteType=singular', function() {
    const oldDefaults = ThangType.defaultActions;
    ThangType.defaultActions = ['idle']; // uses the move side animation
    ogreMunchkinThangType.set('spriteType', 'singular');
    const colorConfig = {team: {hue: 0, saturation: 1, lightness: 0.5}};
    const sprite = new Lank(ogreMunchkinThangType, {colorConfig});
    layer.addLank(sprite);
    const sheet = layer.renderNewSpriteSheet();
    const key = layer.renderGroupingKey(ogreMunchkinThangType, 'idle', colorConfig);
    const animations = sheet.getAnimations();
    expect(animations.length).toBe(1);
    expect(animations[0]).toBe(key);
    expect(sheet.getNumFrames()).toBe(2); // one idle frame, and the emptiness frame
    return ThangType.defaultActions = oldDefaults;
  })",snuts
/test/app/lib/surface/LayerAdapter.spec.js,VerboseStatement,"{'startLine':107,'endLine':122}","it('loads raster images for ThangType', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    spyOn(thangType, 'loadRasterImage');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': bootsThangTypeData});
    spyOn(layer, 'renderNewSpriteSheet');
    expect(layer.numThingsLoading).toBe(1);
    expect(thangType.loadRasterImage).toHaveBeenCalled();
    thangType.loadedRaster = true;
    thangType.trigger('raster-image-loaded', thangType);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer.renderNewSpriteSheet).toHaveBeenCalled();
  })",snuts
/test/app/lib/surface/LayerAdapter.spec.js,VerboseStatement,"{'startLine':124,'endLine':144}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",snuts
/test/app/lib/surface/LankBoss.spec.js,ConditionalTestLogic,"{'startLine':155,'endLine':157}","it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })())",snuts
/test/app/lib/surface/Camera.spec.js,ConditionalTestLogic,"{'startLine':107,'endLine':107}","it('handles lots of different cases correctly', () => Array.from(testWops).map((wop) =>
    Array.from(testCanvasSizes).map((size) =>
      Array.from(testZooms).map((zoom) =>
        Array.from(testZoomTargets).map((target) =>
          Array.from(testAngles).map((angle) =>
            (() => {
              const result = [];
              for (var fov of Array.from(testFOVs)) {
                var cam = new Camera({attr(attr) { if ('attr' === 'width') { return size.width; } else { return size.height; } }}, angle, fov);
                checkCameraPos(cam, wop);
                cam.zoomTo(target, zoom, 0);
                checkConversionsFromWorldPos(wop, cam);
                result.push(checkCameraPos(cam, wop));
              }
              return result;
            })()))))))",snuts
/test/app/lib/surface/Camera.spec.js,ConditionalTestLogic,"{'startLine':177,'endLine':177}","it('works at 2x zoom, 60 degree hFOV, 40 degree vFOV', function() {
    const cam = new Camera({attr(attr) { if (attr === 'height') { return 63.041494; } else { return 100; } }}, null, Math.PI / 3);
    cam.zoomTo(null, 2, 0);
    return checkCameraPos(cam);
  })",snuts
/test/app/lib/world/vector.spec.js,AnonymousTest,"{'startLine':10,'endLine':19}","it('rotates properly', function() {
    const v = new Vector(200, 300);
    v.rotate(Math.PI / 2);
    expect(v.x).toBeCloseTo(-300);
    expect(v.y).toBeCloseTo(200);

    v.rotate(Math.PI / 4);
    expect(v.x).toBeCloseTo(-250 * Math.sqrt(2));
    return expect(v.y).toBeCloseTo(-50 * Math.sqrt(2));
  })",snuts
/test/app/lib/world/vector.spec.js,VerboseStatement,"{'startLine':38,'endLine':60}","it('has class methods equivalent to the instance methods', function() {
    const expectEquivalentMethods = function(method, arg) {
      const v = new Vector(7, 7);
      const classResult = Vector[method](v, arg);
      const instanceResult = v[method](arg);
      return expect(classResult).toEqual(instanceResult);
    };

    expectEquivalentMethods('add', new Vector(1, 1));
    expectEquivalentMethods('subtract', new Vector(3, 3));
    expectEquivalentMethods('multiply', 4);
    expectEquivalentMethods('divide', 2);
    expectEquivalentMethods('limit', 3);
    expectEquivalentMethods('normalize');
    expectEquivalentMethods('rotate', 0.3);
    expectEquivalentMethods('magnitude');
    expectEquivalentMethods('heading');
    expectEquivalentMethods('distance', new Vector(2, 2));
    expectEquivalentMethods('distanceSquared', new Vector(4, 4));
    expectEquivalentMethods('dot', new Vector(3, 3));
    expectEquivalentMethods('equals', new Vector(7, 7));
    return expectEquivalentMethods('copy');
  })",snuts
/test/app/lib/world/line_segment.spec.js,AnonymousTest,"{'startLine':18,'endLine':21}","it('intersects itself', function() {
    const lineSegment = new LineSegment(v00, v34);
    return expect(lineSegment.intersectsLineSegment(lineSegment)).toBe(true);
  })",snuts
/test/app/lib/world/ellipse.spec.js,VerboseStatement,"{'startLine':22,'endLine':43}","it('contains more points properly', function() {
    // ellipse with y major axis, off-origin center, and 45 degree rotation
    const ellipse = new Ellipse(1, 2, 4, 6, Math.PI / 4);
    expect(ellipse.containsPoint(new Vector(1, 2))).toBe(true);
    expect(ellipse.containsPoint(new Vector(-1, 3))).toBe(true);
    expect(ellipse.containsPoint(new Vector(0, 4))).toBe(true);
    expect(ellipse.containsPoint(new Vector(1, 4))).toBe(true);
    expect(ellipse.containsPoint(new Vector(3, 0))).toBe(true);
    expect(ellipse.containsPoint(new Vector(1, 0))).toBe(true);
    expect(ellipse.containsPoint(new Vector(0, 1))).toBe(true);
    expect(ellipse.containsPoint(new Vector(-1, 2))).toBe(true);
    expect(ellipse.containsPoint(new Vector(2, 2))).toBe(true);
    expect(ellipse.containsPoint(new Vector(0, 0))).toBe(false);
    expect(ellipse.containsPoint(new Vector(0, 5))).toBe(false);
    expect(ellipse.containsPoint(new Vector(3, 4))).toBe(false);
    expect(ellipse.containsPoint(new Vector(4, 0))).toBe(false);
    expect(ellipse.containsPoint(new Vector(2, -1))).toBe(false);
    expect(ellipse.containsPoint(new Vector(0, -3))).toBe(false);
    expect(ellipse.containsPoint(new Vector(-2, -2))).toBe(false);
    expect(ellipse.containsPoint(new Vector(-2, 0))).toBe(false);
    return expect(ellipse.containsPoint(new Vector(-2, 4))).toBe(false);
  })",snuts
/test/app/lib/cinematic/DialogSystem.spec.js,AnonymousTest,"{'startLine':56,'endLine':66}","it('handle markdown', () => {
      const tests = [
        [`Hey *italic*!`, `<div><p><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">H</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">y</span></span> <em><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">i</span><span class=""letter"" style=""display: inline-block; opacity:0"">t</span><span class=""letter"" style=""display: inline-block; opacity:0"">a</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">i</span><span class=""letter"" style=""display: inline-block; opacity:0"">c</span></span></em><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">!</span></span></p></div>`],
        [`# A heading!!!`, `<div><h1 id=""a-heading-""><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">A</span></span> <span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">h</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">a</span><span class=""letter"" style=""display: inline-block; opacity:0"">d</span><span class=""letter"" style=""display: inline-block; opacity:0"">i</span><span class=""letter"" style=""display: inline-block; opacity:0"">n</span><span class=""letter"" style=""display: inline-block; opacity:0"">g</span><span class=""letter"" style=""display: inline-block; opacity:0"">!</span><span class=""letter"" style=""display: inline-block; opacity:0"">!</span><span class=""letter"" style=""display: inline-block; opacity:0"">!</span></span></h1></div>`],
        [`**bold**`, `<div><p><strong><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">b</span><span class=""letter"" style=""display: inline-block; opacity:0"">o</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">d</span></span></strong></p></div>`]
      ]

      for (const [template, expected] of tests) {
        expect(processText(dialogNode(template), {})).toEqual(expected)
      }
    })",snuts
/test/app/lib/cinematic/AbstractCommand.spec.js,NonFunctionalStatement,"{'startLine':25,'endLine':25}",Unknown,snuts
/test/app/lib/cinematic/AbstractCommand.spec.js,NonFunctionalStatement,"{'startLine':26,'endLine':26}",Unknown,snuts
/test/app/views/play/level/WebSurfaceView.spec.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}","describe('WebSurfaceView', function() {
  const view = new WebSurfaceView({ goalManager: undefined });
  view.iframeLoaded = true;
  view.iframe = {contentWindow: {postMessage() {}}};
  const studentHtml = `\
<style>
  #some-id {}
  .thing1, .thing2 {
    color: blue;
  }
  div { something: invalid }
  .element[with=""attributes""] {}
</style>
<script>
  var paragraphs = $(  \t""p"" )
  paragraphs.toggleClass(""some-class"")
  $('div').children().insertAfter($('<a> '))
</script>
<div>
  Hi there!
</div>\
`;

  return describe('onHTMLUpdated', () => it('extracts a list of all CSS selectors used', function() {
    view.onHTMLUpdated({ html: studentHtml });
    return expect(view.cssSelectors).toEqual(['#some-id', '.thing1, .thing2', 'div', '.element[with=""attributes""]', 'p', 'div']);
  }));
})",snuts
/test/app/views/play/level/HintsView.spec.js,ConditionalTestLogic,"{'startLine':67,'endLine':69}","it('filters out all code blocks but those of the selected language', function() {
    this.session.set({
      codeLanguage: 'javascript',
      playtime: 9001
    });
    this.view.state.set('hintIndex', 1);
    this.view.render();
    
    if (_.string.contains(this.view.$el.text(), 'print')) {
      fail('Python code snippet found, should be filtered out');
    }
    if (!_.string.contains(this.view.$el.text(), 'console')) {
      return fail('JavaScript code snippet not found');
    }
  })",snuts
/test/app/views/play/level/HintsView.spec.js,ConditionalTestLogic,"{'startLine':70,'endLine':72}","it('filters out all code blocks but those of the selected language', function() {
    this.session.set({
      codeLanguage: 'javascript',
      playtime: 9001
    });
    this.view.state.set('hintIndex', 1);
    this.view.render();
    
    if (_.string.contains(this.view.$el.text(), 'print')) {
      fail('Python code snippet found, should be filtered out');
    }
    if (!_.string.contains(this.view.$el.text(), 'console')) {
      return fail('JavaScript code snippet not found');
    }
  })",snuts
/test/app/views/play/level/HintsView.spec.js,SubOptimalAssert,"{'startLine':41,'endLine':41}","it('does not show the previous button', function() {
    return expect(this.view.$el.find('.previous-btn').length).toBe(0);
  })",snuts
/test/app/views/play/level/HintsView.spec.js,SubOptimalAssert,"{'startLine':55,'endLine':55}","it('shows the next hint button', function() {
      return expect(this.view.$el.find('.next-btn').length).toBe(1);
    })",snuts
/test/ozaria/site/components/interactive/PageInteractive.spec.js,IdenticalTestDescription,"{'startLine':138,'endLine':142}","it('renders correct component', () => {
      expect(pageInteractiveWrapper.contains(draggableOrderingComponent)).toBe(false)
      expect(pageInteractiveWrapper.contains(insertCodeComponent)).toBe(true)
      expect(pageInteractiveWrapper.contains(draggableStatementCompletionComponent)).toBe(false)
    })",snuts
/test/ozaria/site/components/interactive/PageInteractive.spec.js,IdenticalTestDescription,"{'startLine':152,'endLine':156}","it('renders correct component', () => {
      expect(pageInteractiveWrapper.contains(draggableOrderingComponent)).toBe(false)
      expect(pageInteractiveWrapper.contains(insertCodeComponent)).toBe(false)
      expect(pageInteractiveWrapper.contains(draggableStatementCompletionComponent)).toBe(true)
    })",snuts
/test/ozaria/site/components/interactive/PageInteractive.spec.js,NonFunctionalStatement,"{'startLine':56,'endLine':56}",Unknown,snuts
/test/ozaria/site/components/interactive/PageInteractive.spec.js,NonFunctionalStatement,"{'startLine':58,'endLine':58}",Unknown,snuts
/test/ozaria/site/components/interactive/PageInteractive.spec.js,NonFunctionalStatement,"{'startLine':60,'endLine':60}",Unknown,snuts
/test/ozaria/site/components/interactive/PageInteractive.spec.js,NonFunctionalStatement,"{'startLine':62,'endLine':62}",Unknown,snuts
/test/ozaria/site/components/interactive/PageInteractive.spec.js,NonFunctionalStatement,"{'startLine':80,'endLine':80}",Unknown,snuts
/test/ozaria/site/components/interactive/PageInteractive.spec.js,NonFunctionalStatement,"{'startLine':82,'endLine':82}",Unknown,snuts
/test/app/views/editor/component/ThangComponentsEditView.spec.js,SubOptimalAssert,"{'startLine':68,'endLine':68}","it('removes components that are dependent on a removed component', function() {
    view.components = (Array.from(view.components).filter((c) => c.original !== 'A'));
    view.onComponentsChanged();
    expect(view.components.length).toBe(0);
    return expect(_.size(view.subviews)).toBe(0);
  })",snuts
/test/app/core/store/modules/audio.spec.js,CommentsOnlyTest,"{'startLine':823,'endLine':825}","it('Fades and stops a track', () => {

      })",snuts
/test/app/core/store/modules/audio.spec.js,IdenticalTestDescription,"{'startLine':823,'endLine':825}","it('Fades and stops a track', () => {

      })",snuts
/test/app/core/store/modules/audio.spec.js,NonFunctionalStatement,"{'startLine':88,'endLine':88}","it('Requires a track to play a sound', async (done) => {
      try {
        await store.dispatch('audio/playSound', { ...BASE_SOUND_OPTIONS })
        fail('Expected to throw')
      } catch (e) {}

      done()
    })",snuts
/test/app/core/store/modules/audio.spec.js,NonFunctionalStatement,"{'startLine':823,'endLine':825}","it('Fades and stops a track', () => {

      })",snuts
/test/app/core/store/modules/audio.spec.js,VerboseStatement,"{'startLine':180,'endLine':203}","it('Plays the sound after a unique key has been stopped and unloaded', async (done) => {
        const { id: origId } = await playSound(store, 'background', { unique: 'test' })

        const numPrePlayingSounds = Array.from(store.state.audio.tracks['background'].values()).length

        const { id: noPlayId } = await playSound(store, 'background', { unique: 'test' })
        expect(noPlayId).toBeUndefined()

        const numPostPlayingSounds = Array.from(store.state.audio.tracks['background'].values()).length
        expect(numPostPlayingSounds).toEqual(numPrePlayingSounds)

        store.dispatch('audio/stopSound', { id: origId, unload: true })

        const numPostStopSounds= Array.from(store.state.audio.tracks['background'].values()).length
        expect(numPostStopSounds).toEqual(0)

        const { id: nextPlayId} = await playSound(store, 'background', { unique: 'test' })
        expect(nextPlayId).toBeDefined()

        const numSecondPlaySounds = Array.from(store.state.audio.tracks['background'].values()).length
        expect(numSecondPlaySounds).toEqual(1)

        done()
      })",snuts
/test/app/core/store/modules/audio.spec.js,VerboseStatement,"{'startLine':312,'endLine':333}","it('Stops and unloads a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'stop')
      spyOn(sound1, 'unload')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'stop')
      spyOn(sound2, 'unload')

      await store.dispatch('audio/stopTrack', { track: 'background', unload: true })

      expect(sound1.stop.calls.count()).toEqual(1)
      expect(sound2.stop.calls.count()).toEqual(1)

      expect(sound1.unload.calls.count()).toEqual(1)
      expect(sound2.unload.calls.count()).toEqual(1)

      done()
    })",snuts
/test/app/core/store/modules/audio.spec.js,VerboseStatement,"{'startLine':335,'endLine':356}","it('Stops and unloads all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'stop')
      spyOn(backgroundSound, 'unload')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'stop')
      spyOn(uiSound, 'unload')

      await store.dispatch('audio/stopAll', { unload: true })

      expect(backgroundSound.stop.calls.count()).toEqual(1)
      expect(uiSound.stop.calls.count()).toEqual(1)

      expect(backgroundSound.unload.calls.count()).toEqual(1)
      expect(uiSound.unload.calls.count()).toEqual(1)

      done()
    })",snuts
/test/app/core/store/modules/audio.spec.js,VerboseStatement,"{'startLine':488,'endLine':513}","it('Mutes all sounds and updates state', async (done) => {
        const { sound: backgroundSound } = await playSound(store, 'background')
        const { sound: uiSound } = await playSound(store, 'ui')

        expect(backgroundSound).toBeDefined()
        spyOn(backgroundSound, 'mute')

        expect(uiSound).toBeDefined()
        spyOn(uiSound, 'mute')

        await store.dispatch('audio/muteAll')

        expect(backgroundSound.mute.calls.count()).toEqual(1)
        expect(backgroundSound.mute.calls.first().args[0]).toEqual(true)

        expect(uiSound.mute.calls.count()).toEqual(1)
        expect(uiSound.mute.calls.first().args[0]).toEqual(true)

        expect(store.state.audio.muted.all).toEqual(true)
        expect(store.state.audio.muted.background).toEqual(true)
        expect(store.state.audio.muted.ui).toEqual(true)
        expect(store.state.audio.muted.soundEffects).toEqual(true)


        done()
      })",snuts
/test/app/core/store/modules/audio.spec.js,VerboseStatement,"{'startLine':531,'endLine':554}","it('Unmutes a track and updates mute state', async (done) => {
        const { sound: sound1 } = await playSound(store, 'background')
        const { sound: sound2 } = await playSound(store, 'background')

        await store.dispatch('audio/muteTrack', 'background')

        expect(sound1).toBeDefined()
        spyOn(sound1, 'mute')

        expect(sound2).toBeDefined()
        spyOn(sound2, 'mute')

        await store.dispatch('audio/unmuteTrack', 'background')

        expect(sound1.mute.calls.count()).toEqual(1)
        expect(sound1.mute.calls.first().args[0]).toEqual(false)

        expect(sound2.mute.calls.count()).toEqual(1)
        expect(sound2.mute.calls.first().args[0]).toEqual(false)

        expect(store.state.audio.muted.background).toEqual(false)

        done()
      })",snuts
/test/app/core/store/modules/audio.spec.js,VerboseStatement,"{'startLine':556,'endLine':582}","it('Unmutes all sounds and updates state', async (done) => {
        const { sound: backgroundSound } = await playSound(store, 'background')
        const { sound: uiSound } = await playSound(store, 'ui')

        await store.dispatch('audio/muteAll')

        expect(backgroundSound).toBeDefined()
        spyOn(backgroundSound, 'mute')

        expect(uiSound).toBeDefined()
        spyOn(uiSound, 'mute')

        await store.dispatch('audio/unmuteAll')

        expect(backgroundSound.mute.calls.count()).toEqual(1)
        expect(backgroundSound.mute.calls.first().args[0]).toEqual(false)

        expect(uiSound.mute.calls.count()).toEqual(1)
        expect(uiSound.mute.calls.first().args[0]).toEqual(false)

        expect(store.state.audio.muted.all).toEqual(false)
        expect(store.state.audio.muted.background).toEqual(false)
        expect(store.state.audio.muted.ui).toEqual(false)
        expect(store.state.audio.muted.soundEffects).toEqual(false)

        done()
      })",snuts
/test/app/core/store/modules/audio.spec.js,VerboseStatement,"{'startLine':701,'endLine':722}","it('Fades and stops a sound', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        const startVol = 0.11
        spyOn(sound, 'fade')
        spyOn(sound, 'stop')
        spyOn(sound, 'volume').and.returnValue(startVol)

        const fadeConfig = { id, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAndStopSound', fadeConfig)

        sound._emit('fade', id)
        await fadePromise

        expect(sound.fade.calls.count()).toEqual(1)
        expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ])

        expect(sound.stop.calls.count()).toEqual(1)
        expect(sound.stop.calls.first().args)

        done()
      })",snuts
/test/app/core/store/modules/audio.spec.js,VerboseStatement,"{'startLine':724,'endLine':749}","it('Fades stops and unloads a sound', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        const startVol = 0.11
        spyOn(sound, 'fade')
        spyOn(sound, 'stop')
        spyOn(sound, 'unload')
        spyOn(sound, 'volume').and.returnValue(startVol)

        const fadeConfig = { id, to: 1, duration: 100, unload: true }
        const fadePromise = store.dispatch('audio/fadeAndStopSound', fadeConfig)

        sound._emit('fade', id)
        await fadePromise

        expect(sound.fade.calls.count()).toEqual(1)
        expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ])

        expect(sound.stop.calls.count()).toEqual(1)
        expect(sound.stop.calls.first().args)

        expect(sound.unload.calls.count()).toEqual(1)
        expect(sound.unload.calls.first().args)

        done()
      })",snuts
/test/app/core/store/modules/audio.spec.js,VerboseStatement,"{'startLine':781,'endLine':821}","it('Fades stops and unloads a track', async (done) => {
        const wtf = new Vuex.Store({
          strict: false,

          modules: {
            audio: AudioModule
          }
        })

        const { sound: sound1, id: id1 } = await playSound(wtf, 'background')
        const { sound: sound2, id: id2 } = await playSound(wtf, 'background')

        const startVol = 0.11
        const sounds = wtf.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'unload')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = wtf.dispatch('audio/fadeAndStopTrack', { unload: true, track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound1.unload.calls.count()).toEqual(1)

        expect(sound2.stop.calls.count()).toEqual(1)
        expect(sound2.unload.calls.count()).toEqual(1)

        done()
      })",snuts
/test/app/views/play/level/tome/Problem.spec.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}","describe('Problem', function() {
  // boilerplate problem params
  const ace = {
    getSession() { return {
      getDocument() { return {
        createAnchor() {}
      }; },
      addMarker() {}
    }; }
  };
  const aether = {
    raw: ""this.say('hi');\nthis.sad('bye');"",
    language: { id: 'javascript' }
  };
  const aetherProblem = {
    hint: 'did you mean say instead of sad?',
    id: 'unknown_ReferenceError',
    level: 'error',
    message: 'Line 1: tmp2[tmp3] is not a function',
    range: [
      { row: 1 },
      { row: 1 }
    ],
    type: 'runtime'
  };
  const levelID = 'awesome';

  describe('.translate()', () => it('translates messages with line numbers, error types, and placeholders', function() {
    const oldLang = $.i18n.language;
    return $.i18n.changeLanguage('rot13', function() {
      let english = 'Line 12: ReferenceError: `somethin` is not defined';
      let rot13 = 'Yvar 12: ErsreraprReebe: `somethin` vf abg qrsvarq';
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english = ""`foo`'s argument `bar` has a problem. Is there an enemy within your line-of-sight yet?"";
      rot13 = ""`foo`'f nethzrag `bar` unf n ceboyrz. Vf gurer na rarzl jvguva lbhe yvar-bs-fvtug lrg?"";
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english=`\
\`attack\`'s argument \`target\` should have type \`unit\`, but got \`function\`.
Target a unit.\
`;
      rot13=`\
\`attack\`'f nethzrag \`target\` fubhyq unir glcr \`unit\`, ohg tbg \`function\`.
Gnetrg n havg.\
`;
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      return $.i18n.changeLanguage(oldLang);
    });
  }));

  // TODO: Problems are no longer saved when creating Problems; instead it's in SpellView. Update tests?
  xit('save user code problem', function() {
    new Problem({aether, aetherProblem, ace, isCast: false, levelID});
    expect(jasmine.Ajax.requests.count()).toBe(1);

    const request = jasmine.Ajax.requests.mostRecent();
    expect(request.url).toEqual(""/db/user.code.problem"");

    const params = JSON.parse(request.params);
    expect(params.code).toEqual(aether.raw);
    expect(params.codeSnippet).toEqual(""this.sad('bye');"");
    expect(params.errHint).toEqual(aetherProblem.hint);
    expect(params.errId).toEqual(aetherProblem.id);
    expect(params.errLevel).toEqual(aetherProblem.level);
    expect(params.errMessage).toEqual(aetherProblem.message);
    expect(params.errRange).toEqual(aetherProblem.range);
    expect(params.errType).toEqual(aetherProblem.type);
    expect(params.language).toEqual(aether.language.id);
    return expect(params.levelID).toEqual(levelID);
  });

  xit('save user code problem no range', function() {
    aetherProblem.range = null;
    new Problem({aether, aetherProblem, ace, isCast: false, levelID});
    expect(jasmine.Ajax.requests.count()).toBe(1);

    const request = jasmine.Ajax.requests.mostRecent();
    expect(request.url).toEqual(""/db/user.code.problem"");

    const params = JSON.parse(request.params);
    expect(params.code).toEqual(aether.raw);
    expect(params.errHint).toEqual(aetherProblem.hint);
    expect(params.errId).toEqual(aetherProblem.id);
    expect(params.errLevel).toEqual(aetherProblem.level);
    expect(params.errMessage).toEqual(aetherProblem.message);
    expect(params.errType).toEqual(aetherProblem.type);
    expect(params.language).toEqual(aether.language.id);
    expect(params.levelID).toEqual(levelID);

    // Difference when no range
    expect(params.codeSnippet).toBeUndefined();
    return expect(params.errRange).toBeUndefined();
  });

  return xit('save user code problem multi-line snippet', function() {
    aether.raw = ""this.say('hi');\nthis.sad\n('bye');"";
    aetherProblem.range = [ { row: 1 }, { row: 2 } ];

    new Problem({aether, aetherProblem, ace, isCast: false, levelID});
    expect(jasmine.Ajax.requests.count()).toBe(1);

    const request = jasmine.Ajax.requests.mostRecent();
    expect(request.url).toEqual(""/db/user.code.problem"");

    const params = JSON.parse(request.params);
    expect(params.code).toEqual(aether.raw);
    expect(params.codeSnippet).toEqual(""this.sad\n('bye');"");
    expect(params.errHint).toEqual(aetherProblem.hint);
    expect(params.errId).toEqual(aetherProblem.id);
    expect(params.errLevel).toEqual(aetherProblem.level);
    expect(params.errMessage).toEqual(aetherProblem.message);
    expect(params.errRange).toEqual(aetherProblem.range);
    expect(params.errType).toEqual(aetherProblem.type);
    expect(params.language).toEqual(aether.language.id);
    return expect(params.levelID).toEqual(levelID);
  });
})",snuts
/test/app/views/play/level/tome/Problem.spec.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}","describe('Problem', function() {
  // boilerplate problem params
  const ace = {
    getSession() { return {
      getDocument() { return {
        createAnchor() {}
      }; },
      addMarker() {}
    }; }
  };
  const aether = {
    raw: ""this.say('hi');\nthis.sad('bye');"",
    language: { id: 'javascript' }
  };
  const aetherProblem = {
    hint: 'did you mean say instead of sad?',
    id: 'unknown_ReferenceError',
    level: 'error',
    message: 'Line 1: tmp2[tmp3] is not a function',
    range: [
      { row: 1 },
      { row: 1 }
    ],
    type: 'runtime'
  };
  const levelID = 'awesome';

  describe('.translate()', () => it('translates messages with line numbers, error types, and placeholders', function() {
    const oldLang = $.i18n.language;
    return $.i18n.changeLanguage('rot13', function() {
      let english = 'Line 12: ReferenceError: `somethin` is not defined';
      let rot13 = 'Yvar 12: ErsreraprReebe: `somethin` vf abg qrsvarq';
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english = ""`foo`'s argument `bar` has a problem. Is there an enemy within your line-of-sight yet?"";
      rot13 = ""`foo`'f nethzrag `bar` unf n ceboyrz. Vf gurer na rarzl jvguva lbhe yvar-bs-fvtug lrg?"";
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english=`\
\`attack\`'s argument \`target\` should have type \`unit\`, but got \`function\`.
Target a unit.\
`;
      rot13=`\
\`attack\`'f nethzrag \`target\` fubhyq unir glcr \`unit\`, ohg tbg \`function\`.
Gnetrg n havg.\
`;
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      return $.i18n.changeLanguage(oldLang);
    });
  }));

  // TODO: Problems are no longer saved when creating Problems; instead it's in SpellView. Update tests?
  xit('save user code problem', function() {
    new Problem({aether, aetherProblem, ace, isCast: false, levelID});
    expect(jasmine.Ajax.requests.count()).toBe(1);

    const request = jasmine.Ajax.requests.mostRecent();
    expect(request.url).toEqual(""/db/user.code.problem"");

    const params = JSON.parse(request.params);
    expect(params.code).toEqual(aether.raw);
    expect(params.codeSnippet).toEqual(""this.sad('bye');"");
    expect(params.errHint).toEqual(aetherProblem.hint);
    expect(params.errId).toEqual(aetherProblem.id);
    expect(params.errLevel).toEqual(aetherProblem.level);
    expect(params.errMessage).toEqual(aetherProblem.message);
    expect(params.errRange).toEqual(aetherProblem.range);
    expect(params.errType).toEqual(aetherProblem.type);
    expect(params.language).toEqual(aether.language.id);
    return expect(params.levelID).toEqual(levelID);
  });

  xit('save user code problem no range', function() {
    aetherProblem.range = null;
    new Problem({aether, aetherProblem, ace, isCast: false, levelID});
    expect(jasmine.Ajax.requests.count()).toBe(1);

    const request = jasmine.Ajax.requests.mostRecent();
    expect(request.url).toEqual(""/db/user.code.problem"");

    const params = JSON.parse(request.params);
    expect(params.code).toEqual(aether.raw);
    expect(params.errHint).toEqual(aetherProblem.hint);
    expect(params.errId).toEqual(aetherProblem.id);
    expect(params.errLevel).toEqual(aetherProblem.level);
    expect(params.errMessage).toEqual(aetherProblem.message);
    expect(params.errType).toEqual(aetherProblem.type);
    expect(params.language).toEqual(aether.language.id);
    expect(params.levelID).toEqual(levelID);

    // Difference when no range
    expect(params.codeSnippet).toBeUndefined();
    return expect(params.errRange).toBeUndefined();
  });

  return xit('save user code problem multi-line snippet', function() {
    aether.raw = ""this.say('hi');\nthis.sad\n('bye');"";
    aetherProblem.range = [ { row: 1 }, { row: 2 } ];

    new Problem({aether, aetherProblem, ace, isCast: false, levelID});
    expect(jasmine.Ajax.requests.count()).toBe(1);

    const request = jasmine.Ajax.requests.mostRecent();
    expect(request.url).toEqual(""/db/user.code.problem"");

    const params = JSON.parse(request.params);
    expect(params.code).toEqual(aether.raw);
    expect(params.codeSnippet).toEqual(""this.sad\n('bye');"");
    expect(params.errHint).toEqual(aetherProblem.hint);
    expect(params.errId).toEqual(aetherProblem.id);
    expect(params.errLevel).toEqual(aetherProblem.level);
    expect(params.errMessage).toEqual(aetherProblem.message);
    expect(params.errRange).toEqual(aetherProblem.range);
    expect(params.errType).toEqual(aetherProblem.type);
    expect(params.language).toEqual(aether.language.id);
    return expect(params.levelID).toEqual(levelID);
  });
})",snuts
/test/app/views/play/level/modal/ShareProgressModal.spec.js,AnonymousTest,"{'startLine':36,'endLine':36}","it('(demo)', () => jasmine.demoModal(modal))",snuts
/test/app/views/play/level/modal/ShareProgressModal.spec.js,GeneralFixture,"{'startLine':22,'endLine':22}","beforeEach(function(done) {
      // Not sure why this isn't affecting the modal. Do I need to load the locale file?
      me.set('preferredLanguage', 'es-ES');
      // Can position testing be done? These values are zeros at runtime
      modal = new ShareProgressModal();
      modal.render();
      return _.defer(done);
    })",snuts
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,AnonymousTest,"{'startLine':23,'endLine':23}","it('(demo)', () => jasmine.demoModal(modal))",snuts
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,SubOptimalAssert,"{'startLine':64,'endLine':64}","it('shows the video thumbnails and text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.find('.videos-row').exists()).toBe(true)
    expect(wrapper.find('.video-image').exists()).toBe(true)
    expect(wrapper.findAll('.video-image').length).toBe(3)
    expect(wrapper.find('.video-title').exists()).toBe(true)
    expect(wrapper.findAll('.video-title').length).toBe(3)
    expect(wrapper.find('.video-desc').exists()).toBe(true)
    expect(wrapper.findAll('.video-desc').length).toBe(3)
    expect(wrapper.find('.video-status').exists()).toBe(true)
    expect(wrapper.findAll('.video-status').length).toBe(3)
  })",snuts
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,SubOptimalAssert,"{'startLine':66,'endLine':66}","it('shows the video thumbnails and text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.find('.videos-row').exists()).toBe(true)
    expect(wrapper.find('.video-image').exists()).toBe(true)
    expect(wrapper.findAll('.video-image').length).toBe(3)
    expect(wrapper.find('.video-title').exists()).toBe(true)
    expect(wrapper.findAll('.video-title').length).toBe(3)
    expect(wrapper.find('.video-desc').exists()).toBe(true)
    expect(wrapper.findAll('.video-desc').length).toBe(3)
    expect(wrapper.find('.video-status').exists()).toBe(true)
    expect(wrapper.findAll('.video-status').length).toBe(3)
  })",snuts
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,SubOptimalAssert,"{'startLine':68,'endLine':68}","it('shows the video thumbnails and text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.find('.videos-row').exists()).toBe(true)
    expect(wrapper.find('.video-image').exists()).toBe(true)
    expect(wrapper.findAll('.video-image').length).toBe(3)
    expect(wrapper.find('.video-title').exists()).toBe(true)
    expect(wrapper.findAll('.video-title').length).toBe(3)
    expect(wrapper.find('.video-desc').exists()).toBe(true)
    expect(wrapper.findAll('.video-desc').length).toBe(3)
    expect(wrapper.find('.video-status').exists()).toBe(true)
    expect(wrapper.findAll('.video-status').length).toBe(3)
  })",snuts
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,SubOptimalAssert,"{'startLine':70,'endLine':70}","it('shows the video thumbnails and text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.find('.videos-row').exists()).toBe(true)
    expect(wrapper.find('.video-image').exists()).toBe(true)
    expect(wrapper.findAll('.video-image').length).toBe(3)
    expect(wrapper.find('.video-title').exists()).toBe(true)
    expect(wrapper.findAll('.video-title').length).toBe(3)
    expect(wrapper.find('.video-desc').exists()).toBe(true)
    expect(wrapper.findAll('.video-desc').length).toBe(3)
    expect(wrapper.find('.video-status').exists()).toBe(true)
    expect(wrapper.findAll('.video-status').length).toBe(3)
  })",snuts
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,SubOptimalAssert,"{'startLine':75,'endLine':75}","it('shows 1 video as unlocked and other 2 as locked', () => {
    expect(wrapper.findAll('.locked').exists()).toBe(true)
    expect(wrapper.findAll('.locked').length).toBe(2)
    expect(wrapper.findAll('.unlocked').exists()).toBe(true)
    expect(wrapper.findAll('.unlocked').length).toBe(1)
  })",snuts
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,SubOptimalAssert,"{'startLine':77,'endLine':77}","it('shows 1 video as unlocked and other 2 as locked', () => {
    expect(wrapper.findAll('.locked').exists()).toBe(true)
    expect(wrapper.findAll('.locked').length).toBe(2)
    expect(wrapper.findAll('.unlocked').exists()).toBe(true)
    expect(wrapper.findAll('.unlocked').length).toBe(1)
  })",snuts
/test/ozaria/site/components/teacher-dashboard/modals/ModalEditStudent.spec.js,NonFunctionalStatement,"{'startLine':35,'endLine':35}","beforeEach(() => {
      localVue = createLocalVue()
      localVue.use(Vuex)
      sessions = [
        { changed: '2022-01-01T00:00:00Z' },
        { changed: '2022-02-01T00:00:00Z' },
      ]

      projects = [
        [{ changed: '2022-03-01T00:00:00Z' }],
        [{ changed: '2022-04-01T00:00:00Z' }],
      ]

      store = new Vuex.Store({
        getters: {
          'teacherDashboard/getMembersCurrentClassroom': () => [],
          'levels/getLevelsForClassroom': () => () => [],
          'baseSingleClass/currentEditingStudent': () => 'student1',
          'teacherDashboard/getCurrentClassroom': () => ({ _id: 'classroom1' }),
          'teacherDashboard/getLevelSessionsMapCurrentClassroom': () => ({ student1: sessions }),
          'teacherDashboard/getAiProjectsMapCurrentClassroom': () => ({ student1: projects }),
        },
        actions: {
          'levels/fetchForClassroom': () => {},
        },
      })
    })",snuts
/test/ozaria/site/components/teacher-dashboard/modals/ModalEditStudent.spec.js,NonFunctionalStatement,"{'startLine':113,'endLine':113}","describe('lastPlayedString', () => {
    const lastPlayed = {
      project: { name: 'LevelNameProjectName', changed: '2022-04-01T10:00:00Z' },
    }

    const store = new Vuex.Store({
      getters: {
        'teacherDashboard/getMembersCurrentClassroom': () => [],
        'levels/getLevelsForClassroom': () => () => [],
        'baseSingleClass/currentEditingStudent': () => 'student1',
        'teacherDashboard/getCurrentClassroom': () => ({ _id: 'classroom1' }),
      },
      actions: {
        'levels/fetchForClassroom': () => {},
      },
    })

    let componentDefinition

    let localVue

    beforeEach(() => {
      localVue = createLocalVue()
      localVue.use(Vuex)
      componentDefinition = {
        store,
        localVue,
        mounted () {},
        computed: {
          lastPlayed: () => {
            return {
              ...lastPlayed,
            }
          },
        },
        methods: {
          formatDate: (date) => {
            return date.toString()
          },
        },
      }
    })

    it('returns correct last played string with project', () => {
      const wrapper = shallowMount(Component, {
        ...componentDefinition,
        computed: {
          ...componentDefinition.computed,
          lastPlayed: () => {
            return {
              project: { name: 'LevelNameProjectName', changed: '2022-04-01T10:00:00Z' },
            }
          },
        },
      })

      const lastPlayedString = wrapper.vm.lastPlayedString

      expect(lastPlayedString).toBe('LevelNameProjectName, on 2022-04-01T10:00:00Z')
    })

    it('returns correct last played string with only level', () => {
      const wrapper = shallowMount(Component, {
        ...componentDefinition,
        computed: {
          ...componentDefinition.computed,
          lastPlayed: () => {
            return {
              level: { name: 'LevelName' },
              session: { changed: '2022-02-01T00:00:00Z' },
            }
          },
        },
      })

      const lastPlayedString = wrapper.vm.lastPlayedString
      expect(lastPlayedString).toBe('LevelName, on 2022-02-01T00:00:00Z')
    })
  })",snuts
/test/ozaria/site/components/teacher-dashboard/modals/ModalEditStudent.spec.js,NonFunctionalStatement,"{'startLine':127,'endLine':127}","beforeEach(() => {
      localVue = createLocalVue()
      localVue.use(Vuex)
      componentDefinition = {
        store,
        localVue,
        mounted () {},
        computed: {
          lastPlayed: () => {
            return {
              ...lastPlayed,
            }
          },
        },
        methods: {
          formatDate: (date) => {
            return date.toString()
          },
        },
      }
    })",snuts
/test/ozaria/site/components/teacher-dashboard/modals/ModalEditStudent.spec.js,SubOptimalAssert,"{'startLine':44,'endLine':44}","it('returns correct last played project', () => {
      const wrapper = shallowMount(Component, { store, localVue })
      const lastPlayed = wrapper.vm.lastPlayed

      expect(lastPlayed.session).toBe(null)
      expect(lastPlayed.project.changed).toBe('2022-04-01T00:00:00Z')
    })",snuts
/test/ozaria/site/components/teacher-dashboard/modals/ModalEditStudent.spec.js,SubOptimalAssert,"{'startLine':58,'endLine':58}","it('returns correct last played session when no projects exist', () => {
      projects = [
        [],
        [],
      ]

      const wrapper = shallowMount(Component, { store, localVue })
      const lastPlayed = wrapper.vm.lastPlayed

      expect(lastPlayed.session.changed).toBe('2022-02-01T00:00:00Z')
      expect(lastPlayed.project).toBe(null)
    })",snuts
/test/ozaria/site/components/teacher-dashboard/modals/ModalEditStudent.spec.js,SubOptimalAssert,"{'startLine':67,'endLine':67}","it('returns correct last played session when no projects exist at all', () => {
      projects = []
      const wrapper = shallowMount(Component, { store, localVue })
      const lastPlayed = wrapper.vm.lastPlayed

      expect(lastPlayed.session.changed).toBe('2022-02-01T00:00:00Z')
      expect(lastPlayed.project).toBe(null)
    })",snuts
/test/ozaria/site/components/teacher-dashboard/modals/ModalEditStudent.spec.js,SubOptimalAssert,"{'startLine':75,'endLine':75}","it('returns correct last played project when no sessions exist', () => {
      sessions = []
      const wrapper = shallowMount(Component, { store, localVue })
      const lastPlayed = wrapper.vm.lastPlayed

      expect(lastPlayed.session).toBe(null)
      expect(lastPlayed.project.changed).toBe('2022-04-01T00:00:00Z')
    })",snuts
/test/ozaria/site/components/teacher-dashboard/modals/ModalEditStudent.spec.js,SubOptimalAssert,"{'startLine':88,'endLine':88}","it('returns session if that was played later', () => {
      sessions = [
        { changed: '2025-03-01T00:00:00Z' },
        { changed: '2025-04-01T00:00:00Z' },
      ]
      const wrapper = shallowMount(Component, { store, localVue })
      const lastPlayed = wrapper.vm.lastPlayed

      expect(lastPlayed.session.changed).toBe('2025-04-01T00:00:00Z')
      expect(lastPlayed.project).toBe(null)
    })",snuts
/test/ozaria/site/components/teacher-dashboard/modals/ModalEditStudent.spec.js,SubOptimalAssert,"{'startLine':96,'endLine':96}","it('returns null if no sessions or projects exist', () => {
      sessions = []
      projects = []
      const wrapper = shallowMount(Component, { store, localVue })
      const lastPlayed = wrapper.vm.lastPlayed
      expect(lastPlayed).toBe(null)
    })",snuts
/test/app/views/editor/level/modals/SaveBranchModal.spec.js,SubOptimalAssert,"{'startLine':117,'endLine':117}","it('saves a new branch with all local changes to systems and components', function(done) {
  
  // a couple that don't have changes
  const component = factories.makeLevelComponent({name: 'Unchanged Component'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // a couple with changes
  const changedComponent = factories.makeLevelComponent({name: 'Changed Component'});
  const changedSystem = factories.makeLevelSystem({name: 'Changed System'});
  changedComponent.markToRevert();
  changedComponent.set('description', 'new description');
  changedSystem.markToRevert();
  changedSystem.set('description', 'also a new description');
  
  // a component with history
  const componentV0 = factories.makeLevelComponent({
    name: 'Versioned Component',
    version: {
      major: 0,
      minor: 0,
      isLatestMajor: false,
      isLatestMinor: false
    }
  });
  const componentV1 = factories.makeLevelComponent({
    name: 'Versioned Component', 
    original: componentV0.get('original'),
    description:'Recent description change',
    version: {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    }
  });
  const componentV0Changed = componentV0.clone();
  componentV0Changed.markToRevert();
  componentV0Changed.set({name: 'Unconflicting change', description: 'Conflicting change'});
  
  const modal = new SaveBranchModal({ 
    components: new LevelComponents([component, changedComponent, componentV1]),
    systems: new LevelSystems([changedSystem, system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([
      { 
        name: 'First Branch',
        patches: [
          modelDeltas.makePatch(componentV0Changed).toJSON()
        ],
        updatedBy: me.id,
        updatedByName: 'Myself',
        updated: moment().subtract(1, 'day').toISOString()
      },
      {
        name: 'Newer Branch By Someone Else',
        updatedBy: _.uniqueId('user_'),
        updatedByName: 'Someone Else',
        updated: moment().subtract(5, 'hours').toISOString()
      },
      {
        name: 'Older Branch By Me',
        updatedBy: me.id,
        updatedByName: 'Myself',
        updated: moment().subtract(2, 'days').toISOString()
      },
      {
        name: 'Older Branch By Someone Else',
        updatedBy: _.uniqueId('user_'),
        updatedByName: 'Someone Else',
        updated: moment().subtract(1, 'week').toISOString()
      }
    ])
  });
  return _.defer(() => {
    const componentRequest = jasmine.Ajax.requests.mostRecent();
    expect(componentRequest.url).toBe(componentV0.url());
    componentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentV0.toJSON())
    });
    modal.$('#branches-list-group input').val('Branch Name');
    modal.$('#save-branch-btn').click();
    const saveBranchRequest = jasmine.Ajax.requests.mostRecent();
    expect(saveBranchRequest.url).toBe('/db/branches');
    expect(saveBranchRequest.method).toBe('POST');
    const body = JSON.parse(saveBranchRequest.params);
    expect(body.patches.length).toBe(2);
    const targetIds = _.map(body.patches, patch => patch.id);
    expect(_.contains(targetIds, changedComponent.id));
    expect(_.contains(targetIds, changedSystem.id));
    return done();
  });
})",snuts
/test/app/views/editor/level/modals/SaveBranchModal.spec.js,VerboseStatement,"{'startLine':28,'endLine':123}","it('saves a new branch with all local changes to systems and components', function(done) {
  
  // a couple that don't have changes
  const component = factories.makeLevelComponent({name: 'Unchanged Component'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // a couple with changes
  const changedComponent = factories.makeLevelComponent({name: 'Changed Component'});
  const changedSystem = factories.makeLevelSystem({name: 'Changed System'});
  changedComponent.markToRevert();
  changedComponent.set('description', 'new description');
  changedSystem.markToRevert();
  changedSystem.set('description', 'also a new description');
  
  // a component with history
  const componentV0 = factories.makeLevelComponent({
    name: 'Versioned Component',
    version: {
      major: 0,
      minor: 0,
      isLatestMajor: false,
      isLatestMinor: false
    }
  });
  const componentV1 = factories.makeLevelComponent({
    name: 'Versioned Component', 
    original: componentV0.get('original'),
    description:'Recent description change',
    version: {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    }
  });
  const componentV0Changed = componentV0.clone();
  componentV0Changed.markToRevert();
  componentV0Changed.set({name: 'Unconflicting change', description: 'Conflicting change'});
  
  const modal = new SaveBranchModal({ 
    components: new LevelComponents([component, changedComponent, componentV1]),
    systems: new LevelSystems([changedSystem, system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([
      { 
        name: 'First Branch',
        patches: [
          modelDeltas.makePatch(componentV0Changed).toJSON()
        ],
        updatedBy: me.id,
        updatedByName: 'Myself',
        updated: moment().subtract(1, 'day').toISOString()
      },
      {
        name: 'Newer Branch By Someone Else',
        updatedBy: _.uniqueId('user_'),
        updatedByName: 'Someone Else',
        updated: moment().subtract(5, 'hours').toISOString()
      },
      {
        name: 'Older Branch By Me',
        updatedBy: me.id,
        updatedByName: 'Myself',
        updated: moment().subtract(2, 'days').toISOString()
      },
      {
        name: 'Older Branch By Someone Else',
        updatedBy: _.uniqueId('user_'),
        updatedByName: 'Someone Else',
        updated: moment().subtract(1, 'week').toISOString()
      }
    ])
  });
  return _.defer(() => {
    const componentRequest = jasmine.Ajax.requests.mostRecent();
    expect(componentRequest.url).toBe(componentV0.url());
    componentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentV0.toJSON())
    });
    modal.$('#branches-list-group input').val('Branch Name');
    modal.$('#save-branch-btn').click();
    const saveBranchRequest = jasmine.Ajax.requests.mostRecent();
    expect(saveBranchRequest.url).toBe('/db/branches');
    expect(saveBranchRequest.method).toBe('POST');
    const body = JSON.parse(saveBranchRequest.params);
    expect(body.patches.length).toBe(2);
    const targetIds = _.map(body.patches, patch => patch.id);
    expect(_.contains(targetIds, changedComponent.id));
    expect(_.contains(targetIds, changedSystem.id));
    return done();
  });
})",snuts
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,OvercommentedTest,"{'startLine':12,'endLine':167}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",snuts
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,VerboseStatement,"{'startLine':12,'endLine':167}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",snuts
/test/app/views/core/CreateAccountModal/teacher/NcesSearchInput.spec.js,AnonymousTest,"{'startLine':8,'endLine':24}","it('(demo)', function() {
  const component = new NcesSearchInput({
    data: {
      suggestions: [
        {
          _highlightResult: {
            name: { value: 'School' },
            district: { value: 'District' },
            city: { value: 'City' },
            state: { value: 'State' }
          }
        }
      ]
    }
  }).$mount();
  return jasmine.demoEl(component.$el);
})",snuts
/vendor/scripts/SpriteStage.js,SensitiveEquality,"{'startLine':419,'endLine':419}",Unknown,snuts
/vendor/scripts/SpriteStage.js,SensitiveEquality,"{'startLine':423,'endLine':423}",Unknown,snuts
/vendor/scripts/SpriteStage.js,NonFunctionalStatement,"{'startLine':353,'endLine':353}",Unknown,snuts
/app/assets/javascripts/run-tests.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/app/assets/javascripts/run-tests.js,NonFunctionalStatement,"{'startLine':20,'endLine':20}",Unknown,snuts
/app/views/editor/verifier/VerifierTest.js,SensitiveEquality,"{'startLine':109,'endLine':109}",Unknown,snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':13,'endLine':19}","it(""return 1000"", function() {
      const code = `\
return 1000\
`;
      aether.transpile(code);
      return expect(aether.run()).toEqual(1000);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':21,'endLine':28}","it(""simple if"", function() {
      const code = `\
if False: return 2000
return 1000\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe(1000);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':30,'endLine':45}","it(""multiple elif"", function() {
      const code = `\
x = 4
if x == 2:
  x += 1
  return '2'
elif x == 44564:
  x += 1
  return '44564'
elif x == 4:
  x += 1
  return '4'\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe('4');
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':47,'endLine':53}","it(""mathmetics order"", function() {
      const code = `\
return (2*2 + 2/2 - 2*2/2)\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe(3);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':55,'endLine':65}","it(""fibonacci function"", function() {
      const code = `\
def fib(n):
  if n < 2: return n
  else: return fib(n - 1) + fib(n - 2)
chupacabra = fib(6)
return chupacabra\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe(8);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':67,'endLine':77}","it(""for loop"", function() {
      const code = `\
data = [4, 2, 65, 7]
total = 0
for d in data:
  total += d
return total\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe(78);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':79,'endLine':114}","it(""bubble sort"", function() {
      const code = `\
import random
def createShuffled(n):
  r = n * 10 + 1
  shuffle = []
  for i in range(n):
    item = int(r * random.random())
    shuffle.append(item)
  return shuffle

def bubbleSort(data):
  sorted = False
  while not sorted:
    sorted = True
    for i in range(len(data) - 1):
      if data[i] > data[i + 1]:
        t = data[i]
        data[i] = data[i + 1]
        data[i + 1] = t
        sorted = False
  return data

def isSorted(data):
  for i in range(len(data) - 1):
    if data[i] > data[i + 1]:
      return False
  return True

data = createShuffled(10)
bubbleSort(data)
return isSorted(data)\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe(true);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':116,'endLine':123}","it(""dictionary"", function() {
      const code = `\
d = {'p1': 'prop1'}
return d['p1']\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe('prop1');
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':125,'endLine':138}","it(""class"", function() {
      const code = `\
class MyClass:
  i = 123
  def __init__(self, i):
    self.i = i
  def f(self):
    return self.i
x = MyClass(456)
return x.f()\
`;
      aether.transpile(code);
      return expect(aether.run()).toEqual(456);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':140,'endLine':147}","it(""L[0:2]"", function() {
      const code = `\
L = [1, 45, 6, -9]
return L[0:2]\
`;
      aether.transpile(code);
      return expect(aether.run()).toEqual(list([1, 45]));
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':160,'endLine':167}","it(""T[-1:-3:-1]"", function() {
      const code = `\
T = (0, 1, 2, 3, 4)
return T[-1:-3:-1]\
`;
      aether.transpile(code);
      return expect(aether.run()).toEqual(list([4, 3]));
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':196,'endLine':205}","it(""sequence operations"", function() {
      const code = `\
a = [1]
b = a + [2]
b *= 2
return b\
`;
      aether.transpile(code);
      return expect(aether.run()).toEqual(list([1, 2, 1, 2]));
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':266,'endLine':276}","it(""Empty if"", function() {
      const code = `\
if True:
x = 5\
`;
      aether = new Aether({language: ""python"", simpleLoops: true});
      aether.transpile(code);
      expect(aether.problems.errors.length).toEqual(1);
      expect(aether.problems.errors[0].type).toEqual('transpile');
      return expect(aether.problems.errors[0].message).toEqual(""Empty if statement. Put 4 spaces in front of statements inside the if statement."");
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':278,'endLine':296}","it(""convertToNativeType"", function() {
      const globals = {
        foo() {
          const o = {p1: 34, p2: 'Bob'};
          return Object.defineProperty(o, 'health', {value: 42});
        }
      };
      const code = `\
myObj = self.foo()
return myObj.health\
`;
      aether = new Aether({language: ""python"", simpleLoops: true, yieldConditionally: true});
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(globals);
      const result = gen.next();
      expect(aether.problems.errors.length).toEqual(0);
      return expect(result.value).toEqual(42);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':343,'endLine':361}","it(""self.getItems()"", function() {
      const history = [];
      const getItems = () => [{'pos':1}, {'pos':4}, {'pos':3}, {'pos':5}];
      const move = i => history.push(i);
      const thisValue = {getItems, move};
      const aetherOptions = {
        language: 'python'
      };
      const code = `\
items = self.getItems()
for item in items:
  self.move(item['pos'])\
`;
      const aether = new Aether(aetherOptions);
      aether.transpile(code);
      const method = aether.createMethod(thisValue);
      aether.run(method);
      return expect(history).toEqual([1, 4, 3, 5]);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':472,'endLine':483}","it(""Incomplete string"", function() {
      const code = `\
s = 'hi
return s\
`;
      aether.transpile(code);
      expect(aether.problems.errors.length).toEqual(1);
      expect(/Unterminated string constant/.test(aether.problems.errors[0].message)).toBe(true);
      expect(aether.problems.errors[0].range).toEqual([ { ofs : 4, row : 0, col : 4 }, { ofs : 7, row : 0, col : 7 } ]);
      const result = aether.run();
      return expect(result).toEqual('hi');
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':485,'endLine':495}","it(""Runtime ReferenceError"", function() {
      const code = `\
x = 5
y = x + z\
`;
      aether.transpile(code);
      aether.run();
      expect(aether.problems.errors.length).toEqual(1);
      expect(/ReferenceError/.test(aether.problems.errors[0].message)).toBe(true);
      return expect(aether.problems.errors[0].range).toEqual([ { ofs : 14, row : 1, col : 8 }, { ofs : 15, row : 1, col : 9 } ]);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':499,'endLine':510}","it(""loop:"", function() {
      const code = `\
total = 0
loop:
  total += 1
  if total is 10: break;
return total\
`;
      const aether = new Aether({language: ""python"", simpleLoops: true});
      aether.transpile(code);
      return expect(aether.run()).toEqual(10);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':568,'endLine':600}","it(""Conditional yielding"", function() {
      const aether = new Aether({language: ""python"", yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while True:
  self.slay();
  break;
loop:
  self.slay();
  if self.getKillCount() >= 5:
    break;
while True:
  self.slay();
  break;\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      for (let i = 1; i <= 6; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(6);
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':794,'endLine':804}","it(""Empty loop"", function() {
      const code = `\
loop:
x = 5\
`;
      const aether = new Aether({language: ""python"", simpleLoops: true});
      aether.transpile(code);
      expect(aether.problems.warnings.length).toEqual(1);
      expect(aether.problems.warnings[0].type).toEqual('transpile');
      return expect(aether.problems.warnings[0].message).toEqual(""Empty loop. Put 4 spaces in front of statements inside loops."");
    })",snuts
/spec/aether/python_spec.js,AnonymousTest,"{'startLine':1034,'endLine':1045}","it(""Empty loop"", function() {
      const code = `\
while True:
x = 5\
`;
      const aether = new Aether({language: ""python"", whileTrueAutoYield: true});
      aether.transpile(code);
      console.log(JSON.stringify(aether.problems));
      expect(aether.problems.warnings.length).toEqual(1);
      expect(aether.problems.warnings[0].type).toEqual('transpile');
      return expect(aether.problems.warnings[0].message).toEqual(""Empty loop. Put 4 spaces in front of statements inside loops."");
    })",snuts
/spec/aether/python_spec.js,TranscriptingTest,"{'startLine':1034,'endLine':1045}","it(""Empty loop"", function() {
      const code = `\
while True:
x = 5\
`;
      const aether = new Aether({language: ""python"", whileTrueAutoYield: true});
      aether.transpile(code);
      console.log(JSON.stringify(aether.problems));
      expect(aether.problems.warnings.length).toEqual(1);
      expect(aether.problems.warnings[0].type).toEqual('transpile');
      return expect(aether.problems.warnings[0].message).toEqual(""Empty loop. Put 4 spaces in front of statements inside loops."");
    })",snuts
/spec/aether/python_spec.js,IdenticalTestDescription,"{'startLine':849,'endLine':865}","it(""Conditional yielding empty loop"", function() {
      const aether = new Aether({language: ""python"", yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {};
      const code = `\
x = 0
while True:
  x += 1
  if x >= 3:
    break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      return expect(gen.next().done).toEqual(true);
    })",snuts
/spec/aether/python_spec.js,IdenticalTestDescription,"{'startLine':867,'endLine':915}","it(""Conditional yielding mixed loops"", function() {
      let i;
      const aether = new Aether({language: ""python"", yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while True:
  self.slay()
  if self.getKillCount() >= 5:
    break
x = 0
while True:
  x += 1
  if x > 10:
    break
while True:
  self.slay()
  if self.getKillCount() >= 15:
    break
while 4 is 4:
  self.slay()
  break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      for (i = 1; i <= 5; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      for (i = 1; i <= 10; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(5);
      }
      for (i = 6; i <= 15; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      expect(gen.next().done).toEqual(false);
      expect(dude.killCount).toEqual(16);
      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(16);
    })",snuts
/spec/aether/python_spec.js,IdenticalTestDescription,"{'startLine':917,'endLine':1032}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({language: ""python"", yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
# outer auto yield, inner yield
x = 0
while True:
  y = 0
  while True:
    self.slay()
    y += 1
    if y >= 2:
      break
  x += 1
  if x >= 3:
    break

# outer yield, inner auto yield
x = 0
while True:
  self.slay()
  y = 0
  while True:
    y += 1
    if y >= 4:
      break
  x += 1
  if x >= 5:
    break

# outer and inner auto yield
x = 0
while True:
  y = 0
  while True:
    y += 1
    if y >= 6:
      break
  x += 1
  if x >= 7:
    break

# outer and inner yields
x = 0
while True:
  self.slay()
  y = 0
  while True:
    self.slay()
    y += 1
    if y >= 9:
      break
  x += 1
  if x >= 8:
    break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: auto yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/python_spec.js,IdenticalTestDescription,"{'startLine':1034,'endLine':1045}","it(""Empty loop"", function() {
      const code = `\
while True:
x = 5\
`;
      const aether = new Aether({language: ""python"", whileTrueAutoYield: true});
      aether.transpile(code);
      console.log(JSON.stringify(aether.problems));
      expect(aether.problems.warnings.length).toEqual(1);
      expect(aether.problems.warnings[0].type).toEqual('transpile');
      return expect(aether.problems.warnings[0].message).toEqual(""Empty loop. Put 4 spaces in front of statements inside loops."");
    })",snuts
/spec/aether/python_spec.js,ConditionalTestLogic,"{'startLine':753,'endLine':753}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({language: ""python"", yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
# outer auto yield, inner yield
x = 0
loop:
  y = 0
  loop:
    self.slay()
    y += 1
    if y >= 2:
      break
  x += 1
  if x >= 3:
    break

# outer yield, inner auto yield
x = 0
loop:
  self.slay()
  y = 0
  loop:
    y += 1
    if y >= 4:
      break
  x += 1
  if x >= 5:
    break

# outer and inner auto yield
x = 0
loop:
  y = 0
  loop:
    y += 1
    if y >= 6:
      break
  x += 1
  if x >= 7:
    break

# outer and inner yields
x = 0
loop:
  self.slay()
  y = 0
  loop:
    self.slay()
    y += 1
    if y >= 9:
      break
  x += 1
  if x >= 8:
    break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: auto yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/python_spec.js,ConditionalTestLogic,"{'startLine':775,'endLine':775}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({language: ""python"", yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
# outer auto yield, inner yield
x = 0
loop:
  y = 0
  loop:
    self.slay()
    y += 1
    if y >= 2:
      break
  x += 1
  if x >= 3:
    break

# outer yield, inner auto yield
x = 0
loop:
  self.slay()
  y = 0
  loop:
    y += 1
    if y >= 4:
      break
  x += 1
  if x >= 5:
    break

# outer and inner auto yield
x = 0
loop:
  y = 0
  loop:
    y += 1
    if y >= 6:
      break
  x += 1
  if x >= 7:
    break

# outer and inner yields
x = 0
loop:
  self.slay()
  y = 0
  loop:
    self.slay()
    y += 1
    if y >= 9:
      break
  x += 1
  if x >= 8:
    break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: auto yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/python_spec.js,ConditionalTestLogic,"{'startLine':993,'endLine':993}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({language: ""python"", yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
# outer auto yield, inner yield
x = 0
while True:
  y = 0
  while True:
    self.slay()
    y += 1
    if y >= 2:
      break
  x += 1
  if x >= 3:
    break

# outer yield, inner auto yield
x = 0
while True:
  self.slay()
  y = 0
  while True:
    y += 1
    if y >= 4:
      break
  x += 1
  if x >= 5:
    break

# outer and inner auto yield
x = 0
while True:
  y = 0
  while True:
    y += 1
    if y >= 6:
      break
  x += 1
  if x >= 7:
    break

# outer and inner yields
x = 0
while True:
  self.slay()
  y = 0
  while True:
    self.slay()
    y += 1
    if y >= 9:
      break
  x += 1
  if x >= 8:
    break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: auto yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/python_spec.js,ConditionalTestLogic,"{'startLine':1015,'endLine':1015}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({language: ""python"", yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
# outer auto yield, inner yield
x = 0
while True:
  y = 0
  while True:
    self.slay()
    y += 1
    if y >= 2:
      break
  x += 1
  if x >= 3:
    break

# outer yield, inner auto yield
x = 0
while True:
  self.slay()
  y = 0
  while True:
    y += 1
    if y >= 4:
      break
  x += 1
  if x >= 5:
    break

# outer and inner auto yield
x = 0
while True:
  y = 0
  while True:
    y += 1
    if y >= 6:
      break
  x += 1
  if x >= 7:
    break

# outer and inner yields
x = 0
while True:
  self.slay()
  y = 0
  while True:
    self.slay()
    y += 1
    if y >= 9:
      break
  x += 1
  if x >= 8:
    break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: auto yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/python_spec.js,VerboseStatement,"{'startLine':627,'endLine':675}","it(""Conditional yielding mixed loops"", function() {
      let i;
      const aether = new Aether({language: ""python"", yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
loop:
  self.slay()
  if self.getKillCount() >= 5:
    break
x = 0
loop:
  x += 1
  if x > 10:
    break
loop:
  self.slay()
  if self.getKillCount() >= 15:
    break
while True:
  self.slay()
  break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      for (i = 1; i <= 5; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      for (i = 1; i <= 10; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(5);
      }
      for (i = 6; i <= 15; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      expect(gen.next().done).toEqual(false);
      expect(dude.killCount).toEqual(16);
      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(16);
    })",snuts
/spec/aether/python_spec.js,VerboseStatement,"{'startLine':677,'endLine':792}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({language: ""python"", yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
# outer auto yield, inner yield
x = 0
loop:
  y = 0
  loop:
    self.slay()
    y += 1
    if y >= 2:
      break
  x += 1
  if x >= 3:
    break

# outer yield, inner auto yield
x = 0
loop:
  self.slay()
  y = 0
  loop:
    y += 1
    if y >= 4:
      break
  x += 1
  if x >= 5:
    break

# outer and inner auto yield
x = 0
loop:
  y = 0
  loop:
    y += 1
    if y >= 6:
      break
  x += 1
  if x >= 7:
    break

# outer and inner yields
x = 0
loop:
  self.slay()
  y = 0
  loop:
    self.slay()
    y += 1
    if y >= 9:
      break
  x += 1
  if x >= 8:
    break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: auto yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/python_spec.js,VerboseStatement,"{'startLine':867,'endLine':915}","it(""Conditional yielding mixed loops"", function() {
      let i;
      const aether = new Aether({language: ""python"", yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while True:
  self.slay()
  if self.getKillCount() >= 5:
    break
x = 0
while True:
  x += 1
  if x > 10:
    break
while True:
  self.slay()
  if self.getKillCount() >= 15:
    break
while 4 is 4:
  self.slay()
  break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      for (i = 1; i <= 5; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      for (i = 1; i <= 10; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(5);
      }
      for (i = 6; i <= 15; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      expect(gen.next().done).toEqual(false);
      expect(dude.killCount).toEqual(16);
      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(16);
    })",snuts
/spec/aether/python_spec.js,VerboseStatement,"{'startLine':917,'endLine':1032}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({language: ""python"", yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
# outer auto yield, inner yield
x = 0
while True:
  y = 0
  while True:
    self.slay()
    y += 1
    if y >= 2:
      break
  x += 1
  if x >= 3:
    break

# outer yield, inner auto yield
x = 0
while True:
  self.slay()
  y = 0
  while True:
    y += 1
    if y >= 4:
      break
  x += 1
  if x >= 5:
    break

# outer and inner auto yield
x = 0
while True:
  y = 0
  while True:
    y += 1
    if y >= 6:
      break
  x += 1
  if x >= 7:
    break

# outer and inner yields
x = 0
while True:
  self.slay()
  y = 0
  while True:
    self.slay()
    y += 1
    if y >= 9:
      break
  x += 1
  if x >= 8:
    break\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: auto yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':48,'endLine':59}","it(""Unexpected indent"", function() {
      const code = `\
x = 5
  y = 7\
`;
      const aether = new Aether({language: 'python'});
      aether.transpile(code);
      expect(aether.problems.errors.length).toEqual(1);
      expect(aether.problems.errors[0].type).toEqual('transpile');
      expect(aether.problems.errors[0].message).toEqual(""Unexpected indent"");
      return expect(aether.problems.errors[0].hint).toEqual(""Code needs to line up."");
    })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':126,'endLine':138}","it(""Capitalized loop"", function() {
      const code = `\
Loop:
  x = 5\
`;
      const problemContext = {thisMethods: [ 'moveUp', 'moveDown']};
      const aether = new Aether({language: ""python"", problemContext, simpleLoops: true});
      aether.transpile(code);
      expect(aether.problems.errors.length).toEqual(1);
      expect(aether.problems.errors[0].type).toEqual('transpile');
      expect(aether.problems.errors[0].message).toEqual(""Unexpected token"");
      return expect(aether.problems.errors[0].hint).toEqual(""Should be lowercase. Try `loop`"");
    })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':140,'endLine':151}","it(""Double var"", function() {
      const code = `\
var enemy = 'Bob';
var enemy = 'Sue';\
`;
      const aether = new Aether();
      aether.transpile(code);
      expect(aether.problems.warnings.length).toEqual(1);
      expect(aether.problems.warnings[0].type).toEqual('transpile');
      expect(aether.problems.warnings[0].message).toEqual(""'enemy' is already defined."");
      return expect(aether.problems.warnings[0].hint).toEqual(""Don't use the 'var' keyword for 'enemy' the second time."");
    })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':263,'endLine':274}","it(""self.moveRight("", function() {
      const code = `\
self.moveRight(\
`;
      const problemContext = {};
      const aether = new Aether({language: ""python"", problemContext});
      aether.transpile(code);
      expect(aether.problems.errors.length).toEqual(1);
      expect(aether.problems.errors[0].type).toEqual('transpile');
      expect(aether.problems.errors[0].message).toEqual(""Unexpected token"");
      return expect(aether.problems.errors[0].hint).toEqual(""Unmatched `(`.  Every opening `(` needs a closing `)` to match it."");
    })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':276,'endLine':287}","it(""self.moveRight(()"", function() {
      const code = `\
self.moveRight(()\
`;
      const problemContext = {};
      const aether = new Aether({language: ""python"", problemContext});
      aether.transpile(code);
      expect(aether.problems.errors.length).toEqual(1);
      expect(aether.problems.errors[0].type).toEqual('transpile');
      expect(aether.problems.errors[0].message).toEqual(""Unexpected token"");
      return expect(aether.problems.errors[0].hint).toEqual(""Unmatched `(`.  Every opening `(` needs a closing `)` to match it."");
    })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':454,'endLine':470}","it(""Exact thisMethods"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = `\
attack\
`;
        const problemContext = {thisMethods: [ 'log', 'attack' ]};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: attack is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Try `hero.attack()`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':472,'endLine':488}","it(""Case thisMethods"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = `\
Attack\
`;
        const problemContext = {thisMethods: [ 'log', 'attack', 'tickle' ]};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: Attack is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Try `hero.attack()`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':490,'endLine':503}","it(""Exact commonThisMethods"", function() {
        const selfValue = {};
        const code = `\
this.attack(""Brak"");\
`;
        const problemContext = {commonThisMethods: ['attack']};
        const aether = new Aether({problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: Object #<Object> has no method 'attack'"");
        return expect(aether.problems.errors[0].hint).toEqual(""You do not have an item equipped with the attack skill."");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':521,'endLine':534}","it(""Case commonThisMethods"", function() {
        const selfValue = {};
        const code = `\
self.moveup()\
`;
        const problemContext = {commonThisMethods: ['moveUp']};
        const aether = new Aether({language: 'python', problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: Object #<Object> has no method 'moveup'"");
        return expect(aether.problems.errors[0].hint).toEqual(""Did you mean moveUp? You do not have an item equipped with that skill."");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':536,'endLine':550}","it(""Score commonThisMethods"", function() {
        const selfValue = {};
        const code = `\
self.movright()\
`;
        const problemContext = {thisMethods: ['moveUp', 'moveLeft'], commonThisMethods: ['moveRight']};
        const aether = new Aether({problemContext, language: 'python'});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual(""runtime"");
        expect(aether.problems.errors[0].message).toEqual(""Line 1: Object #<Object> has no method 'movright'"");
        return expect(aether.problems.errors[0].hint).toEqual(""Did you mean moveRight? You do not have an item equipped with that skill."");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':587,'endLine':603}","it(""Exact stringReferences"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = `\
self.attack(Brak)\
`;
        const problemContext = {stringReferences: ['Brak']};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: Brak is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Missing quotes. Try `\""Brak\""`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':605,'endLine':618}","it(""Exact thisMethods"", function() {
        const selfValue = {};
        const code = `\
moveleft\
`;
        const problemContext = {thisMethods: ['moveRight', 'moveLeft', 'moveUp', 'moveDown']};
        const aether = new Aether({language: 'python', problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: moveleft is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Try `hero.moveLeft()`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':638,'endLine':654}","it(""Exact thisProperties"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = `\
b = buildables\
`;
        const problemContext = {thisProperties: [ 'buildables' ]};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: buildables is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Try `hero.buildables`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':674,'endLine':690}","it(""Case stringReferences"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = `\
self.attack(brak)\
`;
        const problemContext = {stringReferences: ['Bob', 'Brak', 'Zort']};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: brak is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Missing quotes.  Try `\""Brak\""`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':692,'endLine':706}","it(""Case thisMethods"", function() {
        const selfValue = {};
        const code = `\
this.moveright();\
`;
        const problemContext = {thisMethods: ['moveUp', 'moveRight', 'moveLeft']};
        const aether = new Aether({problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual(""runtime"");
        expect(aether.problems.errors[0].message).toEqual(""Line 1: Object #<Object> has no method 'moveright'"");
        return expect(aether.problems.errors[0].hint).toEqual(""Uppercase or lowercase problem. Try `hero.moveRight()`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':708,'endLine':724}","it(""Case thisProperties"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = `\
b = Buildables\
`;
        const problemContext = {thisProperties: [ 'buildables' ]};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: Buildables is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Try `hero.buildables`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':744,'endLine':760}","it(""Score stringReferences"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = `\
self.attack(brOk)\
`;
        const problemContext = {stringReferences: ['Bob', 'Brak', 'Zort']};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: brOk is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Missing quotes. Try `\""Brak\""`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':762,'endLine':776}","it(""Score thisMethods"", function() {
        const selfValue = {};
        const code = `\
self.moveEight()\
`;
        const problemContext = {thisMethods: ['moveUp', 'moveRight', 'moveLeft']};
        const aether = new Aether({problemContext, language: 'python'});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual(""runtime"");
        expect(aether.problems.errors[0].message).toEqual(""Line 1: Object #<Object> has no method 'moveEight'"");
        return expect(aether.problems.errors[0].hint).toEqual(""Try `hero.moveRight()`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':823,'endLine':839}","it(""Score thisProperties"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = `\
b = Bildaables\
`;
        const problemContext = {thisProperties: [ 'buildables' ]};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: Bildaables is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Try `hero.buildables`"");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':841,'endLine':855}","it(""Exact commonThisMethods"", function() {
        const selfValue = {};
        const code = `\
attack()\
`;
        const problemContext = {thisMethods: [], commonThisMethods: ['attack']};
        const aether = new Aether({problemContext, language: 'python'});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual('runtime');
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: attack is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""You do not have an item equipped with the attack skill."");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':857,'endLine':871}","it(""Case commonThisMethods"", function() {
        const selfValue = {};
        const code = `\
ATTACK()\
`;
        const problemContext = {thisMethods: [], commonThisMethods: ['attack']};
        const aether = new Aether({problemContext, language: 'python'});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual('runtime');
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: ATTACK is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Did you mean attack? You do not have an item equipped with that skill."");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':873,'endLine':887}","it(""Score commonThisMethods"", function() {
        const selfValue = {};
        const code = `\
atac()\
`;
        const problemContext = {thisMethods: [], commonThisMethods: ['attack']};
        const aether = new Aether({problemContext, language: 'python'});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual('runtime');
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: atac is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Did you mean attack? You do not have an item equipped with that skill."");
      })",snuts
/spec/aether/problem_spec.js,AnonymousTest,"{'startLine':906,'endLine':920}","it(""self.self.moveUp()"", function() {
      const selfValue = {};
      const code = `\
self.self.moveUp()\
`;
      const problemContext = {thisMethods: ['moveUp'], commonThisMethods: ['attack']};
      const aether = new Aether({problemContext, language: 'python'});
      aether.transpile(code);
      const method = aether.createMethod(selfValue);
      aether.run(method);
      expect(aether.problems.errors.length).toEqual(1);
      expect(aether.problems.errors[0].type).toEqual('runtime');
      expect(aether.problems.errors[0].message).toEqual(""Line 1: Cannot call method 'moveUp' of undefined"");
      return expect(aether.problems.errors[0].hint).toEqual(""Try `self.moveUp()`"");
    })",snuts
/spec/aether/problem_spec.js,TranscriptingTest,"{'startLine':153,'endLine':166}","it(""if without :"", function() {
      const code = `\
if True
  x = 5\
`;
      const problemContext = {thisMethods: [ 'moveUp', 'moveDown']};
      const aether = new Aether({language: ""python"", problemContext});
      aether.transpile(code);
      console.log(aether.problems.errors[0]);
      expect(aether.problems.errors.length).toEqual(1);
      expect(aether.problems.errors[0].type).toEqual('transpile');
      expect(aether.problems.errors[0].message).toEqual(""Unexpected token"");
      return expect(aether.problems.errors[0].hint).toEqual(""You are missing a `:` on the end of the line following `if True`"");
    })",snuts
/spec/aether/problem_spec.js,IdenticalTestDescription,"{'startLine':605,'endLine':618}","it(""Exact thisMethods"", function() {
        const selfValue = {};
        const code = `\
moveleft\
`;
        const problemContext = {thisMethods: ['moveRight', 'moveLeft', 'moveUp', 'moveDown']};
        const aether = new Aether({language: 'python', problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: moveleft is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Try `hero.moveLeft()`"");
      })",snuts
/spec/aether/problem_spec.js,IdenticalTestDescription,"{'startLine':692,'endLine':706}","it(""Case thisMethods"", function() {
        const selfValue = {};
        const code = `\
this.moveright();\
`;
        const problemContext = {thisMethods: ['moveUp', 'moveRight', 'moveLeft']};
        const aether = new Aether({problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual(""runtime"");
        expect(aether.problems.errors[0].message).toEqual(""Line 1: Object #<Object> has no method 'moveright'"");
        return expect(aether.problems.errors[0].hint).toEqual(""Uppercase or lowercase problem. Try `hero.moveRight()`"");
      })",snuts
/spec/aether/problem_spec.js,IdenticalTestDescription,"{'startLine':841,'endLine':855}","it(""Exact commonThisMethods"", function() {
        const selfValue = {};
        const code = `\
attack()\
`;
        const problemContext = {thisMethods: [], commonThisMethods: ['attack']};
        const aether = new Aether({problemContext, language: 'python'});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual('runtime');
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: attack is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""You do not have an item equipped with the attack skill."");
      })",snuts
/spec/aether/problem_spec.js,IdenticalTestDescription,"{'startLine':857,'endLine':871}","it(""Case commonThisMethods"", function() {
        const selfValue = {};
        const code = `\
ATTACK()\
`;
        const problemContext = {thisMethods: [], commonThisMethods: ['attack']};
        const aether = new Aether({problemContext, language: 'python'});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual('runtime');
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: ATTACK is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Did you mean attack? You do not have an item equipped with that skill."");
      })",snuts
/spec/aether/problem_spec.js,IdenticalTestDescription,"{'startLine':873,'endLine':887}","it(""Score commonThisMethods"", function() {
        const selfValue = {};
        const code = `\
atac()\
`;
        const problemContext = {thisMethods: [], commonThisMethods: ['attack']};
        const aether = new Aether({problemContext, language: 'python'});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual('runtime');
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: atac is not defined"");
        return expect(aether.problems.errors[0].hint).toEqual(""Did you mean attack? You do not have an item equipped with that skill."");
      })",snuts
/spec/aether/problem_spec.js,IdenticalTestDescription,"{'startLine':889,'endLine':902}","it('enemy-ish variable is not defined', function() {
        const dude = { attack() {} };
        const code = 'self.attack(enemy3)';
        const problemContext = { thisMethods: ['findNearestEnemy'] };
        let aether = new Aether({ language: 'python', problemContext });
        aether.transpile(code);
        aether.run(aether.createFunction().bind(dude));
        expect(aether.problems.errors[0].hint).toBe(""There is no `enemy3`. Use `enemy3 = hero.findNearestEnemy()` first."");

        aether = new Aether({ language: 'javascript', problemContext });
        aether.transpile(code);
        aether.run(aether.createFunction().bind(dude));
        return expect(aether.problems.errors[0].hint).toBe(""There is no `enemy3`. Use `var enemy3 = hero.findNearestEnemy()` first."");
      })",snuts
/spec/aether/problem_spec.js,NonFunctionalStatement,"{'startLine':569,'endLine':569}","it('enemy-ish variable is not defined', function() {
        const dude = { attack() {} };
        const problemContext = { thisMethods: ['findNearestEnemy'] };
    
        let aether = new Aether({ language: 'python', problemContext });
        aether.transpile('self.attack(enemy3)');
        aether.run(aether.createFunction().bind(dude));
        expect(aether.problems.errors[0].hint).toBe(""There is no `enemy3`. Use `enemy3 = hero.findNearestEnemy()` first."");
    
        aether = new Aether({ language: 'javascript', problemContext });
        aether.transpile('this.attack(enemy3)');
        aether.run(aether.createFunction().bind(dude));
        return expect(aether.problems.errors[0].hint).toBe(""There is no `enemy3`. Use `var enemy3 = hero.findNearestEnemy()` first."");
      })",snuts
/spec/aether/problem_spec.js,NonFunctionalStatement,"{'startLine':890,'endLine':890}","it('enemy-ish variable is not defined', function() {
        const dude = { attack() {} };
        const code = 'self.attack(enemy3)';
        const problemContext = { thisMethods: ['findNearestEnemy'] };
        let aether = new Aether({ language: 'python', problemContext });
        aether.transpile(code);
        aether.run(aether.createFunction().bind(dude));
        expect(aether.problems.errors[0].hint).toBe(""There is no `enemy3`. Use `enemy3 = hero.findNearestEnemy()` first."");

        aether = new Aether({ language: 'javascript', problemContext });
        aether.transpile(code);
        aether.run(aether.createFunction().bind(dude));
        return expect(aether.problems.errors[0].hint).toBe(""There is no `enemy3`. Use `var enemy3 = hero.findNearestEnemy()` first."");
      })",snuts
/spec/aether/problem_spec.js,VerboseStatement,"{'startLine':291,'endLine':318}","it(""Should capture runtime problems"", function() {
      // 0123456789012345678901234567
      const code = `\
var methodName = 'explode';
this[methodName]();\
`;
      const options = {
        thisValue: {},
        problems: {jshint_W040: {level: ""ignore""}}
      };
      const aether = new Aether(options);
      aether.transpile(code);
      aether.run();
      expect(aether.problems.errors.length).toEqual(1);
      const problem = aether.problems.errors[0];
      expect(problem.type).toEqual('runtime');
      expect(problem.level).toEqual('error');
      expect(problem.message).toMatch(/has no method/);
      expect(problem.range != null ? problem.range.length : undefined).toEqual(2);
      const [start, end] = Array.from(problem.range);
      expect(start.ofs).toEqual(28);
      expect(start.row).toEqual(1);
      expect(start.col).toEqual(0);
      expect(end.ofs).toEqual(46);
      expect(end.row).toEqual(1);
      expect(end.col).toEqual(18);
      return expect(problem.message).toMatch(/Line 2/);
    })",snuts
/spec/aether/problem_spec.js,VerboseStatement,"{'startLine':421,'endLine':437}","it(""Call non-this undefined function x()"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = ""x()"";
        const problemContext = {thisMethods: [ 'log', 'attack' ]};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(1);
        expect(aether.problems.errors[0].type).toEqual(""runtime"");
        expect(aether.problems.errors[0].message).toEqual(""Line 1: ReferenceError: x is not defined"");
        expect(aether.problems.errors[0].hint).toEqual("""");
        return expect(aether.problems.errors[0].range).toEqual([ { ofs: 0, row: 0, col: 0 }, { ofs: 1, row: 0, col: 1 } ]);
      })",snuts
/spec/aether/problem_spec.js,VerboseStatement,"{'startLine':620,'endLine':636}","it(""Exact thisMethods with range checks"", function() {
        const history = [];
        const log = s => history.push(s);
        const attack = () => history.push('attack');
        const selfValue = {say: log, attack};
        const code = ""attack()"";
        const problemContext = {thisMethods: [ 'log', 'attack' ]};
        const aether = new Aether({language: ""python"", problemContext});
        aether.transpile(code);
        const method = aether.createMethod(selfValue);
        aether.run(method);
        expect(aether.problems.errors.length).toEqual(2);
        expect(aether.problems.errors[0].message).toEqual(""Missing `self` keyword; should be `self.attack`."");
        expect(aether.problems.errors[0].range).toEqual([ { ofs: 0, row: 0, col: 0 }, { ofs: 8, row: 0, col: 8 } ]);
        expect(aether.problems.errors[1].message).toEqual(""Line 1: ReferenceError: attack is not defined"");
        return expect(aether.problems.errors[1].range).toEqual([ { ofs: 0, row: 0, col: 0 }, { ofs: 6, row: 0, col: 6 } ]);
      })",snuts
/spec/aether/passthru_spec.js,TranscriptingTest,"{'startLine':8,'endLine':17}","it(""pass through python syntax info"", function() {
  const code = `\
self.attack('Brak)\
`;
  const aether = new Aether({language: 'python'});
  aether.transpile(code);
  console.log(aether.problems.errors[0]);
  expect(aether.problems.errors.length).toEqual(1);
  return expect(aether.problems.errors[0].extra.kind).toBe(""CLASSIFY"");
})",snuts
/spec/aether/lua_spec.js,AnonymousTest,"{'startLine':22,'endLine':26}","it(""return 1000"", () => expect(luaEval(`\

return 1000
\
`)).toEqual(1000))",snuts
/spec/aether/lua_spec.js,AnonymousTest,"{'startLine':27,'endLine':30}","it(""simple if"", () => expect(luaEval(`\
if false then return 2000 end
return 1000\
`)).toBe(1000))",snuts
/spec/aether/lua_spec.js,AnonymousTest,"{'startLine':32,'endLine':44}","it(""multiple elif"", () => expect(luaEval(`\
local x = 4
if x == 2 then
x = x + 1
return '2'
elseif x == 44564 then
x = x + 1
return '44564'
elseif x == 4 then
x = x + 1
return x
end\
`)).toBe(5))",snuts
/spec/aether/lua_spec.js,AnonymousTest,"{'startLine':46,'endLine':52}","it(""mathmetics order"", function() {
      const code = `\
return (2*2 + 2/2 - 2*2/2)\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe(3);
    })",snuts
/spec/aether/lua_spec.js,AnonymousTest,"{'startLine':54,'endLine':61}","it(""fibonacci function"", () => expect(luaEval(`\
function fib(n)
if n < 2 then return n
else return fib(n - 1) + fib(n - 2) end
end
chupacabra = fib(10)
return chupacabra\
`)).toEqual(55))",snuts
/spec/aether/lua_spec.js,AnonymousTest,"{'startLine':63,'endLine':70}","it(""for loop"", () => expect(luaEval(`\
data = {4, 2, 65, 7}
total = 0
for k,d in pairs(data) do
total = total + d
end
return total\
`)).toBe(78))",snuts
/spec/aether/lua_spec.js,AnonymousTest,"{'startLine':72,'endLine':115}","it(""bubble sort"", function() {
      const code = `\
local function createShuffled(n)
  r = n * 10 + 1
  shuffle = {}
  for i=1,n do
    item = r * math.random()
    shuffle[#shuffle] = item
  end
  return shuffle
end

local function bubbleSort(data)
  sorted = false
  while not sorted do
    sorted = true
    for i=1,#data - 1 do
      if data[i] > data[i + 1] then
        t = data[i]
        data[i] = data[i + 1]
        data[i+1] = t
        sorted = false
      end
    end
  end
  return data
end

local function isSorted(data)
  for i=1,#data - 1 do
    if data[i] > data[i + 1] then
      return false
    end
  end
  return true
end

data = createShuffled(10)
bubbleSort(data)
return isSorted(data)\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe(true);
    })",snuts
/spec/aether/lua_spec.js,AnonymousTest,"{'startLine':117,'endLine':124}","it(""dictionary"", function() {
      const code = `\
d = {p1='prop1'}
return d['p1']\
`;
      aether.transpile(code);
      return expect(aether.run()).toBe('prop1');
    })",snuts
/spec/aether/lua_spec.js,AnonymousTest,"{'startLine':168,'endLine':187}","it(""self.getItems"", function() {
      const history = [];
      const getItems = () => [{'pos':1}, {'pos':4}, {'pos':3}, {'pos':5}];
      const move = i => history.push(i);
      const thisValue = {getItems, move};
      const aetherOptions = {
        language
      };
      aether = new Aether(aetherOptions);
      const code = `\
local items = self.getItems()
for k,item in pairs(items) do
  self.move(item['pos'])
end\
`;
      aether.transpile(code);
      const method = aether.createMethod(thisValue);
      aether.run(method);
      return expect(history).toEqual([1, 4, 3, 5]);
    })",snuts
/spec/aether/lua_spec.js,VerboseStatement,"{'startLine':190,'endLine':219}","it(""Should capture runtime problems"", function() {
    // 0123456789012345678901234567
    const code = `\
self:explode()
self:exploooode()  -- should error
self:explode()\
`;
    const explosions = [];
    const thisValue = {explode() { return explosions.push('explosion!'); }};
    const aetherOptions = {language};
    aether = new Aether(aetherOptions);
    aether.transpile(code);
    const method = aether.createMethod(thisValue);
    aether.run(method);
    expect(explosions).toEqual(['explosion!']);
    expect(aether.problems.errors.length).toEqual(1);
    const problem = aether.problems.errors[0];
    expect(problem.type).toEqual('runtime');
    expect(problem.level).toEqual('error');
    expect(problem.message).toMatch(/exploooode/);
    expect(problem.range != null ? problem.range.length : undefined).toEqual(2);
    const [start, end] = Array.from(problem.range);
    expect(start.ofs).toEqual(15);
    expect(start.row).toEqual(1);
    expect(start.col).toEqual(0);
    expect(end.ofs).toEqual(32);
    expect(end.row).toEqual(1);
    expect(end.col).toEqual(17);
    return expect(problem.message).toMatch(/Line 2/);
  })",snuts
/spec/aether/java_errors_spec.js,AnonymousTest,"{'startLine':20,'endLine':29}","it(""no class"", function() {
    const code = `\
hero.moveLeft()\
`;
    aether = new Aether({language});
    aether.transpile(code);
    expect(aether.problems.errors.length).toEqual(1);
    expect(aether.problems.errors[0].message).toEqual('class, interface, or enum expected');
    return checkRange(aether.problems.errors[0], code, {row: 0, col: 0});
  })",snuts
/spec/aether/java_errors_spec.js,AnonymousTest,"{'startLine':47,'endLine':60}","it(""no semicolon"", function() {
    const code = `\
public class Main {
public static void main(String[] args) {
  hero.moveLeft()
}
}\
`;
    aether = new Aether({language});
    aether.transpile(code);
    expect(aether.problems.errors.length).toEqual(1);
    expect(aether.problems.errors[0].message).toEqual(""';' expected"");
    return checkRange(aether.problems.errors[0], code, {row: 3, col: 19});
  })",snuts
/spec/aether/java_errors_spec.js,AnonymousTest,"{'startLine':77,'endLine':90}","it(""unclosed comment"", function() {
    const code = `\
public class Main {
public static void main(String[] args) {
  /*
}
}\
`;
    aether = new Aether({language});
    aether.transpile(code);
    expect(aether.problems.errors.length).toEqual(1);
    expect(aether.problems.errors[0].message).toEqual(""reached end of file while parsing"");
    return checkRange(aether.problems.errors[0], code, {row: 3, col: 5});
  })",snuts
/spec/aether/java_errors_spec.js,AnonymousTest,"{'startLine':92,'endLine':107}","it(""unclosed if"", function() {
    const code = `\
public class Main {
public static void main(String[] args) {
  hero.moveLeft();
  if ( true ) {
    hero.moveRight();
}
}\
`;
    aether = new Aether({language});
    aether.transpile(code);
    expect(aether.problems.errors.length).toEqual(1);
    expect(aether.problems.errors[0].message).toEqual(""reached end of file while parsing"");
    return checkRange(aether.problems.errors[0], code, {row: 6, col: 1});
  })",snuts
/spec/aether/java_errors_spec.js,AnonymousTest,"{'startLine':109,'endLine':123}","it(""dangeling type"", function() {
    const code = `\
public class Main {
public static void main(String[] args) {
  hero.moveLeft();
  int;
}
}\
`;
    aether = new Aether({language});
    aether.transpile(code);
    expect(aether.problems.errors.length).toEqual(1);
    expect(aether.problems.errors[0].message).toEqual(""not a statement"");
    return checkRange(aether.problems.errors[0], code, {row: 4, col: 5});
  })",snuts
/spec/aether/java_errors_spec.js,AnonymousTest,"{'startLine':125,'endLine':136}","it(""no method"", function() {
    const code = `\
public class Main {
moveLeft()
}\
`;
    aether = new Aether({language});
    aether.transpile(code);
    expect(aether.problems.errors.length).toEqual(1);
    expect(aether.problems.errors[0].message).toEqual(""invalid method declaration; return type required"");
    return checkRange(aether.problems.errors[0], code, {row: 3, col: 3});
  })",snuts
/spec/aether/global_scope_spec.js,NonFunctionalStatement,"{'startLine':60,'endLine':60}","it('should protect builtins', function() {
    const code = ""(function(){}).__proto__.constructor = 100;"";
    const aether = new Aether();
    aether.transpile(code);
    aether.run();
    return expect((function() {}).__proto__.constructor).not.toEqual(100);
  })",snuts
/spec/aether/global_scope_spec.js,VerboseStatement,"{'startLine':128,'endLine':157}","it('should protect builtin prototypes', function() {
    const codeOne = `\
Array.prototype.diff = function(a) {
  return this.filter(function(i) { return a.indexOf(i) < 0; });
};
var sweet = [""frogs"", ""toads""];
var salty = [""toads""];
return sweet.diff(salty);\
`;
    const codeTwo = `\
var a = [""just"", ""three"", ""properties""];
var x = 0;
for (var key in a)
  ++x;
return x;\
`;
    let aether = new Aether();
    aether.transpile(codeOne);
    let fn = aether.createFunction();
    let ret = fn();
    expect(ret.length).toEqual(1);

    aether = new Aether();
    aether.transpile(codeTwo);
    fn = aether.createFunction();
    ret = fn();
    expect(ret).toEqual(3);
    expect(Array.prototype.diff).toBeUndefined();
    return delete Array.prototype.diff;
  })",snuts
/spec/aether/flow_spec.js,ConditionalTestLogic,"{'startLine':24,'endLine':29}","it(""should count statements and track vars"", function() {
    const thisValue = {say() {}};
    const options = {
      includeFlow: true,
      includeMetrics: true
    };
    const aether = new Aether(options);
    aether.transpile(code);
    const fn = aether.createMethod(thisValue);
    for (let i = 0; i < 4; i++) {
      if (i) {
        expect(aether.flow.states.length).toEqual(i);
        expect(aether.flow.states[i - 1].statementsExecuted).toEqual(nStatements);
        expect(aether.metrics.callsExecuted).toEqual(i);
        expect(aether.metrics.statementsExecuted).toEqual(i * nStatements);
      }
      fn();
    }
    const last = aether.flow.states[3].statements;
    expect(last[0].variables.four).not.toEqual(""4"");
    return expect(last[last.length - 1].variables.four).toEqual(""4"");
  })",snuts
/spec/aether/flow_spec.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}","it(""should count statements and track vars"", function() {
    const thisValue = {say() {}};
    const options = {
      includeFlow: true,
      includeMetrics: true
    };
    const aether = new Aether(options);
    aether.transpile(code);
    const fn = aether.createMethod(thisValue);
    for (let i = 0; i < 4; i++) {
      if (i) {
        expect(aether.flow.states.length).toEqual(i);
        expect(aether.flow.states[i - 1].statementsExecuted).toEqual(nStatements);
        expect(aether.metrics.callsExecuted).toEqual(i);
        expect(aether.metrics.statementsExecuted).toEqual(i * nStatements);
      }
      fn();
    }
    const last = aether.flow.states[3].statements;
    expect(last[0].variables.four).not.toEqual(""4"");
    return expect(last[last.length - 1].variables.four).toEqual(""4"");
  })",snuts
/spec/aether/flow_spec.js,NonFunctionalStatement,"{'startLine':38,'endLine':38}","it(""should obey includeFlow"", function() {
    const thisValue = {say() {}};
    const options = {
      includeFlow: false,
      includeMetrics: true
    };
    const aether = new Aether(options);
    aether.transpile(code);
    const fn = aether.createMethod(thisValue);
    fn();
    expect(aether.flow.states).toBe(undefined);
    expect(aether.metrics.callsExecuted).toEqual(1);
    return expect(aether.metrics.statementsExecuted).toEqual(nStatements);
  })",snuts
/spec/aether/flow_spec.js,NonFunctionalStatement,"{'startLine':53,'endLine':53}","it(""should obey includeMetrics"", function() {
    const thisValue = {say() {}};
    const options = {
      includeFlow: true,
      includeMetrics: false
    };
    const aether = new Aether(options);
    aether.transpile(code);
    const fn = aether.createMethod(thisValue);
    fn();
    expect(aether.flow.states.length).toEqual(1);
    expect(aether.flow.states[0].statementsExecuted).toEqual(nStatements);
    expect(aether.metrics.callsExecuted).toBe(undefined);
    return expect(aether.metrics.statementsExecuted).toBe(undefined);
  })",snuts
/spec/aether/flow_spec.js,NonFunctionalStatement,"{'startLine':69,'endLine':69}","it(""should not log statements when not needed"", function() {
    const thisValue = {say() {}};
    const options = {
      includeFlow: false,
      includeMetrics: false
    };
    const aether = new Aether(options);
    const pure = aether.transpile(code);
    expect(pure.search(/log(Statement|Call)/)).toEqual(-1);
    expect(pure.search(/_aetherUserInfo/)).toEqual(-1);
    return expect(pure.search(/_aether\.vars/)).toEqual(-1);
  })",snuts
/spec/aether/flow_spec.js,SubOptimalAssert,"{'startLine':47,'endLine':47}","it(""should obey includeFlow"", function() {
    const thisValue = {say() {}};
    const options = {
      includeFlow: false,
      includeMetrics: true
    };
    const aether = new Aether(options);
    aether.transpile(code);
    const fn = aether.createMethod(thisValue);
    fn();
    expect(aether.flow.states).toBe(undefined);
    expect(aether.metrics.callsExecuted).toEqual(1);
    return expect(aether.metrics.statementsExecuted).toEqual(nStatements);
  })",snuts
/spec/aether/flow_spec.js,SubOptimalAssert,"{'startLine':64,'endLine':64}","it(""should obey includeMetrics"", function() {
    const thisValue = {say() {}};
    const options = {
      includeFlow: true,
      includeMetrics: false
    };
    const aether = new Aether(options);
    aether.transpile(code);
    const fn = aether.createMethod(thisValue);
    fn();
    expect(aether.flow.states.length).toEqual(1);
    expect(aether.flow.states[0].statementsExecuted).toEqual(nStatements);
    expect(aether.metrics.callsExecuted).toBe(undefined);
    return expect(aether.metrics.statementsExecuted).toBe(undefined);
  })",snuts
/spec/aether/flow_spec.js,SubOptimalAssert,"{'startLine':65,'endLine':65}","it(""should obey includeMetrics"", function() {
    const thisValue = {say() {}};
    const options = {
      includeFlow: true,
      includeMetrics: false
    };
    const aether = new Aether(options);
    aether.transpile(code);
    const fn = aether.createMethod(thisValue);
    fn();
    expect(aether.flow.states.length).toEqual(1);
    expect(aether.flow.states[0].statementsExecuted).toEqual(nStatements);
    expect(aether.metrics.callsExecuted).toBe(undefined);
    return expect(aether.metrics.statementsExecuted).toBe(undefined);
  })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':103,'endLine':111}","it(""Incomplete string"", function() {
      const code = `\
var s = 'hi
return s;\
`;
      aether.transpile(code);
      expect(aether.problems.errors.length).toEqual(2);
      return expect(aether.problems.errors[0].message).toEqual(""Line 1: Unclosed string."");
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':115,'endLine':127}","it(""Runtime ReferenceError"", function() {
      const code = `\
var x = 5;
var y = x + z;\
`;
      aether.transpile(code);
      aether.run();
      console.log(aether.esperEngine.options);
      console.log(aether.problems.errors);
      expect(aether.problems.errors.length).toEqual(1);
      expect(aether.problems.errors[0].message).toEqual(""Line 2: ReferenceError: z is not defined"");
      return expect(aether.problems.errors[0].range).toEqual([ { ofs : 23, row : 1, col : 12 }, { ofs : 24, row : 1, col : 13 } ]);
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':432,'endLine':453}","it(""IIFE"", function() {
      const dude = {
        slay() { return this.enemy = ""slain!""; },
        hesitate() { return aether._shouldYield = true; }
      };
      const code = `\
(function (self) {
  for (var i = 0, max = 3; i < max; ++i) {
    self.hesitate();
  }
})(this);
this.slay();\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(true);
      return expect(dude.enemy).toEqual(""slain!"");
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':605,'endLine':630}","it(""Complex objects"", function() {
      const dude = {
        slay() { return this.enemy = ""slain!""; },
        hesitate() { return aether._shouldYield = true; }
      };
      const code = `\
var o1 = {};
o1.m = function(self) {
  self.hesitate();
};
o1.o2 = {};
o1.o2.m = function(self) {
  self.hesitate();
};
o1.m(this);
o1.o2.m(this);
this.slay();\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(true);
      return expect(dude.enemy).toEqual(""slain!"");
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':655,'endLine':696}","it(""Nested clauses"", function() {
      const dude = {
        slay() { return this.enemy = ""slain!""; },
        hesitate() { return aether._shouldYield = true; }
      };
      const code = `\
this.b = function (self) {
    self.hesitate();
}
function f(self) {
  self.hesitate();
  self.b(self);
}
if (true) {
  f(this);
}
for (var i = 0; i < 2; i++) {
  if (i === 1) {
    f(this);
  }
}
var inc = 0;
while (inc < 2) {
  f(this);
  inc += 1;
}
this.slay();\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(true);
      return expect(dude.enemy).toEqual(""slain!"");
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':839,'endLine':851}","it(""loop{"", function() {
      const code = `\
var total = 0
while (true) {
  total += 1
  break;
}
return total\
`;
      const aether = new Aether({language: ""javascript"", simpleLoops: true});
      aether.transpile(code);
      return expect(aether.run()).toEqual(1);
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':853,'endLine':862}","it(""loop {}"", function() {
      const code = `\
var total = 0
while (true) { total += 1; if (total >= 12) {break;}}
return total\
`;
      const aether = new Aether({language: ""javascript"", simpleLoops: true});
      aether.transpile(code);
      return expect(aether.run()).toEqual(12);
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':864,'endLine':899}","it(""Conditional yielding"", function() {
      const aether = new Aether({yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while (true) {
  this.slay();
  break;
}
while (true) {
  this.slay();
  if (this.getKillCount() >= 5) {
    break;
  }
}
while (true) {
  this.slay();
  break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      for (let i = 1; i <= 6; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(6);
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':1119,'endLine':1150}","it(""Automatic yielding"", function() {
      const aether = new Aether({yieldAutomatically: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() { return this.killCount += 1; },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while (true) {
  this.slay();
  break;
}
while (true) {
  this.slay();
  if (this.getKillCount() >= 5) {
    break;
  }
}
while (true) {
  this.slay();
  break;
}
\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      while (true) {
        if (gen.next().done) { break; }
      }
      return expect(dude.killCount).toEqual(6);
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':1165,'endLine':1200}","it(""Conditional yielding"", function() {
      const aether = new Aether({yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while (1 === 1) {
  this.slay();
  break;
}
while (true) {
  this.slay();
  if (this.getKillCount() >= 5) {
    break;
  }
}
while (3 === 3) {
  this.slay();
  break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      for (let i = 1; i <= 6; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(6);
    })",snuts
/spec/aether/es6_spec.js,AnonymousTest,"{'startLine':1420,'endLine':1451}","it(""Automatic yielding"", function() {
      const aether = new Aether({yieldAutomatically: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() { return this.killCount += 1; },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while (1 === 1) {
  this.slay();
  break;
}
while (true) {
  this.slay();
  if (this.getKillCount() >= 5) {
    break;
  }
}
while (3 === 3) {
  this.slay();
  break;
}
\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      while (true) {
        if (gen.next().done) { break; }
      }
      return expect(dude.killCount).toEqual(6);
    })",snuts
/spec/aether/es6_spec.js,TranscriptingTest,"{'startLine':115,'endLine':127}","it(""Runtime ReferenceError"", function() {
      const code = `\
var x = 5;
var y = x + z;\
`;
      aether.transpile(code);
      aether.run();
      console.log(aether.esperEngine.options);
      console.log(aether.problems.errors);
      expect(aether.problems.errors.length).toEqual(1);
      expect(aether.problems.errors[0].message).toEqual(""Line 2: ReferenceError: z is not defined"");
      return expect(aether.problems.errors[0].range).toEqual([ { ofs : 23, row : 1, col : 12 }, { ofs : 24, row : 1, col : 13 } ]);
    })",snuts
/spec/aether/es6_spec.js,IdenticalTestDescription,"{'startLine':1165,'endLine':1200}","it(""Conditional yielding"", function() {
      const aether = new Aether({yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while (1 === 1) {
  this.slay();
  break;
}
while (true) {
  this.slay();
  if (this.getKillCount() >= 5) {
    break;
  }
}
while (3 === 3) {
  this.slay();
  break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      for (let i = 1; i <= 6; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(6);
    })",snuts
/spec/aether/es6_spec.js,IdenticalTestDescription,"{'startLine':1202,'endLine':1215}","it(""Conditional yielding infinite loop"", function() {
      const aether = new Aether({yieldConditionally: true, whileTrueAutoYield: true});
      const code = `\
var x = 0;
while (true) {
  x++;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f();
      return __range__(0, 100, true).map((i) =>
        expect(gen.next().done).toEqual(false));
    })",snuts
/spec/aether/es6_spec.js,IdenticalTestDescription,"{'startLine':1217,'endLine':1240}","it(""Conditional yielding empty loop"", function() {
      const aether = new Aether({yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
var x = 0;
while (true) {
  x++;
  if (x >= 3) break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      return expect(gen.next().done).toEqual(true);
    })",snuts
/spec/aether/es6_spec.js,IdenticalTestDescription,"{'startLine':1300,'endLine':1418}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
function f() {
  // outer auto yield, inner yield
  var x = 0;
  while (true) {
    var y = 0;
    while (true) {
      this.slay();
      y++;
      if (y >= 2) break;
    }
    x++;
    if (x >= 3) break;
  }
}
f.call(this);

// outer yield, inner auto yield
var x = 0;
while (true) {
  this.slay();
  var y = 0;
  while (true) {
    y++;
    if (y >= 4) break;
  }
  x++;
  if (x >= 5) break;
}

// outer and inner auto yield
x = 0;
while (true) {
  y = 0;
  while (true) {
    y++;
    if (y >= 6) break;
  }
  x++;
  if (x >= 7) break;
}

// outer and inner yields
x = 0;
while (true) {
  this.slay();
  y = 0;
  while (true) {
    this.slay();
    y++;
    if (y >= 9) break;
  }
  x++;
  if (x >= 8) break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: keep in mind no-yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/es6_spec.js,IdenticalTestDescription,"{'startLine':1420,'endLine':1451}","it(""Automatic yielding"", function() {
      const aether = new Aether({yieldAutomatically: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() { return this.killCount += 1; },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while (1 === 1) {
  this.slay();
  break;
}
while (true) {
  this.slay();
  if (this.getKillCount() >= 5) {
    break;
  }
}
while (3 === 3) {
  this.slay();
  break;
}
\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      while (true) {
        if (gen.next().done) { break; }
      }
      return expect(dude.killCount).toEqual(6);
    })",snuts
/spec/aether/es6_spec.js,ConditionalTestLogic,"{'startLine':232,'endLine':232}","it(""should yield a lot"", function() {
      let i;
      const dude =
        {charge() { return ""attack!""; }};
      const code = `\
this.charge();
var x = 3;
x += 5 * 8;
return this.charge();\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      // At least four times
      for (i = 0; i < 4; i++) {
        expect(gen.next().done).toEqual(false);
      }
      // Should stop eventually
      while (i < 100) {
        if (gen.next().done) { break; } else { ++i; }
      }
      return expect(i < 100).toBe(true);
    })",snuts
/spec/aether/es6_spec.js,ConditionalTestLogic,"{'startLine':259,'endLine':259}","it(""with user method"", function() {
      let i;
      const dude =
        {charge() { return ""attack!""; }};
      const code = `\
function f(self) {
  self.charge();
}
f(this);
var x = 3;
x += 5 * 8;
return this.charge();\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      // At least four times
      for (i = 0; i < 4; i++) {
        expect(gen.next().done).toEqual(false);
      }
      // Should stop eventually
      while (i < 100) {
        if (gen.next().done) { break; } else { ++i; }
      }
      return expect(i < 100).toBe(true);
    })",snuts
/spec/aether/es6_spec.js,ConditionalTestLogic,"{'startLine':1078,'endLine':1078}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
function f() {
  // outer auto yield, inner yield
  var x = 0;
  while (true) {
    var y = 0;
    while (true) {
      this.slay();
      y++;
      if (y >= 2) break;
    }
    x++;
    if (x >= 3) break;
  }
}
f.call(this);

// outer yield, inner auto yield
var x = 0;
while (true) {
  this.slay();
  var y = 0;
  while (true) {
    y++;
    if (y >= 4) break;
  }
  x++;
  if (x >= 5) break;
}

// outer and inner auto yield
x = 0;
while (true) {
  y = 0;
  while (true) {
    y++;
    if (y >= 6) break;
  }
  x++;
  if (x >= 7) break;
}

// outer and inner yields
x = 0;
while (true) {
  this.slay();
  y = 0;
  while (true) {
    this.slay();
    y++;
    if (y >= 9) break;
  }
  x++;
  if (x >= 8) break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: keep in mind no-yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/es6_spec.js,ConditionalTestLogic,"{'startLine':1100,'endLine':1100}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
function f() {
  // outer auto yield, inner yield
  var x = 0;
  while (true) {
    var y = 0;
    while (true) {
      this.slay();
      y++;
      if (y >= 2) break;
    }
    x++;
    if (x >= 3) break;
  }
}
f.call(this);

// outer yield, inner auto yield
var x = 0;
while (true) {
  this.slay();
  var y = 0;
  while (true) {
    y++;
    if (y >= 4) break;
  }
  x++;
  if (x >= 5) break;
}

// outer and inner auto yield
x = 0;
while (true) {
  y = 0;
  while (true) {
    y++;
    if (y >= 6) break;
  }
  x++;
  if (x >= 7) break;
}

// outer and inner yields
x = 0;
while (true) {
  this.slay();
  y = 0;
  while (true) {
    this.slay();
    y++;
    if (y >= 9) break;
  }
  x++;
  if (x >= 8) break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: keep in mind no-yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/es6_spec.js,ConditionalTestLogic,"{'startLine':1147,'endLine':1147}","it(""Automatic yielding"", function() {
      const aether = new Aether({yieldAutomatically: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() { return this.killCount += 1; },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while (true) {
  this.slay();
  break;
}
while (true) {
  this.slay();
  if (this.getKillCount() >= 5) {
    break;
  }
}
while (true) {
  this.slay();
  break;
}
\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      while (true) {
        if (gen.next().done) { break; }
      }
      return expect(dude.killCount).toEqual(6);
    })",snuts
/spec/aether/es6_spec.js,ConditionalTestLogic,"{'startLine':1379,'endLine':1379}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
function f() {
  // outer auto yield, inner yield
  var x = 0;
  while (true) {
    var y = 0;
    while (true) {
      this.slay();
      y++;
      if (y >= 2) break;
    }
    x++;
    if (x >= 3) break;
  }
}
f.call(this);

// outer yield, inner auto yield
var x = 0;
while (true) {
  this.slay();
  var y = 0;
  while (true) {
    y++;
    if (y >= 4) break;
  }
  x++;
  if (x >= 5) break;
}

// outer and inner auto yield
x = 0;
while (true) {
  y = 0;
  while (true) {
    y++;
    if (y >= 6) break;
  }
  x++;
  if (x >= 7) break;
}

// outer and inner yields
x = 0;
while (true) {
  this.slay();
  y = 0;
  while (true) {
    this.slay();
    y++;
    if (y >= 9) break;
  }
  x++;
  if (x >= 8) break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: keep in mind no-yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/es6_spec.js,ConditionalTestLogic,"{'startLine':1401,'endLine':1401}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
function f() {
  // outer auto yield, inner yield
  var x = 0;
  while (true) {
    var y = 0;
    while (true) {
      this.slay();
      y++;
      if (y >= 2) break;
    }
    x++;
    if (x >= 3) break;
  }
}
f.call(this);

// outer yield, inner auto yield
var x = 0;
while (true) {
  this.slay();
  var y = 0;
  while (true) {
    y++;
    if (y >= 4) break;
  }
  x++;
  if (x >= 5) break;
}

// outer and inner auto yield
x = 0;
while (true) {
  y = 0;
  while (true) {
    y++;
    if (y >= 6) break;
  }
  x++;
  if (x >= 7) break;
}

// outer and inner yields
x = 0;
while (true) {
  this.slay();
  y = 0;
  while (true) {
    this.slay();
    y++;
    if (y >= 9) break;
  }
  x++;
  if (x >= 8) break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: keep in mind no-yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/es6_spec.js,ConditionalTestLogic,"{'startLine':1448,'endLine':1448}","it(""Automatic yielding"", function() {
      const aether = new Aether({yieldAutomatically: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() { return this.killCount += 1; },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while (1 === 1) {
  this.slay();
  break;
}
while (true) {
  this.slay();
  if (this.getKillCount() >= 5) {
    break;
  }
}
while (3 === 3) {
  this.slay();
  break;
}
\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      while (true) {
        if (gen.next().done) { break; }
      }
      return expect(dude.killCount).toEqual(6);
    })",snuts
/spec/aether/es6_spec.js,SubOptimalAssert,"{'startLine':234,'endLine':234}","it(""should yield a lot"", function() {
      let i;
      const dude =
        {charge() { return ""attack!""; }};
      const code = `\
this.charge();
var x = 3;
x += 5 * 8;
return this.charge();\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      // At least four times
      for (i = 0; i < 4; i++) {
        expect(gen.next().done).toEqual(false);
      }
      // Should stop eventually
      while (i < 100) {
        if (gen.next().done) { break; } else { ++i; }
      }
      return expect(i < 100).toBe(true);
    })",snuts
/spec/aether/es6_spec.js,SubOptimalAssert,"{'startLine':261,'endLine':261}","it(""with user method"", function() {
      let i;
      const dude =
        {charge() { return ""attack!""; }};
      const code = `\
function f(self) {
  self.charge();
}
f(this);
var x = 3;
x += 5 * 8;
return this.charge();\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      // At least four times
      for (i = 0; i < 4; i++) {
        expect(gen.next().done).toEqual(false);
      }
      // Should stop eventually
      while (i < 100) {
        if (gen.next().done) { break; } else { ++i; }
      }
      return expect(i < 100).toBe(true);
    })",snuts
/spec/aether/es6_spec.js,VerboseStatement,"{'startLine':655,'endLine':696}","it(""Nested clauses"", function() {
      const dude = {
        slay() { return this.enemy = ""slain!""; },
        hesitate() { return aether._shouldYield = true; }
      };
      const code = `\
this.b = function (self) {
    self.hesitate();
}
function f(self) {
  self.hesitate();
  self.b(self);
}
if (true) {
  f(this);
}
for (var i = 0; i < 2; i++) {
  if (i === 1) {
    f(this);
  }
}
var inc = 0;
while (inc < 2) {
  f(this);
  inc += 1;
}
this.slay();\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(false);
      expect(gen.next().done).toEqual(true);
      return expect(dude.enemy).toEqual(""slain!"");
    })",snuts
/spec/aether/es6_spec.js,VerboseStatement,"{'startLine':941,'endLine':997}","it(""Conditional yielding mixed loops"", function() {
      let i;
      const aether = new Aether({yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
while (true) {
  this.slay();
  if (this.getKillCount() >= 5) {
    break;
  }
}
function f() {
  var x = 0;
  while (true) {
    x++;
    if (x > 10) break;
  }
  while (true) {
    this.slay();
    if (this.getKillCount() >= 15) {
      break;
    }
  }
}
f.call(this);
while (true) {
  this.slay();
  break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);
      for (i = 1; i <= 5; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      for (i = 1; i <= 10; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(5);
      }
      for (i = 6; i <= 15; i++) {
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i);
      }
      expect(gen.next().done).toEqual(false);
      expect(dude.killCount).toEqual(16);
      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(16);
    })",snuts
/spec/aether/es6_spec.js,VerboseStatement,"{'startLine':999,'endLine':1117}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({yieldConditionally: true, simpleLoops: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
function f() {
  // outer auto yield, inner yield
  var x = 0;
  while (true) {
    var y = 0;
    while (true) {
      this.slay();
      y++;
      if (y >= 2) break;
    }
    x++;
    if (x >= 3) break;
  }
}
f.call(this);

// outer yield, inner auto yield
var x = 0;
while (true) {
  this.slay();
  var y = 0;
  while (true) {
    y++;
    if (y >= 4) break;
  }
  x++;
  if (x >= 5) break;
}

// outer and inner auto yield
x = 0;
while (true) {
  y = 0;
  while (true) {
    y++;
    if (y >= 6) break;
  }
  x++;
  if (x >= 7) break;
}

// outer and inner yields
x = 0;
while (true) {
  this.slay();
  y = 0;
  while (true) {
    this.slay();
    y++;
    if (y >= 9) break;
  }
  x++;
  if (x >= 8) break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: keep in mind no-yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/es6_spec.js,VerboseStatement,"{'startLine':1300,'endLine':1418}","it(""Conditional yielding nested loops"", function() {
      let i, j;
      const aether = new Aether({yieldConditionally: true, whileTrueAutoYield: true});
      const dude = {
        killCount: 0,
        slay() {
          this.killCount += 1;
          return aether._shouldYield = true;
        },
        getKillCount() { return this.killCount; }
      };
      const code = `\
function f() {
  // outer auto yield, inner yield
  var x = 0;
  while (true) {
    var y = 0;
    while (true) {
      this.slay();
      y++;
      if (y >= 2) break;
    }
    x++;
    if (x >= 3) break;
  }
}
f.call(this);

// outer yield, inner auto yield
var x = 0;
while (true) {
  this.slay();
  var y = 0;
  while (true) {
    y++;
    if (y >= 4) break;
  }
  x++;
  if (x >= 5) break;
}

// outer and inner auto yield
x = 0;
while (true) {
  y = 0;
  while (true) {
    y++;
    if (y >= 6) break;
  }
  x++;
  if (x >= 7) break;
}

// outer and inner yields
x = 0;
while (true) {
  this.slay();
  y = 0;
  while (true) {
    this.slay();
    y++;
    if (y >= 9) break;
  }
  x++;
  if (x >= 8) break;
}\
`;
      aether.transpile(code);
      const f = aether.createFunction();
      const gen = f.apply(dude);

      // NOTE: keep in mind no-yield loops break before invisible automatic yield

      // outer auto yield, inner yield
      for (i = 1; i <= 3; i++) {
        for (j = 1; j <= 2; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 2) + j);
        }
        if (i < 3) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6);

      // outer yield, inner auto yield
      let killOffset = dude.killCount;
      for (i = 1; i <= 5; i++) {
        for (j = 1; j <= 3; j++) {
          expect(gen.next().done).toEqual(false);
        }
        expect(gen.next().done).toEqual(false);
        expect(dude.killCount).toEqual(i + killOffset);
      }
      expect(dude.killCount).toEqual(6 + 5);

      // outer and inner auto yield
      killOffset = dude.killCount;
      for (i = 1; i <= 7; i++) {
        for (j = 1; j <= 5; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(killOffset);
        }
        if (i < 7) { expect(gen.next().done).toEqual(false); }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0);

      // outer and inner yields
      killOffset = dude.killCount;
      for (i = 1; i <= 8; i++) {
        expect(gen.next().done).toEqual(false);
        for (j = 1; j <= 9; j++) {
          expect(gen.next().done).toEqual(false);
          expect(dude.killCount).toEqual(((i - 1) * 9) + i + j + killOffset);
        }
      }
      expect(dude.killCount).toEqual(6 + 5 + 0 + 80);

      expect(gen.next().done).toEqual(true);
      return expect(dude.killCount).toEqual(91);
    })",snuts
/spec/aether/cs_spec.js,AnonymousTest,"{'startLine':37,'endLine':44}","it(""mathmetics order"", function() {
      const code = `\
return (2*2 + 2/2 - 2*2/2)\
`;
      aether.transpile(code);
      expect(aether.run()).toEqual(3);
      return expect(aether.problems.errors).toEqual([]);
  })",snuts
/spec/aether/cs_spec.js,AnonymousTest,"{'startLine':49,'endLine':60}","it(""function call"", function() {
      const code = `\
fib = (n) ->
  (if n < 2 then n else fib(n - 1) + fib(n - 2))
chupacabra = fib(6)\
`;
      aether.transpile(code);
      const fn = aether.createFunction();
      expect(aether.canTranspile(code)).toEqual(true);
      expect(aether.run()).toEqual(8); // fail
      return expect(aether.problems.errors).toEqual([]);
  })",snuts
/spec/aether/cs_spec.js,AnonymousTest,"{'startLine':65,'endLine':75}","it(""Simple For"", function() {
      const code = `\
count = 0
count++ for num in [1..10]
return count\
`;
      aether.transpile(code);
      expect(aether.canTranspile(code)).toEqual(true);
      expect(aether.run()).toEqual(10);
      return expect(aether.problems.errors).toEqual([]);
  })",snuts
/spec/aether/cs_spec.js,AnonymousTest,"{'startLine':77,'endLine':87}","it(""Simple While"", function() {
      const code = `\
count = 0
count++ until count is 100
return count\
`;
      aether.transpile(code);
      expect(aether.canTranspile(code)).toEqual(true);
      expect(aether.run()).toEqual(100);
      return expect(aether.problems.errors).toEqual([]);
  })",snuts
/spec/aether/cs_spec.js,AnonymousTest,"{'startLine':89,'endLine':97}","it(""Should Map"", function() {
      // See: https://github.com/codecombat/aether/issues/97
      const code = ""return (num for num in [10..1])"";

      aether.transpile(code);
      expect(aether.canTranspile(code)).toEqual(true);
      expect(aether.run()).toEqual([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
      return expect(aether.problems.errors).toEqual([]);
  })",snuts
/spec/aether/cs_spec.js,AnonymousTest,"{'startLine':186,'endLine':199}","it(""Bad indent"", function() {
      const code = `\
fn = ->
  x = 45
    x += 5
  return x
return fn()\
`;
      aether.transpile(code);
      expect(aether.problems.errors.length).toEqual(1);
      // TODO: No range information for this error
      // https://github.com/codecombat/aether/issues/114
      return expect(aether.problems.errors[0].message.indexOf(""Syntax error on line 5, column 10: unexpected '+'"")).toBe(0);
    })",snuts
/spec/aether/cs_spec.js,AnonymousTest,"{'startLine':289,'endLine':297}","it(""Incomplete string"", function() {
      const code = `\
s = 'hi
return s\
`;
      aether.transpile(code);
      expect(aether.problems.errors.length).toEqual(1);
      return expect(aether.problems.errors[0].message).toEqual(""Unclosed \""'\"" at EOF"");
    })",snuts
/spec/aether/cs_spec.js,IdenticalTestDescription,"{'startLine':23,'endLine':32}","it(""Should compile functions"", function() {
      const code = `\
return 2000 if false
return 1000\
`;
      aether.setLanguage(""coffeescript"");
      aether.transpile(code);
      expect(aether.canTranspile(code)).toEqual(true);
      return expect(aether.problems.errors).toEqual([]);
  })",snuts
/test/app/lib/LevelLoader.spec.ozar.js,AnonymousTest,"{'startLine':126,'endLine':143}","it('is idempotent', function() {
      const levelLoader = new LevelLoader({supermodel:new SuperModel(), sessionID: 'id', levelID: 'id'});

      // first load Tharin by the 'normal' session load
      let responses = {'/db/level/id': levelWithOgreWithMace};
      jasmine.Ajax.requests.sendResponses(responses);
      responses = {'/db/level.session/id': sessionWithTharinWithHelmet};
      jasmine.Ajax.requests.sendResponses(responses);

      // then try to load Tharin some more
      const session = new LevelSession(sessionWithTharinWithHelmet);
      levelLoader.loadDependenciesForSession(session);
      const numRequestsBefore = jasmine.Ajax.requests.count();
      levelLoader.loadDependenciesForSession(session);
      levelLoader.loadDependenciesForSession(session);
      const numRequestsAfter = jasmine.Ajax.requests.count();
      return expect(numRequestsAfter).toBe(numRequestsBefore);
    })",snuts
/test/app/lib/LevelLoader.spec.coco.js,AnonymousTest,"{'startLine':126,'endLine':143}","it('is idempotent', function() {
      const levelLoader = new LevelLoader({supermodel:new SuperModel(), sessionID: 'id', levelID: 'id'});

      // first load Tharin by the 'normal' session load
      let responses = {'/db/level/id': levelWithOgreWithMace};
      jasmine.Ajax.requests.sendResponses(responses);
      responses = {'/db/level.session/id': sessionWithTharinWithHelmet};
      jasmine.Ajax.requests.sendResponses(responses);

      // then try to load Tharin some more
      const session = new LevelSession(sessionWithTharinWithHelmet);
      levelLoader.loadDependenciesForSession(session);
      const numRequestsBefore = jasmine.Ajax.requests.count();
      levelLoader.loadDependenciesForSession(session);
      levelLoader.loadDependenciesForSession(session);
      const numRequestsAfter = jasmine.Ajax.requests.count();
      return expect(numRequestsAfter).toBe(numRequestsBefore);
    })",snuts
/test/app/core/utils.spec.ozar.js,AnonymousTest,"{'startLine':56,'endLine':56}","it('undefined', () => expect(utils.ageToBracket()).toBe('open'))",snuts
/test/app/core/utils.spec.ozar.js,AnonymousTest,"{'startLine':57,'endLine':57}","it('>= 19', () => expect(utils.ageToBracket(19)).toBe('open'))",snuts
/test/app/core/utils.spec.ozar.js,AnonymousTest,"{'startLine':465,'endLine':465}","it('defaultIfUnknown works', () => expect(utils.ageOfConsent(undefined, 13)).toEqual(13))",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':237,'endLine':254}","it('if born before 8/31/2002, should be open', function() {
          const now = new Date('2021-5-1');
          const end = new Date('2021-8-31');
          const birthDates = [
            '2002-8-31',
            '2001-10-1',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('open');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('open'));
            }
            return result;
          })();
        })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':802,'endLine':820}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1);
      })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':825,'endLine':832}","it('returns correct next levels when rc* p', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false }
        ];
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(1);
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1);
      })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':860,'endLine':870}","it('returns correct next levels when rc rc rc* a r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3);
      })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':990,'endLine':1008}","it('returns correct next levels when rc rc* p p p a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 1, needsPractice)).toEqual(2);
        return expect(utils.findNextAssessmentForLevel(levels, 1, needsPractice)).toEqual(-1);
      })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':1009,'endLine':1027}","it('returns correct next levels when rc rc pc* p p a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(3);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1);
      })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':1028,'endLine':1046}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':1047,'endLine':1065}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1);
      })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':1066,'endLine':1084}","it('returns correct next levels when rc rc pc pc pc ac rc* p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 6, needsPractice)).toEqual(7);
        return expect(utils.findNextAssessmentForLevel(levels, 6, needsPractice)).toEqual(-1);
      })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':1104,'endLine':1122}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(7);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",snuts
/test/app/core/utils.spec.ozar.js,IdenticalTestDescription,"{'startLine':1142,'endLine':1160}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1);
      })",snuts
/test/app/core/utils.spec.coco.js,AnonymousTest,"{'startLine':58,'endLine':58}","it('undefined', () => expect(utils.ageToBracket()).toBe('open'))",snuts
/test/app/core/utils.spec.coco.js,AnonymousTest,"{'startLine':59,'endLine':59}","it('>= 19', () => expect(utils.ageToBracket(19)).toBe('open'))",snuts
/test/app/core/utils.spec.coco.js,AnonymousTest,"{'startLine':463,'endLine':463}","it('defaultIfUnknown works', () => expect(utils.ageOfConsent(undefined, 13)).toEqual(13))",snuts
/test/app/core/utils.spec.coco.js,GeneralFixture,"{'startLine':1323,'endLine':1323}","beforeEach(() => {
      // Save the original 'me' object
      originalMe = global.me;
  
      me = {
        isTeacher: jasmine.createSpy(),
        isAnonymous: jasmine.createSpy()
      };
      global.me = me;
    })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':162,'endLine':183}","it('if born after 9/1/2009, should be 0-11', function () {
          const now = new Date(2021, 4, 1)
          const end = new Date(2021, 7, 31)
          const birthDates = [
            '2009-9-1',
            '2009-10-1',
            '2010-1-1',
            '2010-8-31',
            '2010-9-1',
            '2011-09-01'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('0-11')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('0-11'))
            }
            return result
          })()
        })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':185,'endLine':208}","it('if born during 9/1/2006 to 8/31/2009, should be 11-14', function () {
          const now = new Date(2021, 4, 1)
          const end = new Date(2021, 7, 31)
          const birthDates = [
            '2006-9-1',
            '2006-10-1',
            '2007-1-1',
            '2007-9-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-8-31'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('11-14')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('11-14'))
            }
            return result
          })()
        })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':210,'endLine':233}","it('if born during 9/1/2002 to 8/31/2006, should be 14-18', function () {
          const now = new Date(2021, 4, 1)
          const end = new Date(2021, 7, 31)
          const birthDates = [
            '2002-9-1',
            '2002-10-1',
            '2003-1-1',
            '2003-9-1',
            '2004-1-1',
            '2005-9-1',
            '2006-1-1',
            '2006-8-31'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('14-18')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('14-18'))
            }
            return result
          })()
        })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':235,'endLine':252}","it('if born before 8/31/2002, should be open', function () {
          const now = new Date(2021, 4, 1)
          const end = new Date(2021, 7, 31)
          const birthDates = [
            '2002-8-31',
            '2001-10-1'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('open')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('open'))
            }
            return result
          })()
        })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':887,'endLine':905}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':921,'endLine':928}","it('returns correct next levels when rc* p', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(1)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':956,'endLine':966}","it('returns correct next levels when rc rc rc* a r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':1086,'endLine':1104}","it('returns correct next levels when rc rc* p p p a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 1, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 1, needsPractice)).toEqual(-1)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':1105,'endLine':1123}","it('returns correct next levels when rc rc pc* p p a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(3)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':1124,'endLine':1142}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':1143,'endLine':1161}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':1162,'endLine':1180}","it('returns correct next levels when rc rc pc pc pc ac rc* p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 6, needsPractice)).toEqual(7)
        return expect(utils.findNextAssessmentForLevel(levels, 6, needsPractice)).toEqual(-1)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':1200,'endLine':1218}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(7)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':1238,'endLine':1256}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1)
      })",snuts
/test/app/core/utils.spec.coco.js,IdenticalTestDescription,"{'startLine':1257,'endLine':1267}","it('returns correct next levels when rc rc* rcl p r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true, locked: true },
          { practice: true, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 1, needsPractice)).toEqual(-1)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",snuts
/test/app/core/locale.spec.coco.js,ConditionalTestLogic,"{'startLine':23,'endLine':29}","it('should have numbered placeholders $1 through $N', function() {
        const placeholders = (esper[key].match(/\$\d/g) || []).sort();
        const expectedPlaceholders = (Array.from(placeholders).map((val, index) => `$${index+1}`));
        if (!_.isEqual(placeholders, expectedPlaceholders)) {
          return fail(`\
Some placeholders were skipped: ${placeholders}
Translated string: ${esper[key]}\
`
          );
        }
      })",snuts
/test/app/core/locale.spec.coco.js,ConditionalTestLogic,"{'startLine':33,'endLine':35}","it('should have the same placeholders in each entry as in English', function() {
        if (!englishEsper[key]) {
          return fail(`Expected English to have a corresponding key for ${key}`);
        }
        const englishPlaceholders = (englishEsper[key].match(/\$\d/g) || []).sort();
        const placeholders = (esper[key].match(/\$\d/g) || []).sort();
        if (!_.isEqual(placeholders, englishPlaceholders)) {
          return fail(`\
Expected translated placeholders: [${placeholders}] (${esper[key]})
To match English placeholders: [${englishPlaceholders}] (${englishEsper[key]})\
`
          );
        }
      })",snuts
/test/app/core/locale.spec.coco.js,ConditionalTestLogic,"{'startLine':38,'endLine':44}","it('should have the same placeholders in each entry as in English', function() {
        if (!englishEsper[key]) {
          return fail(`Expected English to have a corresponding key for ${key}`);
        }
        const englishPlaceholders = (englishEsper[key].match(/\$\d/g) || []).sort();
        const placeholders = (esper[key].match(/\$\d/g) || []).sort();
        if (!_.isEqual(placeholders, englishPlaceholders)) {
          return fail(`\
Expected translated placeholders: [${placeholders}] (${esper[key]})
To match English placeholders: [${englishPlaceholders}] (${englishEsper[key]})\
`
          );
        }
      })",snuts
/test/app/core/locale.spec.coco.js,ConditionalTestLogic,"{'startLine':82,'endLine':93}","it('should have the same keys in each entry as in English', function() {
      if (diff.length) {
        return diff.slice(0, 100).forEach(key => fail(`\
Expected english to have translation '${key}'
This can occur when:
* Parent key for '${key.split('.')[0]}' is accidentally commented.
* English translation for '${key}' has been deleted.
You may need to run copy-i18n-tags.js\
`
        ));
      } else {
        return expect(diff.length).toBe(0);
      }
    })",snuts
/test/app/core/locale.spec.coco.js,SubOptimalAssert,"{'startLine':92,'endLine':92}","it('should have the same keys in each entry as in English', function() {
      if (diff.length) {
        return diff.slice(0, 100).forEach(key => fail(`\
Expected english to have translation '${key}'
This can occur when:
* Parent key for '${key.split('.')[0]}' is accidentally commented.
* English translation for '${key}' has been deleted.
You may need to run copy-i18n-tags.js\
`
        ));
      } else {
        return expect(diff.length).toBe(0);
      }
    })",snuts
/app/views/play/SpectateView.js,NonFunctionalStatement,"{'startLine':360,'endLine':360}",Unknown,snuts
/test/app/views/core/SubscribeModal.spec.ozar.js,AnonymousTest,"{'startLine':194,'endLine':198}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.ozar.js,AnonymousTest,"{'startLine':242,'endLine':246}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.ozar.js,IdenticalTestDescription,"{'startLine':242,'endLine':246}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.ozar.js,SubOptimalAssert,"{'startLine':195,'endLine':195}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.ozar.js,SubOptimalAssert,"{'startLine':196,'endLine':196}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.ozar.js,SubOptimalAssert,"{'startLine':243,'endLine':243}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.ozar.js,SubOptimalAssert,"{'startLine':244,'endLine':244}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.coco.js,AnonymousTest,"{'startLine':209,'endLine':213}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.coco.js,AnonymousTest,"{'startLine':257,'endLine':261}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.coco.js,IdenticalTestDescription,"{'startLine':257,'endLine':261}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.coco.js,SubOptimalAssert,"{'startLine':128,'endLine':128}","it('expect yearly subscription button', function() {
      // TODO: update this to handle more complex logic (either annual or lifetime)
      return expect(this.modal.$('.stripe-annual-button').length).toBe(1);
    })",snuts
/test/app/views/core/SubscribeModal.spec.coco.js,SubOptimalAssert,"{'startLine':210,'endLine':210}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.coco.js,SubOptimalAssert,"{'startLine':211,'endLine':211}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.coco.js,SubOptimalAssert,"{'startLine':258,'endLine':258}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/views/core/SubscribeModal.spec.coco.js,SubOptimalAssert,"{'startLine':259,'endLine':259}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':90,'endLine':90}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':114,'endLine':114}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':115,'endLine':115}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':117,'endLine':117}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':150,'endLine':150}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':189,'endLine':189}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':237,'endLine':237}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':279,'endLine':279}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':294,'endLine':294}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':318,'endLine':318}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,SubOptimalAssert,"{'startLine':378,'endLine':378}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,VerboseStatement,"{'startLine':38,'endLine':56}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,VerboseStatement,"{'startLine':58,'endLine':79}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,VerboseStatement,"{'startLine':81,'endLine':118}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,VerboseStatement,"{'startLine':137,'endLine':190}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,VerboseStatement,"{'startLine':192,'endLine':238}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,VerboseStatement,"{'startLine':240,'endLine':281}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,VerboseStatement,"{'startLine':283,'endLine':320}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",snuts
/test/app/lib/world/GoalManager.spec.ozar.js,VerboseStatement,"{'startLine':322,'endLine':380}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",snuts
/test/app/lib/world/GoalManager.spec.coco.js,VerboseStatement,"{'startLine':20,'endLine':38}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",snuts
/test/app/lib/world/GoalManager.spec.coco.js,VerboseStatement,"{'startLine':40,'endLine':61}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,SubOptimalAssert,"{'startLine':76,'endLine':76}","it('adds googleClassrooms to the `me` object', async function(done) {
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(gClassrooms))
    expect(me.get('googleClassrooms')).toBeUndefined()
    try {
      await GoogleClassroomHandler.importClassrooms()
      expect(me.get('googleClassrooms')).toBeDefined()
      expect(me.get('googleClassrooms').length).toBe(gClassrooms.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,SubOptimalAssert,"{'startLine':92,'endLine':92}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,SubOptimalAssert,"{'startLine':114,'endLine':114}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,SubOptimalAssert,"{'startLine':134,'endLine':134}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(1)

    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,SubOptimalAssert,"{'startLine':146,'endLine':146}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(1)

    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,SubOptimalAssert,"{'startLine':76,'endLine':76}","it('adds googleClassrooms to the `me` object', async function(done) {
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(gClassrooms))
    expect(me.get('googleClassrooms')).toBeUndefined()
    try {
      await GoogleClassroomHandler.importClassrooms()
      expect(me.get('googleClassrooms')).toBeDefined()
      expect(me.get('googleClassrooms').length).toBe(gClassrooms.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,SubOptimalAssert,"{'startLine':92,'endLine':92}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,SubOptimalAssert,"{'startLine':114,'endLine':114}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,SubOptimalAssert,"{'startLine':134,'endLine':134}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(1)
    
    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))
  
    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,SubOptimalAssert,"{'startLine':146,'endLine':146}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(1)
    
    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))
  
    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",snuts
/test/ozaria/site/components/sign-up/signUpConfig.spec.js,Conditional Test Logic,"{'line': 59, 'column': 2, 'index': 1733}",Unknown,steel
/test/ozaria/site/components/sign-up/signUpConfig.spec.js,Conditional Test Logic,"{'line': 60, 'column': 4, 'index': 1758}",Unknown,steel
/test/ozaria/site/components/sign-up/signUpConfig.spec.js,Conditional Test Logic,"{'line': 69, 'column': 4, 'index': 2064}",Unknown,steel
/test/ozaria/site/components/sign-up/signUpConfig.spec.js,Conditional Test Logic,"{'line': 71, 'column': 6, 'index': 2149}",Unknown,steel
/test/ozaria/site/components/sign-up/signUpConfig.spec.js,Unknown Test,"{'column': 4, 'line': 85}","it('role = parent, any country', () => {
      const fields = getSchoolFormFieldsConfig('test', EDUCATOR_ROLES.PARENT.value, isChinaServer)
      const expected = getExpectedConfigParents()
      checkFields(fields, expected)
    })",steel
/test/ozaria/site/components/sign-up/signUpConfig.spec.js,Unknown Test,"{'column': 4, 'line': 91}","it('any educator role, any non-US country', () => {
      const fields = getSchoolFormFieldsConfig('test', EDUCATOR_ROLES.TEACHER.value, isChinaServer)
      const expected = getExpectedConfigNonUSEducator()
      checkFields(fields, expected)
    })",steel
/test/ozaria/site/components/sign-up/signUpConfig.spec.js,Unknown Test,"{'column': 4, 'line': 97}","it('role = teacher/principal, country = US', () => {
      const fields1 = getSchoolFormFieldsConfig(COUNTRIES.US, EDUCATOR_ROLES.TEACHER.value, isChinaServer)
      const expected1 = getExpectedConfigUSTeacher()
      checkFields(fields1, expected1)
      const fields2 = getSchoolFormFieldsConfig(COUNTRIES.US, EDUCATOR_ROLES.PRINCIPAL.value, isChinaServer)
      const expected2 = getExpectedConfigUSTeacher()
      checkFields(fields2, expected2)
    })",steel
/test/ozaria/site/components/sign-up/signUpConfig.spec.js,Unknown Test,"{'column': 4, 'line': 106}","it('role = tech coord/advisor, country = US', () => {
      const fields1 = getSchoolFormFieldsConfig(COUNTRIES.US, EDUCATOR_ROLES.TECH_COORD.value, isChinaServer)
      const expected1 = getExpectedConfigUSTechCoord()
      checkFields(fields1, expected1)
      const fields2 = getSchoolFormFieldsConfig(COUNTRIES.US, EDUCATOR_ROLES.CURR_SPEC_ADV.value, isChinaServer)
      const expected2 = getExpectedConfigUSTechCoord()
      checkFields(fields2, expected2)
    })",steel
/test/ozaria/site/components/sign-up/signUpConfig.spec.js,Unknown Test,"{'column': 4, 'line': 115}","it('role = superintendent, country = US', () => {
      const fields = getSchoolFormFieldsConfig(COUNTRIES.US, EDUCATOR_ROLES.SUPERIN.value, isChinaServer)
      const expected = getExpectedConfigUSSuperint()
      checkFields(fields, expected)
    })",steel
/test/ozaria/site/components/sign-up/PageEducatorSignup.spec.js,Conditional Test Logic,"{'line': 38, 'column': 2, 'index': 1225}","describe('Educator sign up page', () => {
  beforeEach((done) => {
    pageEducatorSignupWrapper = createComponent()
    _.defer(done)
  })

  it('renders a vue instance and the first expected component is visible', () => {
    expect(pageEducatorSignupWrapper.isVueInstance()).toBe(true)
    expect(pageEducatorSignupWrapper.contains(firstExpectedComponent)).toBe(true)
    pageEducatorSignupWrapper.destroy()
  })

  if (!isChinaServer) {
    it('scrolls to the basic info form when sign-up is clicked', async (done) => {
      expect(pageEducatorSignupWrapper.contains(PageBasicInfo)).toBe(false)
      await pageEducatorSignupWrapper.find('.email-sign-up').find('a').trigger('click')
      expect(pageEducatorSignupWrapper.contains(PageBasicInfo)).toBe(true)
      pageEducatorSignupWrapper.destroy()
      done()
    })
  }

  // Not adding a test for scrollbale UX, because it would need each input in the form
  // to be filled out to scroll to the next form - That seems to be too specific for a unit test,
  // and should be covered in an integration test.
})",steel
/test/ozaria/site/components/sign-up/PageEducatorSignup.spec.js,Duplicate Assert,"{'line': 40, 'column': 6, 'index': 1336}","it('scrolls to the basic info form when sign-up is clicked', async (done) => {
      expect(pageEducatorSignupWrapper.contains(PageBasicInfo)).toBe(false)
      await pageEducatorSignupWrapper.find('.email-sign-up').find('a').trigger('click')
      expect(pageEducatorSignupWrapper.contains(PageBasicInfo)).toBe(true)
      pageEducatorSignupWrapper.destroy()
      done()
    })",steel
/test/ozaria/site/components/sign-up/PageEducatorSignup.spec.js,Duplicate Assert,"{'line': 42, 'column': 6, 'index': 1500}","it('scrolls to the basic info form when sign-up is clicked', async (done) => {
      expect(pageEducatorSignupWrapper.contains(PageBasicInfo)).toBe(false)
      await pageEducatorSignupWrapper.find('.email-sign-up').find('a').trigger('click')
      expect(pageEducatorSignupWrapper.contains(PageBasicInfo)).toBe(true)
      pageEducatorSignupWrapper.destroy()
      done()
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Conditional Test Logic,"{'line': 9, 'column': 2, 'index': 355}",Unknown,steel
/test/ozaria/site/common/ozariaUtils.spec.js,Conditional Test Logic,"{'line': 12, 'column': 4, 'index': 494}",Unknown,steel
/test/ozaria/site/common/ozariaUtils.spec.js,Conditional Test Logic,"{'line': 21, 'column': 4, 'index': 825}",Unknown,steel
/test/ozaria/site/common/ozariaUtils.spec.js,Conditional Test Logic,"{'line': 36, 'column': 2, 'index': 1235}",Unknown,steel
/test/ozaria/site/common/ozariaUtils.spec.js,Conditional Test Logic,"{'line': 39, 'column': 4, 'index': 1374}",Unknown,steel
/test/ozaria/site/common/ozariaUtils.spec.js,Conditional Test Logic,"{'line': 70, 'column': 4, 'index': 2447}",Unknown,steel
/test/ozaria/site/common/ozariaUtils.spec.js,Conditional Test Logic,"{'line': 82, 'column': 2, 'index': 2850}",Unknown,steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 101, 'column': 6, 'index': 3753}","it('for levels that are cc*n', () => {
      const levels = makeLevels(4)
      const sessions = makeLevelSessions(levels, [{ complete: true }, { complete: true }, { complete: false }])
      const expectedNextLevel = levels[2]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 102, 'column': 6, 'index': 3799}","it('for levels that are cc*n', () => {
      const levels = makeLevels(4)
      const sessions = makeLevelSessions(levels, [{ complete: true }, { complete: true }, { complete: false }])
      const expectedNextLevel = levels[2]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 110, 'column': 6, 'index': 4148}","it('for levels that are *nnn', () => {
      const levels = makeLevels(4)
      const sessions = makeLevelSessions(levels, [{ complete: false }])
      const expectedNextLevel = levels[0]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 111, 'column': 6, 'index': 4194}","it('for levels that are *nnn', () => {
      const levels = makeLevels(4)
      const sessions = makeLevelSessions(levels, [{ complete: false }])
      const expectedNextLevel = levels[0]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 119, 'column': 6, 'index': 4583}","it('for levels that are nnnn', () => {
      const levels = makeLevels(4)
      const sessions = makeLevelSessions(levels, [])
      const expectedNextLevel = levels.find((l) => l.get('first')) // first level will be next level
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 120, 'column': 6, 'index': 4629}","it('for levels that are nnnn', () => {
      const levels = makeLevels(4)
      const sessions = makeLevelSessions(levels, [])
      const expectedNextLevel = levels.find((l) => l.get('first')) // first level will be next level
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 128, 'column': 6, 'index': 5074}","it('for capstone played in stages: c1nn', () => {
      const levels = makeLevelsForCapstoneFlow()
      const sessions = makeLevelSessions(levels, [{ complete: true }, { complete: false }]) // capstoneStage is undefined when playing stage 1
      const expectedNextLevel = levels[1]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 129, 'column': 6, 'index': 5120}","it('for capstone played in stages: c1nn', () => {
      const levels = makeLevelsForCapstoneFlow()
      const sessions = makeLevelSessions(levels, [{ complete: true }, { complete: false }]) // capstoneStage is undefined when playing stage 1
      const expectedNextLevel = levels[1]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 137, 'column': 6, 'index': 5515}","it('for capstone played in stages: c2nn', () => {
      const levels = makeLevelsForCapstoneFlow()
      const sessions = makeLevelSessions(levels, [{ complete: true }, { capstoneStage: 2 }])
      const expectedNextLevel = levels[2]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 138, 'column': 6, 'index': 5561}","it('for capstone played in stages: c2nn', () => {
      const levels = makeLevelsForCapstoneFlow()
      const sessions = makeLevelSessions(levels, [{ complete: true }, { capstoneStage: 2 }])
      const expectedNextLevel = levels[2]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 146, 'column': 6, 'index': 6015}","it('for capstone played in stages: c2cn', () => {
      const levels = makeLevelsForCapstoneFlow()
      const sessions = makeLevelSessions(levels, [{ complete: true }, { capstoneStage: 2 }, { complete: true }])
      const expectedNextLevel = levels[1] // next level should be capstone level
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 147, 'column': 6, 'index': 6061}","it('for capstone played in stages: c2cn', () => {
      const levels = makeLevelsForCapstoneFlow()
      const sessions = makeLevelSessions(levels, [{ complete: true }, { capstoneStage: 2 }, { complete: true }])
      const expectedNextLevel = levels[1] // next level should be capstone level
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 155, 'column': 6, 'index': 6476}","it('for capstone played in stages: c3cn', () => {
      const levels = makeLevelsForCapstoneFlow()
      const sessions = makeLevelSessions(levels, [{ complete: true }, { capstoneStage: 3 }, { complete: true }])
      const expectedNextLevel = levels[3]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/ozaria/site/common/ozariaUtils.spec.js,Duplicate Assert,"{'line': 156, 'column': 6, 'index': 6522}","it('for capstone played in stages: c3cn', () => {
      const levels = makeLevelsForCapstoneFlow()
      const sessions = makeLevelSessions(levels, [{ complete: true }, { capstoneStage: 3 }, { complete: true }])
      const expectedNextLevel = levels[3]
      const nextLevelOriginal = findNextLevelsBySession(sessions, levels)
      expect(nextLevelOriginal).toBeDefined()
      expect(nextLevelOriginal).toEqual(expectedNextLevel.get('original'))
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 73, 'column': 6, 'index': 3745}","beforeEach(function(done) {
      let level;
      this.classroom = factories.makeClassroom({ aceConfig: { language: 'python' }}, { courses: this.releasedCourses, members: this.students, levels: [this.levels, new Levels()] });
      this.courseInstances = new CourseInstances([
        factories.makeCourseInstance({}, { course: this.releasedCourses.first(), classroom: this.classroom, members: this.students }),
        factories.makeCourseInstance({}, { course: this.releasedCourses.last(), classroom: this.classroom, members: this.students })
      ]);

      const sessions = [];
      this.finishedStudent = this.students.models[0];
      this.finishedStudentWithPractice = this.students.models[1];
      this.unfinishedStudent = this.students.last();
      for (level of Array.from(this.levels.models)) {
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudentWithPractice})
        );
        if (level.get('practice')) { continue; }
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudent})
        );
      }
      sessions.push(factories.makeLevelSession(
          {state: {complete: true}, playtime: 60},
          {level: this.levels.first(), creator: this.unfinishedStudent})
      );
      this.levelSessions = new LevelSessions(sessions);

      this.view = new TeacherClassView({}, this.courseInstances.first().id);
      this.view.classroom.fakeRequests[0].respondWith({ status: 200, responseText: this.classroom.stringify() });
      this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: this.courses.stringify() });
      this.view.courseInstances.fakeRequests[0].respondWith({ status: 200, responseText: this.courseInstances.stringify() });
      this.view.students.fakeRequests[0].respondWith({ status: 200, responseText: this.students.stringify() });
      this.view.classroom.sessions.fakeRequests[0].respondWith({ status: 200, responseText: this.levelSessions.stringify() });
      this.view.levels.fakeRequests[0].respondWith({ status: 200, responseText: this.levels.stringify() });
      this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: this.prepaids.stringify() });

      jasmine.demoEl(this.view.$el);
      return _.defer(done);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 78, 'column': 8, 'index': 3979}","beforeEach(function(done) {
      let level;
      this.classroom = factories.makeClassroom({ aceConfig: { language: 'python' }}, { courses: this.releasedCourses, members: this.students, levels: [this.levels, new Levels()] });
      this.courseInstances = new CourseInstances([
        factories.makeCourseInstance({}, { course: this.releasedCourses.first(), classroom: this.classroom, members: this.students }),
        factories.makeCourseInstance({}, { course: this.releasedCourses.last(), classroom: this.classroom, members: this.students })
      ]);

      const sessions = [];
      this.finishedStudent = this.students.models[0];
      this.finishedStudentWithPractice = this.students.models[1];
      this.unfinishedStudent = this.students.last();
      for (level of Array.from(this.levels.models)) {
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudentWithPractice})
        );
        if (level.get('practice')) { continue; }
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudent})
        );
      }
      sessions.push(factories.makeLevelSession(
          {state: {complete: true}, playtime: 60},
          {level: this.levels.first(), creator: this.unfinishedStudent})
      );
      this.levelSessions = new LevelSessions(sessions);

      this.view = new TeacherClassView({}, this.courseInstances.first().id);
      this.view.classroom.fakeRequests[0].respondWith({ status: 200, responseText: this.classroom.stringify() });
      this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: this.courses.stringify() });
      this.view.courseInstances.fakeRequests[0].respondWith({ status: 200, responseText: this.courseInstances.stringify() });
      this.view.students.fakeRequests[0].respondWith({ status: 200, responseText: this.students.stringify() });
      this.view.classroom.sessions.fakeRequests[0].respondWith({ status: 200, responseText: this.levelSessions.stringify() });
      this.view.levels.fakeRequests[0].respondWith({ status: 200, responseText: this.levels.stringify() });
      this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: this.prepaids.stringify() });

      jasmine.demoEl(this.view.$el);
      return _.defer(done);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 185, 'column': 10, 'index': 8833}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 189, 'column': 12, 'index': 9191}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 191, 'column': 19, 'index': 9362}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 193, 'column': 19, 'index': 9545}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 195, 'column': 19, 'index': 9714}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 221, 'column': 6, 'index': 10894}","beforeEach(function(done) {
      let level;
      this.classroom = factories.makeClassroom({ aceConfig: { language: 'javascript' }}, { courses: this.releasedCourses, members: this.students, levels: [this.levels, new Levels()]});
      this.courseInstances = new CourseInstances([
        factories.makeCourseInstance({}, { course: this.releasedCourses.first(), classroom: this.classroom, members: this.students }),
        factories.makeCourseInstance({}, { course: this.releasedCourses.last(), classroom: this.classroom, members: this.students })
      ]);

      const sessions = [];
      this.finishedStudent = this.students.first();
      this.unfinishedStudent = this.students.last();
      const classLanguage = __guard__(this.classroom.get('aceConfig'), x => x.language);
      for (level of Array.from(this.levels.models)) {
        if (classLanguage && (classLanguage === level.get('primerLanguage'))) { continue; }
        if (level.get('practice')) { continue; }
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudent})
        );
      }
      sessions.push(factories.makeLevelSession(
          {state: {complete: true}, playtime: 60},
          {level: this.levels.first(), creator: this.unfinishedStudent})
      );
      this.levelSessions = new LevelSessions(sessions);

      this.view = new TeacherClassView({}, this.courseInstances.first().id);
      this.view.classroom.fakeRequests[0].respondWith({ status: 200, responseText: this.classroom.stringify() });
      this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: this.courses.stringify() });
      this.view.courseInstances.fakeRequests[0].respondWith({ status: 200, responseText: this.courseInstances.stringify() });
      this.view.students.fakeRequests[0].respondWith({ status: 200, responseText: this.students.stringify() });
      this.view.classroom.sessions.fakeRequests[0].respondWith({ status: 200, responseText: this.levelSessions.stringify() });
      this.view.levels.fakeRequests[0].respondWith({ status: 200, responseText: this.levels.stringify() });
      this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: this.prepaids.stringify() });

      jasmine.demoEl(this.view.$el);
      return _.defer(done);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 222, 'column': 8, 'index': 10950}","beforeEach(function(done) {
      let level;
      this.classroom = factories.makeClassroom({ aceConfig: { language: 'javascript' }}, { courses: this.releasedCourses, members: this.students, levels: [this.levels, new Levels()]});
      this.courseInstances = new CourseInstances([
        factories.makeCourseInstance({}, { course: this.releasedCourses.first(), classroom: this.classroom, members: this.students }),
        factories.makeCourseInstance({}, { course: this.releasedCourses.last(), classroom: this.classroom, members: this.students })
      ]);

      const sessions = [];
      this.finishedStudent = this.students.first();
      this.unfinishedStudent = this.students.last();
      const classLanguage = __guard__(this.classroom.get('aceConfig'), x => x.language);
      for (level of Array.from(this.levels.models)) {
        if (classLanguage && (classLanguage === level.get('primerLanguage'))) { continue; }
        if (level.get('practice')) { continue; }
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudent})
        );
      }
      sessions.push(factories.makeLevelSession(
          {state: {complete: true}, playtime: 60},
          {level: this.levels.first(), creator: this.unfinishedStudent})
      );
      this.levelSessions = new LevelSessions(sessions);

      this.view = new TeacherClassView({}, this.courseInstances.first().id);
      this.view.classroom.fakeRequests[0].respondWith({ status: 200, responseText: this.classroom.stringify() });
      this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: this.courses.stringify() });
      this.view.courseInstances.fakeRequests[0].respondWith({ status: 200, responseText: this.courseInstances.stringify() });
      this.view.students.fakeRequests[0].respondWith({ status: 200, responseText: this.students.stringify() });
      this.view.classroom.sessions.fakeRequests[0].respondWith({ status: 200, responseText: this.levelSessions.stringify() });
      this.view.levels.fakeRequests[0].respondWith({ status: 200, responseText: this.levels.stringify() });
      this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: this.prepaids.stringify() });

      jasmine.demoEl(this.view.$el);
      return _.defer(done);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 223, 'column': 8, 'index': 11042}","beforeEach(function(done) {
      let level;
      this.classroom = factories.makeClassroom({ aceConfig: { language: 'javascript' }}, { courses: this.releasedCourses, members: this.students, levels: [this.levels, new Levels()]});
      this.courseInstances = new CourseInstances([
        factories.makeCourseInstance({}, { course: this.releasedCourses.first(), classroom: this.classroom, members: this.students }),
        factories.makeCourseInstance({}, { course: this.releasedCourses.last(), classroom: this.classroom, members: this.students })
      ]);

      const sessions = [];
      this.finishedStudent = this.students.first();
      this.unfinishedStudent = this.students.last();
      const classLanguage = __guard__(this.classroom.get('aceConfig'), x => x.language);
      for (level of Array.from(this.levels.models)) {
        if (classLanguage && (classLanguage === level.get('primerLanguage'))) { continue; }
        if (level.get('practice')) { continue; }
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudent})
        );
      }
      sessions.push(factories.makeLevelSession(
          {state: {complete: true}, playtime: 60},
          {level: this.levels.first(), creator: this.unfinishedStudent})
      );
      this.levelSessions = new LevelSessions(sessions);

      this.view = new TeacherClassView({}, this.courseInstances.first().id);
      this.view.classroom.fakeRequests[0].respondWith({ status: 200, responseText: this.classroom.stringify() });
      this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: this.courses.stringify() });
      this.view.courseInstances.fakeRequests[0].respondWith({ status: 200, responseText: this.courseInstances.stringify() });
      this.view.students.fakeRequests[0].respondWith({ status: 200, responseText: this.students.stringify() });
      this.view.classroom.sessions.fakeRequests[0].respondWith({ status: 200, responseText: this.levelSessions.stringify() });
      this.view.levels.fakeRequests[0].respondWith({ status: 200, responseText: this.levels.stringify() });
      this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: this.prepaids.stringify() });

      jasmine.demoEl(this.view.$el);
      return _.defer(done);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 256, 'column': 10, 'index': 12928}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 260, 'column': 12, 'index': 13286}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 262, 'column': 19, 'index': 13457}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 264, 'column': 19, 'index': 13626}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 290, 'column': 6, 'index': 14807}","beforeEach(function(done) {
      let level;
      this.classroom = factories.makeClassroom({ aceConfig: { language: 'javascript' }}, { courses: this.releasedCourses, members: this.students, levels: [this.levels, new Levels()]});
      this.courseInstances = new CourseInstances([
        factories.makeCourseInstance({}, { course: this.releasedCourses.first(), classroom: this.classroom, members: new Users() }),
        factories.makeCourseInstance({}, { course: this.releasedCourses.last(), classroom: this.classroom, members: new Users() })
      ]);

      const sessions = [];
      this.finishedStudent = this.students.first();
      this.unfinishedStudent = this.students.last();
      const classLanguage = __guard__(this.classroom.get('aceConfig'), x => x.language);
      for (level of Array.from(this.levels.models)) {
        if (classLanguage && (classLanguage === level.get('primerLanguage'))) { continue; }
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudent})
        );
      }
      sessions.push(factories.makeLevelSession(
          {state: {complete: true}, playtime: 60},
          {level: this.levels.first(), creator: this.unfinishedStudent})
      );
      this.levelSessions = new LevelSessions(sessions);

      this.view = new TeacherClassView({}, this.courseInstances.first().id);
      this.view.classroom.fakeRequests[0].respondWith({ status: 200, responseText: this.classroom.stringify() });
      this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: this.courses.stringify() });
      this.view.courseInstances.fakeRequests[0].respondWith({ status: 200, responseText: this.courseInstances.stringify() });
      this.view.students.fakeRequests[0].respondWith({ status: 200, responseText: this.students.stringify() });
      this.view.classroom.sessions.fakeRequests[0].respondWith({ status: 200, responseText: this.levelSessions.stringify() });
      this.view.levels.fakeRequests[0].respondWith({ status: 200, responseText: this.levels.stringify() });
      this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: this.prepaids.stringify() });

      jasmine.demoEl(this.view.$el);
      return _.defer(done);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 291, 'column': 8, 'index': 14863}","beforeEach(function(done) {
      let level;
      this.classroom = factories.makeClassroom({ aceConfig: { language: 'javascript' }}, { courses: this.releasedCourses, members: this.students, levels: [this.levels, new Levels()]});
      this.courseInstances = new CourseInstances([
        factories.makeCourseInstance({}, { course: this.releasedCourses.first(), classroom: this.classroom, members: new Users() }),
        factories.makeCourseInstance({}, { course: this.releasedCourses.last(), classroom: this.classroom, members: new Users() })
      ]);

      const sessions = [];
      this.finishedStudent = this.students.first();
      this.unfinishedStudent = this.students.last();
      const classLanguage = __guard__(this.classroom.get('aceConfig'), x => x.language);
      for (level of Array.from(this.levels.models)) {
        if (classLanguage && (classLanguage === level.get('primerLanguage'))) { continue; }
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudent})
        );
      }
      sessions.push(factories.makeLevelSession(
          {state: {complete: true}, playtime: 60},
          {level: this.levels.first(), creator: this.unfinishedStudent})
      );
      this.levelSessions = new LevelSessions(sessions);

      this.view = new TeacherClassView({}, this.courseInstances.first().id);
      this.view.classroom.fakeRequests[0].respondWith({ status: 200, responseText: this.classroom.stringify() });
      this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: this.courses.stringify() });
      this.view.courseInstances.fakeRequests[0].respondWith({ status: 200, responseText: this.courseInstances.stringify() });
      this.view.students.fakeRequests[0].respondWith({ status: 200, responseText: this.students.stringify() });
      this.view.classroom.sessions.fakeRequests[0].respondWith({ status: 200, responseText: this.levelSessions.stringify() });
      this.view.levels.fakeRequests[0].respondWith({ status: 200, responseText: this.levels.stringify() });
      this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: this.prepaids.stringify() });

      jasmine.demoEl(this.view.$el);
      return _.defer(done);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 345, 'column': 6, 'index': 17953}","beforeEach(function(done) {
      let level;
      this.classroom = factories.makeClassroom({ aceConfig: { language: 'javascript' }}, { courses: this.releasedCourses, members: this.students, levels: [this.levels, new Levels()]});
      this.courseInstances = new CourseInstances([
        factories.makeCourseInstance({}, { course: this.releasedCourses.first(), classroom: this.classroom, members: this.students }),
        factories.makeCourseInstance({}, { course: this.releasedCourses.last(), classroom: this.classroom, members: this.students })
      ]);

      const sessions = [];
      this.finishedStudent = this.students.first();
      this.unfinishedStudent = this.students.last();
      const classLanguage = __guard__(this.classroom.get('aceConfig'), x => x.language);
      for (level of Array.from(this.levels.models)) {
        if (classLanguage && (classLanguage === level.get('primerLanguage'))) { continue; }
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudent})
        );
      }
      sessions.push(factories.makeLevelSession(
          {state: {complete: true}, playtime: 60},
          {level: this.levels.first(), creator: this.unfinishedStudent})
      );
      this.levelSessions = new LevelSessions(sessions);

      this.view = new TeacherClassView({}, this.courseInstances.first().id);
      this.view.classroom.fakeRequests[0].respondWith({ status: 200, responseText: this.classroom.stringify() });
      this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: this.courses.stringify() });
      this.view.courseInstances.fakeRequests[0].respondWith({ status: 200, responseText: this.courseInstances.stringify() });
      this.view.students.fakeRequests[0].respondWith({ status: 200, responseText: this.students.stringify() });
      this.view.classroom.sessions.fakeRequests[0].respondWith({ status: 200, responseText: this.levelSessions.stringify() });
      this.view.levels.fakeRequests[0].respondWith({ status: 200, responseText: this.levels.stringify() });
      this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: this.prepaids.stringify() });

      jasmine.demoEl(this.view.$el);
      return _.defer(done);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Conditional Test Logic,"{'line': 346, 'column': 8, 'index': 18009}","beforeEach(function(done) {
      let level;
      this.classroom = factories.makeClassroom({ aceConfig: { language: 'javascript' }}, { courses: this.releasedCourses, members: this.students, levels: [this.levels, new Levels()]});
      this.courseInstances = new CourseInstances([
        factories.makeCourseInstance({}, { course: this.releasedCourses.first(), classroom: this.classroom, members: this.students }),
        factories.makeCourseInstance({}, { course: this.releasedCourses.last(), classroom: this.classroom, members: this.students })
      ]);

      const sessions = [];
      this.finishedStudent = this.students.first();
      this.unfinishedStudent = this.students.last();
      const classLanguage = __guard__(this.classroom.get('aceConfig'), x => x.language);
      for (level of Array.from(this.levels.models)) {
        if (classLanguage && (classLanguage === level.get('primerLanguage'))) { continue; }
        sessions.push(factories.makeLevelSession(
            {state: {complete: true}, playtime: 60},
            {level, creator: this.finishedStudent})
        );
      }
      sessions.push(factories.makeLevelSession(
          {state: {complete: true}, playtime: 60},
          {level: this.levels.first(), creator: this.unfinishedStudent})
      );
      this.levelSessions = new LevelSessions(sessions);

      this.view = new TeacherClassView({}, this.courseInstances.first().id);
      this.view.classroom.fakeRequests[0].respondWith({ status: 200, responseText: this.classroom.stringify() });
      this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: this.courses.stringify() });
      this.view.courseInstances.fakeRequests[0].respondWith({ status: 200, responseText: this.courseInstances.stringify() });
      this.view.students.fakeRequests[0].respondWith({ status: 200, responseText: this.students.stringify() });
      this.view.classroom.sessions.fakeRequests[0].respondWith({ status: 200, responseText: this.levelSessions.stringify() });
      this.view.levels.fakeRequests[0].respondWith({ status: 200, responseText: this.levels.stringify() });
      this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: this.prepaids.stringify() });

      jasmine.demoEl(this.view.$el);
      return _.defer(done);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 121, 'column': 8, 'index': 6051}","it('shows alert when assigning but no students are selected', function(done) {
        expect(this.view.$el.find('.no-students-selected').hasClass('visible')).toBe(false);
        this.view.$el.find('.assign-to-selected-students').click();
        return _.defer(() => {
          expect(this.view.$el.find('.no-students-selected').hasClass('visible')).toBe(true);
          return done();
        });
      })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 124, 'column': 10, 'index': 6245}","it('shows alert when assigning but no students are selected', function(done) {
        expect(this.view.$el.find('.no-students-selected').hasClass('visible')).toBe(false);
        this.view.$el.find('.assign-to-selected-students').click();
        return _.defer(() => {
          expect(this.view.$el.find('.no-students-selected').hasClass('visible')).toBe(true);
          return done();
        });
      })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 190, 'column': 14, 'index': 9277}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 190, 'column': 14, 'index': 9277}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 192, 'column': 14, 'index': 9460}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 192, 'column': 14, 'index': 9460}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 194, 'column': 14, 'index': 9633}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 196, 'column': 14, 'index': 9758}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 261, 'column': 14, 'index': 13372}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 263, 'column': 14, 'index': 13545}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Duplicate Assert,"{'line': 265, 'column': 14, 'index': 13670}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Global Variable,"{'line': 185, 'column': 15, 'index': 8838}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Global Variable,"{'line': 186, 'column': 12, 'index': 8883}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.finishedStudentWithPractice.get('email')))) {
              expect(simplerLine).toMatch(/3,3 minutes,180,3,3 minutes,180,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Global Variable,"{'line': 256, 'column': 15, 'index': 12933}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Global Variable,"{'line': 257, 'column': 12, 'index': 12978}","it('downloads a CSV file', function(done) {
      spyOn(window, 'saveAs').and.callFake((blob, fileName) => {
        const reader = new FileReader();
        reader.onload = event => {
          const encodedCSV = reader.result;
          const progressData = decodeURI(encodedCSV);
          const lines = progressData.split('\n');
          expect(lines.length).toBe(this.students.length + 1);
          for (var line of Array.from(lines)) {
            var simplerLine = line.replace(/""[^""]+""/g, '""""');
            // Name, Username,Email,Total Levels,Total Playtime(humanize), Total Playtime(seconds), [CS1 Levels, CS1 Playtime, ...], Concepts
            expect(simplerLine.match(/[^,]+/g).length).toBe(6 + (this.releasedCourses.length * 3) + 1);
            if (simplerLine.match(new RegExp(this.finishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/2,2 minutes,120,2,2 minutes,120,0/);
            } else if (simplerLine.match(new RegExp(this.unfinishedStudent.get('email')))) {
              expect(simplerLine).toMatch(/1,a minute,60,1,a minute,60,0/);
            } else if (simplerLine.match(/@/)) {
              expect(simplerLine).toMatch(/0,0,0,0/);
            }
          }
          return done();
        };
        return reader.readAsText(blob);
      });
      this.view.calculateProgressAndLevelsAux();
      return this.view.$el.find('.export-student-progress-btn').click();
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Magic Number,"{'line': 104, 'column': 69, 'index': 5498}","it('has contents', function() {
      return expect(this.view.$el.children().length).toBeGreaterThan(0);
    })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Magic Number,"{'line': 148, 'column': 34, 'index': 7197}","it('calls enrollStudents with that user when clicked', function() {
        spyOn(this.view, 'enrollStudents');
        this.view.$el.find('.enroll-student-button:first').click();
        expect(this.view.enrollStudents).toHaveBeenCalled();
        const users = this.view.enrollStudents.calls.argsFor(0)[0];
        expect(users.size()).toBe(1);
        return expect(users.first().id).toBe(this.view.students.models[0].id);
      })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Magic Number,"{'line': 405, 'column': 38, 'index': 21008}","it('enrolls all unenrolled students', function(done) {
        const numberOfRequests = _(this.view.prepaids.models)
        .map(prepaid => prepaid.fakeRequests.length)
        .reduce((num, value) => num + value);
        expect(numberOfRequests).toBe(2);
        return done();
      })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Magic Number,"{'line': 442, 'column': 61, 'index': 22427}","it('adds students to the course instances', function() {
        expect(this.courseInstance.fakeRequests.length).toBe(1);
        const request = this.courseInstance.fakeRequests[0];
        expect(request.url).toBe(`/db/course_instance/${this.courseInstance.id}/members`);
        return expect(request.method).toBe('POST');
      })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Magic Number,"{'line': 450, 'column': 61, 'index': 22823}","it('shows a noty if POSTing students fails', function(done) {
        this.notySpy.and.callFake(done);
        expect(this.courseInstance.fakeRequests.length).toBe(1);
        const request = this.courseInstance.fakeRequests[0];
        return request.respondWith({
          status: 500,
          responseText: JSON.stringify({ message: ""Internal Server Error"" })
        });
      })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Unknown Test,"{'column': 13, 'line': 384}","it('shows a noty if the course instance request fails', function(done) {
        this.notySpy.and.callFake(done);
        const request = jasmine.Ajax.requests.mostRecent();
        return request.respondWith({
          status: 500,
          responseText: JSON.stringify({ message: ""Internal Server Error"" })
        });
      })",steel
/test/app/views/teachers/TeacherClassView.spec.js,Unknown Test,"{'column': 13, 'line': 409}","it('shows a noty if a redeem request fails', function(done) {
        this.notySpy.and.callFake(done);
        const request = jasmine.Ajax.requests.mostRecent();
        return request.respondWith({
          status: 500,
          responseText: JSON.stringify({ message: ""Internal Server Error"" })
        });
      })",steel
/test/app/views/teachers/ShareLicensesModal.spec.js,Conditional Test Logic,"{'line': 15, 'column': 4, 'index': 653}","afterEach(function() {
    if (!(this.modal != null ? this.modal.destroyed : undefined)) { return __guardMethod__(this.modal, 'destroy', o => o.destroy()); }
  })",steel
/test/app/views/teachers/ShareLicensesModal.spec.js,Conditional Test Logic,"{'line': 106, 'column': 2, 'index': 5365}",Unknown,steel
/test/app/views/teachers/RequestQuoteView.spec.js,Conditional Test Logic,"{'line': 118, 'column': 12, 'index': 4361}","beforeEach(function() {
            if (window.features.chinaUx) { return; }
            application.facebookHandler.fakeAPI();
            return application.gplusHandler.fakeAPI();
          })",steel
/test/app/views/teachers/RequestQuoteView.spec.js,Conditional Test Logic,"{'line': 126, 'column': 12, 'index': 4769}","xit('includes a facebook button which will sign them in immediately', function() {
            if (window.features.chinUx) { return pending(); }
            view.$('#facebook-signup-btn').click();
            const request = jasmine.Ajax.requests.mostRecent();
            expect(request.method).toBe('PUT');
            return expect(request.url).toBe('/db/user?facebookID=abcd&facebookAccessToken=1234');
          })",steel
/test/app/views/teachers/RequestQuoteView.spec.js,Conditional Test Logic,"{'line': 134, 'column': 12, 'index': 5198}","xit('includes a gplus button which will sign them in immediately', function() {
            if (window.features.chinaUx) { return pending(); }
            view.$('#gplus-signup-btn').click();
            const request = jasmine.Ajax.requests.mostRecent();
            expect(request.method).toBe('PUT');
            return expect(request.url).toBe('/db/user?gplusID=abcd&gplusAccessToken=1234');
          })",steel
/test/app/views/teachers/RequestQuoteView.spec.js,Duplicate Assert,"{'line': 275, 'column': 8, 'index': 10968}","it('requires confirmation to submit the form', function() {
        const form = view.$('#request-form');
        forms.objectToForm(form, successForm);
        spyOn(view, 'openModalView');
        form.submit();
        expect(view.openModalView).toHaveBeenCalled();

        let submitRequest = _.last(jasmine.Ajax.requests.filter(isSubmitRequest));
        expect(submitRequest).toBeFalsy();
        const confirmModal = view.openModalView.calls.argsFor(0)[0];
        confirmModal.trigger('confirm');
        submitRequest = _.last(jasmine.Ajax.requests.filter(isSubmitRequest));
        return expect(submitRequest).toBeTruthy();
      })",steel
/test/app/views/teachers/RequestQuoteView.spec.js,Duplicate Assert,"{'line': 279, 'column': 15, 'index': 11207}","it('requires confirmation to submit the form', function() {
        const form = view.$('#request-form');
        forms.objectToForm(form, successForm);
        spyOn(view, 'openModalView');
        form.submit();
        expect(view.openModalView).toHaveBeenCalled();

        let submitRequest = _.last(jasmine.Ajax.requests.filter(isSubmitRequest));
        expect(submitRequest).toBeFalsy();
        const confirmModal = view.openModalView.calls.argsFor(0)[0];
        confirmModal.trigger('confirm');
        submitRequest = _.last(jasmine.Ajax.requests.filter(isSubmitRequest));
        return expect(submitRequest).toBeTruthy();
      })",steel
/test/app/views/teachers/RequestQuoteView.spec.js,Magic Number,"{'line': 170, 'column': 81, 'index': 6697}","it('shows an error that the email already exists', function() {
        expect(view.$('#email-form-group').hasClass('has-error')).toBe(true);
        return expect(view.$('#email-form-group .error-help-block').length).toBe(1);
      })",steel
/test/app/views/teachers/RequestQuoteView.spec.js,Magic Number,"{'line': 265, 'column': 95, 'index': 10588}","it('shows a conversion warning', () => expect(view.$('#conversion-warning').length).toBe(1))",steel
/test/app/views/teachers/EditStudentModal.spec.js,Conditional Test Logic,"{'line': 31, 'column': 6, 'index': 1096}","it(""has a new password field"", function() {
      if (modal.$('.new-password-input').length < 1) {
        return fail(""Expected there to be a new password input field"");
      }
    })",steel
/test/app/views/teachers/EditStudentModal.spec.js,Conditional Test Logic,"{'line': 37, 'column': 6, 'index': 1299}","it(""has a change password button"", function() {
      if (modal.$('.change-password-btn').length < 1) {
        return fail(""Expected there to be a Change Password button"");
      }
    })",steel
/test/app/views/teachers/EditStudentModal.spec.js,Conditional Test Logic,"{'line': 56, 'column': 6, 'index': 1989}","it(""has a new password field"", function() {
      if (modal.$('.new-password-input').length < 1) {
        return fail(""Expected there to be a new password input field"");
      }
    })",steel
/test/app/views/teachers/EditStudentModal.spec.js,Conditional Test Logic,"{'line': 62, 'column': 6, 'index': 2185}","it(""has a change password button"", function() {
      if (modal.$('.change-password-btn').length < 1) {
        return fail(""Expected there to be a Change Password button"");
      }
    })",steel
/test/app/views/teachers/EditStudentModal.spec.js,Conditional Test Logic,"{'line': 76, 'column': 8, 'index': 2712}","xit('updates the button', function() {
        const request1 = jasmine.Ajax.requests.mostRecent();
        if (!request1) { fail(""Expected a request to be sent""); }
        modal.$('.new-password-input').val(newPassword).change().trigger('input');
        modal.$('.change-password-btn').click();
        const request2 = jasmine.Ajax.requests.mostRecent();
        expect(request1).not.toBe(request2);
        if (request1 != null) {
          request1.respondWith({ status: 200, responseText: JSON.stringify(user) });
        }
        return expect(modal.$('.change-password-btn [data-i18n]').data('i18n')).toEqual('teacher.changed');
      })",steel
/test/app/views/teachers/EditStudentModal.spec.js,Conditional Test Logic,"{'line': 81, 'column': 8, 'index': 3016}","xit('updates the button', function() {
        const request1 = jasmine.Ajax.requests.mostRecent();
        if (!request1) { fail(""Expected a request to be sent""); }
        modal.$('.new-password-input').val(newPassword).change().trigger('input');
        modal.$('.change-password-btn').click();
        const request2 = jasmine.Ajax.requests.mostRecent();
        expect(request1).not.toBe(request2);
        if (request1 != null) {
          request1.respondWith({ status: 200, responseText: JSON.stringify(user) });
        }
        return expect(modal.$('.change-password-btn [data-i18n]').data('i18n')).toEqual('teacher.changed');
      })",steel
/test/app/views/teachers/EditStudentModal.spec.js,Unknown Test,"{'column': 4, 'line': 30}","it(""has a new password field"", function() {
      if (modal.$('.new-password-input').length < 1) {
        return fail(""Expected there to be a new password input field"");
      }
    })",steel
/test/app/views/teachers/EditStudentModal.spec.js,Unknown Test,"{'column': 11, 'line': 36}","it(""has a change password button"", function() {
      if (modal.$('.change-password-btn').length < 1) {
        return fail(""Expected there to be a Change Password button"");
      }
    })",steel
/test/app/views/teachers/EditStudentModal.spec.js,Unknown Test,"{'column': 4, 'line': 55}","it(""has a new password field"", function() {
      if (modal.$('.new-password-input').length < 1) {
        return fail(""Expected there to be a new password input field"");
      }
    })",steel
/test/app/views/teachers/EditStudentModal.spec.js,Unknown Test,"{'column': 4, 'line': 61}","it(""has a change password button"", function() {
      if (modal.$('.change-password-btn').length < 1) {
        return fail(""Expected there to be a Change Password button"");
      }
    })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Conditional Test Logic,"{'line': 93, 'column': 2, 'index': 3156}","describe('CreateTeacherAccountView', function() {

  let view = null;

  const successForm = {
    name: 'New Name',
    phoneNumber: '555-555-5555',
    role: 'Teacher',
    organization: 'School',
    district: 'District',
    city: 'Springfield',
    state: 'AL',
    country: 'United States',
    numStudents: '1-10',
    numStudentsTotal: '1-500',
    educationLevel: ['Middle'],
    email: 'some@email.com',
    firstName: 'Mr',
    lastName: 'Bean',
    password1: 'letmein',
    password2: 'letmein'
  };

  beforeEach(function(done) {
    me.clear();
    me.set('_id', '1234');
    me._revertAttributes = {};
    spyOn(me, 'isAnonymous').and.returnValue(true);
    view = new CreateTeacherAccountView();
    view.render();
    jasmine.demoEl(view.$el);

    const request = jasmine.Ajax.requests.mostRecent();
    request.respondWith({
      status: 200,
      responseText: JSON.stringify([{
        _id: '1',
        properties: {
          firstName: 'First',
          lastName: 'Last'
        }
      }])
    });
    return _.defer(done);
  }); // Let SuperModel finish

  describe('when the form is unchanged', () => it('does not prevent navigating away', () => expect(_.result(view, 'onLeaveMessage')).toBeFalsy()));

  describe('when the form has changed but is not submitted', function() {
    beforeEach(() => view.$el.find('form').trigger('change'));

    return it('prevents navigating away', () => expect(_.result(view, 'onLeaveMessage')).toBeTruthy());
  });

  describe('""Log in"" link', () => it('opens the log in modal', function() {
    spyOn(view, 'openModalView');
    view.$('.alert .login-link').click();
    expect(view.openModalView.calls.count()).toBe(1);
    const AuthModal = require('views/core/AuthModal');
    return expect(view.openModalView.calls.argsFor(0)[0] instanceof AuthModal).toBe(true);
  }));

  if (!window.features.chinaUx) {
    xdescribe('clicking the Facebook button', function() {

      beforeEach(function() {
        application.facebookHandler.fakeAPI();
        view.$('#facebook-signup-btn').click();
        const request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user?facebookID=abcd&facebookAccessToken=1234');
        return expect(request.method).toBe('GET');
      });

      describe('when an associated user already exists', function() {
        beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return request.respondWith({
            status: 200,
            responseText: JSON.stringify({_id: 'abcd'})
          });
        });

        return it('logs them in and redirects them to the ConvertToTeacherAccountView', function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return expect(request.url).toBe('/auth/login-facebook');
        });
      });

      return xdescribe('when the user connects with Facebook and there isn\'t already an associated account', function() {
        beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return request.respondWith({ status: 404, responseText: '{}' });
        });

        it('disables and fills in the email, first name, last name and password fields', () => ['email', 'firstName', 'lastName', 'password1', 'password2'].map((field) =>
          expect(view.$(`input[name='${field}']`).attr('disabled')).toBeTruthy()));

        it('hides the social login buttons and shows a success message', function() {
          expect(view.$('#facebook-logged-in-row').hasClass('hide')).toBe(false);
          return expect(view.$('#social-network-signups').hasClass('hide')).toBe(true);
        });

        return describe('and the user finishes filling in the form and submits', function() {

          beforeEach(function() {
            const form = view.$('form');
            forms.objectToForm(form, successForm);
            return form.submit();
          });

          return it('creates a user associated with the Facebook account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-facebook"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""facebookID"":""abcd"",""facebookAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          });
        });
      });
    });
  }

  if (false) {
    describe('clicking the G+ button', function() {

      beforeEach(function() {
        application.gplusHandler.fakeAPI();
        view.$('#gplus-signup-btn').click();
        const request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user?gplusID=abcd&gplusAccessToken=1234&email=some%40email.com');
        return expect(request.method).toBe('GET');
      });

      describe('when an associated user already exists', function() {
        beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return request.respondWith({
            status: 200,
            responseText: JSON.stringify({_id: 'abcd'})
          });
        });

        return it('logs them in and redirects them to the ConvertToTeacherAccountView', function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return expect(request.url).toBe('/auth/login-gplus');
        });
      });

      return describe('when the user connects with G+ and there isn\'t already an associated account', function() {
        beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return request.respondWith({ status: 404, responseText: '{}' });
        });

        it('disables and fills in the email, first name, last name and password fields', () => ['email', 'firstName', 'lastName', 'password1', 'password2'].map((field) =>
          expect(view.$(`input[name='${field}']`).attr('disabled')).toBeTruthy()));

        it('hides the social login buttons and shows a success message', function() {
          expect(view.$('#gplus-logged-in-row').hasClass('hide')).toBe(false);
          return expect(view.$('#social-network-signups').hasClass('hide')).toBe(true);
        });

        return describe('and the user finishes filling in the form and submits', function() {

          beforeEach(function() {
            const form = view.$('form');
            forms.objectToForm(form, successForm);
            return form.submit();
          });

          return it('creates a user associated with the GPlus account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-gplus"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""gplusID"":""abcd"",""gplusAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          });
        });
      });
    });
  }

  describe('submitting the form successfully', function() {

    beforeEach(function() {
      view.$el.find('#request-form').trigger('change'); // to confirm navigating away isn't prevented
      const form = view.$('form');
      forms.objectToForm(form, successForm);
      return form.submit();
    });

    it('does not prevent navigating away', () => expect(_.result(view, 'onLeaveMessage')).toBeFalsy());

    it('submits a trial request, which does not include ""account"" settings', function() {
      const request = jasmine.Ajax.requests.mostRecent();
      expect(request.url).toBe('/db/trial.request');
      expect(request.method).toBe('POST');
      const attrs = JSON.parse(request.params);
      expect(attrs.password1).toBeUndefined();
      expect(attrs.password2).toBeUndefined();
      expect(attrs.name).toBeUndefined();
      expect(attrs.properties != null ? attrs.properties.siteOrigin : undefined).toBe('create teacher');
      expect(attrs.properties != null ? attrs.properties.organization : undefined).toEqual('School');
      return expect(attrs.properties != null ? attrs.properties.district : undefined).toEqual('District');
    });

    return describe('after saving the new trial request', function() {
      beforeEach(function(done) {
        view.once('update-settings', done);
        const request = jasmine.Ajax.requests.mostRecent();
        return request.respondWith({
          status: 201,
          responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
        });
      });

      it('updates user and signs up with password', function(done) {
        let attr;
        let request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user/1234');
        expect(request.method).toBe('PUT');
        const attrs = JSON.parse(request.params);
        for (attr of ['role', 'firstName', 'lastName']) {
          expect(attrs[attr]).toBeDefined();
        }
        request.respondWith({ status: 201, responseText: '{}' });
        return view.once('signup', () => {
          request = jasmine.Ajax.requests.mostRecent();
          expect(request.url).toBe('/db/user/1234/signup-with-password');
          const body = JSON.parse(request.params);
          for (attr of ['email', 'password', 'name']) {
            expect(body[attr]).toBeDefined();
          }
          return done();
        });
      });

      return describe('after saving the new user', function() {

        beforeEach(function(done) {
          spyOn(application.router, 'navigate');
          spyOn(application.router, 'reload');
          let request = jasmine.Ajax.requests.mostRecent();
          request.respondWith({
            status: 201,
            responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
          });
          expect(request.url).toBe('/db/user/1234');
          return view.once('signup', () => {
            request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/user/1234/signup-with-password');
            request.respondWith({ status: 201, responseText: '{}' });
            return view.once('on-trial-request-submit-complete', done);
          });
        });

        return it('redirects to ""/teachers/courses""', function() {
          expect(application.router.navigate).toHaveBeenCalled();
          return expect(application.router.reload).toHaveBeenCalled();
        });
      });
    });
  });


  describe('submitting the form with an email for an existing account', function() {

    beforeEach(function() {
      const form = view.$('form');
      forms.objectToForm(form, successForm);
      form.submit();
      const request = jasmine.Ajax.requests.mostRecent();
      return request.respondWith({ status: 409, responseText: '{}' });
    });

    return it('displays an error with a log in link', function() {
      expect(view.$('#email-form-group').hasClass('has-error')).toBe(true);
      spyOn(view, 'openModalView');
      view.$('#email-form-group .login-link').click();
      return expect(view.openModalView).toHaveBeenCalled();
    });
  });

  describe('submitting the form without school', function() {
    beforeEach(function() {
      view.$el.find('#request-form').trigger('change'); // to confirm navigating away isn't prevented
      const form = view.$('form');
      const formData = _.omit(successForm, ['organization']);
      forms.objectToForm(form, formData);
      return form.submit();
    });

    return it('submits a trial request, which does not include school setting', function() {
      const request = jasmine.Ajax.requests.mostRecent();
      expect(request.url).toBe('/db/trial.request');
      expect(request.method).toBe('POST');
      const attrs = JSON.parse(request.params);
      expect(attrs.properties != null ? attrs.properties.organization : undefined).toBeUndefined();
      return expect(attrs.properties != null ? attrs.properties.district : undefined).toEqual('District');
    });
  });

  describe('submitting the form without district', function() {
    beforeEach(function() {
      view.$el.find('#request-form').trigger('change'); // to confirm navigating away isn't prevented
      const form = view.$('form');
      const formData = _.omit(successForm, ['district']);
      forms.objectToForm(form, formData);
      return form.submit();
    });

    return it('displays a validation error on district and not school', function() {
      expect(view.$('#organization-control').closest('.form-group').hasClass('has-error')).toEqual(false);
      return expect(view.$('#district-control').closest('.form-group').hasClass('has-error')).toEqual(true);
    });
  });

  return describe('submitting the form district set to n/a', function() {
    beforeEach(function() {
      view.$el.find('#request-form').trigger('change'); // to confirm navigating away isn't prevented
      const form = view.$('form');
      const formData = _.omit(successForm, ['organization']);
      formData.district = 'N/A';
      forms.objectToForm(form, formData);
      return form.submit();
    });

    return it('submits a trial request, which does not include district setting', function() {
      expect(view.$('#organization-control').closest('.form-group').hasClass('has-error')).toEqual(false);
      expect(view.$('#district-control').closest('.form-group').hasClass('has-error')).toEqual(false);
      const request = jasmine.Ajax.requests.mostRecent();
      expect(request.url).toBe('/db/trial.request');
      expect(request.method).toBe('POST');
      const attrs = JSON.parse(request.params);
      return expect(attrs.properties != null ? attrs.properties.district : undefined).toBeUndefined();
    });
  });
})",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Conditional Test Logic,"{'line': 173, 'column': 2, 'index': 6641}","describe('CreateTeacherAccountView', function() {

  let view = null;

  const successForm = {
    name: 'New Name',
    phoneNumber: '555-555-5555',
    role: 'Teacher',
    organization: 'School',
    district: 'District',
    city: 'Springfield',
    state: 'AL',
    country: 'United States',
    numStudents: '1-10',
    numStudentsTotal: '1-500',
    educationLevel: ['Middle'],
    email: 'some@email.com',
    firstName: 'Mr',
    lastName: 'Bean',
    password1: 'letmein',
    password2: 'letmein'
  };

  beforeEach(function(done) {
    me.clear();
    me.set('_id', '1234');
    me._revertAttributes = {};
    spyOn(me, 'isAnonymous').and.returnValue(true);
    view = new CreateTeacherAccountView();
    view.render();
    jasmine.demoEl(view.$el);

    const request = jasmine.Ajax.requests.mostRecent();
    request.respondWith({
      status: 200,
      responseText: JSON.stringify([{
        _id: '1',
        properties: {
          firstName: 'First',
          lastName: 'Last'
        }
      }])
    });
    return _.defer(done);
  }); // Let SuperModel finish

  describe('when the form is unchanged', () => it('does not prevent navigating away', () => expect(_.result(view, 'onLeaveMessage')).toBeFalsy()));

  describe('when the form has changed but is not submitted', function() {
    beforeEach(() => view.$el.find('form').trigger('change'));

    return it('prevents navigating away', () => expect(_.result(view, 'onLeaveMessage')).toBeTruthy());
  });

  describe('""Log in"" link', () => it('opens the log in modal', function() {
    spyOn(view, 'openModalView');
    view.$('.alert .login-link').click();
    expect(view.openModalView.calls.count()).toBe(1);
    const AuthModal = require('views/core/AuthModal');
    return expect(view.openModalView.calls.argsFor(0)[0] instanceof AuthModal).toBe(true);
  }));

  if (!window.features.chinaUx) {
    xdescribe('clicking the Facebook button', function() {

      beforeEach(function() {
        application.facebookHandler.fakeAPI();
        view.$('#facebook-signup-btn').click();
        const request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user?facebookID=abcd&facebookAccessToken=1234');
        return expect(request.method).toBe('GET');
      });

      describe('when an associated user already exists', function() {
        beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return request.respondWith({
            status: 200,
            responseText: JSON.stringify({_id: 'abcd'})
          });
        });

        return it('logs them in and redirects them to the ConvertToTeacherAccountView', function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return expect(request.url).toBe('/auth/login-facebook');
        });
      });

      return xdescribe('when the user connects with Facebook and there isn\'t already an associated account', function() {
        beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return request.respondWith({ status: 404, responseText: '{}' });
        });

        it('disables and fills in the email, first name, last name and password fields', () => ['email', 'firstName', 'lastName', 'password1', 'password2'].map((field) =>
          expect(view.$(`input[name='${field}']`).attr('disabled')).toBeTruthy()));

        it('hides the social login buttons and shows a success message', function() {
          expect(view.$('#facebook-logged-in-row').hasClass('hide')).toBe(false);
          return expect(view.$('#social-network-signups').hasClass('hide')).toBe(true);
        });

        return describe('and the user finishes filling in the form and submits', function() {

          beforeEach(function() {
            const form = view.$('form');
            forms.objectToForm(form, successForm);
            return form.submit();
          });

          return it('creates a user associated with the Facebook account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-facebook"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""facebookID"":""abcd"",""facebookAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          });
        });
      });
    });
  }

  if (false) {
    describe('clicking the G+ button', function() {

      beforeEach(function() {
        application.gplusHandler.fakeAPI();
        view.$('#gplus-signup-btn').click();
        const request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user?gplusID=abcd&gplusAccessToken=1234&email=some%40email.com');
        return expect(request.method).toBe('GET');
      });

      describe('when an associated user already exists', function() {
        beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return request.respondWith({
            status: 200,
            responseText: JSON.stringify({_id: 'abcd'})
          });
        });

        return it('logs them in and redirects them to the ConvertToTeacherAccountView', function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return expect(request.url).toBe('/auth/login-gplus');
        });
      });

      return describe('when the user connects with G+ and there isn\'t already an associated account', function() {
        beforeEach(function() {
          const request = jasmine.Ajax.requests.mostRecent();
          return request.respondWith({ status: 404, responseText: '{}' });
        });

        it('disables and fills in the email, first name, last name and password fields', () => ['email', 'firstName', 'lastName', 'password1', 'password2'].map((field) =>
          expect(view.$(`input[name='${field}']`).attr('disabled')).toBeTruthy()));

        it('hides the social login buttons and shows a success message', function() {
          expect(view.$('#gplus-logged-in-row').hasClass('hide')).toBe(false);
          return expect(view.$('#social-network-signups').hasClass('hide')).toBe(true);
        });

        return describe('and the user finishes filling in the form and submits', function() {

          beforeEach(function() {
            const form = view.$('form');
            forms.objectToForm(form, successForm);
            return form.submit();
          });

          return it('creates a user associated with the GPlus account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-gplus"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""gplusID"":""abcd"",""gplusAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          });
        });
      });
    });
  }

  describe('submitting the form successfully', function() {

    beforeEach(function() {
      view.$el.find('#request-form').trigger('change'); // to confirm navigating away isn't prevented
      const form = view.$('form');
      forms.objectToForm(form, successForm);
      return form.submit();
    });

    it('does not prevent navigating away', () => expect(_.result(view, 'onLeaveMessage')).toBeFalsy());

    it('submits a trial request, which does not include ""account"" settings', function() {
      const request = jasmine.Ajax.requests.mostRecent();
      expect(request.url).toBe('/db/trial.request');
      expect(request.method).toBe('POST');
      const attrs = JSON.parse(request.params);
      expect(attrs.password1).toBeUndefined();
      expect(attrs.password2).toBeUndefined();
      expect(attrs.name).toBeUndefined();
      expect(attrs.properties != null ? attrs.properties.siteOrigin : undefined).toBe('create teacher');
      expect(attrs.properties != null ? attrs.properties.organization : undefined).toEqual('School');
      return expect(attrs.properties != null ? attrs.properties.district : undefined).toEqual('District');
    });

    return describe('after saving the new trial request', function() {
      beforeEach(function(done) {
        view.once('update-settings', done);
        const request = jasmine.Ajax.requests.mostRecent();
        return request.respondWith({
          status: 201,
          responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
        });
      });

      it('updates user and signs up with password', function(done) {
        let attr;
        let request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user/1234');
        expect(request.method).toBe('PUT');
        const attrs = JSON.parse(request.params);
        for (attr of ['role', 'firstName', 'lastName']) {
          expect(attrs[attr]).toBeDefined();
        }
        request.respondWith({ status: 201, responseText: '{}' });
        return view.once('signup', () => {
          request = jasmine.Ajax.requests.mostRecent();
          expect(request.url).toBe('/db/user/1234/signup-with-password');
          const body = JSON.parse(request.params);
          for (attr of ['email', 'password', 'name']) {
            expect(body[attr]).toBeDefined();
          }
          return done();
        });
      });

      return describe('after saving the new user', function() {

        beforeEach(function(done) {
          spyOn(application.router, 'navigate');
          spyOn(application.router, 'reload');
          let request = jasmine.Ajax.requests.mostRecent();
          request.respondWith({
            status: 201,
            responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
          });
          expect(request.url).toBe('/db/user/1234');
          return view.once('signup', () => {
            request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/user/1234/signup-with-password');
            request.respondWith({ status: 201, responseText: '{}' });
            return view.once('on-trial-request-submit-complete', done);
          });
        });

        return it('redirects to ""/teachers/courses""', function() {
          expect(application.router.navigate).toHaveBeenCalled();
          return expect(application.router.reload).toHaveBeenCalled();
        });
      });
    });
  });


  describe('submitting the form with an email for an existing account', function() {

    beforeEach(function() {
      const form = view.$('form');
      forms.objectToForm(form, successForm);
      form.submit();
      const request = jasmine.Ajax.requests.mostRecent();
      return request.respondWith({ status: 409, responseText: '{}' });
    });

    return it('displays an error with a log in link', function() {
      expect(view.$('#email-form-group').hasClass('has-error')).toBe(true);
      spyOn(view, 'openModalView');
      view.$('#email-form-group .login-link').click();
      return expect(view.openModalView).toHaveBeenCalled();
    });
  });

  describe('submitting the form without school', function() {
    beforeEach(function() {
      view.$el.find('#request-form').trigger('change'); // to confirm navigating away isn't prevented
      const form = view.$('form');
      const formData = _.omit(successForm, ['organization']);
      forms.objectToForm(form, formData);
      return form.submit();
    });

    return it('submits a trial request, which does not include school setting', function() {
      const request = jasmine.Ajax.requests.mostRecent();
      expect(request.url).toBe('/db/trial.request');
      expect(request.method).toBe('POST');
      const attrs = JSON.parse(request.params);
      expect(attrs.properties != null ? attrs.properties.organization : undefined).toBeUndefined();
      return expect(attrs.properties != null ? attrs.properties.district : undefined).toEqual('District');
    });
  });

  describe('submitting the form without district', function() {
    beforeEach(function() {
      view.$el.find('#request-form').trigger('change'); // to confirm navigating away isn't prevented
      const form = view.$('form');
      const formData = _.omit(successForm, ['district']);
      forms.objectToForm(form, formData);
      return form.submit();
    });

    return it('displays a validation error on district and not school', function() {
      expect(view.$('#organization-control').closest('.form-group').hasClass('has-error')).toEqual(false);
      return expect(view.$('#district-control').closest('.form-group').hasClass('has-error')).toEqual(true);
    });
  });

  return describe('submitting the form district set to n/a', function() {
    beforeEach(function() {
      view.$el.find('#request-form').trigger('change'); // to confirm navigating away isn't prevented
      const form = view.$('form');
      const formData = _.omit(successForm, ['organization']);
      formData.district = 'N/A';
      forms.objectToForm(form, formData);
      return form.submit();
    });

    return it('submits a trial request, which does not include district setting', function() {
      expect(view.$('#organization-control').closest('.form-group').hasClass('has-error')).toEqual(false);
      expect(view.$('#district-control').closest('.form-group').hasClass('has-error')).toEqual(false);
      const request = jasmine.Ajax.requests.mostRecent();
      expect(request.url).toBe('/db/trial.request');
      expect(request.method).toBe('POST');
      const attrs = JSON.parse(request.params);
      return expect(attrs.properties != null ? attrs.properties.district : undefined).toBeUndefined();
    });
  });
})",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Conditional Test Logic,"{'line': 293, 'column': 8, 'index': 11936}","it('updates user and signs up with password', function(done) {
        let attr;
        let request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user/1234');
        expect(request.method).toBe('PUT');
        const attrs = JSON.parse(request.params);
        for (attr of ['role', 'firstName', 'lastName']) {
          expect(attrs[attr]).toBeDefined();
        }
        request.respondWith({ status: 201, responseText: '{}' });
        return view.once('signup', () => {
          request = jasmine.Ajax.requests.mostRecent();
          expect(request.url).toBe('/db/user/1234/signup-with-password');
          const body = JSON.parse(request.params);
          for (attr of ['email', 'password', 'name']) {
            expect(body[attr]).toBeDefined();
          }
          return done();
        });
      })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Conditional Test Logic,"{'line': 301, 'column': 10, 'index': 12341}","it('updates user and signs up with password', function(done) {
        let attr;
        let request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user/1234');
        expect(request.method).toBe('PUT');
        const attrs = JSON.parse(request.params);
        for (attr of ['role', 'firstName', 'lastName']) {
          expect(attrs[attr]).toBeDefined();
        }
        request.respondWith({ status: 201, responseText: '{}' });
        return view.once('signup', () => {
          request = jasmine.Ajax.requests.mostRecent();
          expect(request.url).toBe('/db/user/1234/signup-with-password');
          const body = JSON.parse(request.params);
          for (attr of ['email', 'password', 'name']) {
            expect(body[attr]).toBeDefined();
          }
          return done();
        });
      })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Duplicate Assert,"{'line': 143, 'column': 12, 'index': 5412}","it('creates a user associated with the Facebook account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-facebook"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""facebookID"":""abcd"",""facebookAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Duplicate Assert,"{'line': 150, 'column': 14, 'index': 5768}","it('creates a user associated with the Facebook account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-facebook"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""facebookID"":""abcd"",""facebookAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Duplicate Assert,"{'line': 160, 'column': 16, 'index': 6210}","it('creates a user associated with the Facebook account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-facebook"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""facebookID"":""abcd"",""facebookAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Duplicate Assert,"{'line': 223, 'column': 12, 'index': 8866}","it('creates a user associated with the GPlus account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-gplus"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""gplusID"":""abcd"",""gplusAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Duplicate Assert,"{'line': 230, 'column': 14, 'index': 9222}","it('creates a user associated with the GPlus account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-gplus"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""gplusID"":""abcd"",""gplusAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Duplicate Assert,"{'line': 240, 'column': 16, 'index': 9664}","it('creates a user associated with the GPlus account', function(done) {
            let request = jasmine.Ajax.requests.mostRecent();
            expect(request.url).toBe('/db/trial.request');
            request.respondWith({
              status: 201,
              responseText: JSON.stringify(_.extend({_id:'fraghlarghl'}, JSON.parse(request.params)))
            });
            return view.once('update-settings', () => {
              request = jasmine.Ajax.requests.mostRecent();
              expect(request.url).toBe(""/db/user/1234"");
              const body = JSON.parse(request.params);
              expect(body.firstName).toBe('Mr');
              expect(body.lastName).toBe('Bean');
              request.respondWith({
                status: 200,
                responseText: '{}'
              });
              return view.once('signup', () => {
                request = jasmine.Ajax.requests.mostRecent();
                expect(request.url).toBe(""/db/user/1234/signup-with-gplus"");
                const expected = {""name"":""New Name"",""email"":""some@email.com"",""gplusID"":""abcd"",""gplusAccessToken"":""1234""};
                const actual = JSON.parse(request.params);
                expect(_.isEqual(expected, actual)).toBe(true);
                return done();
              });
            });
          })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Duplicate Assert,"{'line': 290, 'column': 8, 'index': 11791}","it('updates user and signs up with password', function(done) {
        let attr;
        let request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user/1234');
        expect(request.method).toBe('PUT');
        const attrs = JSON.parse(request.params);
        for (attr of ['role', 'firstName', 'lastName']) {
          expect(attrs[attr]).toBeDefined();
        }
        request.respondWith({ status: 201, responseText: '{}' });
        return view.once('signup', () => {
          request = jasmine.Ajax.requests.mostRecent();
          expect(request.url).toBe('/db/user/1234/signup-with-password');
          const body = JSON.parse(request.params);
          for (attr of ['email', 'password', 'name']) {
            expect(body[attr]).toBeDefined();
          }
          return done();
        });
      })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Duplicate Assert,"{'line': 299, 'column': 10, 'index': 12216}","it('updates user and signs up with password', function(done) {
        let attr;
        let request = jasmine.Ajax.requests.mostRecent();
        expect(request.url).toBe('/db/user/1234');
        expect(request.method).toBe('PUT');
        const attrs = JSON.parse(request.params);
        for (attr of ['role', 'firstName', 'lastName']) {
          expect(attrs[attr]).toBeDefined();
        }
        request.respondWith({ status: 201, responseText: '{}' });
        return view.once('signup', () => {
          request = jasmine.Ajax.requests.mostRecent();
          expect(request.url).toBe('/db/user/1234/signup-with-password');
          const body = JSON.parse(request.params);
          for (attr of ['email', 'password', 'name']) {
            expect(body[attr]).toBeDefined();
          }
          return done();
        });
      })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Magic Number,"{'line': 16, 'column': 64, 'index': 717}","it('displays CreateTeacherAccountView', function() {
    spyOn(me, 'isAnonymous').and.returnValue(true);
    spyOn(application.router, 'routeDirectly');
    Backbone.history.loadUrl('/teachers/signup');
    expect(application.router.routeDirectly.calls.count()).toBe(1);
    const args = application.router.routeDirectly.calls.argsFor(0);
    return expect(args[0]).toBe('teachers/CreateTeacherAccountView');
  })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Magic Number,"{'line': 25, 'column': 59, 'index': 1171}","it('redirects to /teachers/update-account', function() {
    spyOn(me, 'isAnonymous').and.returnValue(false);
    spyOn(application.router, 'navigate');
    Backbone.history.loadUrl('/teachers/signup');
    expect(application.router.navigate.calls.count()).toBe(1);
    const args = application.router.navigate.calls.argsFor(0);
    return expect(args[0]).toBe('/teachers/update-account');
  })",steel
/test/app/views/teachers/CreateTeacherAccountView.spec.js,Magic Number,"{'line': 88, 'column': 50, 'index': 2996}","it('opens the log in modal', function() {
    spyOn(view, 'openModalView');
    view.$('.alert .login-link').click();
    expect(view.openModalView.calls.count()).toBe(1);
    const AuthModal = require('views/core/AuthModal');
    return expect(view.openModalView.calls.argsFor(0)[0] instanceof AuthModal).toBe(true);
  })",steel
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,Magic Number,"{'line': 16, 'column': 59, 'index': 765}","it('redirects to /teachers/signup', function() {
    spyOn(me, 'isAnonymous').and.returnValue(true);
    spyOn(application.router, 'navigate');
    Backbone.history.loadUrl('/teachers/update-account');
    expect(application.router.navigate.calls.count()).toBe(1);
    const args = application.router.navigate.calls.argsFor(0);
    return expect(args[0]).toBe('/teachers/signup');
  })",steel
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,Magic Number,"{'line': 26, 'column': 64, 'index': 1265}","it('displays ConvertToTeacherAccountView', function() {
    spyOn(me, 'isAnonymous').and.returnValue(false);
    spyOn(me, 'isTeacher').and.returnValue(false);
    spyOn(application.router, 'routeDirectly');
    Backbone.history.loadUrl('/teachers/update-account');
    expect(application.router.routeDirectly.calls.count()).toBe(1);
    const args = application.router.routeDirectly.calls.argsFor(0);
    return expect(args[0]).toBe('teachers/ConvertToTeacherAccountView');
  })",steel
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,Magic Number,"{'line': 112, 'column': 126, 'index': 4098}","it('shows a warning that they will convert to a teacher account', () => expect(view.$('#conversion-warning').length).toBe(1))",steel
/test/app/views/teachers/ConvertToTeacherAccountView.spec.js,Magic Number,"{'line': 127, 'column': 59, 'index': 4644}","it('requires confirmation', function() {
        expect(view.trialRequest.fakeRequests.length).toBe(0);
        const confirmModal = view.openModalView.calls.argsFor(0)[0];
        confirmModal.trigger('confirm');
        const request = _.last(view.trialRequest.fakeRequests);
        expect(request.url).toBe('/db/trial.request');
        return expect(request.method).toBe('POST');
      })",steel
/test/app/views/teachers/BaseSingleClass.spec.js,Conditional Test Logic,"{'line': 123, 'column': 2, 'index': 3289}","describe('BaseSingleClass', () => {
  if (!isOzaria) return  // This is specific to the Ozaria teacher dashboard

  it('empty module returns empty array default', () => {
    // Here we fill in the `this` object in the method.
    const mockedCourse = 'mockCourse'
    const localThis = {
      selectedCourseId: mockedCourse,
      classroom: {
        ownerID: 'mockOwnerID',
        _id: 'mockID'
      },
      getCourseInstancesForClass: () => {
        return [
          { courseID: 'mockCourseID', members: [] }
        ]
      },
      getCourseInstancesOfClass: () => {
        return [
          { courseID: 'mockCourseID', members: [] }
        ]
      },
      gameContent: {
        [mockedCourse]: {
          modules: [] // Empty course returns nothing
        }
      }
    }
    expect(BaseSingleClass.computed.modules.call(localThis)).toEqual([])
  })

  describe('student assignment', () => {
    it('will fill in assigned dots', () => {
      const localThis = singleStudentMockData({ levelSessionsMapByUser: {} })
      // Here we fill in the `this` object in the method.
      expect(BaseSingleClass.computed.modules.call(localThis)).toEqual([{
        moduleNum: '1',
        displayName: 'TranslatedMockundefined',
        contentList: [ jasmine.objectContaining({ displayName: 'Practice Level Mock Name', type: 'practicelvl', _id: 'practiceID', normalizedOriginal: 'PRACTICE_ORIGINAL', tooltipName: 'Practice Level: Practice Level Mock Name', description: '', contentKey: 'PRACTICE_ORIGINAL' })],
        studentSessions: { MOCK_STUDENT1_ID: [ { status: 'assigned', normalizedType: 'practicelvl', isLocked: false } ] },
        classSummaryProgress: [{ status: 'assigned', border: '' }]
      }])
    })

    it('will fill in unassigned dots if student is not in course instance', () => {
      const localThis = singleStudentMockData({ members: [] })
      // Here we fill in the `this` object in the method.
      expect(BaseSingleClass.computed.modules.call(localThis)).toEqual([
        {
          moduleNum: '1',
          // This is due to patching in $t for the test.
          displayName: 'TranslatedMockundefined',
          contentList: [
            jasmine.objectContaining({ displayName: 'Practice Level Mock Name', type: 'practicelvl', _id: 'practiceID', description: '' })
          ],
          studentSessions: {
            MOCK_STUDENT1_ID: [
              { status: 'unassigned', normalizedType: 'practicelvl', isLocked: false }
            ]
          },
          classSummaryProgress: [ { status: 'assigned', border: '' } ]
        }
      ])
    })
  })

  xit('handle empty classroom', () => {
    const localThis = singleStudentMockData({ members: [], students: [] })

    expect(BaseSingleClass.computed.modules.call(localThis)).toEqual([
      {
        displayName: 'TranslatedMockundefined',
        contentList: [ jasmine.objectContaining({
          displayName: 'Practice Level Mock Name', type: 'practicelvl', _id: 'practiceID', description: ''
        }) ],
        studentSessions: { },
        // TODO: This is interesting and should maybe be blank
        classSummaryProgress: [ { status: 'assigned', border: '', isLocked: false } ]
      }
    ])
  })

  xdescribe('practice level summary dot - single student', () => {
    it('summary and student match completed', () => {
      const localThis = singleStudentMockData({ complete: true })

      expect(BaseSingleClass.computed.modules.call(localThis)).toEqual([
        {
          // Due to mocked translation missing
          displayName: 'TranslatedMockundefined',
          contentList: [
            { displayName: 'Practice Level Mock Name', type: 'practicelvl', _id: 'practiceID', description: '' }
          ],
          studentSessions: {
            MOCK_STUDENT1_ID: [
              // There is a function on this object that doesn't compare.
              jasmine.objectContaining({ status: 'complete', normalizedType: 'practicelvl', selectedKey: 'MOCK_STUDENT1_ID_practiceID' })
            ]
          },
          classSummaryProgress: [ { status: 'complete', border: '' } ]
        }
      ])
    })
    it('summary and student match in progress', () => {
      const localThis = singleStudentMockData({ complete: false })

      expect(BaseSingleClass.computed.modules.call(localThis)).toEqual([
        {
          // Due to mocked translation missing
          displayName: 'TranslatedMockundefined',
          contentList: [
            { displayName: 'Practice Level Mock Name', type: 'practicelvl', _id: 'practiceID', description: '' }
          ],
          studentSessions: {
            [MOCK_STUDENT1_ID]: [
              // There is a function on this object that doesn't compare.
              jasmine.objectContaining({ status: 'progress', normalizedType: 'practicelvl', selectedKey: 'MOCK_STUDENT1_ID_practiceID' })
            ]
          },
          classSummaryProgress: [ { status: 'progress', border: '' } ]
        }
      ])
    })
  })

  describe('practice level summary dot - two students', () => {
    it('two students with level sessions show up as in progress', () => {
      const localThis = twoStudentsMockData()
      expect(BaseSingleClass.computed.modules.call(localThis)[0]).toEqual(jasmine.objectContaining(
        {
          studentSessions: {
            [MOCK_STUDENT1_ID]: [
              jasmine.objectContaining({ status: 'progress', normalizedType: 'practicelvl', selectedKey: 'MOCK_STUDENT1_ID_practiceID' })
            ],
            [MOCK_STUDENT2_ID]: [
              jasmine.objectContaining({ status: 'progress', normalizedType: 'practicelvl', selectedKey: 'MOCK_STUDENT2_ID_practiceID' })
            ]
          },
          classSummaryProgress: [ { status: 'progress', border: '' } ]
        }
      ))
    })

    xit('having one student unassigned is handled', () => {
      const localThis = twoStudentsMockData({
        members: [MOCK_STUDENT2_ID]
      })
      expect(BaseSingleClass.computed.modules.call(localThis)[0]).toEqual(jasmine.objectContaining(
        {
          studentSessions: {
            [MOCK_STUDENT1_ID]: [
              { status: 'unassigned', normalizedType: 'practicelvl' }
            ],
            [MOCK_STUDENT2_ID]: [
              jasmine.objectContaining({ status: 'progress', normalizedType: 'practicelvl', selectedKey: 'MOCK_STUDENT2_ID_practiceID' })
            ]
          },
          classSummaryProgress: [ { status: 'progress', border: '' } ]
        }
      ))
    })

    it('one student is completed and the other is in progress', () => {
      const localThis = twoStudentsMockData({
        mock1complete: false,
        mock2complete: true
      })
      expect(BaseSingleClass.computed.modules.call(localThis)[0]).toEqual(jasmine.objectContaining(
        {
          studentSessions: {
            [MOCK_STUDENT1_ID]: [
              jasmine.objectContaining({ status: 'progress', normalizedType: 'practicelvl', selectedKey: 'MOCK_STUDENT1_ID_practiceID' })
            ],
            [MOCK_STUDENT2_ID]: [
              jasmine.objectContaining({ status: 'complete', normalizedType: 'practicelvl', selectedKey: 'MOCK_STUDENT2_ID_practiceID' })
            ]
          },
          classSummaryProgress: [ { status: 'complete', border: '' } ]
        }
      ))
    })
  })
})",steel
/test/app/views/teachers/ActivateLicensesModal.spec.js,Conditional Test Logic,"{'line': 115, 'column': 10, 'index': 4500}","it('enrolls the selected students with the selected prepaid', function() {
          const request = jasmine.Ajax.requests.mostRecent();
          if (request.url.indexOf(this.prepaidThatExpiresSooner.id) === -1) {
            fail('The first prepaid should be the prepaid that expires sooner');
          }
          return request.respondWith({ status: 200, responseText: '{ ""redeemers"": [{}] }' });
        })",steel
/test/app/views/teachers/ActivateLicensesModal.spec.js,Global Variable,"{'line': 25, 'column': 4, 'index': 977}","beforeEach(function(done) {
    this.members = new Users(_.times(4, i => factories.makeUser()));
    this.classrooms = new Classrooms([
      factories.makeClassroom({}, { members: this.members }),
      factories.makeClassroom()
    ]);
    const selectedUsers = new Users(this.members.slice(0,3));
    var options = _.extend({}, {
      classroom: this.classrooms.first(), classrooms: this.classrooms, users: this.members, selectedUsers
    }, options);
    this.modal = new ActivateLicensesModal(options);
    this.prepaidThatExpiresSooner = factories.makePrepaid({maxRedeemers: 1, endDate: moment().add(1, 'month').toISOString()});
    this.prepaidThatExpiresLater = factories.makePrepaid({maxRedeemers: 1, endDate: moment().add(2, 'months').toISOString()});
    const prepaids = new Prepaids([
      // empty
      factories.makePrepaid({maxRedeemers: 0, endDate: moment().add(1, 'day').toISOString()}),
      
      // expired
      factories.makePrepaid({maxRedeemers: 10, endDate: moment().subtract(1, 'day').toISOString()}),
        
      // pending
      factories.makePrepaid({
        maxRedeemers: 100,
        startDate: moment().add(1, 'month').toISOString(),
        endDate: moment().add(2, 'months').toISOString()
      }),

      // these should be used
      this.prepaidThatExpiresSooner,
      this.prepaidThatExpiresLater
    ]);
    this.modal.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: prepaids.stringify() });
    this.modal.classrooms.fakeRequests[0].respondWith({
      status: 200,
      responseText: this.classrooms.stringify()
    });
    this.modal.classrooms.first().users.fakeRequests[0].respondWith({
      status: 200,
      responseText: this.members.stringify()
    });

    jasmine.demoModal(this.modal);
    return _.defer(done);
  })",steel
/test/app/views/teachers/ActivateLicensesModal.spec.js,Magic Number,"{'line': 73, 'column': 63, 'index': 2998}","it('contains all of the teacher\'s classes', function() {
      return expect(this.modal.$('select option').length).toBe(3);
    })",steel
/test/app/views/teachers/ActivateLicensesModal.spec.js,Unknown Test,"{'column': 15, 'line': 113}","it('enrolls the selected students with the selected prepaid', function() {
          const request = jasmine.Ajax.requests.mostRecent();
          if (request.url.indexOf(this.prepaidThatExpiresSooner.id) === -1) {
            fail('The first prepaid should be the prepaid that expires sooner');
          }
          return request.respondWith({ status: 200, responseText: '{ ""redeemers"": [{}] }' });
        })",steel
/test/app/views/play/CampaignView.spec.ozar.js,Conditional Test Logic,"{'line': 22, 'column': 6, 'index': 912}","beforeEach(function() {
    let level;
    this.campaignView = new CampaignView();
    this.campaignView.levelStatusMap = {};
    const levels = new Levels(_.times(4, () => factories.makeLevel()));
    this.campaignView.campaign = factories.makeCampaign({}, {levels});
    this.levels = ((() => {
      const result = [];
      for (level of Array.from(levels.models)) {           result.push(level.toJSON());
      }
      return result;
    })());
    const earned = me.get('earned') || {};
    if (earned.levels == null) { earned.levels = []; }
    for (level of Array.from(this.levels)) { earned.levels.push(level.original); }
    return me.set('earned', earned);
  })",steel
/test/app/views/play/CampaignView.spec.ozar.js,Conditional Test Logic,"{'line': 27, 'column': 4, 'index': 1081}","beforeEach(function() {
    let level;
    this.campaignView = new CampaignView();
    this.campaignView.levelStatusMap = {};
    const levels = new Levels(_.times(4, () => factories.makeLevel()));
    this.campaignView.campaign = factories.makeCampaign({}, {levels});
    this.levels = ((() => {
      const result = [];
      for (level of Array.from(levels.models)) {           result.push(level.toJSON());
      }
      return result;
    })());
    const earned = me.get('earned') || {};
    if (earned.levels == null) { earned.levels = []; }
    for (level of Array.from(this.levels)) { earned.levels.push(level.original); }
    return me.set('earned', earned);
  })",steel
/test/app/views/play/CampaignView.spec.ozar.js,Conditional Test Logic,"{'line': 28, 'column': 4, 'index': 1136}","beforeEach(function() {
    let level;
    this.campaignView = new CampaignView();
    this.campaignView.levelStatusMap = {};
    const levels = new Levels(_.times(4, () => factories.makeLevel()));
    this.campaignView.campaign = factories.makeCampaign({}, {levels});
    this.levels = ((() => {
      const result = [];
      for (level of Array.from(levels.models)) {           result.push(level.toJSON());
      }
      return result;
    })());
    const earned = me.get('earned') || {};
    if (earned.levels == null) { earned.levels = []; }
    for (level of Array.from(this.levels)) { earned.levels.push(level.original); }
    return me.set('earned', earned);
  })",steel
/test/app/views/play/CampaignView.spec.coco.js,Conditional Test Logic,"{'line': 22, 'column': 6, 'index': 906}","beforeEach(function () {
    let level
    this.campaignView = new CampaignView()
    this.campaignView.levelStatusMap = {}
    const levels = new Levels(_.times(4, () => factories.makeLevel()))
    this.campaignView.campaign = factories.makeCampaign({}, { levels })
    this.levels = ((() => {
      const result = []
      for (level of Array.from(levels.models)) {
        result.push(level.toJSON())
      }
      return result
    })())
    const earned = me.get('earned') || {}
    if (earned.levels == null) { earned.levels = [] }
    for (level of Array.from(this.levels)) { earned.levels.push(level.original) }
    return me.set('earned', earned)
  })",steel
/test/app/views/play/CampaignView.spec.coco.js,Conditional Test Logic,"{'line': 28, 'column': 4, 'index': 1069}","beforeEach(function () {
    let level
    this.campaignView = new CampaignView()
    this.campaignView.levelStatusMap = {}
    const levels = new Levels(_.times(4, () => factories.makeLevel()))
    this.campaignView.campaign = factories.makeCampaign({}, { levels })
    this.levels = ((() => {
      const result = []
      for (level of Array.from(levels.models)) {
        result.push(level.toJSON())
      }
      return result
    })())
    const earned = me.get('earned') || {}
    if (earned.levels == null) { earned.levels = [] }
    for (level of Array.from(this.levels)) { earned.levels.push(level.original) }
    return me.set('earned', earned)
  })",steel
/test/app/views/play/CampaignView.spec.coco.js,Conditional Test Logic,"{'line': 29, 'column': 4, 'index': 1123}","beforeEach(function () {
    let level
    this.campaignView = new CampaignView()
    this.campaignView.levelStatusMap = {}
    const levels = new Levels(_.times(4, () => factories.makeLevel()))
    this.campaignView.campaign = factories.makeCampaign({}, { levels })
    this.levels = ((() => {
      const result = []
      for (level of Array.from(levels.models)) {
        result.push(level.toJSON())
      }
      return result
    })())
    const earned = me.get('earned') || {}
    if (earned.levels == null) { earned.levels = [] }
    for (level of Array.from(this.levels)) { earned.levels.push(level.original) }
    return me.set('earned', earned)
  })",steel
/test/app/views/play/level/PlayLevelVideoView.spec.js,Conditional Test Logic,"{'line': 18, 'column': 8, 'index': 470}",Unknown,steel
/test/app/views/play/level/HintsView.spec.js,Conditional Test Logic,"{'line': 67, 'column': 4, 'index': 1823}","it('filters out all code blocks but those of the selected language', function() {
    this.session.set({
      codeLanguage: 'javascript',
      playtime: 9001
    });
    this.view.state.set('hintIndex', 1);
    this.view.render();
    
    if (_.string.contains(this.view.$el.text(), 'print')) {
      fail('Python code snippet found, should be filtered out');
    }
    if (!_.string.contains(this.view.$el.text(), 'console')) {
      return fail('JavaScript code snippet not found');
    }
  })",steel
/test/app/views/play/level/HintsView.spec.js,Conditional Test Logic,"{'line': 70, 'column': 4, 'index': 1954}","it('filters out all code blocks but those of the selected language', function() {
    this.session.set({
      codeLanguage: 'javascript',
      playtime: 9001
    });
    this.view.state.set('hintIndex', 1);
    this.view.render();
    
    if (_.string.contains(this.view.$el.text(), 'print')) {
      fail('Python code snippet found, should be filtered out');
    }
    if (!_.string.contains(this.view.$el.text(), 'console')) {
      return fail('JavaScript code snippet not found');
    }
  })",steel
/test/app/views/play/level/HintsView.spec.js,Magic Number,"{'line': 41, 'column': 67, 'index': 1149}","it('does not show the previous button', function() {
    return expect(this.view.$el.find('.previous-btn').length).toBe(0);
  })",steel
/test/app/views/play/level/HintsView.spec.js,Magic Number,"{'line': 55, 'column': 65, 'index': 1553}","it('shows the next hint button', function() {
      return expect(this.view.$el.find('.next-btn').length).toBe(1);
    })",steel
/test/app/views/play/level/HintsView.spec.js,Unknown Test,"{'column': 9, 'line': 59}","it('filters out all code blocks but those of the selected language', function() {
    this.session.set({
      codeLanguage: 'javascript',
      playtime: 9001
    });
    this.view.state.set('hintIndex', 1);
    this.view.render();
    
    if (_.string.contains(this.view.$el.text(), 'print')) {
      fail('Python code snippet found, should be filtered out');
    }
    if (!_.string.contains(this.view.$el.text(), 'console')) {
      return fail('JavaScript code snippet not found');
    }
  })",steel
/test/app/views/play/level/tome/Problem.spec.js,Duplicate Assert,"{'line': 42, 'column': 6, 'index': 1370}","it('translates messages with line numbers, error types, and placeholders', function() {
    const oldLang = $.i18n.language;
    return $.i18n.changeLanguage('rot13', function() {
      let english = 'Line 12: ReferenceError: `somethin` is not defined';
      let rot13 = 'Yvar 12: ErsreraprReebe: `somethin` vf abg qrsvarq';
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english = ""`foo`'s argument `bar` has a problem. Is there an enemy within your line-of-sight yet?"";
      rot13 = ""`foo`'f nethzrag `bar` unf n ceboyrz. Vf gurer na rarzl jvguva lbhe yvar-bs-fvtug lrg?"";
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english=`\
\`attack\`'s argument \`target\` should have type \`unit\`, but got \`function\`.
Target a unit.\
`;
      rot13=`\
\`attack\`'f nethzrag \`target\` fubhyq unir glcr \`unit\`, ohg tbg \`function\`.
Gnetrg n havg.\
`;
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      return $.i18n.changeLanguage(oldLang);
    });
  })",steel
/test/app/views/play/level/tome/Problem.spec.js,Duplicate Assert,"{'line': 42, 'column': 6, 'index': 1370}","it('translates messages with line numbers, error types, and placeholders', function() {
    const oldLang = $.i18n.language;
    return $.i18n.changeLanguage('rot13', function() {
      let english = 'Line 12: ReferenceError: `somethin` is not defined';
      let rot13 = 'Yvar 12: ErsreraprReebe: `somethin` vf abg qrsvarq';
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english = ""`foo`'s argument `bar` has a problem. Is there an enemy within your line-of-sight yet?"";
      rot13 = ""`foo`'f nethzrag `bar` unf n ceboyrz. Vf gurer na rarzl jvguva lbhe yvar-bs-fvtug lrg?"";
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english=`\
\`attack\`'s argument \`target\` should have type \`unit\`, but got \`function\`.
Target a unit.\
`;
      rot13=`\
\`attack\`'f nethzrag \`target\` fubhyq unir glcr \`unit\`, ohg tbg \`function\`.
Gnetrg n havg.\
`;
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      return $.i18n.changeLanguage(oldLang);
    });
  })",steel
/test/app/views/play/level/tome/Problem.spec.js,Duplicate Assert,"{'line': 45, 'column': 6, 'index': 1647}","it('translates messages with line numbers, error types, and placeholders', function() {
    const oldLang = $.i18n.language;
    return $.i18n.changeLanguage('rot13', function() {
      let english = 'Line 12: ReferenceError: `somethin` is not defined';
      let rot13 = 'Yvar 12: ErsreraprReebe: `somethin` vf abg qrsvarq';
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english = ""`foo`'s argument `bar` has a problem. Is there an enemy within your line-of-sight yet?"";
      rot13 = ""`foo`'f nethzrag `bar` unf n ceboyrz. Vf gurer na rarzl jvguva lbhe yvar-bs-fvtug lrg?"";
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english=`\
\`attack\`'s argument \`target\` should have type \`unit\`, but got \`function\`.
Target a unit.\
`;
      rot13=`\
\`attack\`'f nethzrag \`target\` fubhyq unir glcr \`unit\`, ohg tbg \`function\`.
Gnetrg n havg.\
`;
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      return $.i18n.changeLanguage(oldLang);
    });
  })",steel
/test/app/views/play/level/tome/Problem.spec.js,Duplicate Assert,"{'line': 45, 'column': 6, 'index': 1647}","it('translates messages with line numbers, error types, and placeholders', function() {
    const oldLang = $.i18n.language;
    return $.i18n.changeLanguage('rot13', function() {
      let english = 'Line 12: ReferenceError: `somethin` is not defined';
      let rot13 = 'Yvar 12: ErsreraprReebe: `somethin` vf abg qrsvarq';
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english = ""`foo`'s argument `bar` has a problem. Is there an enemy within your line-of-sight yet?"";
      rot13 = ""`foo`'f nethzrag `bar` unf n ceboyrz. Vf gurer na rarzl jvguva lbhe yvar-bs-fvtug lrg?"";
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english=`\
\`attack\`'s argument \`target\` should have type \`unit\`, but got \`function\`.
Target a unit.\
`;
      rot13=`\
\`attack\`'f nethzrag \`target\` fubhyq unir glcr \`unit\`, ohg tbg \`function\`.
Gnetrg n havg.\
`;
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      return $.i18n.changeLanguage(oldLang);
    });
  })",steel
/test/app/views/play/level/tome/Problem.spec.js,Duplicate Assert,"{'line': 54, 'column': 6, 'index': 1948}","it('translates messages with line numbers, error types, and placeholders', function() {
    const oldLang = $.i18n.language;
    return $.i18n.changeLanguage('rot13', function() {
      let english = 'Line 12: ReferenceError: `somethin` is not defined';
      let rot13 = 'Yvar 12: ErsreraprReebe: `somethin` vf abg qrsvarq';
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english = ""`foo`'s argument `bar` has a problem. Is there an enemy within your line-of-sight yet?"";
      rot13 = ""`foo`'f nethzrag `bar` unf n ceboyrz. Vf gurer na rarzl jvguva lbhe yvar-bs-fvtug lrg?"";
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english=`\
\`attack\`'s argument \`target\` should have type \`unit\`, but got \`function\`.
Target a unit.\
`;
      rot13=`\
\`attack\`'f nethzrag \`target\` fubhyq unir glcr \`unit\`, ohg tbg \`function\`.
Gnetrg n havg.\
`;
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      return $.i18n.changeLanguage(oldLang);
    });
  })",steel
/test/app/views/play/level/tome/Problem.spec.js,Duplicate Assert,"{'line': 54, 'column': 6, 'index': 1948}","it('translates messages with line numbers, error types, and placeholders', function() {
    const oldLang = $.i18n.language;
    return $.i18n.changeLanguage('rot13', function() {
      let english = 'Line 12: ReferenceError: `somethin` is not defined';
      let rot13 = 'Yvar 12: ErsreraprReebe: `somethin` vf abg qrsvarq';
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english = ""`foo`'s argument `bar` has a problem. Is there an enemy within your line-of-sight yet?"";
      rot13 = ""`foo`'f nethzrag `bar` unf n ceboyrz. Vf gurer na rarzl jvguva lbhe yvar-bs-fvtug lrg?"";
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      english=`\
\`attack\`'s argument \`target\` should have type \`unit\`, but got \`function\`.
Target a unit.\
`;
      rot13=`\
\`attack\`'f nethzrag \`target\` fubhyq unir glcr \`unit\`, ohg tbg \`function\`.
Gnetrg n havg.\
`;
      expect(Problem.prototype.translate(english)).toEqual(rot13);
      return $.i18n.changeLanguage(oldLang);
    });
  })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 54, 'column': 6, 'index': 2215}","it('Shows Windows shortcuts to Windows users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.windows);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .windows-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 54, 'column': 6, 'index': 2215}","it('Shows Windows shortcuts to Windows users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.windows);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .windows-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 55, 'column': 6, 'index': 2306}","it('Shows Windows shortcuts to Windows users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.windows);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .windows-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 55, 'column': 6, 'index': 2306}","it('Shows Windows shortcuts to Windows users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.windows);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .windows-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 58, 'column': 8, 'index': 2498}","it('Shows Windows shortcuts to Windows users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.windows);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .windows-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 58, 'column': 8, 'index': 2498}","it('Shows Windows shortcuts to Windows users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.windows);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .windows-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 59, 'column': 8, 'index': 2591}","it('Shows Windows shortcuts to Windows users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.windows);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .windows-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 59, 'column': 8, 'index': 2591}","it('Shows Windows shortcuts to Windows users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.windows);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .windows-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Control|Ctrl/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Command|Cmd/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 68, 'column': 6, 'index': 2988}","it('Shows Mac shortcuts to Mac users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.mac);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .mac-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 68, 'column': 6, 'index': 2988}","it('Shows Mac shortcuts to Mac users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.mac);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .mac-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 69, 'column': 6, 'index': 3078}","it('Shows Mac shortcuts to Mac users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.mac);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .mac-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 69, 'column': 6, 'index': 3078}","it('Shows Mac shortcuts to Mac users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.mac);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .mac-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 72, 'column': 8, 'index': 3271}","it('Shows Mac shortcuts to Mac users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.mac);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .mac-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 72, 'column': 8, 'index': 3271}","it('Shows Mac shortcuts to Mac users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.mac);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .mac-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 73, 'column': 8, 'index': 3363}","it('Shows Mac shortcuts to Mac users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.mac);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .mac-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Duplicate Assert,"{'line': 73, 'column': 8, 'index': 3363}","it('Shows Mac shortcuts to Mac users', function(done) {
      spyOn(utils, 'userAgent').and.callFake(() => userAgents.mac);
      modal.render();
      // This test is a little fragile Only works if the text node is an immediate child to .mac-only
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
      expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
      this.clickedImage = modal.$('li:nth-child(5)').click();
      return _.defer(function() {
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).toMatch(/Command|Cmd/i);
        expect(modal.$('.how-to-copy-paste :not(.hidden)').text()).not.toMatch(/Control|Ctrl/i);
        return done();
      });
    })",steel
/test/app/views/play/level/modal/ImageGalleryModal.spec.js,Magic Number,"{'line': 25, 'column': 83, 'index': 879}","it('shows a list of images', () => expect(modal.$('img').length).toBeGreaterThan(16))",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Conditional Test Logic,"{'line': 16, 'column': 8, 'index': 562}",Unknown,steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 3222}","it('sets the iframe video src when clicked on an unlocked thumbnail', () => {
    spyOn($.fn, 'init').and.callFake((el) => {
      return [wrapper.find(el).element]
    })
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
    wrapper.findAll('.video-image').at(0).trigger('click')
    expect(wrapper.find('.video-frame').attributes().src).toBeDefined()
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 3355}","it('sets the iframe video src when clicked on an unlocked thumbnail', () => {
    spyOn($.fn, 'init').and.callFake((el) => {
      return [wrapper.find(el).element]
    })
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
    wrapper.findAll('.video-image').at(0).trigger('click')
    expect(wrapper.find('.video-frame').attributes().src).toBeDefined()
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 3503}","it('doesnt do anything when clicked on a locked thumbnail', () => {
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
    wrapper.findAll('.video-image').at(1).trigger('click')
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 3503}","it('doesnt do anything when clicked on a locked thumbnail', () => {
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
    wrapper.findAll('.video-image').at(1).trigger('click')
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 3636}","it('doesnt do anything when clicked on a locked thumbnail', () => {
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
    wrapper.findAll('.video-image').at(1).trigger('click')
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 3636}","it('doesnt do anything when clicked on a locked thumbnail', () => {
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
    wrapper.findAll('.video-image').at(1).trigger('click')
    expect(wrapper.find('.video-frame').attributes().src).toBeUndefined()
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Global Variable,"{'line': 42, 'column': 0, 'index': 1386}",Unknown,steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Magic Number,"{'line': 64, 'column': 56, 'index': 2375}","it('shows the video thumbnails and text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.find('.videos-row').exists()).toBe(true)
    expect(wrapper.find('.video-image').exists()).toBe(true)
    expect(wrapper.findAll('.video-image').length).toBe(3)
    expect(wrapper.find('.video-title').exists()).toBe(true)
    expect(wrapper.findAll('.video-title').length).toBe(3)
    expect(wrapper.find('.video-desc').exists()).toBe(true)
    expect(wrapper.findAll('.video-desc').length).toBe(3)
    expect(wrapper.find('.video-status').exists()).toBe(true)
    expect(wrapper.findAll('.video-status').length).toBe(3)
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Magic Number,"{'line': 66, 'column': 56, 'index': 2495}","it('shows the video thumbnails and text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.find('.videos-row').exists()).toBe(true)
    expect(wrapper.find('.video-image').exists()).toBe(true)
    expect(wrapper.findAll('.video-image').length).toBe(3)
    expect(wrapper.find('.video-title').exists()).toBe(true)
    expect(wrapper.findAll('.video-title').length).toBe(3)
    expect(wrapper.find('.video-desc').exists()).toBe(true)
    expect(wrapper.findAll('.video-desc').length).toBe(3)
    expect(wrapper.find('.video-status').exists()).toBe(true)
    expect(wrapper.findAll('.video-status').length).toBe(3)
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Magic Number,"{'line': 68, 'column': 55, 'index': 2613}","it('shows the video thumbnails and text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.find('.videos-row').exists()).toBe(true)
    expect(wrapper.find('.video-image').exists()).toBe(true)
    expect(wrapper.findAll('.video-image').length).toBe(3)
    expect(wrapper.find('.video-title').exists()).toBe(true)
    expect(wrapper.findAll('.video-title').length).toBe(3)
    expect(wrapper.find('.video-desc').exists()).toBe(true)
    expect(wrapper.findAll('.video-desc').length).toBe(3)
    expect(wrapper.find('.video-status').exists()).toBe(true)
    expect(wrapper.findAll('.video-status').length).toBe(3)
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Magic Number,"{'line': 70, 'column': 57, 'index': 2735}","it('shows the video thumbnails and text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.find('.videos-row').exists()).toBe(true)
    expect(wrapper.find('.video-image').exists()).toBe(true)
    expect(wrapper.findAll('.video-image').length).toBe(3)
    expect(wrapper.find('.video-title').exists()).toBe(true)
    expect(wrapper.findAll('.video-title').length).toBe(3)
    expect(wrapper.find('.video-desc').exists()).toBe(true)
    expect(wrapper.findAll('.video-desc').length).toBe(3)
    expect(wrapper.find('.video-status').exists()).toBe(true)
    expect(wrapper.findAll('.video-status').length).toBe(3)
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Magic Number,"{'line': 75, 'column': 51, 'index': 2918}","it('shows 1 video as unlocked and other 2 as locked', () => {
    expect(wrapper.findAll('.locked').exists()).toBe(true)
    expect(wrapper.findAll('.locked').length).toBe(2)
    expect(wrapper.findAll('.unlocked').exists()).toBe(true)
    expect(wrapper.findAll('.unlocked').length).toBe(1)
  })",steel
/test/app/views/play/level/modal/CourseVideosModalComponent.spec.js,Magic Number,"{'line': 77, 'column': 53, 'index': 3035}","it('shows 1 video as unlocked and other 2 as locked', () => {
    expect(wrapper.findAll('.locked').exists()).toBe(true)
    expect(wrapper.findAll('.locked').length).toBe(2)
    expect(wrapper.findAll('.unlocked').exists()).toBe(true)
    expect(wrapper.findAll('.unlocked').length).toBe(1)
  })",steel
/test/app/views/play/ladder/LadderTabView.spec.js,Magic Number,"{'line': 16, 'column': 45, 'index': 681}","it('triggers ""sync"" when its request is finished', function() {
  const level = factories.makeLevel();
  const leaderboard = new LadderTabView.LeaderboardData(level, 'humans', null, 4);
  leaderboard.fetch();

  // no session passed in, so only one request
  expect(jasmine.Ajax.requests.count()).toBe(1);

  const request = jasmine.Ajax.requests.mostRecent();
  let triggered = false;
  leaderboard.once('sync', () => triggered = true);
  request.respondWith({status: 200, responseText: '{}'});
  return expect(triggered).toBe(true);
})",steel
/test/app/views/editor/level/EditorLevelView.spec.js,Magic Number,"{'line': 18, 'column': 55, 'index': 1412}","it('opens just one modal when you click it', function() {
  const view = new LevelEditView({}, 'something');
  const request = jasmine.Ajax.requests.first();
  request.respondWith({status: 200, responseText: JSON.stringify(emptyLevel)});
  me.set('anonymous', false); // otherwise button may be disabled an not fire
  view.render();
  spyOn(view, 'openModalView');
  view.$el.find('#revert-button').click();
  return expect(view.openModalView.calls.count()).toBe(1);
})",steel
/test/app/views/editor/level/modals/SaveBranchModal.spec.js,Conditional Test Logic,"{'line': 15, 'column': 2, 'index': 655}",Unknown,steel
/test/app/views/editor/level/modals/SaveBranchModal.spec.js,Conditional Test Logic,"{'line': 18, 'column': 2, 'index': 750}",Unknown,steel
/test/app/views/editor/level/modals/SaveBranchModal.spec.js,Conditional Test Logic,"{'line': 21, 'column': 2, 'index': 872}",Unknown,steel
/test/app/views/editor/level/modals/SaveBranchModal.spec.js,Global Variable,"{'line': 18, 'column': 7, 'index': 755}",Unknown,steel
/test/app/views/editor/level/modals/SaveBranchModal.spec.js,Global Variable,"{'line': 21, 'column': 7, 'index': 877}",Unknown,steel
/test/app/views/editor/level/modals/SaveBranchModal.spec.js,Magic Number,"{'line': 117, 'column': 37, 'index': 4224}","it('saves a new branch with all local changes to systems and components', function(done) {
  
  // a couple that don't have changes
  const component = factories.makeLevelComponent({name: 'Unchanged Component'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // a couple with changes
  const changedComponent = factories.makeLevelComponent({name: 'Changed Component'});
  const changedSystem = factories.makeLevelSystem({name: 'Changed System'});
  changedComponent.markToRevert();
  changedComponent.set('description', 'new description');
  changedSystem.markToRevert();
  changedSystem.set('description', 'also a new description');
  
  // a component with history
  const componentV0 = factories.makeLevelComponent({
    name: 'Versioned Component',
    version: {
      major: 0,
      minor: 0,
      isLatestMajor: false,
      isLatestMinor: false
    }
  });
  const componentV1 = factories.makeLevelComponent({
    name: 'Versioned Component', 
    original: componentV0.get('original'),
    description:'Recent description change',
    version: {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    }
  });
  const componentV0Changed = componentV0.clone();
  componentV0Changed.markToRevert();
  componentV0Changed.set({name: 'Unconflicting change', description: 'Conflicting change'});
  
  const modal = new SaveBranchModal({ 
    components: new LevelComponents([component, changedComponent, componentV1]),
    systems: new LevelSystems([changedSystem, system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([
      { 
        name: 'First Branch',
        patches: [
          modelDeltas.makePatch(componentV0Changed).toJSON()
        ],
        updatedBy: me.id,
        updatedByName: 'Myself',
        updated: moment().subtract(1, 'day').toISOString()
      },
      {
        name: 'Newer Branch By Someone Else',
        updatedBy: _.uniqueId('user_'),
        updatedByName: 'Someone Else',
        updated: moment().subtract(5, 'hours').toISOString()
      },
      {
        name: 'Older Branch By Me',
        updatedBy: me.id,
        updatedByName: 'Myself',
        updated: moment().subtract(2, 'days').toISOString()
      },
      {
        name: 'Older Branch By Someone Else',
        updatedBy: _.uniqueId('user_'),
        updatedByName: 'Someone Else',
        updated: moment().subtract(1, 'week').toISOString()
      }
    ])
  });
  return _.defer(() => {
    const componentRequest = jasmine.Ajax.requests.mostRecent();
    expect(componentRequest.url).toBe(componentV0.url());
    componentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentV0.toJSON())
    });
    modal.$('#branches-list-group input').val('Branch Name');
    modal.$('#save-branch-btn').click();
    const saveBranchRequest = jasmine.Ajax.requests.mostRecent();
    expect(saveBranchRequest.url).toBe('/db/branches');
    expect(saveBranchRequest.method).toBe('POST');
    const body = JSON.parse(saveBranchRequest.params);
    expect(body.patches.length).toBe(2);
    const targetIds = _.map(body.patches, patch => patch.id);
    expect(_.contains(targetIds, changedComponent.id));
    expect(_.contains(targetIds, changedSystem.id));
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 141, 'column': 4, 'index': 5318}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 142, 'column': 4, 'index': 5380}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 5484}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 5596}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 5596}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 156, 'column': 4, 'index': 6087}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 159, 'column': 4, 'index': 6270}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 160, 'column': 4, 'index': 6339}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 163, 'column': 4, 'index': 6512}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Duplicate Assert,"{'line': 163, 'column': 4, 'index': 6512}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/level/modals/LoadBranchModal.spec.js,Magic Number,"{'line': 153, 'column': 35, 'index': 6034}","it('loads branch patches into local systems and components', function(done) {
  
  const patches = [];
  
  // CASE 0: no changes
  const component = factories.makeLevelComponent({name: 'Unchanged'});
  const system = factories.makeLevelSystem({name: 'Unchanged System'});
  
  // CASE 1: changes that will be applied no problem
  const componentFine = factories.makeLevelComponent({name: 'BasicCase'});
  componentFine.markToRevert();
  componentFine.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentFine).toJSON());
  componentFine.revert();
  
  // CASE 2: there are existing local changes to the component that will be overwritten
  const componentOverwrite = factories.makeLevelComponent({name: 'OverWriting'});
  componentOverwrite.markToRevert();
  componentOverwrite.set('description', 'Adding a description');
  patches.push(modelDeltas.makePatch(componentOverwrite).toJSON());

  componentOverwrite.revert();
  componentOverwrite.set('searchStrings', 'unrelated setting that will be overwritten');
  componentOverwrite.set('description', 'local change to description that will be overwritten');
  
  // CASE 3: we're applying changes to an old version, but the patch will still work
  const componentOldVersion = factories.makeLevelComponent({name: 'OldVersion'});
  componentOldVersion.markToRevert();
  componentOldVersion.set('description', 'Change that should make it');
  patches.push(modelDeltas.makePatch(componentOldVersion).toJSON());

  // the new version (without changes) will be given to the modal...
  const componentNewVersion = componentOldVersion.clone(false);
  componentNewVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    system: 'ai' // unconflicting change
  });
  componentNewVersion.markToRevert(); // make it as if it was loaded from the db, unchanged
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldVersion.revert();
  componentOldVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldVersion.markToRevert();
  
  // CASE 4: The delta could not be applied
  const componentOldWillFailVersion = factories.makeLevelComponent({
    name: 'ErrorCausingChangesVersion',
    dependencies: [{
      majorVersion: 0,
      original: '1234'
    }]
  });
  componentOldWillFailVersion.markToRevert();
  componentOldWillFailVersion.set('dependencies', [{
    majorVersion: 1, // patch will show majorVersion going from 0 to 1
    original: '1234'
  }]);
  patches.push(modelDeltas.makePatch(componentOldWillFailVersion).toJSON());
  
  // the new version which will break when the patch is applied is given to the modal...
  const componentNewWillFailVersion = componentOldWillFailVersion.clone(false);
  componentNewWillFailVersion.set({
    _id: _.uniqueId('new_version'),
    'version': {
      major: 0,
      minor: 1,
      isLatestMajor: true,
      isLatestMinor: true
    },
    dependencies: null // conflicting change, won't be able to apply change to dependency subdoc
  });
  componentNewWillFailVersion.markToRevert();
  
  // ... and the old version (also without changes) will be loaded separately
  componentOldWillFailVersion.revert();
  componentOldWillFailVersion.set('version', {
    major: 0,
    minor: 0,
    isLatestMajor: false,
    isLatestMinor: false
  });
  componentOldWillFailVersion.markToRevert();
  
  const branch = {
    name: 'First Branch',
    patches,
    updatedBy: me.id,
    updatedByName: 'Author name',
    updated: moment().subtract(1, 'day').toISOString()
  };
  
  const components = new LevelComponents([component, componentFine, componentOverwrite, componentNewVersion, componentNewWillFailVersion]);
  const modal = new LoadBranchModal({ 
    components,
    systems: new LevelSystems([system])
  });
  jasmine.demoModal(modal);
  jasmine.Ajax.requests.mostRecent().respondWith({
    status: 200,
    responseText: JSON.stringify([branch])
  });
  
  return _.defer(() => {
    // handle requests for components which were targeted by patches but not given to the modal
    const requests = jasmine.Ajax.requests.all();
    
    const willWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldVersion.id));
    willWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldVersion.toJSON())
    });

    const willNotWorkComponentRequest = _.find(requests, r => _.string.endsWith(r.url, componentOldWillFailVersion.id));
    willNotWorkComponentRequest.respondWith({
      status: 200,
      responseText: JSON.stringify(componentOldWillFailVersion.toJSON())
    });

    expect(componentFine.get('description')).toBeUndefined();
    expect(componentOverwrite.get('searchStrings')).toBe('unrelated setting that will be overwritten');
    expect(componentOverwrite.get('description')).toBe('local change to description that will be overwritten');
    expect(componentNewVersion.get('system')).toBe('ai');
    
    let unexpectedChanges = 0;
    component.on('change', () => unexpectedChanges++);
    componentNewWillFailVersion.on('change', () => unexpectedChanges++);
    modal.hide = _.noop; // so it doesn't close for demos
    modal.$('#load-branch-btn').click();
    
    // case 0 (unchanged component) and case 4 (cannot apply patch): no changes!
    expect(unexpectedChanges).toBe(0);

    // case 1: definition should be changed
    expect(componentFine.get('description')).toBe('Adding a description');
    
    // case 2: search strings and the description which were local, unsaved changes, have been removed
    expect(componentOverwrite.get('searchStrings')).toBeUndefined();
    expect(componentOverwrite.get('description')).toBe('Adding a description');
    
    // case 3: the changes from v0 -> v1 should remain, and the patch to v0 are applied
    expect(componentNewVersion.get('system')).toBe('ai');
    expect(componentNewVersion.get('description')).toBe('Change that should make it');
    return done();
  });
})",steel
/test/app/views/editor/component/ThangComponentsEditView.spec.js,Magic Number,"{'line': 55, 'column': 119, 'index': 1822}","it('loads dependencies when you add a component with the left side treema', () => expect(_.size(view.subviews)).toBe(3))",steel
/test/app/views/editor/component/ThangComponentsEditView.spec.js,Magic Number,"{'line': 68, 'column': 40, 'index': 2521}","it('removes components that are dependent on a removed component', function() {
    view.components = (Array.from(view.components).filter((c) => c.original !== 'A'));
    view.onComponentsChanged();
    expect(view.components.length).toBe(0);
    return expect(_.size(view.subviews)).toBe(0);
  })",steel
/test/app/views/editor/component/ThangComponentsEditView.spec.js,Magic Number,"{'line': 69, 'column': 46, 'index': 2571}","it('removes components that are dependent on a removed component', function() {
    view.components = (Array.from(view.components).filter((c) => c.original !== 'A'));
    view.onComponentsChanged();
    expect(view.components.length).toBe(0);
    return expect(_.size(view.subviews)).toBe(0);
  })",steel
/test/app/views/courses/TeachersContactModal.spec.js,Magic Number,"{'line': 63, 'column': 65, 'index': 2745}","it('shows an error', function() {
        return expect(this.modal.$('.alert-danger').length).toBe(1);
      })",steel
/test/app/views/courses/TeachersContactModal.spec.js,Magic Number,"{'line': 74, 'column': 66, 'index': 3110}","it('shows a success message', function() {
        return expect(this.modal.$('.alert-success').length).toBe(1);
      })",steel
/test/app/views/courses/TeacherCoursesView.spec.js,Duplicate Assert,"{'line': 40, 'column': 6, 'index': 2137}","it('opens HeroSelectModal for the first level of the first course', function(done) {
      spyOn(view, 'openModalView').and.callFake(modal => modal);
      spyOn(application.router, 'navigate');
      view.$('.play-level-button').first().click();
      expect(view.openModalView).toHaveBeenCalled();
      expect(application.router.navigate).not.toHaveBeenCalled();
      const args = view.openModalView.calls.argsFor(0);
      const modalView = args[0];
      expect(modalView instanceof HeroSelectModal).toBe(true);
      modalView.trigger('hero-select:success');
      expect(application.router.navigate).not.toHaveBeenCalled();
      modalView.trigger('hide');
      modalView.trigger('hidden');
      return _.defer(function() {
        expect(application.router.navigate).toHaveBeenCalled();
        return done();
      });
    })",steel
/test/app/views/courses/TeacherCoursesView.spec.js,Duplicate Assert,"{'line': 40, 'column': 6, 'index': 2137}","it('opens HeroSelectModal for the first level of the first course', function(done) {
      spyOn(view, 'openModalView').and.callFake(modal => modal);
      spyOn(application.router, 'navigate');
      view.$('.play-level-button').first().click();
      expect(view.openModalView).toHaveBeenCalled();
      expect(application.router.navigate).not.toHaveBeenCalled();
      const args = view.openModalView.calls.argsFor(0);
      const modalView = args[0];
      expect(modalView instanceof HeroSelectModal).toBe(true);
      modalView.trigger('hero-select:success');
      expect(application.router.navigate).not.toHaveBeenCalled();
      modalView.trigger('hide');
      modalView.trigger('hidden');
      return _.defer(function() {
        expect(application.router.navigate).toHaveBeenCalled();
        return done();
      });
    })",steel
/test/app/views/courses/TeacherCoursesView.spec.js,Duplicate Assert,"{'line': 45, 'column': 6, 'index': 2403}","it('opens HeroSelectModal for the first level of the first course', function(done) {
      spyOn(view, 'openModalView').and.callFake(modal => modal);
      spyOn(application.router, 'navigate');
      view.$('.play-level-button').first().click();
      expect(view.openModalView).toHaveBeenCalled();
      expect(application.router.navigate).not.toHaveBeenCalled();
      const args = view.openModalView.calls.argsFor(0);
      const modalView = args[0];
      expect(modalView instanceof HeroSelectModal).toBe(true);
      modalView.trigger('hero-select:success');
      expect(application.router.navigate).not.toHaveBeenCalled();
      modalView.trigger('hide');
      modalView.trigger('hidden');
      return _.defer(function() {
        expect(application.router.navigate).toHaveBeenCalled();
        return done();
      });
    })",steel
/test/app/views/courses/TeacherCoursesView.spec.js,Duplicate Assert,"{'line': 45, 'column': 6, 'index': 2403}","it('opens HeroSelectModal for the first level of the first course', function(done) {
      spyOn(view, 'openModalView').and.callFake(modal => modal);
      spyOn(application.router, 'navigate');
      view.$('.play-level-button').first().click();
      expect(view.openModalView).toHaveBeenCalled();
      expect(application.router.navigate).not.toHaveBeenCalled();
      const args = view.openModalView.calls.argsFor(0);
      const modalView = args[0];
      expect(modalView instanceof HeroSelectModal).toBe(true);
      modalView.trigger('hero-select:success');
      expect(application.router.navigate).not.toHaveBeenCalled();
      modalView.trigger('hide');
      modalView.trigger('hidden');
      return _.defer(function() {
        expect(application.router.navigate).toHaveBeenCalled();
        return done();
      });
    })",steel
/test/app/views/courses/TeacherCoursesView.spec.js,Duplicate Assert,"{'line': 49, 'column': 8, 'index': 2573}","it('opens HeroSelectModal for the first level of the first course', function(done) {
      spyOn(view, 'openModalView').and.callFake(modal => modal);
      spyOn(application.router, 'navigate');
      view.$('.play-level-button').first().click();
      expect(view.openModalView).toHaveBeenCalled();
      expect(application.router.navigate).not.toHaveBeenCalled();
      const args = view.openModalView.calls.argsFor(0);
      const modalView = args[0];
      expect(modalView instanceof HeroSelectModal).toBe(true);
      modalView.trigger('hero-select:success');
      expect(application.router.navigate).not.toHaveBeenCalled();
      modalView.trigger('hide');
      modalView.trigger('hidden');
      return _.defer(function() {
        expect(application.router.navigate).toHaveBeenCalled();
        return done();
      });
    })",steel
/test/app/views/courses/HeroSelectModal.spec.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 2557}","it('triggers its events properly', function(done) {
    spyOn(modal, 'trigger');
    modal.render();
    modal.$('.hero-option:nth-child(2)').click();
    const request = jasmine.Ajax.requests.mostRecent();
    request.respondWith({ status: 200, responseText: me.attributes });
    expect(modal.trigger).toHaveBeenCalled();
    expect(modal.trigger.calls.argsFor(0)[0]).toBe('hero-select:success');
    expect(modal.trigger).not.toHaveBeenCalledWith('hide');
    modal.$('.select-hero-btn').click();
    expect(modal.trigger).toHaveBeenCalledWith('hide');
    return done();
  })",steel
/test/app/views/courses/HeroSelectModal.spec.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 2678}","it('triggers its events properly', function(done) {
    spyOn(modal, 'trigger');
    modal.render();
    modal.$('.hero-option:nth-child(2)').click();
    const request = jasmine.Ajax.requests.mostRecent();
    request.respondWith({ status: 200, responseText: me.attributes });
    expect(modal.trigger).toHaveBeenCalled();
    expect(modal.trigger.calls.argsFor(0)[0]).toBe('hero-select:success');
    expect(modal.trigger).not.toHaveBeenCalledWith('hide');
    modal.$('.select-hero-btn').click();
    expect(modal.trigger).toHaveBeenCalledWith('hide');
    return done();
  })",steel
/test/app/views/courses/HeroSelectModal.spec.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 2779}","it('triggers its events properly', function(done) {
    spyOn(modal, 'trigger');
    modal.render();
    modal.$('.hero-option:nth-child(2)').click();
    const request = jasmine.Ajax.requests.mostRecent();
    request.respondWith({ status: 200, responseText: me.attributes });
    expect(modal.trigger).toHaveBeenCalled();
    expect(modal.trigger.calls.argsFor(0)[0]).toBe('hero-select:success');
    expect(modal.trigger).not.toHaveBeenCalledWith('hide');
    modal.$('.select-hero-btn').click();
    expect(modal.trigger).toHaveBeenCalledWith('hide');
    return done();
  })",steel
/test/app/views/courses/HeroSelectModal.spec.js,Magic Number,"{'line': 42, 'column': 44, 'index': 1960}","it('saves when you change heroes', function(done) {
    modal.$(`.hero-option[data-hero-original='${hero2.get('original')}']`).click();
    return setTimeout(function() { // TODO Webpack: Figure out how to not need this race condition
      expect(user.fakeRequests.length).toBe(1);
      const request = user.fakeRequests[0];
      expect(request != null ? request.method : undefined).toBe(""PUT"");
      expect(__guard__(JSON.parse(request != null ? request.params : undefined).heroConfig, x => x.thangType)).toBe(hero2.get('original'));
      return done();
    }
    , 500);
  })",steel
/test/app/views/courses/HeroSelectModal.spec.js,Sleepy Test,"{'line': 41, 'column': 11, 'index': 1828}","it('saves when you change heroes', function(done) {
    modal.$(`.hero-option[data-hero-original='${hero2.get('original')}']`).click();
    return setTimeout(function() { // TODO Webpack: Figure out how to not need this race condition
      expect(user.fakeRequests.length).toBe(1);
      const request = user.fakeRequests[0];
      expect(request != null ? request.method : undefined).toBe(""PUT"");
      expect(__guard__(JSON.parse(request != null ? request.params : undefined).heroConfig, x => x.thangType)).toBe(hero2.get('original'));
      return done();
    }
    , 500);
  })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Conditional Test Logic,"{'line': 36, 'column': 4, 'index': 1489}","beforeEach(function() {
    me.set('anonymous', false);
    me.set('role', 'teacher');
    me.set('enrollmentRequestSent', false);
    this.view = new EnrollmentsView();

    // Make three classrooms, sharing users from a pool of 10, 5 of which are enrolled
    const prepaid = factories.makePrepaid();
    const students = new Users(_.times(10, i => factories.makeUser({}, { prepaid: i%2 ? prepaid : null }))
    );

    const userSlices = [
      new Users(students.slice(0, 5)),
      new Users(students.slice(3, 8)),
      new Users(students.slice(7, 10))
    ];

    const classrooms = new Classrooms(Array.from(userSlices).map((userSlice) => factories.makeClassroom({}, {members: userSlice})));
    this.view.classrooms.fakeRequests[0].respondWith({ status: 200, responseText: classrooms.stringify() });
    for (let i = 0; i < this.view.members.fakeRequests.length; i++) {
      var request = this.view.members.fakeRequests[i];
      request.respondWith({status: 200, responseText: userSlices[i].stringify()});
    }

    // Make prepaids of various status
    const prepaids = new Prepaids([
      factories.makePrepaid({}, {redeemers: new Users(_.times(5, () => factories.makeUser()))}),
      factories.makePrepaid(),
      factories.makePrepaid({ // pending
        startDate: moment().add(2, 'months').toISOString(),
        endDate: moment().add(14, 'months').toISOString()
      }),
      factories.makePrepaid( // empty
        { maxRedeemers: 2 },
        {redeemers: new Users(_.times(2, () => factories.makeUser()))}
      )
    ]);
    this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: prepaids.stringify() });

    // Make a few courses, one free
    const courses = new Courses([
      factories.makeCourse({free: true}),
      factories.makeCourse({free: false}),
      factories.makeCourse({free: false}),
      factories.makeCourse({free: false})
    ]);
    this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: courses.stringify() });

    jasmine.demoEl(this.view.$el);
    return window.view = this.view;
  })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Conditional Test Logic,"{'line': 76, 'column': 6, 'index': 3139}","describe('shows the starter license upsell', function() {
      if (features.chinaInfra) { return; }
    })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Conditional Test Logic,"{'line': 180, 'column': 8, 'index': 7111}","it('shows confirmation and a mailto link to schools@codecombat.com', function() {
        if (!this.view.$('#request-sent-btn').length) {
          fail('Request button not found.');
        }
        if (!this.view.$('#enrollment-request-sent-blurb').length) {
          return fail('License request sent blurb not found.');
        }
      })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Conditional Test Logic,"{'line': 183, 'column': 8, 'index': 7222}","it('shows confirmation and a mailto link to schools@codecombat.com', function() {
        if (!this.view.$('#request-sent-btn').length) {
          fail('Request button not found.');
        }
        if (!this.view.$('#enrollment-request-sent-blurb').length) {
          return fail('License request sent blurb not found.');
        }
      })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Global Variable,"{'line': 37, 'column': 6, 'index': 1561}","beforeEach(function() {
    me.set('anonymous', false);
    me.set('role', 'teacher');
    me.set('enrollmentRequestSent', false);
    this.view = new EnrollmentsView();

    // Make three classrooms, sharing users from a pool of 10, 5 of which are enrolled
    const prepaid = factories.makePrepaid();
    const students = new Users(_.times(10, i => factories.makeUser({}, { prepaid: i%2 ? prepaid : null }))
    );

    const userSlices = [
      new Users(students.slice(0, 5)),
      new Users(students.slice(3, 8)),
      new Users(students.slice(7, 10))
    ];

    const classrooms = new Classrooms(Array.from(userSlices).map((userSlice) => factories.makeClassroom({}, {members: userSlice})));
    this.view.classrooms.fakeRequests[0].respondWith({ status: 200, responseText: classrooms.stringify() });
    for (let i = 0; i < this.view.members.fakeRequests.length; i++) {
      var request = this.view.members.fakeRequests[i];
      request.respondWith({status: 200, responseText: userSlices[i].stringify()});
    }

    // Make prepaids of various status
    const prepaids = new Prepaids([
      factories.makePrepaid({}, {redeemers: new Users(_.times(5, () => factories.makeUser()))}),
      factories.makePrepaid(),
      factories.makePrepaid({ // pending
        startDate: moment().add(2, 'months').toISOString(),
        endDate: moment().add(14, 'months').toISOString()
      }),
      factories.makePrepaid( // empty
        { maxRedeemers: 2 },
        {redeemers: new Users(_.times(2, () => factories.makeUser()))}
      )
    ]);
    this.view.prepaids.fakeRequests[0].respondWith({ status: 200, responseText: prepaids.stringify() });

    // Make a few courses, one free
    const courses = new Courses([
      factories.makeCourse({free: true}),
      factories.makeCourse({free: false}),
      factories.makeCourse({free: false}),
      factories.makeCourse({free: false})
    ]);
    this.view.courses.fakeRequests[0].respondWith({ status: 200, responseText: courses.stringify() });

    jasmine.demoEl(this.view.$el);
    return window.view = this.view;
  })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Magic Number,"{'line': 134, 'column': 87, 'index': 5311}","it('when full licenses have existed', function() {
        this.view.prepaids.set([]);
        this.view.prepaids.add(factories.makePrepaid({
          startDate: moment().subtract(2, 'month').toISOString(),
          endDate: moment().subtract(1, 'month').toISOString()
        }));

        this.view.render();
        return expect(this.view.$('a[href=""/teachers/starter-licenses""]').length).toBe(0);
      })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Magic Number,"{'line': 145, 'column': 87, 'index': 5737}","it('when full licenses currently exist', function() {
        this.view.prepaids.set([]);
        this.view.prepaids.add(factories.makePrepaid({
          startDate: moment().subtract(2, 'month').toISOString(),
          endDate: moment().add(1, 'month').toISOString()
        }));

        this.view.render();
        return expect(this.view.$('a[href=""/teachers/starter-licenses""]').length).toBe(0);
      })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Magic Number,"{'line': 158, 'column': 85, 'index': 6258}","it(""doesn't show the Starter License upsell"", function() {
      return expect(this.view.$('a[href=""/teachers/starter-licenses""]').length).toBe(0);
    })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Magic Number,"{'line': 170, 'column': 85, 'index': 6770}","it(""doesn't show the Starter License upsell"", function() {
      return expect(this.view.$('a[href=""/teachers/starter-licenses""]').length).toBe(0);
    })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Magic Number,"{'line': 200, 'column': 63, 'index': 7963}","it('fills the void with the rest of the page content', function() {
        return expect(this.view.$('#actions-col').length).toBe(0);
      })",steel
/test/app/views/courses/EnrollmentsView.spec.js,Unknown Test,"{'column': 13, 'line': 179}","it('shows confirmation and a mailto link to schools@codecombat.com', function() {
        if (!this.view.$('#request-sent-btn').length) {
          fail('Request button not found.');
        }
        if (!this.view.$('#enrollment-request-sent-blurb').length) {
          return fail('License request sent blurb not found.');
        }
      })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 20, 'column': 69, 'index': 698}","it('shows log in button', function() {
      return expect(this.view.$el.find('.login-btn').length).toEqual(1);
    })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 34, 'column': 78, 'index': 1158}","it('shows update to teacher button', function() {
      return expect(this.view.$el.find('.update-teacher-btn').length).toEqual(1);
    })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 38, 'column': 71, 'index': 1323}","it('shows update to student button and classCode input', function() {
      expect(this.view.$el.find('.update-student-btn').length).toEqual(1);
      return expect(this.view.$el.find('input[name=""classCode""]').length).toEqual(1);
    })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 39, 'column': 82, 'index': 1409}","it('shows update to student button and classCode input', function() {
      expect(this.view.$el.find('.update-student-btn').length).toEqual(1);
      return expect(this.view.$el.find('input[name=""classCode""]').length).toEqual(1);
    })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 55, 'column': 71, 'index': 2015}","it('shows remain a student button', function() {
      expect(this.view.$el.find('.remain-student-btn').length).toEqual(1);
      return expect(this.view.$el.find('input[name=""classCode""]').length).toEqual(0);
    })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 56, 'column': 82, 'index': 2101}","it('shows remain a student button', function() {
      expect(this.view.$el.find('.remain-student-btn').length).toEqual(1);
      return expect(this.view.$el.find('input[name=""classCode""]').length).toEqual(0);
    })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 60, 'column': 78, 'index': 2253}","it('shows update to teacher button', function() {
      return expect(this.view.$el.find('.update-teacher-btn').length).toEqual(1);
    })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 75, 'column': 78, 'index': 2806}","it('shows remain a teacher button', function() {
      return expect(this.view.$el.find('.remain-teacher-btn').length).toEqual(1);
    })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 79, 'column': 71, 'index': 2951}","it('shows update to student button', function() {
      expect(this.view.$el.find('.update-student-btn').length).toEqual(1);
      return expect(this.view.$el.find('input[name=""classCode""]').length).toEqual(1);
    })",steel
/test/app/views/courses/CoursesUpdateAccountView.spec.js,Magic Number,"{'line': 80, 'column': 82, 'index': 3037}","it('shows update to student button', function() {
      expect(this.view.$el.find('.update-student-btn').length).toEqual(1);
      return expect(this.view.$el.find('input[name=""classCode""]').length).toEqual(1);
    })",steel
/test/app/views/courses/CourseVideosComponent.spec.js,Conditional Test Logic,"{'line': 11, 'column': 8, 'index': 342}",Unknown,steel
/test/app/views/courses/CourseVideosComponent.spec.js,Conditional Test Logic,"{'line': 39, 'column': 4, 'index': 1199}","it('shows the videos and concept text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').length).toBe(3)
    const me = factories.makeUser({})
    if (me.showChinaVideo()) {
      expect(wrapper.findAll('video').exists()).toBe(true)
      expect(wrapper.findAll('video').length).toBe(3)
    } else {
      expect(wrapper.findAll('.video').exists()).toBe(true)
      expect(wrapper.findAll('.video').length).toBe(3)
    }
  })",steel
/test/app/views/courses/CourseVideosComponent.spec.js,Magic Number,"{'line': 37, 'column': 57, 'index': 1154}","it('shows the videos and concept text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').length).toBe(3)
    const me = factories.makeUser({})
    if (me.showChinaVideo()) {
      expect(wrapper.findAll('video').exists()).toBe(true)
      expect(wrapper.findAll('video').length).toBe(3)
    } else {
      expect(wrapper.findAll('.video').exists()).toBe(true)
      expect(wrapper.findAll('.video').length).toBe(3)
    }
  })",steel
/test/app/views/courses/CourseVideosComponent.spec.js,Magic Number,"{'line': 41, 'column': 51, 'index': 1336}","it('shows the videos and concept text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').length).toBe(3)
    const me = factories.makeUser({})
    if (me.showChinaVideo()) {
      expect(wrapper.findAll('video').exists()).toBe(true)
      expect(wrapper.findAll('video').length).toBe(3)
    } else {
      expect(wrapper.findAll('.video').exists()).toBe(true)
      expect(wrapper.findAll('.video').length).toBe(3)
    }
  })",steel
/test/app/views/courses/CourseVideosComponent.spec.js,Magic Number,"{'line': 44, 'column': 52, 'index': 1464}","it('shows the videos and concept text', () => {
    expect(wrapper.find('#videos-content').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').exists()).toBe(true)
    expect(wrapper.findAll('.concept-text').length).toBe(3)
    const me = factories.makeUser({})
    if (me.showChinaVideo()) {
      expect(wrapper.findAll('video').exists()).toBe(true)
      expect(wrapper.findAll('video').length).toBe(3)
    } else {
      expect(wrapper.findAll('.video').exists()).toBe(true)
      expect(wrapper.findAll('.video').length).toBe(3)
    }
  })",steel
/test/app/views/core/SubscribeModal.spec.ozar.js,Conditional Test Logic,"{'line': 102, 'column': 4, 'index': 3179}","afterEach(function() {
    if (this.openAsync.calls != null ? this.openAsync.calls.any() : undefined) {
      const options = this.openAsync.calls.argsFor(0)[0];
      expect(options.alipayReusable).toBeDefined();
      return expect(options.alipay).toBeDefined();
    }
  })",steel
/test/app/views/core/SubscribeModal.spec.ozar.js,Magic Number,"{'line': 195, 'column': 68, 'index': 6925}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",steel
/test/app/views/core/SubscribeModal.spec.ozar.js,Magic Number,"{'line': 196, 'column': 69, 'index': 6998}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",steel
/test/app/views/core/SubscribeModal.spec.ozar.js,Magic Number,"{'line': 243, 'column': 68, 'index': 8908}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",steel
/test/app/views/core/SubscribeModal.spec.ozar.js,Magic Number,"{'line': 244, 'column': 69, 'index': 8981}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",steel
/test/app/views/core/SubscribeModal.spec.coco.js,Conditional Test Logic,"{'line': 110, 'column': 4, 'index': 3299}","afterEach(function() {
    if (this.openAsync.calls != null ? this.openAsync.calls.any() : undefined) {
      const options = this.openAsync.calls.argsFor(0)[0];
      expect(options.alipayReusable).toBeDefined();
      return expect(options.alipay).toBeDefined();
    }
  })",steel
/test/app/views/core/SubscribeModal.spec.coco.js,Magic Number,"{'line': 128, 'column': 71, 'index': 4101}","it('expect yearly subscription button', function() {
      // TODO: update this to handle more complex logic (either annual or lifetime)
      return expect(this.modal.$('.stripe-annual-button').length).toBe(1);
    })",steel
/test/app/views/core/SubscribeModal.spec.coco.js,Magic Number,"{'line': 210, 'column': 68, 'index': 7406}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",steel
/test/app/views/core/SubscribeModal.spec.coco.js,Magic Number,"{'line': 211, 'column': 69, 'index': 7479}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",steel
/test/app/views/core/SubscribeModal.spec.coco.js,Magic Number,"{'line': 258, 'column': 68, 'index': 9389}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",steel
/test/app/views/core/SubscribeModal.spec.coco.js,Magic Number,"{'line': 259, 'column': 69, 'index': 9462}","it('uses Stripe', function() {
        expect(this.modal.$('.stripe-lifetime-button').length).toBe(1);
        expect(this.modal.$('#paypal-button-container').length).toBe(0);
        return expect(this.payPalButton).toBeUndefined();
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 122, 'column': 8, 'index': 4660}","it('is memoized', function() {
        const promise1 = segmentCheckView.fetchClassByCode('testA');
        const promise2 = segmentCheckView.fetchClassByCode('testA');
        const promise3 = segmentCheckView.fetchClassByCode('testB');
        expect(promise1).toBe(promise2);
        return expect(promise1).not.toBe(promise3);
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 123, 'column': 15, 'index': 4708}","it('is memoized', function() {
        const promise1 = segmentCheckView.fetchClassByCode('testA');
        const promise2 = segmentCheckView.fetchClassByCode('testA');
        const promise3 = segmentCheckView.fetchClassByCode('testB');
        expect(promise1).toBe(promise2);
        return expect(promise1).not.toBe(promise3);
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 128, 'column': 8, 'index': 4933}","it('shows a success message if the classCode is found', function() {
        let request = jasmine.Ajax.requests.mostRecent();
        expect(_.string.startsWith(request.url, '/db/classroom')).toBe(false);
        modal.$('.class-code-input').val('test').trigger('input');
        segmentCheckView.checkClassCode();
        request = jasmine.Ajax.requests.mostRecent();
        expect(_.string.startsWith(request.url, '/db/classroom')).toBe(true);
        return request.respondWith({
          status: 200,
          responseText: JSON.stringify({
            data: factories.makeClassroom({name: 'Some Classroom'}).toJSON(),
            owner: factories.makeUser({name: 'Some Teacher'}).toJSON()
          })
        });
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 132, 'column': 8, 'index': 5176}","it('shows a success message if the classCode is found', function() {
        let request = jasmine.Ajax.requests.mostRecent();
        expect(_.string.startsWith(request.url, '/db/classroom')).toBe(false);
        modal.$('.class-code-input').val('test').trigger('input');
        segmentCheckView.checkClassCode();
        request = jasmine.Ajax.requests.mostRecent();
        expect(_.string.startsWith(request.url, '/db/classroom')).toBe(true);
        return request.respondWith({
          status: 200,
          responseText: JSON.stringify({
            data: factories.makeClassroom({name: 'Some Classroom'}).toJSON(),
            owner: factories.makeUser({name: 'Some Teacher'}).toJSON()
          })
        });
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 519, 'column': 8, 'index': 19201}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 520, 'column': 8, 'index': 19265}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 521, 'column': 8, 'index': 19325}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 522, 'column': 8, 'index': 19384}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 523, 'column': 8, 'index': 19446}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 525, 'column': 8, 'index': 19586}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 526, 'column': 8, 'index': 19656}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 527, 'column': 8, 'index': 19730}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 528, 'column': 8, 'index': 19785}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 529, 'column': 15, 'index': 19850}","it('clears the school NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('organization', 'homeschool');
        expect(this.schoolInfoPanel.organization).toBe('homeschool');
        expect(this.schoolInfoPanel.district).toBe('suggested district');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('district NCES id');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 533, 'column': 8, 'index': 20071}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 534, 'column': 8, 'index': 20135}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 535, 'column': 8, 'index': 20195}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 536, 'column': 8, 'index': 20254}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 537, 'column': 8, 'index': 20316}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 539, 'column': 8, 'index': 20454}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 540, 'column': 8, 'index': 20530}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 541, 'column': 8, 'index': 20598}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 542, 'column': 8, 'index': 20653}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Duplicate Assert,"{'line': 543, 'column': 15, 'index': 20718}","it('clears the school and district NCES info', function() {
        expect(this.schoolInfoPanel.organization).not.toBe('');
        expect(this.schoolInfoPanel.district).not.toBe('');
        expect(this.schoolInfoPanel.nces_id).not.toBe('');
        expect(this.schoolInfoPanel.nces_phone).not.toBe('');
        expect(this.schoolInfoPanel.nces_district_id).not.toBe('');
        this.schoolInfoPanel.updateValue('district', 'homedistrict');
        expect(this.schoolInfoPanel.organization).toBe('suggested school');
        expect(this.schoolInfoPanel.district).toBe('homedistrict');
        expect(this.schoolInfoPanel.nces_id).toBe('');
        expect(this.schoolInfoPanel.nces_phone).toBe('');
        return expect(this.schoolInfoPanel.nces_district_id).toBe('');
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Empty Test,"{'line': 345, 'column': 17, 'index': 13157}","it('re-enables the form and shows which field failed', function() {})",steel
/test/app/views/core/CreateAccountModal.spec.js,Empty Test,"{'line': 488, 'column': 11, 'index': 18237}","it('(for demo testing)', function() {})",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 97, 'column': 98, 'index': 3635}","it('has a birthdate form', () => expect(modal.$('.birthday-form-group').length).toBe(1))",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 111, 'column': 89, 'index': 4133}","it('has a classCode input', () => expect(modal.$('.class-code-input').length).toBe(1))",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 182, 'column': 116, 'index': 7191}","it('shows an error', () => expect(modal.$('[data-i18n=""signup.classroom_not_found""]').length).toBe(1))",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 203, 'column': 142, 'index': 7737}","it('shows an input for a parent\'s email address to sign up their child', () => expect(modal.$('#parent-email-input').length).toBe(1))",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 234, 'column': 102, 'index': 8671}","it('shows checking', () => expect(basicInfoView.$('[data-i18n=""signup.checking""]').length).toBe(1))",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 246, 'column': 85, 'index': 9140}","it('says an account already exists and encourages to sign in', function() {
          expect(basicInfoView.$('[data-i18n=""signup.account_exists""]').length).toBe(1);
          return expect(basicInfoView.$('.login-link[data-i18n=""signup.sign_in""]').length).toBe(1);
        })",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 247, 'column': 96, 'index': 9240}","it('says an account already exists and encourages to sign in', function() {
          expect(basicInfoView.$('[data-i18n=""signup.account_exists""]').length).toBe(1);
          return expect(basicInfoView.$('.login-link[data-i18n=""signup.sign_in""]').length).toBe(1);
        })",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 260, 'column': 120, 'index': 9686}","it('says email looks good', () => expect(basicInfoView.$('[data-i18n=""signup.email_good""]').length).toBe(1))",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 270, 'column': 102, 'index': 10018}","it('shows checking', () => expect(basicInfoView.$('[data-i18n=""signup.checking""]').length).toBe(1))",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 293, 'column': 123, 'index': 10982}","it('says name looks good', () => expect(basicInfoView.$('[data-i18n=""signup.name_available""]').length).toBe(1))",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 302, 'column': 76, 'index': 11370}","it('shows required errors for empty fields when on INDIVIDUAL path', function() {
        modal.signupState.set('path', 'individual');
        basicInfoView.$('input').val('');
        basicInfoView.$('#basic-info-form').submit();
        return expect(basicInfoView.$('.form-group.has-error').length).toBe(3);
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 309, 'column': 76, 'index': 11674}","it('shows required errors for empty fields when on STUDENT path', function() {
        modal.signupState.set('path', 'student');
        modal.render();
        basicInfoView.$('#basic-info-form').submit();
        return expect(basicInfoView.$('.form-group.has-error').length).toBe(4);
      })",steel
/test/app/views/core/CreateAccountModal.spec.js,Magic Number,"{'line': 384, 'column': 110, 'index': 14848}","it('displays the server error', () => expect(basicInfoView.$('.alert-danger').length).toBe(1))",steel
/test/app/views/core/CreateAccountModal.spec.js,Unknown Test,"{'column': 11, 'line': 447}","it('(for demo testing)', function() {
      me.set('name', 'A Sweet New Username');
      me.set('email', 'some@email.com');
      return confirmationView.signupState.set('ssoUsed', 'gplus');
    })",steel
/test/app/views/core/CreateAccountModal.spec.js,Unknown Test,"{'column': 11, 'line': 468}","it('(for demo testing)', function() {
      me.set('name', 'A Sweet New Username');
      me.set('email', 'some@email.com');
      return singleSignOnConfirmView.signupState.set('ssoUsed', 'facebook');
    })",steel
/test/app/views/core/CocoView.spec.js,Conditional Test Logic,"{'line': 14, 'column': 4, 'index': 538}",Unknown,steel
/test/app/views/core/CocoView.spec.js,Conditional Test Logic,"{'line': 29, 'column': 4, 'index': 967}",Unknown,steel
/test/app/views/core/CocoView.spec.js,Conditional Test Logic,"{'line': 42, 'column': 4, 'index': 1327}","describe('network error handling', function() {
  let view = null;
  const respond = function(code, index) {
    if (!index) { index = 0 }
    view.render();
    const requests = jasmine.Ajax.requests.all();
    return requests[index].respondWith({status: code, responseText: JSON.stringify({})});
  };

  beforeEach(() => view = new BlandView());

  describe('when the view overrides onResourceLoadFailed', function() {
    beforeEach(function() {
      view.render();
      expect(view.$('#content').hasClass('hidden')).toBe(true);
      return respond(400);
    });

    it('can show a custom message for a given error and model', function() {
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      expect(view.$('#content').text()).toBe('custom message');
      respond(200, 1);
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      return expect(view.$('#content').text()).toBe('custom message');
    });

    return it('(demo)', () => jasmine.demoEl(view.$el));
  });


  describe('when the server returns 401', function() {
    beforeEach(function() {
      me.set('anonymous', true);
      return respond(401);
    });

    it('shows a login button which opens the AuthModal', function() {
      const button = view.$el.find('.login-btn');
      expect(button.length).toBe(1);
      spyOn(view, 'openModalView').and.callFake(function(modal) {
        expect(modal instanceof AuthModal).toBe(true);
        return modal.stopListening();
      });
      button.click();
      return expect(view.openModalView).toHaveBeenCalled();
    });

    it('shows a create account button which opens the CreateAccountModal', function() {
      const button = view.$el.find('#create-account-btn');
      expect(button.length).toBe(1);
      spyOn(view, 'openModalView').and.callFake(function(modal) {
        expect(modal instanceof CreateAccountModal).toBe(true);
        return modal.stopListening();
      });
      button.click();
      return expect(view.openModalView).toHaveBeenCalled();
    });

    it('says ""Login Required""', () => expect(view.$('[data-i18n=""loading_error.login_required""]').length).toBeTruthy());

    return it('(demo)', () => jasmine.demoEl(view.$el));
  });



  describe('when the server returns 402', function() {

    beforeEach(() => respond(402));

    return it('does nothing, because it is up to the view to handle payment next steps');
  });


  describe('when the server returns 403', function() {

    beforeEach(function() {
      me.set('anonymous', false);
      return respond(403);
    });

    it('includes a logout button which logs out the account', function() {
      const button = view.$el.find('#logout-btn');
      expect(button.length).toBe(1);
      button.click();
      const request = jasmine.Ajax.requests.mostRecent();
      return expect(request.url).toBe('/auth/logout');
    });

    return it('(demo)', () => jasmine.demoEl(view.$el));
  });


  describe('when the server returns 404', function() {

    beforeEach(() => respond(404));

    it('includes one of the 404 images', function() {
      const img = view.$el.find('#not-found-img');
      return expect(img.length).toBe(1);
    });

    return it('(demo)', () => jasmine.demoEl(view.$el));
  });


  describe('when the server returns 408', function() {

    beforeEach(() => respond(408));

    it('includes ""Server Timeout"" in the header', () => expect(view.$('[data-i18n=""loading_error.timeout""]').length).toBeTruthy());

    it('shows a message encouraging refreshing the page or following links', () => expect(view.$('[data-i18n=""loading_error.general_desc""]').length).toBeTruthy());

    return it('(demo)', () => jasmine.demoEl(view.$el));
  });


  describe('when no connection is made', function() {

    beforeEach(() => respond());

    it('shows ""Connection Failed""', () => expect(view.$('[data-i18n=""loading_error.connection_failure""]').length).toBeTruthy());

    return it('(demo)', () => jasmine.demoEl(view.$el));
  });


  return describe('when the server returns any other number >= 400', function() {

    beforeEach(() => respond(9001));

    it('includes ""Unknown Error"" in the header', () => expect(view.$('[data-i18n=""loading_error.unknown""]').length).toBeTruthy());

    it('shows a message encouraging refreshing the page or following links', () => expect(view.$('[data-i18n=""loading_error.general_desc""]').length).toBeTruthy());

    return it('(demo)', () => jasmine.demoEl(view.$el));
  });
})",steel
/test/app/views/core/CocoView.spec.js,Duplicate Assert,"{'line': 58, 'column': 6, 'index': 1867}","it('can show a custom message for a given error and model', function() {
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      expect(view.$('#content').text()).toBe('custom message');
      respond(200, 1);
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      return expect(view.$('#content').text()).toBe('custom message');
    })",steel
/test/app/views/core/CocoView.spec.js,Duplicate Assert,"{'line': 58, 'column': 6, 'index': 1867}","it('can show a custom message for a given error and model', function() {
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      expect(view.$('#content').text()).toBe('custom message');
      respond(200, 1);
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      return expect(view.$('#content').text()).toBe('custom message');
    })",steel
/test/app/views/core/CocoView.spec.js,Duplicate Assert,"{'line': 59, 'column': 6, 'index': 1932}","it('can show a custom message for a given error and model', function() {
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      expect(view.$('#content').text()).toBe('custom message');
      respond(200, 1);
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      return expect(view.$('#content').text()).toBe('custom message');
    })",steel
/test/app/views/core/CocoView.spec.js,Duplicate Assert,"{'line': 59, 'column': 6, 'index': 1932}","it('can show a custom message for a given error and model', function() {
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      expect(view.$('#content').text()).toBe('custom message');
      respond(200, 1);
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      return expect(view.$('#content').text()).toBe('custom message');
    })",steel
/test/app/views/core/CocoView.spec.js,Duplicate Assert,"{'line': 61, 'column': 6, 'index': 2019}","it('can show a custom message for a given error and model', function() {
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      expect(view.$('#content').text()).toBe('custom message');
      respond(200, 1);
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      return expect(view.$('#content').text()).toBe('custom message');
    })",steel
/test/app/views/core/CocoView.spec.js,Duplicate Assert,"{'line': 61, 'column': 6, 'index': 2019}","it('can show a custom message for a given error and model', function() {
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      expect(view.$('#content').text()).toBe('custom message');
      respond(200, 1);
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      return expect(view.$('#content').text()).toBe('custom message');
    })",steel
/test/app/views/core/CocoView.spec.js,Duplicate Assert,"{'line': 62, 'column': 13, 'index': 2091}","it('can show a custom message for a given error and model', function() {
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      expect(view.$('#content').text()).toBe('custom message');
      respond(200, 1);
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      return expect(view.$('#content').text()).toBe('custom message');
    })",steel
/test/app/views/core/CocoView.spec.js,Duplicate Assert,"{'line': 62, 'column': 13, 'index': 2091}","it('can show a custom message for a given error and model', function() {
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      expect(view.$('#content').text()).toBe('custom message');
      respond(200, 1);
      expect(view.$('#content').hasClass('hidden')).toBe(false);
      return expect(view.$('#content').text()).toBe('custom message');
    })",steel
/test/app/views/core/CocoView.spec.js,Global Variable,"{'line': 12, 'column': 0, 'index': 455}",Unknown,steel
/test/app/views/core/CocoView.spec.js,Magic Number,"{'line': 77, 'column': 33, 'index': 2528}","it('shows a login button which opens the AuthModal', function() {
      const button = view.$el.find('.login-btn');
      expect(button.length).toBe(1);
      spyOn(view, 'openModalView').and.callFake(function(modal) {
        expect(modal instanceof AuthModal).toBe(true);
        return modal.stopListening();
      });
      button.click();
      return expect(view.openModalView).toHaveBeenCalled();
    })",steel
/test/app/views/core/CocoView.spec.js,Magic Number,"{'line': 88, 'column': 33, 'index': 2972}","it('shows a create account button which opens the CreateAccountModal', function() {
      const button = view.$el.find('#create-account-btn');
      expect(button.length).toBe(1);
      spyOn(view, 'openModalView').and.callFake(function(modal) {
        expect(modal instanceof CreateAccountModal).toBe(true);
        return modal.stopListening();
      });
      button.click();
      return expect(view.openModalView).toHaveBeenCalled();
    })",steel
/test/app/views/core/CocoView.spec.js,Magic Number,"{'line': 121, 'column': 33, 'index': 3937}","it('includes a logout button which logs out the account', function() {
      const button = view.$el.find('#logout-btn');
      expect(button.length).toBe(1);
      button.click();
      const request = jasmine.Ajax.requests.mostRecent();
      return expect(request.url).toBe('/auth/logout');
    })",steel
/test/app/views/core/CocoView.spec.js,Magic Number,"{'line': 137, 'column': 37, 'index': 4385}","it('includes one of the 404 images', function() {
      const img = view.$el.find('#not-found-img');
      return expect(img.length).toBe(1);
    })",steel
/test/app/views/core/AuthModal.spec.js,Conditional Test Logic,"{'line': 14, 'column': 4, 'index': 395}","beforeEach(function() {
    if (!window.features.chinaUx) {
      application.facebookHandler.fakeAPI();
      application.gplusHandler.fakeAPI();
    }
    modal = new AuthModal();
    return modal.render();
  })",steel
/test/app/views/core/AuthModal.spec.js,Magic Number,"{'line': 27, 'column': 54, 'index': 840}","it('opens the recover modal when you click the recover link', function() {
    spyOn(modal, 'openModalView');
    modal.$el.find('#link-to-recover').click();
    expect(modal.openModalView.calls.count()).toEqual(1);
    const args = modal.openModalView.calls.argsFor(0);
    return expect(args[0] instanceof RecoverModal).toBeTruthy();
  })",steel
/test/app/views/core/CreateAccountModal/teacher/SchoolInfoPanel.spec.js,Magic Number,"{'line': 25, 'column': 53, 'index': 1031}","it('converts nces data to strings', function() {
  const component = {
    $store: {
      state: { modal: _.cloneDeep(TeacherSignupStoreModule.state) },
      commit: jasmine.createSpy()
    },
    commitValues: SchoolInfoPanel.methods.commitValues,
    data: SchoolInfoPanel.data
  };
  _.assign(component, component.data(), {
    nces_district_schools: 20,
    nces_district_students: 524,
    nces_students: 203
  });
  component.commitValues();
  expect(component.$store.commit.calls.count()).toBe(1);
  return expect(component.$store.commit.calls.argsFor(0)).toDeepEqual([
    'modal/updateTrialRequestProperties',
    {
      city: """",
      country: """",
      district: """",
      nces_district: """",
      nces_district_id: """",
      nces_district_schools: ""20"",
      nces_district_students: '524',
      nces_id: """",
      nces_name: """",
      nces_phone: """",
      nces_students: ""203"",
      organization: """",
      state: """"
    }
  ]);
})",steel
/test/app/views/core/CreateAccountModal/teacher/NcesSearchInput.spec.js,Unknown Test,"{'column': 34, 'line': 8}","it('(demo)', function() {
  const component = new NcesSearchInput({
    data: {
      suggestions: [
        {
          _highlightResult: {
            name: { value: 'School' },
            district: { value: 'District' },
            city: { value: 'City' },
            state: { value: 'State' }
          }
        }
      ]
    }
  }).$mount();
  return jasmine.demoEl(component.$el);
})",steel
/test/app/views/account/IsraelSignupView.spec.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 954}","it('sets state.fatalError to ""missing-input"" if the proper query parameters are not provided', function() {
    let queryVariables = null;
    spyOn(me, 'isAnonymous').and.returnValue(true);
    spyOn(utils, 'getQueryVariables').and.callFake(() => queryVariables);

    // no inputs
    queryVariables = {};
    expect(new IsraelSignupView().state.get('fatalError')).toBe('missing-input');
    
    // id and email but email is not valid
    queryVariables = { email: 'notanemail', israelId: '...' };
    expect(new IsraelSignupView().state.get('fatalError')).toBe('invalid-email');

    // valid inputs
    queryVariables = { email: 'test@email.com', israelId: '...' };
    return expect(new IsraelSignupView().state.get('fatalError')).toBe(null);
  })",steel
/test/app/views/account/IsraelSignupView.spec.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 1147}","it('sets state.fatalError to ""missing-input"" if the proper query parameters are not provided', function() {
    let queryVariables = null;
    spyOn(me, 'isAnonymous').and.returnValue(true);
    spyOn(utils, 'getQueryVariables').and.callFake(() => queryVariables);

    // no inputs
    queryVariables = {};
    expect(new IsraelSignupView().state.get('fatalError')).toBe('missing-input');
    
    // id and email but email is not valid
    queryVariables = { email: 'notanemail', israelId: '...' };
    expect(new IsraelSignupView().state.get('fatalError')).toBe('invalid-email');

    // valid inputs
    queryVariables = { email: 'test@email.com', israelId: '...' };
    return expect(new IsraelSignupView().state.get('fatalError')).toBe(null);
  })",steel
/test/app/views/account/IsraelSignupView.spec.js,Duplicate Assert,"{'line': 31, 'column': 11, 'index': 1324}","it('sets state.fatalError to ""missing-input"" if the proper query parameters are not provided', function() {
    let queryVariables = null;
    spyOn(me, 'isAnonymous').and.returnValue(true);
    spyOn(utils, 'getQueryVariables').and.callFake(() => queryVariables);

    // no inputs
    queryVariables = {};
    expect(new IsraelSignupView().state.get('fatalError')).toBe('missing-input');
    
    // id and email but email is not valid
    queryVariables = { email: 'notanemail', israelId: '...' };
    expect(new IsraelSignupView().state.get('fatalError')).toBe('invalid-email');

    // valid inputs
    queryVariables = { email: 'test@email.com', israelId: '...' };
    return expect(new IsraelSignupView().state.get('fatalError')).toBe(null);
  })",steel
/test/app/vendorTests/lodash.spec.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 829}","it('treats arrays as atomic', function() {
    let a = { i: 0 };
    let b = { i: [1,2,3] };
    let res = _.merge(a, b);
    expect(_.isEqual(res, b)).toBeTruthy();

    a = { i: [5,4,3] };
    b = { i: [1,2,3] };
    res = _.merge(a, b);
    return expect(_.isEqual(res, b)).toBeTruthy();
  })",steel
/test/app/vendorTests/lodash.spec.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 829}","it('treats arrays as atomic', function() {
    let a = { i: 0 };
    let b = { i: [1,2,3] };
    let res = _.merge(a, b);
    expect(_.isEqual(res, b)).toBeTruthy();

    a = { i: [5,4,3] };
    b = { i: [1,2,3] };
    res = _.merge(a, b);
    return expect(_.isEqual(res, b)).toBeTruthy();
  })",steel
/test/app/vendorTests/lodash.spec.js,Duplicate Assert,"{'line': 30, 'column': 11, 'index': 954}","it('treats arrays as atomic', function() {
    let a = { i: 0 };
    let b = { i: [1,2,3] };
    let res = _.merge(a, b);
    expect(_.isEqual(res, b)).toBeTruthy();

    a = { i: [5,4,3] };
    b = { i: [1,2,3] };
    res = _.merge(a, b);
    return expect(_.isEqual(res, b)).toBeTruthy();
  })",steel
/test/app/vendorTests/lodash.spec.js,Duplicate Assert,"{'line': 30, 'column': 11, 'index': 954}","it('treats arrays as atomic', function() {
    let a = { i: 0 };
    let b = { i: [1,2,3] };
    let res = _.merge(a, b);
    expect(_.isEqual(res, b)).toBeTruthy();

    a = { i: [5,4,3] };
    b = { i: [1,2,3] };
    res = _.merge(a, b);
    return expect(_.isEqual(res, b)).toBeTruthy();
  })",steel
/test/app/models/User.spec.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 772}","it('level is calculated correctly', function () {
    me.clear()
    me.set('points', 0)
    expect(me.level()).toBe(1)

    me.set('points', 50)
    return expect(me.level()).toBe(User.levelFromExp(50))
  })",steel
/test/app/models/User.spec.js,Duplicate Assert,"{'line': 24, 'column': 11, 'index': 836}","it('level is calculated correctly', function () {
    me.clear()
    me.set('points', 0)
    expect(me.level()).toBe(1)

    me.set('points', 50)
    return expect(me.level()).toBe(User.levelFromExp(50))
  })",steel
/test/app/models/User.spec.js,Magic Number,"{'line': 11, 'column': 56, 'index': 432}","it('experience functions are correct', function () {
    expect(User.expForLevel(User.levelFromExp(0))).toBe(0)
    expect(User.levelFromExp(User.expForLevel(1))).toBe(1)
    expect(User.levelFromExp(User.expForLevel(10))).toBe(10)
    expect(User.expForLevel(1)).toBe(0)
    return expect(User.expForLevel(2)).toBeGreaterThan(User.expForLevel(1))
  })",steel
/test/app/models/User.spec.js,Magic Number,"{'line': 12, 'column': 56, 'index': 491}","it('experience functions are correct', function () {
    expect(User.expForLevel(User.levelFromExp(0))).toBe(0)
    expect(User.levelFromExp(User.expForLevel(1))).toBe(1)
    expect(User.levelFromExp(User.expForLevel(10))).toBe(10)
    expect(User.expForLevel(1)).toBe(0)
    return expect(User.expForLevel(2)).toBeGreaterThan(User.expForLevel(1))
  })",steel
/test/app/models/User.spec.js,Magic Number,"{'line': 13, 'column': 57, 'index': 551}","it('experience functions are correct', function () {
    expect(User.expForLevel(User.levelFromExp(0))).toBe(0)
    expect(User.levelFromExp(User.expForLevel(1))).toBe(1)
    expect(User.levelFromExp(User.expForLevel(10))).toBe(10)
    expect(User.expForLevel(1)).toBe(0)
    return expect(User.expForLevel(2)).toBeGreaterThan(User.expForLevel(1))
  })",steel
/test/app/models/User.spec.js,Magic Number,"{'line': 14, 'column': 37, 'index': 592}","it('experience functions are correct', function () {
    expect(User.expForLevel(User.levelFromExp(0))).toBe(0)
    expect(User.levelFromExp(User.expForLevel(1))).toBe(1)
    expect(User.levelFromExp(User.expForLevel(10))).toBe(10)
    expect(User.expForLevel(1)).toBe(0)
    return expect(User.expForLevel(2)).toBeGreaterThan(User.expForLevel(1))
  })",steel
/test/app/models/User.spec.js,Magic Number,"{'line': 21, 'column': 28, 'index': 796}","it('level is calculated correctly', function () {
    me.clear()
    me.set('points', 0)
    expect(me.level()).toBe(1)

    me.set('points', 50)
    return expect(me.level()).toBe(User.levelFromExp(50))
  })",steel
/test/app/models/SuperModel.spec.js,Conditional Test Logic,"{'line': 86, 'column': 8, 'index': 2880}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",steel
/test/app/models/SuperModel.spec.js,Conditional Test Logic,"{'line': 106, 'column': 8, 'index': 3663}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 817}","it('takes a jqxhr and tracks its progress', function(done) {
    const s = new SuperModel();
    const jqxhrA = $.get('/db/a');
    const reqA = jasmine.Ajax.requests.mostRecent();
    const jqxhrB = $.get('/db/b');
    const reqB = jasmine.Ajax.requests.mostRecent();
    s.trackRequest(jqxhrA, 1);
    s.trackRequest(jqxhrB, 3);
    expect(s.progress).toBe(0);
    reqA.respondWith({status: 200, responseText: '[]'});
    return _.defer(function() {
      expect(s.progress).toBe(0.25);
      reqB.respondWith({status: 200, responseText: '[]'});
      return _.defer(function() {
        expect(s.progress).toBe(1);
        return done();
      });
    });
  })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 24, 'column': 6, 'index': 940}","it('takes a jqxhr and tracks its progress', function(done) {
    const s = new SuperModel();
    const jqxhrA = $.get('/db/a');
    const reqA = jasmine.Ajax.requests.mostRecent();
    const jqxhrB = $.get('/db/b');
    const reqB = jasmine.Ajax.requests.mostRecent();
    s.trackRequest(jqxhrA, 1);
    s.trackRequest(jqxhrB, 3);
    expect(s.progress).toBe(0);
    reqA.respondWith({status: 200, responseText: '[]'});
    return _.defer(function() {
      expect(s.progress).toBe(0.25);
      reqB.respondWith({status: 200, responseText: '[]'});
      return _.defer(function() {
        expect(s.progress).toBe(1);
        return done();
      });
    });
  })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 27, 'column': 8, 'index': 1072}","it('takes a jqxhr and tracks its progress', function(done) {
    const s = new SuperModel();
    const jqxhrA = $.get('/db/a');
    const reqA = jasmine.Ajax.requests.mostRecent();
    const jqxhrB = $.get('/db/b');
    const reqB = jasmine.Ajax.requests.mostRecent();
    s.trackRequest(jqxhrA, 1);
    s.trackRequest(jqxhrB, 3);
    expect(s.progress).toBe(0);
    reqA.respondWith({status: 200, responseText: '[]'});
    return _.defer(function() {
      expect(s.progress).toBe(0.25);
      reqB.respondWith({status: 200, responseText: '[]'});
      return _.defer(function() {
        expect(s.progress).toBe(1);
        return done();
      });
    });
  })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 43, 'column': 6, 'index': 1553}","it('is based on resource completion and value', function(done) {
      const s = new SuperModel();
      const r1 = s.addSomethingResource('???', 2);
      const r2 = s.addSomethingResource('???', 3);
      expect(s.progress).toBe(0);
      r1.markLoaded();

      // progress updates are deferred so defer more
      return _.defer(function() {
        expect(s.progress).toBe(0.4);
        r2.markLoaded();
        return _.defer(function() {
          expect(s.progress).toBe(1);
          return done();
        });
      });
    })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 48, 'column': 8, 'index': 1700}","it('is based on resource completion and value', function(done) {
      const s = new SuperModel();
      const r1 = s.addSomethingResource('???', 2);
      const r2 = s.addSomethingResource('???', 3);
      expect(s.progress).toBe(0);
      r1.markLoaded();

      // progress updates are deferred so defer more
      return _.defer(function() {
        expect(s.progress).toBe(0.4);
        r2.markLoaded();
        return _.defer(function() {
          expect(s.progress).toBe(1);
          return done();
        });
      });
    })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 51, 'column': 10, 'index': 1801}","it('is based on resource completion and value', function(done) {
      const s = new SuperModel();
      const r1 = s.addSomethingResource('???', 2);
      const r2 = s.addSomethingResource('???', 3);
      expect(s.progress).toBe(0);
      r1.markLoaded();

      // progress updates are deferred so defer more
      return _.defer(function() {
        expect(s.progress).toBe(0.4);
        r2.markLoaded();
        return _.defer(function() {
          expect(s.progress).toBe(1);
          return done();
        });
      });
    })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 87, 'column': 10, 'index': 2948}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 88, 'column': 10, 'index': 2988}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 89, 'column': 10, 'index': 3054}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 95, 'column': 8, 'index': 3249}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 96, 'column': 8, 'index': 3304}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 97, 'column': 15, 'index': 3371}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 107, 'column': 10, 'index': 3731}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 107, 'column': 10, 'index': 3731}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 108, 'column': 10, 'index': 3771}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 109, 'column': 10, 'index': 3837}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 115, 'column': 8, 'index': 4037}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 116, 'column': 8, 'index': 4079}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 116, 'column': 8, 'index': 4079}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 121, 'column': 10, 'index': 4339}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 122, 'column': 10, 'index': 4382}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 122, 'column': 10, 'index': 4382}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 125, 'column': 10, 'index': 4486}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 125, 'column': 10, 'index': 4486}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 126, 'column': 10, 'index': 4543}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 126, 'column': 10, 'index': 4543}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 128, 'column': 10, 'index': 4644}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 128, 'column': 10, 'index': 4644}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 129, 'column': 10, 'index': 4701}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Duplicate Assert,"{'line': 129, 'column': 10, 'index': 4701}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 21, 'column': 28, 'index': 841}","it('takes a jqxhr and tracks its progress', function(done) {
    const s = new SuperModel();
    const jqxhrA = $.get('/db/a');
    const reqA = jasmine.Ajax.requests.mostRecent();
    const jqxhrB = $.get('/db/b');
    const reqB = jasmine.Ajax.requests.mostRecent();
    s.trackRequest(jqxhrA, 1);
    s.trackRequest(jqxhrB, 3);
    expect(s.progress).toBe(0);
    reqA.respondWith({status: 200, responseText: '[]'});
    return _.defer(function() {
      expect(s.progress).toBe(0.25);
      reqB.respondWith({status: 200, responseText: '[]'});
      return _.defer(function() {
        expect(s.progress).toBe(1);
        return done();
      });
    });
  })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 24, 'column': 30, 'index': 964}","it('takes a jqxhr and tracks its progress', function(done) {
    const s = new SuperModel();
    const jqxhrA = $.get('/db/a');
    const reqA = jasmine.Ajax.requests.mostRecent();
    const jqxhrB = $.get('/db/b');
    const reqB = jasmine.Ajax.requests.mostRecent();
    s.trackRequest(jqxhrA, 1);
    s.trackRequest(jqxhrB, 3);
    expect(s.progress).toBe(0);
    reqA.respondWith({status: 200, responseText: '[]'});
    return _.defer(function() {
      expect(s.progress).toBe(0.25);
      reqB.respondWith({status: 200, responseText: '[]'});
      return _.defer(function() {
        expect(s.progress).toBe(1);
        return done();
      });
    });
  })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 27, 'column': 32, 'index': 1096}","it('takes a jqxhr and tracks its progress', function(done) {
    const s = new SuperModel();
    const jqxhrA = $.get('/db/a');
    const reqA = jasmine.Ajax.requests.mostRecent();
    const jqxhrB = $.get('/db/b');
    const reqB = jasmine.Ajax.requests.mostRecent();
    s.trackRequest(jqxhrA, 1);
    s.trackRequest(jqxhrB, 3);
    expect(s.progress).toBe(0);
    reqA.respondWith({status: 200, responseText: '[]'});
    return _.defer(function() {
      expect(s.progress).toBe(0.25);
      reqB.respondWith({status: 200, responseText: '[]'});
      return _.defer(function() {
        expect(s.progress).toBe(1);
        return done();
      });
    });
  })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 43, 'column': 30, 'index': 1577}","it('is based on resource completion and value', function(done) {
      const s = new SuperModel();
      const r1 = s.addSomethingResource('???', 2);
      const r2 = s.addSomethingResource('???', 3);
      expect(s.progress).toBe(0);
      r1.markLoaded();

      // progress updates are deferred so defer more
      return _.defer(function() {
        expect(s.progress).toBe(0.4);
        r2.markLoaded();
        return _.defer(function() {
          expect(s.progress).toBe(1);
          return done();
        });
      });
    })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 48, 'column': 32, 'index': 1724}","it('is based on resource completion and value', function(done) {
      const s = new SuperModel();
      const r1 = s.addSomethingResource('???', 2);
      const r2 = s.addSomethingResource('???', 3);
      expect(s.progress).toBe(0);
      r1.markLoaded();

      // progress updates are deferred so defer more
      return _.defer(function() {
        expect(s.progress).toBe(0.4);
        r2.markLoaded();
        return _.defer(function() {
          expect(s.progress).toBe(1);
          return done();
        });
      });
    })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 51, 'column': 34, 'index': 1825}","it('is based on resource completion and value', function(done) {
      const s = new SuperModel();
      const r1 = s.addSomethingResource('???', 2);
      const r2 = s.addSomethingResource('???', 3);
      expect(s.progress).toBe(0);
      r1.markLoaded();

      // progress updates are deferred so defer more
      return _.defer(function() {
        expect(s.progress).toBe(0.4);
        r2.markLoaded();
        return _.defer(function() {
          expect(s.progress).toBe(1);
          return done();
        });
      });
    })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 95, 'column': 51, 'index': 3292}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 96, 'column': 56, 'index': 3352}","it('automatically retries stalled requests', function() {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;

        // Retry request 5 times
        for (let timesTried = 1; timesTried <= 5; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // And then stop retrying
        expect(s.resources[1].loadsAttempted).toBe(5);
        expect(jasmine.Ajax.requests.all().length).toBe(5);
        return expect(s.failed).toBe(true);
      })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 125, 'column': 53, 'index': 4529}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 126, 'column': 58, 'index': 4591}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 128, 'column': 53, 'index': 4687}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/SuperModel.spec.js,Magic Number,"{'line': 129, 'column': 58, 'index': 4749}","it('stops retrying once the model loads', function(done) {
        const s = new SuperModel();
        const m = new User({_id: '12345'});
        s.loadModel(m);
        let timeUntilRetry = 5000;
        // Retry request 2 times
        for (let timesTried = 1; timesTried <= 2; timesTried++) {
          expect(s.failed).toBeFalsy();
          expect(s.resources[1].loadsAttempted).toBe(timesTried);
          expect(jasmine.Ajax.requests.all().length).toBe(timesTried);
          jasmine.clock().tick(timeUntilRetry);
          timeUntilRetry *= 1.5;
        }

        // Respond to the third reqest
        expect(s.finished()).toBeFalsy();
        expect(s.failed).toBeFalsy();
        const request = jasmine.Ajax.requests.mostRecent();
        request.respondWith({status: 200, responseText: JSON.stringify(factories.makeUser({ _id: '12345' }).attributes)});

        return _.defer(function() {
          expect(s.finished()).toBe(true);
          expect(s.failed).toBeFalsy();

          // It shouldn't send any more requests after loading
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          jasmine.clock().tick(60000);
          expect(s.resources[1].loadsAttempted).toBe(3);
          expect(jasmine.Ajax.requests.all().length).toBe(3);
          return done();
        });
      })",steel
/test/app/models/CourseInstance.spec.js,Magic Number,"{'line': 17, 'column': 39, 'index': 618}","it('returns a jqxhr', function() {
    const res = this.courseInstance.addMember('1234');
    return expect(res.readyState).toBe(1);
  })",steel
/test/app/models/CourseInstance.spec.js,Magic Number,"{'line': 22, 'column': 39, 'index': 808}","it('returns a jqxhr', function() {
    const res = this.courseInstance.addMembers(['1234']);
    return expect(res.readyState).toBe(1);
  })",steel
/test/app/models/CourseInstance.spec.js,Magic Number,"{'line': 27, 'column': 39, 'index': 1006}","it('returns a jqxhr', function() {
    const res = this.courseInstance.removeMember('1234');
    return expect(res.readyState).toBe(1);
  })",steel
/test/app/models/CocoModel.spec.js,Conditional Test Logic,"{'line': 159, 'column': 6, 'index': 5751}","it('achievements are polled upon saving a model', function(done) {
    //spyOn(CocoModel, 'pollAchievements')
    Backbone.Mediator.subscribe('achievements:new', function(collection) {
      Backbone.Mediator.unsubscribe('achievements:new');
      expect(collection.constructor.name).toBe('NewAchievementCollection');
      return done();
    });

    const b = new BlandClass({});
    const res = b.save();
    let request = jasmine.Ajax.requests.mostRecent();
    request.respondWith({status: 200, responseText: '{}'});

    const collection = [];
    const model = {
      _id: ""5390f7637b4d6f2a074a7bb4"",
      achievement: ""537ce4855c91b8d1dda7fda8""
    };
    collection.push(model);

    return utils.keepDoingUntil(function(ready) {
      request = jasmine.Ajax.requests.mostRecent();
      const achievementURLMatch = (/.*achievements\?notified=false$/).exec(request.url);
      if (achievementURLMatch) {
        ready(true);
      } else { return ready(false); }

      request.respondWith({status: 200, responseText: JSON.stringify(collection)});

      return utils.keepDoingUntil(function(ready) {
        request = jasmine.Ajax.requests.mostRecent();
        const userURLMatch = (/^\/db\/user\/[a-zA-Z0-9]*$/).exec(request.url);
        if (userURLMatch) {
          ready(true);
        } else { return ready(false); }

        return request.respondWith({status:200, responseText: JSON.stringify(me)});});});
})",steel
/test/app/models/CocoModel.spec.js,Conditional Test Logic,"{'line': 168, 'column': 8, 'index': 6116}","it('achievements are polled upon saving a model', function(done) {
    //spyOn(CocoModel, 'pollAchievements')
    Backbone.Mediator.subscribe('achievements:new', function(collection) {
      Backbone.Mediator.unsubscribe('achievements:new');
      expect(collection.constructor.name).toBe('NewAchievementCollection');
      return done();
    });

    const b = new BlandClass({});
    const res = b.save();
    let request = jasmine.Ajax.requests.mostRecent();
    request.respondWith({status: 200, responseText: '{}'});

    const collection = [];
    const model = {
      _id: ""5390f7637b4d6f2a074a7bb4"",
      achievement: ""537ce4855c91b8d1dda7fda8""
    };
    collection.push(model);

    return utils.keepDoingUntil(function(ready) {
      request = jasmine.Ajax.requests.mostRecent();
      const achievementURLMatch = (/.*achievements\?notified=false$/).exec(request.url);
      if (achievementURLMatch) {
        ready(true);
      } else { return ready(false); }

      request.respondWith({status: 200, responseText: JSON.stringify(collection)});

      return utils.keepDoingUntil(function(ready) {
        request = jasmine.Ajax.requests.mostRecent();
        const userURLMatch = (/^\/db\/user\/[a-zA-Z0-9]*$/).exec(request.url);
        if (userURLMatch) {
          ready(true);
        } else { return ready(false); }

        return request.respondWith({status:200, responseText: JSON.stringify(me)});});});
})",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 43, 'column': 6, 'index': 1491}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 43, 'column': 6, 'index': 1491}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 45, 'column': 6, 'index': 1576}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 45, 'column': 6, 'index': 1576}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 47, 'column': 6, 'index': 1651}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 49, 'column': 6, 'index': 1741}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 49, 'column': 6, 'index': 1741}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 51, 'column': 6, 'index': 1817}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 51, 'column': 6, 'index': 1817}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/CocoModel.spec.js,Duplicate Assert,"{'line': 53, 'column': 13, 'index': 1916}","it('can update its projection', function() {
      const baseURL = '/db/bland/test?filter-creator=Mojambo&project=number,object&ignore-evil=false';
      const unprojectedURL = baseURL.replace(/&project=number,object/, '');
      const b = new BlandClass({});
      b.setURL(baseURL);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number', 'object']);
      expect(b.getURL()).toBe(baseURL);
      b.setProjection(['number']);
      expect(b.getURL()).toBe(baseURL.replace(/,object/, ''));
      b.setProjection([]);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(null);
      expect(b.getURL()).toBe(unprojectedURL);
      b.setProjection(['object', 'number']);
      return expect(b.getURL()).toBe(unprojectedURL + '&project=object,number');
    })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 5, 'column': 2, 'index': 160}","describe('isStudentOnLockedCourse', () => {
  if (!isOzaria) return  // This is specific to the Ozaria level locking

  it('no lock is always false', () => {
    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedCourse({
        studentLockMap: undefined
      },
      'StudentIdExample',
      courseId)).toEqual(false)
    }
  })

  it('student has lock on that course is always locked', () => {
    const studentId = 'StudentIdExample'
    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedCourse({
        studentLockMap: {
          [studentId]: {
            courseId
          }
        }
      },
      'StudentIdExample',
      courseId)).toEqual(true)
    }
  })

  it('course locked before returns locked', () => {
    const studentId = 'StudentIdExample'
    expect(ClassroomLib.isStudentOnLockedCourse({
      studentLockMap: {
        [studentId]: {
          courseId: courseIDs.CHAPTER_TWO
        }
      }
    },
    'StudentIdExample',
    courseIDs.CHAPTER_THREE)).toEqual(true)
  })

  it('later locked course return unlocked', () => {
    const studentId = 'StudentIdExample'
    expect(ClassroomLib.isStudentOnLockedCourse({
      studentLockMap: {
        [studentId]: {
          courseId: courseIDs.CHAPTER_TWO
        }
      }
    },
    'StudentIdExample',
    courseIDs.CHAPTER_ONE)).toEqual(false)
  })
})",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 8, 'column': 4, 'index': 276}","it('no lock is always false', () => {
    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedCourse({
        studentLockMap: undefined
      },
      'StudentIdExample',
      courseId)).toEqual(false)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 19, 'column': 4, 'index': 602}","it('student has lock on that course is always locked', () => {
    const studentId = 'StudentIdExample'
    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedCourse({
        studentLockMap: {
          [studentId]: {
            courseId
          }
        }
      },
      'StudentIdExample',
      courseId)).toEqual(true)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 60, 'column': 2, 'index': 1586}","describe('isStudentOnLockedLevel', () => {
  if (!isOzaria) return  // This is specific to the Ozaria level locking

  it('no lock is always false', () => {
    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: undefined
      },
      'StudentIdExample',
      courseId,
      'levelOriginal')).toEqual(false)
    }
  })

  it('same course and same level original', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, levelOriginal)).toEqual(true)
    }
  })

  it('same course and after locked level', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, 'original3')).toEqual(true)
    }
  })

  it('same course and before locked level', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, 'original1')).toEqual(false)
    }
  })

  it('same course and corrupt missing level original', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId,
            levelOriginal: 'CORRUPT LEVEL ORIGINAL LOCKED'
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, levelOriginal)).toEqual(false)
    }
  })

  it('same course with only course lock is locked', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, levelOriginal)).toEqual(true)
    }

    for (const original of ['original1', 'original2', 'original3']) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId: courseIDs.CHAPTER_ONE
          }
        },
        courses: [{
          _id: courseIDs.CHAPTER_ONE,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseIDs.CHAPTER_ONE, original)).toEqual(true)
    }
  })

  it('level is always unlocked if lock is in an earlier course', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const original of ['original1', 'original2', 'original3']) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId: courseIDs.CHAPTER_TWO,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseIDs.CHAPTER_THREE,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseIDs.CHAPTER_ONE, original)).toEqual(false)
    }
  })

  it('level is always locked if lock is in an earlier course', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const original of ['original1', 'original2', 'original3']) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId: courseIDs.CHAPTER_TWO,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseIDs.CHAPTER_THREE,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseIDs.CHAPTER_THREE, original)).toEqual(true)
    }
  })
})",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 63, 'column': 4, 'index': 1702}","it('no lock is always false', () => {
    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: undefined
      },
      'StudentIdExample',
      courseId,
      'levelOriginal')).toEqual(false)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 77, 'column': 4, 'index': 2076}","it('same course and same level original', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, levelOriginal)).toEqual(true)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 103, 'column': 4, 'index': 2740}","it('same course and after locked level', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, 'original3')).toEqual(true)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 129, 'column': 4, 'index': 3403}","it('same course and before locked level', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, 'original1')).toEqual(false)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 155, 'column': 4, 'index': 4078}","it('same course and corrupt missing level original', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId,
            levelOriginal: 'CORRUPT LEVEL ORIGINAL LOCKED'
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, levelOriginal)).toEqual(false)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 181, 'column': 4, 'index': 4770}","it('same course with only course lock is locked', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, levelOriginal)).toEqual(true)
    }

    for (const original of ['original1', 'original2', 'original3']) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId: courseIDs.CHAPTER_ONE
          }
        },
        courses: [{
          _id: courseIDs.CHAPTER_ONE,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseIDs.CHAPTER_ONE, original)).toEqual(true)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 201, 'column': 4, 'index': 5256}","it('same course with only course lock is locked', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const courseId of Object.values(courseIDs)) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId
          }
        },
        courses: [{
          _id: courseId,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseId, levelOriginal)).toEqual(true)
    }

    for (const original of ['original1', 'original2', 'original3']) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId: courseIDs.CHAPTER_ONE
          }
        },
        courses: [{
          _id: courseIDs.CHAPTER_ONE,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseIDs.CHAPTER_ONE, original)).toEqual(true)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 226, 'column': 4, 'index': 5959}","it('level is always unlocked if lock is in an earlier course', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const original of ['original1', 'original2', 'original3']) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId: courseIDs.CHAPTER_TWO,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseIDs.CHAPTER_THREE,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseIDs.CHAPTER_ONE, original)).toEqual(false)
    }
  })",steel
/test/app/models/ClassroomLib.spec.js,Conditional Test Logic,"{'line': 252, 'column': 4, 'index': 6705}","it('level is always locked if lock is in an earlier course', () => {
    const studentId = 'StudentIdExample'
    const levelOriginal = 'original2'

    for (const original of ['original1', 'original2', 'original3']) {
      expect(ClassroomLib.isStudentOnLockedLevel({
        studentLockMap: {
          [studentId]: {
            courseId: courseIDs.CHAPTER_TWO,
            levelOriginal: levelOriginal
          }
        },
        courses: [{
          _id: courseIDs.CHAPTER_THREE,
          levels: [
            { original: 'original1' },
            { original: levelOriginal },
            { original: 'original3' }
          ]
        }]
      },
      studentId,
      courseIDs.CHAPTER_THREE, original)).toEqual(true)
    }
  })",steel
/test/app/models/Cinematic.spec.js,Conditional Test Logic,"{'line': 306, 'column': 6, 'index': 10539}","it('returns undefined if the left thangType doesn\'t have type', () => {
      for (const testData of data) {
        expect(selector(testData)).toBeUndefined()
      }
    })",steel
/test/app/models/Cinematic.spec.js,Global Variable,"{'line': 314, 'column': 0, 'index': 10689}",Unknown,steel
/test/app/models/Cinematic.spec.js,Global Variable,"{'line': 408, 'column': 0, 'index': 12330}",Unknown,steel
/test/app/models/Cinematic.spec.js,Magic Number,"{'line': 114, 'column': 29, 'index': 4137}","it('getClearBackgroundObject', () => {
      const result = getClearBackgroundObject(shotFixture1.dialogNodes[0])
      expect(result).toEqual(7331)

      const result2 = getClearBackgroundObject(shotFixture2.dialogNodes[0])
      expect(result2).toBeUndefined()
    })",steel
/test/app/models/Cinematic.spec.js,Magic Number,"{'line': 130, 'column': 29, 'index': 4757}","it('getBackgroundObjectDelay', () => {
      const result = getBackgroundObjectDelay(shotFixture1.dialogNodes[0])
      expect(result).toEqual(1337)

      const result2 = getBackgroundObjectDelay(shotFixture2.dialogNodes[0])
      expect(result2).toBeUndefined()
    })",steel
/test/app/models/Cinematic.spec.js,Magic Number,"{'line': 207, 'column': 29, 'index': 7108}","it('getTextAnimationLength', () => {
      const result = getTextAnimationLength(shotFixture1.dialogNodes[1])
      expect(result).toEqual(42)

      const result2 = getTextAnimationLength(shotFixture2.dialogNodes[0])
      expect(result2).toBeUndefined()
    })",steel
/test/app/models/Campaign.spec.js,Magic Number,"{'line': 37, 'column': 46, 'index': 1704}","it('returns the level number taking into account practice levels', function() {
    const campaign = new Campaign({ levels: getLevelNumberData });
    expect(campaign.getLevelNumber('a')).toBe(1);
    expect(campaign.getLevelNumber('b')).toBe(2);
    expect(campaign.getLevelNumber('c')).toBe('2a');
    expect(campaign.getLevelNumber('d')).toBe('2b');
    return expect(campaign.getLevelNumber('e')).toBe(3);
  })",steel
/test/app/models/Campaign.spec.js,Magic Number,"{'line': 38, 'column': 46, 'index': 1754}","it('returns the level number taking into account practice levels', function() {
    const campaign = new Campaign({ levels: getLevelNumberData });
    expect(campaign.getLevelNumber('a')).toBe(1);
    expect(campaign.getLevelNumber('b')).toBe(2);
    expect(campaign.getLevelNumber('c')).toBe('2a');
    expect(campaign.getLevelNumber('d')).toBe('2b');
    return expect(campaign.getLevelNumber('e')).toBe(3);
  })",steel
/test/app/models/Campaign.spec.js,Magic Number,"{'line': 41, 'column': 53, 'index': 1917}","it('returns the level number taking into account practice levels', function() {
    const campaign = new Campaign({ levels: getLevelNumberData });
    expect(campaign.getLevelNumber('a')).toBe(1);
    expect(campaign.getLevelNumber('b')).toBe(2);
    expect(campaign.getLevelNumber('c')).toBe('2a');
    expect(campaign.getLevelNumber('d')).toBe('2b');
    return expect(campaign.getLevelNumber('e')).toBe(3);
  })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1018, 'column': 2, 'index': 33173}",Unknown,steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1022, 'column': 2, 'index': 33228}",Unknown,steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1026, 'column': 2, 'index': 33283}",Unknown,steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1027, 'column': 4, 'index': 33318}",Unknown,steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1028, 'column': 6, 'index': 33355}",Unknown,steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1145, 'column': 4, 'index': 39813}","describe('translateJS can handle full solutions', () => {
    const unsupported = [
      // Permanent (must write these solutions manually)
      ['lua', 'snowdrops'], // manual rewriting needed for off-by-one error with 1-indexed arrays for row/col in the map
      ['cpp', 'snowdrops'], // row/col literals need to be manually rewritten to x/y for our {x, y} Vector hack
      ['java', 'snowdrops'], // row/col literals need to be manually rewritten to [row, col] arrays, also indexed with [0] and [1]
      // Temporary (should fix the code generation to be smarter)
      ['java', 'libraryTactician'], // Need to auto-detect self-defined function return type
      ['java', 'aFineMint'], // Need to not strip out each hoisted function's start comments
      ['cpp', 'aFineMint'] // Need to not strip out each hoisted function's start comments
    ]
    const targetLanguage = ''
    const targetLevel = ''

    for (const language in solutionsByLanguage) {
      const solutions = solutionsByLanguage[language]
      if (language !== 'javascript') {
        describe(`in ${language}`, () => {
          for (const level in solutions) {
            const code = solutions[level]
            let f
            if (_.find(unsupported, ([lang, lev]) => lang === language && lev === level)) {
              f = xit
            } else if (!targetLevel && !targetLanguage) {
              f = it
            } else if ((targetLevel && level === targetLevel) || (targetLanguage && language === targetLanguage)) {
              f = fit
            } else {
              f = it
            }
            f(`properly translates ${level}`, () => {
              const js = solutionsByLanguage.javascript[level]
              const translated = translateUtils.translateJS(js, language, true)
              const editDistance = levenshteinDistance(translated, code)
              expect(`\n${translated}`).toEqual(`\n${code}`)
              expect(editDistance).toEqual(0)
            })
          }
        })
      }
    }
  })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1147, 'column': 6, 'index': 39919}","describe('translateJS can handle full solutions', () => {
    const unsupported = [
      // Permanent (must write these solutions manually)
      ['lua', 'snowdrops'], // manual rewriting needed for off-by-one error with 1-indexed arrays for row/col in the map
      ['cpp', 'snowdrops'], // row/col literals need to be manually rewritten to x/y for our {x, y} Vector hack
      ['java', 'snowdrops'], // row/col literals need to be manually rewritten to [row, col] arrays, also indexed with [0] and [1]
      // Temporary (should fix the code generation to be smarter)
      ['java', 'libraryTactician'], // Need to auto-detect self-defined function return type
      ['java', 'aFineMint'], // Need to not strip out each hoisted function's start comments
      ['cpp', 'aFineMint'] // Need to not strip out each hoisted function's start comments
    ]
    const targetLanguage = ''
    const targetLevel = ''

    for (const language in solutionsByLanguage) {
      const solutions = solutionsByLanguage[language]
      if (language !== 'javascript') {
        describe(`in ${language}`, () => {
          for (const level in solutions) {
            const code = solutions[level]
            let f
            if (_.find(unsupported, ([lang, lev]) => lang === language && lev === level)) {
              f = xit
            } else if (!targetLevel && !targetLanguage) {
              f = it
            } else if ((targetLevel && level === targetLevel) || (targetLanguage && language === targetLanguage)) {
              f = fit
            } else {
              f = it
            }
            f(`properly translates ${level}`, () => {
              const js = solutionsByLanguage.javascript[level]
              const translated = translateUtils.translateJS(js, language, true)
              const editDistance = levenshteinDistance(translated, code)
              expect(`\n${translated}`).toEqual(`\n${code}`)
              expect(editDistance).toEqual(0)
            })
          }
        })
      }
    }
  })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1149, 'column': 10, 'index': 40005}","describe(`in ${language}`, () => {
          for (const level in solutions) {
            const code = solutions[level]
            let f
            if (_.find(unsupported, ([lang, lev]) => lang === language && lev === level)) {
              f = xit
            } else if (!targetLevel && !targetLanguage) {
              f = it
            } else if ((targetLevel && level === targetLevel) || (targetLanguage && language === targetLanguage)) {
              f = fit
            } else {
              f = it
            }
            f(`properly translates ${level}`, () => {
              const js = solutionsByLanguage.javascript[level]
              const translated = translateUtils.translateJS(js, language, true)
              const editDistance = levenshteinDistance(translated, code)
              expect(`\n${translated}`).toEqual(`\n${code}`)
              expect(editDistance).toEqual(0)
            })
          }
        })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1152, 'column': 12, 'index': 40110}","describe(`in ${language}`, () => {
          for (const level in solutions) {
            const code = solutions[level]
            let f
            if (_.find(unsupported, ([lang, lev]) => lang === language && lev === level)) {
              f = xit
            } else if (!targetLevel && !targetLanguage) {
              f = it
            } else if ((targetLevel && level === targetLevel) || (targetLanguage && language === targetLanguage)) {
              f = fit
            } else {
              f = it
            }
            f(`properly translates ${level}`, () => {
              const js = solutionsByLanguage.javascript[level]
              const translated = translateUtils.translateJS(js, language, true)
              const editDistance = levenshteinDistance(translated, code)
              expect(`\n${translated}`).toEqual(`\n${code}`)
              expect(editDistance).toEqual(0)
            })
          }
        })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1154, 'column': 19, 'index': 40231}","describe(`in ${language}`, () => {
          for (const level in solutions) {
            const code = solutions[level]
            let f
            if (_.find(unsupported, ([lang, lev]) => lang === language && lev === level)) {
              f = xit
            } else if (!targetLevel && !targetLanguage) {
              f = it
            } else if ((targetLevel && level === targetLevel) || (targetLanguage && language === targetLanguage)) {
              f = fit
            } else {
              f = it
            }
            f(`properly translates ${level}`, () => {
              const js = solutionsByLanguage.javascript[level]
              const translated = translateUtils.translateJS(js, language, true)
              const editDistance = levenshteinDistance(translated, code)
              expect(`\n${translated}`).toEqual(`\n${code}`)
              expect(editDistance).toEqual(0)
            })
          }
        })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1156, 'column': 19, 'index': 40310}","describe(`in ${language}`, () => {
          for (const level in solutions) {
            const code = solutions[level]
            let f
            if (_.find(unsupported, ([lang, lev]) => lang === language && lev === level)) {
              f = xit
            } else if (!targetLevel && !targetLanguage) {
              f = it
            } else if ((targetLevel && level === targetLevel) || (targetLanguage && language === targetLanguage)) {
              f = fit
            } else {
              f = it
            }
            f(`properly translates ${level}`, () => {
              const js = solutionsByLanguage.javascript[level]
              const translated = translateUtils.translateJS(js, language, true)
              const editDistance = levenshteinDistance(translated, code)
              expect(`\n${translated}`).toEqual(`\n${code}`)
              expect(editDistance).toEqual(0)
            })
          }
        })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1307, 'column': 4, 'index': 42243}","describe('translateJS can handle var, let, and const', () => {
    const sourceByLanguage = {
      javascript: `\
var a;
var b = 1;
var c = 2, d = 3;
a = 5;

let e;
let f = 1;
let g = 2, h = 3;
e = 5;

const l = 1;
const m = 2, n = 3;

var i = 1;
let j = 2;
const k = 3;

var x = 4;
let y = 5;
const z = 6;
`,
      cpp: `\
auto a;
auto b = 1;
auto c = 2, auto d = 3;
a = 5;

auto e;
auto f = 1;
auto g = 2, auto h = 3;
e = 5;

const auto l = 1;
const auto m = 2, const auto n = 3;

int i = 1;
int j = 2;
const int k = 3;

float x = 4;
float y = 5;
const float z = 6;
`,
      java: `\
var b = 1;
var c = 2, var d = 3;
var a = 5;

var f = 1;
var g = 2, var h = 3;
var e = 5;

final var l = 1;
final var m = 2, final var n = 3;

int i = 1;
int j = 2;
final int k = 3;

float x = 4;
float y = 5;
final float z = 6;
`,
      python: `\
b = 1
c = 2, d = 3
a = 5

f = 1
g = 2, h = 3
e = 5

l = 1
m = 2, n = 3

i = 1
j = 2
k = 3

x = 4
y = 5
z = 6
`,
      coffeescript: `\
b = 1
c = 2, d = 3
a = 5

f = 1
g = 2, h = 3
e = 5

l = 1
m = 2, n = 3

i = 1
j = 2
k = 3

x = 4
y = 5
z = 6
`,
      lua: `\
local a
local b = 1
local c = 2
local d = 3
a = 5

local e
local f = 1
local g = 2
local h = 3
e = 5

local l = 1
local m = 2
local n = 3

local i = 1
local j = 2
local k = 3

local x = 4
local y = 5
local z = 6
`,
    }

    for (const [language, targetSource] of Object.entries(sourceByLanguage)) {
      // At time of test writing, we don't yet properly handle:
      // 1. java/cpp/lua multiple variable definitions on one line
      // 2. java not able to use `var a` for uninitialized variables
      const func = ['python', 'coffeescript', 'javascript'].includes(language) ? it : xit
      func(`in ${language}`, () => {
        const translated = translateUtils.translateJS(sourceByLanguage.javascript, language, false)
        const editDistance = levenshteinDistance(translated, targetSource)
        if (translated !== targetSource) {
          console.log(`\n${translated}`)
          console.log(`\n${targetSource}`)
        }
        expect(translated).toBe(targetSource)
        expect(editDistance).toEqual(0)
      })
    }
  })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1315, 'column': 8, 'index': 42828}","describe('translateJS can handle var, let, and const', () => {
    const sourceByLanguage = {
      javascript: `\
var a;
var b = 1;
var c = 2, d = 3;
a = 5;

let e;
let f = 1;
let g = 2, h = 3;
e = 5;

const l = 1;
const m = 2, n = 3;

var i = 1;
let j = 2;
const k = 3;

var x = 4;
let y = 5;
const z = 6;
`,
      cpp: `\
auto a;
auto b = 1;
auto c = 2, auto d = 3;
a = 5;

auto e;
auto f = 1;
auto g = 2, auto h = 3;
e = 5;

const auto l = 1;
const auto m = 2, const auto n = 3;

int i = 1;
int j = 2;
const int k = 3;

float x = 4;
float y = 5;
const float z = 6;
`,
      java: `\
var b = 1;
var c = 2, var d = 3;
var a = 5;

var f = 1;
var g = 2, var h = 3;
var e = 5;

final var l = 1;
final var m = 2, final var n = 3;

int i = 1;
int j = 2;
final int k = 3;

float x = 4;
float y = 5;
final float z = 6;
`,
      python: `\
b = 1
c = 2, d = 3
a = 5

f = 1
g = 2, h = 3
e = 5

l = 1
m = 2, n = 3

i = 1
j = 2
k = 3

x = 4
y = 5
z = 6
`,
      coffeescript: `\
b = 1
c = 2, d = 3
a = 5

f = 1
g = 2, h = 3
e = 5

l = 1
m = 2, n = 3

i = 1
j = 2
k = 3

x = 4
y = 5
z = 6
`,
      lua: `\
local a
local b = 1
local c = 2
local d = 3
a = 5

local e
local f = 1
local g = 2
local h = 3
e = 5

local l = 1
local m = 2
local n = 3

local i = 1
local j = 2
local k = 3

local x = 4
local y = 5
local z = 6
`,
    }

    for (const [language, targetSource] of Object.entries(sourceByLanguage)) {
      // At time of test writing, we don't yet properly handle:
      // 1. java/cpp/lua multiple variable definitions on one line
      // 2. java not able to use `var a` for uninitialized variables
      const func = ['python', 'coffeescript', 'javascript'].includes(language) ? it : xit
      func(`in ${language}`, () => {
        const translated = translateUtils.translateJS(sourceByLanguage.javascript, language, false)
        const editDistance = levenshteinDistance(translated, targetSource)
        if (translated !== targetSource) {
          console.log(`\n${translated}`)
          console.log(`\n${targetSource}`)
        }
        expect(translated).toBe(targetSource)
        expect(editDistance).toEqual(0)
      })
    }
  })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1421, 'column': 4, 'index': 44383}","describe('translateJS can handle empty blocks', () => {
    const sourceByLanguage = {
      javascript: `\
for (let i = 0; i < 5; ++i) {
    
}

for (let j = 0; j < 5; ++j) {
    if (look('right') == 'crab') {
        
    }
    if (look('left') == 'gem') {
        
    }
}

for (let k = 0; k < 5; ++k) {
    
}`,
      cpp: `\
for (int i = 0; i < 5; ++i) {
    
}

for (int j = 0; j < 5; ++j) {
    if (look(""right"") == ""crab"") {
        
    }
    if (look(""left"") == ""gem"") {
        
    }
}

for (int k = 0; k < 5; ++k) {
    
}`,
      java: `\
for (int i = 0; i < 5; ++i) {
    
}

for (int j = 0; j < 5; ++j) {
    if (look(""right"") == ""crab"") {
        
    }
    if (look(""left"") == ""gem"") {
        
    }
}

for (int k = 0; k < 5; ++k) {
    
}`,
      python: `\
for i in range(0, 5):
    pass

for j in range(0, 5):
    if look('right') == 'crab':
        pass
    if look('left') == 'gem':
        pass

for k in range(0, 5):
    pass`,
      coffeescript: `\
for i in [0...5]
    

for j in [0...5]
    if look('right') is 'crab'
        
    if look('left') is 'gem'
        

for k in [0...5]
    `,
      lua: `\
for i=1, 5 do
    
end

for j=1, 5 do
    if look('right') == 'crab' then
        
    end
    if look('left') == 'gem' then
        
    end
end

for k=1, 5 do
    
end`,
    }

    for (const [language, targetSource] of Object.entries(sourceByLanguage)) {
      it(`in ${language}`, () => {
        const translated = translateUtils.translateJS(sourceByLanguage.javascript, language, false)
        const editDistance = levenshteinDistance(translated, targetSource)
        if (translated !== targetSource) {
          console.log(`\n${translated}`)
          console.log(`\n${targetSource}`)
        }
        expect(translated).toBe(targetSource)
        expect(editDistance).toEqual(0)
      })
    }
  })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1425, 'column': 8, 'index': 44676}","it(`in ${language}`, () => {
        const translated = translateUtils.translateJS(sourceByLanguage.javascript, language, false)
        const editDistance = levenshteinDistance(translated, targetSource)
        if (translated !== targetSource) {
          console.log(`\n${translated}`)
          console.log(`\n${targetSource}`)
        }
        expect(translated).toBe(targetSource)
        expect(editDistance).toEqual(0)
      })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1491, 'column': 4, 'index': 46122}","describe('translateJS can handle empty indented blocks at end of file', () => {
    const sourceByLanguage = {
      javascript: `\
for (let i = 0; i < 5; ++i) {
    for (let j = 0; j < 5; ++j) {
        if (look('right') == 'crab') {
            while (health < 4) {
                
            }
        }
    }
}`,
      cpp: `\
for (int i = 0; i < 5; ++i) {
    for (int j = 0; j < 5; ++j) {
        if (look(""right"") == ""crab"") {
            while (health < 4) {
                
            }
        }
    }
}`,
      java: `\
for (int i = 0; i < 5; ++i) {
    for (int j = 0; j < 5; ++j) {
        if (look(""right"") == ""crab"") {
            while (health < 4) {
                
            }
        }
    }
}`,
      python: `\
for i in range(0, 5):
    for j in range(0, 5):
        if look('right') == 'crab':
            while health < 4:
                pass`,
      coffeescript: `\
for i in [0...5]
    for j in [0...5]
        if look('right') is 'crab'
            while health < 4
                `,
      lua: `\
for i=1, 5 do
    for j=1, 5 do
        if look('right') == 'crab' then
            while health < 4 do
                
            end
        end
    end
end`,
    }

    for (const [language, targetSource] of Object.entries(sourceByLanguage)) {
      it(`in ${language}`, () => {
        const translated = translateUtils.translateJS(sourceByLanguage.javascript, language, false)
        const editDistance = levenshteinDistance(translated, targetSource)
        if (translated !== targetSource) {
          console.log(`\n${translated}`)
          console.log(`\n${targetSource}`)
        }
        expect(translated).toBe(targetSource)
        expect(editDistance).toEqual(0)
      })
    }
  })",steel
/test/app/lib/translate_utils.spec.js,Conditional Test Logic,"{'line': 1495, 'column': 8, 'index': 46415}","it(`in ${language}`, () => {
        const translated = translateUtils.translateJS(sourceByLanguage.javascript, language, false)
        const editDistance = levenshteinDistance(translated, targetSource)
        if (translated !== targetSource) {
          console.log(`\n${translated}`)
          console.log(`\n${targetSource}`)
        }
        expect(translated).toBe(targetSource)
        expect(editDistance).toEqual(0)
      })",steel
/test/app/lib/ScriptManager.spec.js,Conditional Test Logic,"{'line': 92, 'column': 6, 'index': 2940}","xit('fills out lots of notes based on note group properties', function() {
    let note;
    note = {channel: 'cnn', event: {1: 1}};

    const noteGroup = {
      duration: 0,
      botPos: [1, 2],
      botMessage: 'testers',
      domHighlight: '#code-area',
      surfaceHighlights: ['Guy0', 'Guy1'],
      scrubToTime: 20,
      notes: [note]
    };

    const script = {channel: 'pbs', noteChain: [noteGroup]};

    const sm = new ScriptManager([script]);
    sm.paused = false;

    Backbone.Mediator.publish('pbs');
    expect(sm.lastNoteGroup.notes.length).toBe(7);
    const channels = ((() => {
      const result = [];
      for (note of Array.from(sm.lastNoteGroup.notes)) {         result.push(note.channel);
      }
      return result;
    })());
    expect(channels).toContain('cnn');
    expect(channels).toContain('level-bot-move');
    expect(channels).toContain('level-bot-say');
    expect(channels).toContain('level-highlight-dom');
    expect(channels).toContain('level-highlight-sprites');
    expect(channels).toContain('level-set-time');
    expect(channels).toContain('level-disable-controls');
    return sm.destroy();
  })",steel
/test/app/lib/GoalManager.spec.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 870}","it('can tell when everyone is dead', function() {
    const gm = new GoalManager(1);
    const world =
      {frames: [liveState, liveState, liveState]};
    gm.setWorld(world);

    const goal = {id: 'die', name: 'Kill Everyone', killGuy: ['1', '2']};
    gm.addGoal(goal);

    expect(gm.goalStates['die'].complete).toBe(false);

    world.frames.push(deadState);
    world.frames.push(deadState);
    gm.setWorld(world);
    expect(gm.goalStates['die'].complete).toBe(true);
    return expect(gm.goalStates['die'].frameCompleted).toBe(3);
  })",steel
/test/app/lib/GoalManager.spec.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1018}","it('can tell when everyone is dead', function() {
    const gm = new GoalManager(1);
    const world =
      {frames: [liveState, liveState, liveState]};
    gm.setWorld(world);

    const goal = {id: 'die', name: 'Kill Everyone', killGuy: ['1', '2']};
    gm.addGoal(goal);

    expect(gm.goalStates['die'].complete).toBe(false);

    world.frames.push(deadState);
    world.frames.push(deadState);
    gm.setWorld(world);
    expect(gm.goalStates['die'].complete).toBe(true);
    return expect(gm.goalStates['die'].frameCompleted).toBe(3);
  })",steel
/test/app/lib/GoalManager.spec.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 1439}","it('can tell when someone is saved', function() {
    const gm = new GoalManager(1);
    let world =
      {frames: [liveState, liveState, liveState, deadState, deadState]};
    gm.setWorld(world);

    const goal = {id: 'live', name: 'Save guy 2', saveGuy: '2'};
    gm.addGoal(goal);

    expect(gm.goalStates['live'].complete).toBe(false);
    world =
      {frames: [liveState, liveState, liveState, liveState, liveState]};
    gm.setWorld(world);
    return expect(gm.goalStates['live'].complete).toBe(true);
  })",steel
/test/app/lib/GoalManager.spec.js,Duplicate Assert,"{'line': 62, 'column': 11, 'index': 1611}","it('can tell when someone is saved', function() {
    const gm = new GoalManager(1);
    let world =
      {frames: [liveState, liveState, liveState, deadState, deadState]};
    gm.setWorld(world);

    const goal = {id: 'live', name: 'Save guy 2', saveGuy: '2'};
    gm.addGoal(goal);

    expect(gm.goalStates['live'].complete).toBe(false);
    world =
      {frames: [liveState, liveState, liveState, liveState, liveState]};
    gm.setWorld(world);
    return expect(gm.goalStates['live'].complete).toBe(true);
  })",steel
/test/app/lib/GoalManager.spec.js,Magic Number,"{'line': 46, 'column': 60, 'index': 1128}","it('can tell when everyone is dead', function() {
    const gm = new GoalManager(1);
    const world =
      {frames: [liveState, liveState, liveState]};
    gm.setWorld(world);

    const goal = {id: 'die', name: 'Kill Everyone', killGuy: ['1', '2']};
    gm.addGoal(goal);

    expect(gm.goalStates['die'].complete).toBe(false);

    world.frames.push(deadState);
    world.frames.push(deadState);
    gm.setWorld(world);
    expect(gm.goalStates['die'].complete).toBe(true);
    return expect(gm.goalStates['die'].frameCompleted).toBe(3);
  })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 41, 'column': 8, 'index': 1852}","beforeEach(function() {
        const sessions = [];
        for (var level of Array.from(this.levels.models)) {
          if (level === this.practiceLevel) { continue; }
          for (var creator of Array.from(this.members.models)) {
            sessions.push(factories.makeLevelSession({state: {complete: true}}, { level, creator }));
          }
        }
        return this.classroom.sessions = new LevelSessions(sessions);
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 42, 'column': 10, 'index': 1914}","beforeEach(function() {
        const sessions = [];
        for (var level of Array.from(this.levels.models)) {
          if (level === this.practiceLevel) { continue; }
          for (var creator of Array.from(this.members.models)) {
            sessions.push(factories.makeLevelSession({state: {complete: true}}, { level, creator }));
          }
        }
        return this.classroom.sessions = new LevelSessions(sessions);
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 43, 'column': 10, 'index': 1972}","beforeEach(function() {
        const sessions = [];
        for (var level of Array.from(this.levels.models)) {
          if (level === this.practiceLevel) { continue; }
          for (var creator of Array.from(this.members.models)) {
            sessions.push(factories.makeLevelSession({state: {complete: true}}, { level, creator }));
          }
        }
        return this.classroom.sessions = new LevelSessions(sessions);
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 60, 'column': 10, 'index': 2913}","it('returns object with .completed=true and .started=true', function() {
        return (() => {
          const result = [];
          for (var student of Array.from(this.members.models)) {
            var progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
            var progress = progressData.get({classroom: this.classroom, course: this.course, user: student});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 74, 'column': 10, 'index': 3717}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 75, 'column': 12, 'index': 3781}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 88, 'column': 10, 'index': 4450}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            result.push((() => {
              const result1 = [];
              for (var user of Array.from(this.members.models)) {
                var progress = progressData.get({classroom: this.classroom, course: this.course, level, user});
                expect(progress.completed).toBe(true);
                result1.push(expect(progress.started).toBe(true));
              }
              return result1;
            })());
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 89, 'column': 12, 'index': 4514}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            result.push((() => {
              const result1 = [];
              for (var user of Array.from(this.members.models)) {
                var progress = progressData.get({classroom: this.classroom, course: this.course, level, user});
                expect(progress.completed).toBe(true);
                result1.push(expect(progress.started).toBe(true));
              }
              return result1;
            })());
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 92, 'column': 14, 'index': 4643}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            result.push((() => {
              const result1 = [];
              for (var user of Array.from(this.members.models)) {
                var progress = progressData.get({classroom: this.classroom, course: this.course, level, user});
                expect(progress.completed).toBe(true);
                result1.push(expect(progress.started).toBe(true));
              }
              return result1;
            })());
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 112, 'column': 8, 'index': 5332}","beforeEach(function() {
        let level;
        const sessions = [];
        this.finishedMember = this.members.first();
        this.unfinishedMember = this.members.last();
        for (level of Array.from(this.levels.models)) {
          if (level === this.practiceLevel) { continue; }
          sessions.push(factories.makeLevelSession(
            {state: {complete: true}}, 
            {level, creator: this.finishedMember})
          );
        }
        sessions.push(factories.makeLevelSession(
          {state: {complete: false}}, 
          {level: this.levels.first(), creator: this.unfinishedMember})
        );
        return this.classroom.sessions = new LevelSessions(sessions);
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 113, 'column': 10, 'index': 5390}","beforeEach(function() {
        let level;
        const sessions = [];
        this.finishedMember = this.members.first();
        this.unfinishedMember = this.members.last();
        for (level of Array.from(this.levels.models)) {
          if (level === this.practiceLevel) { continue; }
          sessions.push(factories.makeLevelSession(
            {state: {complete: true}}, 
            {level, creator: this.finishedMember})
          );
        }
        sessions.push(factories.makeLevelSession(
          {state: {complete: false}}, 
          {level: this.levels.first(), creator: this.unfinishedMember})
        );
        return this.classroom.sessions = new LevelSessions(sessions);
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 136, 'column': 10, 'index': 6617}","it('progressData.get({classroom, course, level}) returns object with .completed=false and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            result.push(expect(progress.completed).toBe(false));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 137, 'column': 12, 'index': 6681}","it('progressData.get({classroom, course, level}) returns object with .completed=false and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            result.push(expect(progress.completed).toBe(false));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 163, 'column': 10, 'index': 8415}","it('progressData.get({classroom, course, level, user}) returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level, user: this.finishedMember});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Conditional Test Logic,"{'line': 164, 'column': 12, 'index': 8479}","it('progressData.get({classroom, course, level, user}) returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level, user: this.finishedMember});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 194, 'column': 6, 'index': 10576}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 194, 'column': 6, 'index': 10576}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 195, 'column': 6, 'index': 10622}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 203, 'column': 6, 'index': 11075}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 203, 'column': 6, 'index': 11075}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 204, 'column': 6, 'index': 11121}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 204, 'column': 6, 'index': 11121}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 213, 'column': 6, 'index': 11685}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 213, 'column': 6, 'index': 11685}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 214, 'column': 13, 'index': 11738}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Duplicate Assert,"{'line': 214, 'column': 13, 'index': 11738}","it('returns an object with .completed=true if there\'s at least one completed session and no incomplete sessions', function() {
      this.classroom.sessions = new LevelSessions();
      let progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      let progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(false);

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: true}},
          {level: this.practiceLevel, creator: this.members.first()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      expect(progress.started).toBe(true);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});

      this.classroom.sessions.push(factories.makeLevelSession(
          {state: {complete: false}},
          {level: this.practiceLevel, creator: this.members.last()})
      );
      progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
      progress = progressData.get({classroom: this.classroom, course: this.course, level: this.practiceLevel});
      expect(progress.completed).toBe(false);
      return expect(progress.started).toBe(true);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 41, 'column': 13, 'index': 1857}","beforeEach(function() {
        const sessions = [];
        for (var level of Array.from(this.levels.models)) {
          if (level === this.practiceLevel) { continue; }
          for (var creator of Array.from(this.members.models)) {
            sessions.push(factories.makeLevelSession({state: {complete: true}}, { level, creator }));
          }
        }
        return this.classroom.sessions = new LevelSessions(sessions);
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 43, 'column': 15, 'index': 1977}","beforeEach(function() {
        const sessions = [];
        for (var level of Array.from(this.levels.models)) {
          if (level === this.practiceLevel) { continue; }
          for (var creator of Array.from(this.members.models)) {
            sessions.push(factories.makeLevelSession({state: {complete: true}}, { level, creator }));
          }
        }
        return this.classroom.sessions = new LevelSessions(sessions);
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 60, 'column': 15, 'index': 2918}","it('returns object with .completed=true and .started=true', function() {
        return (() => {
          const result = [];
          for (var student of Array.from(this.members.models)) {
            var progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
            var progress = progressData.get({classroom: this.classroom, course: this.course, user: student});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 61, 'column': 12, 'index': 2980}","it('returns object with .completed=true and .started=true', function() {
        return (() => {
          const result = [];
          for (var student of Array.from(this.members.models)) {
            var progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
            var progress = progressData.get({classroom: this.classroom, course: this.course, user: student});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 62, 'column': 12, 'index': 3107}","it('returns object with .completed=true and .started=true', function() {
        return (() => {
          const result = [];
          for (var student of Array.from(this.members.models)) {
            var progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
            var progress = progressData.get({classroom: this.classroom, course: this.course, user: student});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 74, 'column': 15, 'index': 3722}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 76, 'column': 12, 'index': 3841}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 88, 'column': 15, 'index': 4455}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            result.push((() => {
              const result1 = [];
              for (var user of Array.from(this.members.models)) {
                var progress = progressData.get({classroom: this.classroom, course: this.course, level, user});
                expect(progress.completed).toBe(true);
                result1.push(expect(progress.started).toBe(true));
              }
              return result1;
            })());
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 92, 'column': 19, 'index': 4648}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            result.push((() => {
              const result1 = [];
              for (var user of Array.from(this.members.models)) {
                var progress = progressData.get({classroom: this.classroom, course: this.course, level, user});
                expect(progress.completed).toBe(true);
                result1.push(expect(progress.started).toBe(true));
              }
              return result1;
            })());
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 93, 'column': 16, 'index': 4711}","it('returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level === this.practiceLevel) { continue; }
            result.push((() => {
              const result1 = [];
              for (var user of Array.from(this.members.models)) {
                var progress = progressData.get({classroom: this.classroom, course: this.course, level, user});
                expect(progress.completed).toBe(true);
                result1.push(expect(progress.started).toBe(true));
              }
              return result1;
            })());
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 136, 'column': 15, 'index': 6622}","it('progressData.get({classroom, course, level}) returns object with .completed=false and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            result.push(expect(progress.completed).toBe(false));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 138, 'column': 12, 'index': 6734}","it('progressData.get({classroom, course, level}) returns object with .completed=false and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level});
            result.push(expect(progress.completed).toBe(false));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 163, 'column': 15, 'index': 8420}","it('progressData.get({classroom, course, level, user}) returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level, user: this.finishedMember});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Global Variable,"{'line': 165, 'column': 12, 'index': 8532}","it('progressData.get({classroom, course, level, user}) returns object with .completed=true and .started=true', function() {
        const progressData = helper.calculateAllProgress(this.classrooms, this.courses, this.courseInstances, this.members);
        return (() => {
          const result = [];
          for (var level of Array.from(this.levels.models)) {
            if (level.get('practice')) { continue; }
            var progress = progressData.get({classroom: this.classroom, course: this.course, level, user: this.finishedMember});
            expect(progress.completed).toBe(true);
            result.push(expect(progress.started).toBe(true));
          }
          return result;
        })();
      })",steel
/test/app/lib/CoursesHelper.spec.js,Magic Number,"{'line': 223, 'column': 45, 'index': 12191}","it('user completed a single level but hasn\'t completed all levels', function() {
      const [userStarted, allComplete, levelsCompleted] = Array.from(helper.hasUserCompletedCourse({'a': true}, new Set(['a', 'b'])));
      expect(userStarted).toBe(true);
      expect(allComplete).toBe(false);
      return expect(levelsCompleted).toEqual(1);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Magic Number,"{'line': 230, 'column': 45, 'index': 12520}","it('user completed all levels', function() {
      const [userStarted, allComplete, levelsCompleted] = Array.from(helper.hasUserCompletedCourse({'a': true, 'b': true}, new Set(['a', 'b'])));
      expect(userStarted).toBe(true);
      expect(allComplete).toBe(true);
      return expect(levelsCompleted).toEqual(2);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Magic Number,"{'line': 237, 'column': 45, 'index': 12838}","it('undefined user state passed in', function() {
      const [userStarted, allComplete, levelsCompleted] = Array.from(helper.hasUserCompletedCourse(undefined, new Set(['a'])));
      expect(userStarted).toBe(false);
      expect(allComplete).toBe(false);
      return expect(levelsCompleted).toEqual(0);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Magic Number,"{'line': 244, 'column': 45, 'index': 13176}","it(""User hasn't completed all levels"", function() {
      const [userStarted, allComplete, levelsCompleted] = Array.from(helper.hasUserCompletedCourse({'a': true, 'b': false}, new Set(['a', 'b'])));
      expect(userStarted).toBe(true);
      expect(allComplete).toBe(false);
      return expect(levelsCompleted).toEqual(1);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Magic Number,"{'line': 251, 'column': 45, 'index': 13510}","it(""User has completed required levels"", function() {
      const [userStarted, allComplete, levelsCompleted] = Array.from(helper.hasUserCompletedCourse({'a': true, 'b': false}, new Set(['a'])));
      expect(userStarted).toBe(true);
      expect(allComplete).toBe(true);
      return expect(levelsCompleted).toEqual(1);
    })",steel
/test/app/lib/CoursesHelper.spec.js,Magic Number,"{'line': 258, 'column': 45, 'index': 13853}","it(""User has completed different levels"", function() {
      const [userStarted, allComplete, levelsCompleted] = Array.from(helper.hasUserCompletedCourse({'a': true, 'b': true}, new Set(['c'])));
      expect(userStarted).toBe(false);
      expect(allComplete).toBe(false);
      return expect(levelsCompleted).toEqual(0);
    })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 431}","it('rotates properly', function() {
    const v = new Vector(200, 300);
    v.rotate(Math.PI / 2);
    expect(v.x).toBeCloseTo(-300);
    expect(v.y).toBeCloseTo(200);

    v.rotate(Math.PI / 4);
    expect(v.x).toBeCloseTo(-250 * Math.sqrt(2));
    return expect(v.y).toBeCloseTo(-50 * Math.sqrt(2));
  })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 466}","it('rotates properly', function() {
    const v = new Vector(200, 300);
    v.rotate(Math.PI / 2);
    expect(v.x).toBeCloseTo(-300);
    expect(v.y).toBeCloseTo(200);

    v.rotate(Math.PI / 4);
    expect(v.x).toBeCloseTo(-250 * Math.sqrt(2));
    return expect(v.y).toBeCloseTo(-50 * Math.sqrt(2));
  })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 528}","it('rotates properly', function() {
    const v = new Vector(200, 300);
    v.rotate(Math.PI / 2);
    expect(v.x).toBeCloseTo(-300);
    expect(v.y).toBeCloseTo(200);

    v.rotate(Math.PI / 4);
    expect(v.x).toBeCloseTo(-250 * Math.sqrt(2));
    return expect(v.y).toBeCloseTo(-50 * Math.sqrt(2));
  })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 18, 'column': 11, 'index': 585}","it('rotates properly', function() {
    const v = new Vector(200, 300);
    v.rotate(Math.PI / 2);
    expect(v.x).toBeCloseTo(-300);
    expect(v.y).toBeCloseTo(200);

    v.rotate(Math.PI / 4);
    expect(v.x).toBeCloseTo(-250 * Math.sqrt(2));
    return expect(v.y).toBeCloseTo(-50 * Math.sqrt(2));
  })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 797}","it('hardly moves when rotated a tiny bit', function() {
    let v = new Vector(-100.25, -101);
    let v2 = v.copy();
    v2.rotate(0.0000001 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(100.25, -101);
    v2 = v.copy();
    v2.rotate(1.99999999 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(10.25, 301);
    v2 = v.copy();
    v2.rotate(-0.0000001 * Math.PI);
    return expect(v.distance(v2)).toBeCloseTo(0);
  })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 797}","it('hardly moves when rotated a tiny bit', function() {
    let v = new Vector(-100.25, -101);
    let v2 = v.copy();
    v2.rotate(0.0000001 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(100.25, -101);
    v2 = v.copy();
    v2.rotate(1.99999999 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(10.25, 301);
    v2 = v.copy();
    v2.rotate(-0.0000001 * Math.PI);
    return expect(v.distance(v2)).toBeCloseTo(0);
  })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 931}","it('hardly moves when rotated a tiny bit', function() {
    let v = new Vector(-100.25, -101);
    let v2 = v.copy();
    v2.rotate(0.0000001 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(100.25, -101);
    v2 = v.copy();
    v2.rotate(1.99999999 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(10.25, 301);
    v2 = v.copy();
    v2.rotate(-0.0000001 * Math.PI);
    return expect(v.distance(v2)).toBeCloseTo(0);
  })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 931}","it('hardly moves when rotated a tiny bit', function() {
    let v = new Vector(-100.25, -101);
    let v2 = v.copy();
    v2.rotate(0.0000001 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(100.25, -101);
    v2 = v.copy();
    v2.rotate(1.99999999 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(10.25, 301);
    v2 = v.copy();
    v2.rotate(-0.0000001 * Math.PI);
    return expect(v.distance(v2)).toBeCloseTo(0);
  })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 35, 'column': 11, 'index': 1070}","it('hardly moves when rotated a tiny bit', function() {
    let v = new Vector(-100.25, -101);
    let v2 = v.copy();
    v2.rotate(0.0000001 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(100.25, -101);
    v2 = v.copy();
    v2.rotate(1.99999999 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(10.25, 301);
    v2 = v.copy();
    v2.rotate(-0.0000001 * Math.PI);
    return expect(v.distance(v2)).toBeCloseTo(0);
  })",steel
/test/app/lib/world/vector.spec.js,Duplicate Assert,"{'line': 35, 'column': 11, 'index': 1070}","it('hardly moves when rotated a tiny bit', function() {
    let v = new Vector(-100.25, -101);
    let v2 = v.copy();
    v2.rotate(0.0000001 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(100.25, -101);
    v2 = v.copy();
    v2.rotate(1.99999999 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(10.25, 301);
    v2 = v.copy();
    v2.rotate(-0.0000001 * Math.PI);
    return expect(v.distance(v2)).toBeCloseTo(0);
  })",steel
/test/app/lib/world/vector.spec.js,Magic Number,"{'line': 14, 'column': 28, 'index': 490}","it('rotates properly', function() {
    const v = new Vector(200, 300);
    v.rotate(Math.PI / 2);
    expect(v.x).toBeCloseTo(-300);
    expect(v.y).toBeCloseTo(200);

    v.rotate(Math.PI / 4);
    expect(v.x).toBeCloseTo(-250 * Math.sqrt(2));
    return expect(v.y).toBeCloseTo(-50 * Math.sqrt(2));
  })",steel
/test/app/lib/world/vector.spec.js,Magic Number,"{'line': 25, 'column': 39, 'index': 832}","it('hardly moves when rotated a tiny bit', function() {
    let v = new Vector(-100.25, -101);
    let v2 = v.copy();
    v2.rotate(0.0000001 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(100.25, -101);
    v2 = v.copy();
    v2.rotate(1.99999999 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(10.25, 301);
    v2 = v.copy();
    v2.rotate(-0.0000001 * Math.PI);
    return expect(v.distance(v2)).toBeCloseTo(0);
  })",steel
/test/app/lib/world/vector.spec.js,Magic Number,"{'line': 30, 'column': 39, 'index': 966}","it('hardly moves when rotated a tiny bit', function() {
    let v = new Vector(-100.25, -101);
    let v2 = v.copy();
    v2.rotate(0.0000001 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(100.25, -101);
    v2 = v.copy();
    v2.rotate(1.99999999 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(10.25, 301);
    v2 = v.copy();
    v2.rotate(-0.0000001 * Math.PI);
    return expect(v.distance(v2)).toBeCloseTo(0);
  })",steel
/test/app/lib/world/vector.spec.js,Magic Number,"{'line': 35, 'column': 46, 'index': 1105}","it('hardly moves when rotated a tiny bit', function() {
    let v = new Vector(-100.25, -101);
    let v2 = v.copy();
    v2.rotate(0.0000001 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(100.25, -101);
    v2 = v.copy();
    v2.rotate(1.99999999 * Math.PI);
    expect(v.distance(v2)).toBeCloseTo(0);

    v = new Vector(10.25, 301);
    v2 = v.copy();
    v2.rotate(-0.0000001 * Math.PI);
    return expect(v.distance(v2)).toBeCloseTo(0);
  })",steel
/test/app/lib/world/vector.spec.js,Magic Number,"{'line': 84, 'column': 30, 'index': 2983}","it('mutates when not in player code', function() {
    const expectMutation = function(fn) {
      const v = new Vector(5, 5);
      const v2 = fn(v);
      expect(v.x).not.toEqual(5);
      return expect(v).toBe(v2);
    };

    expectMutation(v => v.normalize());
    expectMutation(v => v.limit(2));
    expectMutation(v => v.subtract(new Vector(2, 2)));
    expectMutation(v => v.add(new Vector(2, 2)));
    expectMutation(v => v.divide(2));
    expectMutation(v => v.multiply(2));
    return expectMutation(v => v.rotate(0.5));
  })",steel
/test/app/lib/world/rectangle.spec.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1627}","it('correctly calculates distance to a faraway point', function() {
    const rect = new Rectangle(100, 50, 20, 40);
    const p = new Vector(200, 300);
    let d = 10 * Math.sqrt(610);
    expect(rect.distanceToPoint(p)).toBeCloseTo(d);
    rect.rotation = Math.PI / 2;
    d = 80 * Math.sqrt(10);
    return expect(rect.distanceToPoint(p)).toBeCloseTo(d);
  })",steel
/test/app/lib/world/rectangle.spec.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1627}","it('correctly calculates distance to a faraway point', function() {
    const rect = new Rectangle(100, 50, 20, 40);
    const p = new Vector(200, 300);
    let d = 10 * Math.sqrt(610);
    expect(rect.distanceToPoint(p)).toBeCloseTo(d);
    rect.rotation = Math.PI / 2;
    d = 80 * Math.sqrt(10);
    return expect(rect.distanceToPoint(p)).toBeCloseTo(d);
  })",steel
/test/app/lib/world/rectangle.spec.js,Duplicate Assert,"{'line': 45, 'column': 11, 'index': 1747}","it('correctly calculates distance to a faraway point', function() {
    const rect = new Rectangle(100, 50, 20, 40);
    const p = new Vector(200, 300);
    let d = 10 * Math.sqrt(610);
    expect(rect.distanceToPoint(p)).toBeCloseTo(d);
    rect.rotation = Math.PI / 2;
    d = 80 * Math.sqrt(10);
    return expect(rect.distanceToPoint(p)).toBeCloseTo(d);
  })",steel
/test/app/lib/world/rectangle.spec.js,Duplicate Assert,"{'line': 45, 'column': 11, 'index': 1747}","it('correctly calculates distance to a faraway point', function() {
    const rect = new Rectangle(100, 50, 20, 40);
    const p = new Vector(200, 300);
    let d = 10 * Math.sqrt(610);
    expect(rect.distanceToPoint(p)).toBeCloseTo(d);
    rect.rotation = Math.PI / 2;
    d = 80 * Math.sqrt(10);
    return expect(rect.distanceToPoint(p)).toBeCloseTo(d);
  })",steel
/test/app/lib/world/rectangle.spec.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 2527}","it('correctly calculates distance to contained point', function() {
    const rect = new Rectangle(-100, -200, 1, 100);
    const p = new Vector(-100.25, -160);
    expect(rect.distanceToPoint(p)).toBe(0);
    rect.rotation = 0.00000001 * Math.PI;
    return expect(rect.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 2527}","it('correctly calculates distance to contained point', function() {
    const rect = new Rectangle(-100, -200, 1, 100);
    const p = new Vector(-100.25, -160);
    expect(rect.distanceToPoint(p)).toBe(0);
    rect.rotation = 0.00000001 * Math.PI;
    return expect(rect.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Duplicate Assert,"{'line': 68, 'column': 11, 'index': 2621}","it('correctly calculates distance to contained point', function() {
    const rect = new Rectangle(-100, -200, 1, 100);
    const p = new Vector(-100.25, -160);
    expect(rect.distanceToPoint(p)).toBe(0);
    rect.rotation = 0.00000001 * Math.PI;
    return expect(rect.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Duplicate Assert,"{'line': 68, 'column': 11, 'index': 2621}","it('correctly calculates distance to contained point', function() {
    const rect = new Rectangle(-100, -200, 1, 100);
    const p = new Vector(-100.25, -160);
    expect(rect.distanceToPoint(p)).toBe(0);
    rect.rotation = 0.00000001 * Math.PI;
    return expect(rect.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 66, 'column': 41, 'index': 2564}","it('correctly calculates distance to contained point', function() {
    const rect = new Rectangle(-100, -200, 1, 100);
    const p = new Vector(-100.25, -160);
    expect(rect.distanceToPoint(p)).toBe(0);
    rect.rotation = 0.00000001 * Math.PI;
    return expect(rect.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 68, 'column': 48, 'index': 2658}","it('correctly calculates distance to contained point', function() {
    const rect = new Rectangle(-100, -200, 1, 100);
    const p = new Vector(-100.25, -160);
    expect(rect.distanceToPoint(p)).toBe(0);
    rect.rotation = 0.00000001 * Math.PI;
    return expect(rect.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 72, 'column': 114, 'index': 2854}","it('correctly calculates distance to other rectangles', function() {
    expect(new Rectangle(0, 0, 4, 4, Math.PI / 4).distanceToRectangle(new Rectangle(4, -4, 2, 2, 0))).toBeCloseTo(2.2426);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2, 2, 0))).toBe(0);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2.5, 2.5, Math.PI / 4))).toBe(0);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, 0))).toBe(1);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, Math.PI / 4))).toBeCloseTo(2 - Math.SQRT2);

    // https://www.desmos.com/calculator/po8ifjklfs
    const rect1 = Rectangle.fromVertices([new Vector(89.936, 100.355), new Vector(105.842, 88.077), new Vector(54.581, 21.670), new Vector(38.675, 33.948)]);
    const rect2 = Rectangle.fromVertices([new Vector(116.029, 61.108), new Vector(87.422, 9.247), new Vector(68.955, 19.433), new Vector(97.563, 71.294)]);
    return expect(rect1.distanceToRectangle(rect2)).toBeCloseTo(3.701777957811988);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 73, 'column': 96, 'index': 2959}","it('correctly calculates distance to other rectangles', function() {
    expect(new Rectangle(0, 0, 4, 4, Math.PI / 4).distanceToRectangle(new Rectangle(4, -4, 2, 2, 0))).toBeCloseTo(2.2426);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2, 2, 0))).toBe(0);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2.5, 2.5, Math.PI / 4))).toBe(0);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, 0))).toBe(1);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, Math.PI / 4))).toBeCloseTo(2 - Math.SQRT2);

    // https://www.desmos.com/calculator/po8ifjklfs
    const rect1 = Rectangle.fromVertices([new Vector(89.936, 100.355), new Vector(105.842, 88.077), new Vector(54.581, 21.670), new Vector(38.675, 33.948)]);
    const rect2 = Rectangle.fromVertices([new Vector(116.029, 61.108), new Vector(87.422, 9.247), new Vector(68.955, 19.433), new Vector(97.563, 71.294)]);
    return expect(rect1.distanceToRectangle(rect2)).toBeCloseTo(3.701777957811988);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 74, 'column': 110, 'index': 3073}","it('correctly calculates distance to other rectangles', function() {
    expect(new Rectangle(0, 0, 4, 4, Math.PI / 4).distanceToRectangle(new Rectangle(4, -4, 2, 2, 0))).toBeCloseTo(2.2426);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2, 2, 0))).toBe(0);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2.5, 2.5, Math.PI / 4))).toBe(0);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, 0))).toBe(1);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, Math.PI / 4))).toBeCloseTo(2 - Math.SQRT2);

    // https://www.desmos.com/calculator/po8ifjklfs
    const rect1 = Rectangle.fromVertices([new Vector(89.936, 100.355), new Vector(105.842, 88.077), new Vector(54.581, 21.670), new Vector(38.675, 33.948)]);
    const rect2 = Rectangle.fromVertices([new Vector(116.029, 61.108), new Vector(87.422, 9.247), new Vector(68.955, 19.433), new Vector(97.563, 71.294)]);
    return expect(rect1.distanceToRectangle(rect2)).toBeCloseTo(3.701777957811988);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 75, 'column': 96, 'index': 3173}","it('correctly calculates distance to other rectangles', function() {
    expect(new Rectangle(0, 0, 4, 4, Math.PI / 4).distanceToRectangle(new Rectangle(4, -4, 2, 2, 0))).toBeCloseTo(2.2426);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2, 2, 0))).toBe(0);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2.5, 2.5, Math.PI / 4))).toBe(0);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, 0))).toBe(1);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, Math.PI / 4))).toBeCloseTo(2 - Math.SQRT2);

    // https://www.desmos.com/calculator/po8ifjklfs
    const rect1 = Rectangle.fromVertices([new Vector(89.936, 100.355), new Vector(105.842, 88.077), new Vector(54.581, 21.670), new Vector(38.675, 33.948)]);
    const rect2 = Rectangle.fromVertices([new Vector(116.029, 61.108), new Vector(87.422, 9.247), new Vector(68.955, 19.433), new Vector(97.563, 71.294)]);
    return expect(rect1.distanceToRectangle(rect2)).toBeCloseTo(3.701777957811988);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 81, 'column': 64, 'index': 3738}","it('correctly calculates distance to other rectangles', function() {
    expect(new Rectangle(0, 0, 4, 4, Math.PI / 4).distanceToRectangle(new Rectangle(4, -4, 2, 2, 0))).toBeCloseTo(2.2426);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2, 2, 0))).toBe(0);
    expect(new Rectangle(0, 0, 3, 3, 0).distanceToRectangle(new Rectangle(0, 0, 2.5, 2.5, Math.PI / 4))).toBe(0);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, 0))).toBe(1);
    expect(new Rectangle(0, 0, 4, 4, 0).distanceToRectangle(new Rectangle(4, 2, 2, 2, Math.PI / 4))).toBeCloseTo(2 - Math.SQRT2);

    // https://www.desmos.com/calculator/po8ifjklfs
    const rect1 = Rectangle.fromVertices([new Vector(89.936, 100.355), new Vector(105.842, 88.077), new Vector(54.581, 21.670), new Vector(38.675, 33.948)]);
    const rect2 = Rectangle.fromVertices([new Vector(116.029, 61.108), new Vector(87.422, 9.247), new Vector(68.955, 19.433), new Vector(97.563, 71.294)]);
    return expect(rect1.distanceToRectangle(rect2)).toBeCloseTo(3.701777957811988);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 87, 'column': 27, 'index': 3919}","it('has predictable vertices', function() {
    const rect = new Rectangle(50, 50, 100, 100);
    const v = rect.vertices();
    expect(v[0].x).toEqual(0);
    expect(v[0].y).toEqual(0);
    expect(v[1].x).toEqual(0);
    expect(v[1].y).toEqual(100);
    expect(v[2].x).toEqual(100);
    expect(v[2].y).toEqual(100);
    expect(v[3].x).toEqual(100);
    return expect(v[3].y).toEqual(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 88, 'column': 27, 'index': 3950}","it('has predictable vertices', function() {
    const rect = new Rectangle(50, 50, 100, 100);
    const v = rect.vertices();
    expect(v[0].x).toEqual(0);
    expect(v[0].y).toEqual(0);
    expect(v[1].x).toEqual(0);
    expect(v[1].y).toEqual(100);
    expect(v[2].x).toEqual(100);
    expect(v[2].y).toEqual(100);
    expect(v[3].x).toEqual(100);
    return expect(v[3].y).toEqual(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 89, 'column': 27, 'index': 3981}","it('has predictable vertices', function() {
    const rect = new Rectangle(50, 50, 100, 100);
    const v = rect.vertices();
    expect(v[0].x).toEqual(0);
    expect(v[0].y).toEqual(0);
    expect(v[1].x).toEqual(0);
    expect(v[1].y).toEqual(100);
    expect(v[2].x).toEqual(100);
    expect(v[2].y).toEqual(100);
    expect(v[3].x).toEqual(100);
    return expect(v[3].y).toEqual(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 90, 'column': 27, 'index': 4012}","it('has predictable vertices', function() {
    const rect = new Rectangle(50, 50, 100, 100);
    const v = rect.vertices();
    expect(v[0].x).toEqual(0);
    expect(v[0].y).toEqual(0);
    expect(v[1].x).toEqual(0);
    expect(v[1].y).toEqual(100);
    expect(v[2].x).toEqual(100);
    expect(v[2].y).toEqual(100);
    expect(v[3].x).toEqual(100);
    return expect(v[3].y).toEqual(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 91, 'column': 27, 'index': 4045}","it('has predictable vertices', function() {
    const rect = new Rectangle(50, 50, 100, 100);
    const v = rect.vertices();
    expect(v[0].x).toEqual(0);
    expect(v[0].y).toEqual(0);
    expect(v[1].x).toEqual(0);
    expect(v[1].y).toEqual(100);
    expect(v[2].x).toEqual(100);
    expect(v[2].y).toEqual(100);
    expect(v[3].x).toEqual(100);
    return expect(v[3].y).toEqual(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 92, 'column': 27, 'index': 4078}","it('has predictable vertices', function() {
    const rect = new Rectangle(50, 50, 100, 100);
    const v = rect.vertices();
    expect(v[0].x).toEqual(0);
    expect(v[0].y).toEqual(0);
    expect(v[1].x).toEqual(0);
    expect(v[1].y).toEqual(100);
    expect(v[2].x).toEqual(100);
    expect(v[2].y).toEqual(100);
    expect(v[3].x).toEqual(100);
    return expect(v[3].y).toEqual(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 93, 'column': 27, 'index': 4111}","it('has predictable vertices', function() {
    const rect = new Rectangle(50, 50, 100, 100);
    const v = rect.vertices();
    expect(v[0].x).toEqual(0);
    expect(v[0].y).toEqual(0);
    expect(v[1].x).toEqual(0);
    expect(v[1].y).toEqual(100);
    expect(v[2].x).toEqual(100);
    expect(v[2].y).toEqual(100);
    expect(v[3].x).toEqual(100);
    return expect(v[3].y).toEqual(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 94, 'column': 34, 'index': 4151}","it('has predictable vertices', function() {
    const rect = new Rectangle(50, 50, 100, 100);
    const v = rect.vertices();
    expect(v[0].x).toEqual(0);
    expect(v[0].y).toEqual(0);
    expect(v[1].x).toEqual(0);
    expect(v[1].y).toEqual(100);
    expect(v[2].x).toEqual(100);
    expect(v[2].y).toEqual(100);
    expect(v[3].x).toEqual(100);
    return expect(v[3].y).toEqual(0);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 102, 'column': 31, 'index': 4434}","it('has predictable vertices when rotated', function() {
    const rect = new Rectangle(50, 50, 100, 100, Math.PI / 4);
    const v = rect.vertices();
    const d = (Math.sqrt(2 * 100 * 100) - 100) / 2;
    expect(v[0].x).toBeCloseTo(-d);
    expect(v[0].y).toBeCloseTo(50);
    expect(v[1].x).toBeCloseTo(50);
    expect(v[1].y).toBeCloseTo(100 + d);
    expect(v[2].x).toBeCloseTo(100 + d);
    expect(v[2].y).toBeCloseTo(50);
    expect(v[3].x).toBeCloseTo(50);
    return expect(v[3].y).toBeCloseTo(-d);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 103, 'column': 31, 'index': 4470}","it('has predictable vertices when rotated', function() {
    const rect = new Rectangle(50, 50, 100, 100, Math.PI / 4);
    const v = rect.vertices();
    const d = (Math.sqrt(2 * 100 * 100) - 100) / 2;
    expect(v[0].x).toBeCloseTo(-d);
    expect(v[0].y).toBeCloseTo(50);
    expect(v[1].x).toBeCloseTo(50);
    expect(v[1].y).toBeCloseTo(100 + d);
    expect(v[2].x).toBeCloseTo(100 + d);
    expect(v[2].y).toBeCloseTo(50);
    expect(v[3].x).toBeCloseTo(50);
    return expect(v[3].y).toBeCloseTo(-d);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 106, 'column': 31, 'index': 4588}","it('has predictable vertices when rotated', function() {
    const rect = new Rectangle(50, 50, 100, 100, Math.PI / 4);
    const v = rect.vertices();
    const d = (Math.sqrt(2 * 100 * 100) - 100) / 2;
    expect(v[0].x).toBeCloseTo(-d);
    expect(v[0].y).toBeCloseTo(50);
    expect(v[1].x).toBeCloseTo(50);
    expect(v[1].y).toBeCloseTo(100 + d);
    expect(v[2].x).toBeCloseTo(100 + d);
    expect(v[2].y).toBeCloseTo(50);
    expect(v[3].x).toBeCloseTo(50);
    return expect(v[3].y).toBeCloseTo(-d);
  })",steel
/test/app/lib/world/rectangle.spec.js,Magic Number,"{'line': 107, 'column': 31, 'index': 4624}","it('has predictable vertices when rotated', function() {
    const rect = new Rectangle(50, 50, 100, 100, Math.PI / 4);
    const v = rect.vertices();
    const d = (Math.sqrt(2 * 100 * 100) - 100) / 2;
    expect(v[0].x).toBeCloseTo(-d);
    expect(v[0].y).toBeCloseTo(50);
    expect(v[1].x).toBeCloseTo(50);
    expect(v[1].y).toBeCloseTo(100 + d);
    expect(v[2].x).toBeCloseTo(100 + d);
    expect(v[2].y).toBeCloseTo(50);
    expect(v[3].x).toBeCloseTo(50);
    return expect(v[3].y).toBeCloseTo(-d);
  })",steel
/test/app/lib/world/line_segment.spec.js,Duplicate Assert,"{'line': 50, 'column': 4, 'index': 2043}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Duplicate Assert,"{'line': 50, 'column': 4, 'index': 2043}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 2097}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 2097}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 2554}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 2554}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Duplicate Assert,"{'line': 59, 'column': 11, 'index': 2615}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Duplicate Assert,"{'line': 59, 'column': 11, 'index': 2615}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Magic Number,"{'line': 49, 'column': 50, 'index': 2035}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Magic Number,"{'line': 50, 'column': 50, 'index': 2089}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/line_segment.spec.js,Magic Number,"{'line': 58, 'column': 50, 'index': 2600}","it('correctly calculates distance to points', function() {
    const lineSegment = new LineSegment(v00, v11);
    expect(lineSegment.distanceToPoint(v00)).toBe(0);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
    expect(lineSegment.distanceToPoint(v34)).toBeCloseTo(Math.sqrt((2 * 2) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v04)).toBeCloseTo(Math.sqrt((1 * 1) + (3 * 3)));
    expect(lineSegment.distanceToPoint(v30)).toBeCloseTo(Math.sqrt((2 * 2) + (1 * 1)));
    expect(lineSegment.distanceToPoint(vneg)).toBeCloseTo(Math.SQRT2);

    const nullSegment = new LineSegment(v11, v11);
    expect(lineSegment.distanceToPoint(v11)).toBe(0);
    return expect(lineSegment.distanceToPoint(v22)).toBeCloseTo(Math.SQRT2);
  })",steel
/test/app/lib/world/ellipse.spec.js,Duplicate Assert,"{'line': 76, 'column': 4, 'index': 3514}","it('correctly calculates distance to contained point', function() {
    const ellipse = new Ellipse(-100, -200, 1, 100);
    const ellipse2 = ellipse.copy();
    const p = new Vector(-100.25, -160);
    const p2 = p.copy();
    expect(ellipse.distanceToPoint(p)).toBe(0);
    ellipse.rotation = 0.00000001 * Math.PI;
    return expect(ellipse.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/ellipse.spec.js,Duplicate Assert,"{'line': 76, 'column': 4, 'index': 3514}","it('correctly calculates distance to contained point', function() {
    const ellipse = new Ellipse(-100, -200, 1, 100);
    const ellipse2 = ellipse.copy();
    const p = new Vector(-100.25, -160);
    const p2 = p.copy();
    expect(ellipse.distanceToPoint(p)).toBe(0);
    ellipse.rotation = 0.00000001 * Math.PI;
    return expect(ellipse.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/ellipse.spec.js,Duplicate Assert,"{'line': 78, 'column': 11, 'index': 3614}","it('correctly calculates distance to contained point', function() {
    const ellipse = new Ellipse(-100, -200, 1, 100);
    const ellipse2 = ellipse.copy();
    const p = new Vector(-100.25, -160);
    const p2 = p.copy();
    expect(ellipse.distanceToPoint(p)).toBe(0);
    ellipse.rotation = 0.00000001 * Math.PI;
    return expect(ellipse.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/ellipse.spec.js,Duplicate Assert,"{'line': 78, 'column': 11, 'index': 3614}","it('correctly calculates distance to contained point', function() {
    const ellipse = new Ellipse(-100, -200, 1, 100);
    const ellipse2 = ellipse.copy();
    const p = new Vector(-100.25, -160);
    const p2 = p.copy();
    expect(ellipse.distanceToPoint(p)).toBe(0);
    ellipse.rotation = 0.00000001 * Math.PI;
    return expect(ellipse.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/ellipse.spec.js,Magic Number,"{'line': 76, 'column': 44, 'index': 3554}","it('correctly calculates distance to contained point', function() {
    const ellipse = new Ellipse(-100, -200, 1, 100);
    const ellipse2 = ellipse.copy();
    const p = new Vector(-100.25, -160);
    const p2 = p.copy();
    expect(ellipse.distanceToPoint(p)).toBe(0);
    ellipse.rotation = 0.00000001 * Math.PI;
    return expect(ellipse.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/ellipse.spec.js,Magic Number,"{'line': 78, 'column': 51, 'index': 3654}","it('correctly calculates distance to contained point', function() {
    const ellipse = new Ellipse(-100, -200, 1, 100);
    const ellipse2 = ellipse.copy();
    const p = new Vector(-100.25, -160);
    const p2 = p.copy();
    expect(ellipse.distanceToPoint(p)).toBe(0);
    ellipse.rotation = 0.00000001 * Math.PI;
    return expect(ellipse.distanceToPoint(p)).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 2040}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 2098}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 2098}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 2153}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 2209}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 2378}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 2433}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 2433}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 2488}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 55, 'column': 11, 'index': 2550}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 65, 'column': 4, 'index': 2896}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 2951}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 3006}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 3006}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 3062}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 75, 'column': 4, 'index': 3273}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 76, 'column': 4, 'index': 3328}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 77, 'column': 4, 'index': 3384}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 77, 'column': 4, 'index': 3384}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 78, 'column': 11, 'index': 3447}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 4130}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 4130}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 4185}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 4185}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 97, 'column': 4, 'index': 4240}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 97, 'column': 4, 'index': 4240}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 4295}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 4295}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 109, 'column': 4, 'index': 4885}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 109, 'column': 4, 'index': 4885}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 110, 'column': 4, 'index': 4940}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 110, 'column': 4, 'index': 4940}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 111, 'column': 4, 'index': 4995}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 111, 'column': 4, 'index': 4995}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 112, 'column': 4, 'index': 5050}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 112, 'column': 4, 'index': 5050}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 130, 'column': 4, 'index': 5767}","it('does not progress past the same stage twice in one goal manager', function() {
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    stageFinished = gm.finishLevel();
    return expect(session.get('state').capstoneStage).toBe(2);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 130, 'column': 4, 'index': 5767}","it('does not progress past the same stage twice in one goal manager', function() {
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    stageFinished = gm.finishLevel();
    return expect(session.get('state').capstoneStage).toBe(2);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 133, 'column': 11, 'index': 5869}","it('does not progress past the same stage twice in one goal manager', function() {
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    stageFinished = gm.finishLevel();
    return expect(session.get('state').capstoneStage).toBe(2);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 133, 'column': 11, 'index': 5869}","it('does not progress past the same stage twice in one goal manager', function() {
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    stageFinished = gm.finishLevel();
    return expect(session.get('state').capstoneStage).toBe(2);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 166, 'column': 4, 'index': 7100}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 167, 'column': 4, 'index': 7168}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 167, 'column': 4, 'index': 7168}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 168, 'column': 4, 'index': 7248}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 168, 'column': 4, 'index': 7248}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 169, 'column': 4, 'index': 7328}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 181, 'column': 4, 'index': 7994}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 182, 'column': 4, 'index': 8059}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 184, 'column': 4, 'index': 8217}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 215, 'column': 4, 'index': 9642}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 215, 'column': 4, 'index': 9642}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 216, 'column': 4, 'index': 9722}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 216, 'column': 4, 'index': 9722}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 217, 'column': 4, 'index': 9802}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 218, 'column': 4, 'index': 9861}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 218, 'column': 4, 'index': 9861}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 219, 'column': 4, 'index': 9926}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 219, 'column': 4, 'index': 9926}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 230, 'column': 4, 'index': 10588}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 232, 'column': 4, 'index': 10746}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 233, 'column': 4, 'index': 10806}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 233, 'column': 4, 'index': 10806}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 236, 'column': 4, 'index': 11031}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 236, 'column': 4, 'index': 11031}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 247, 'column': 4, 'index': 11431}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 247, 'column': 4, 'index': 11431}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 248, 'column': 4, 'index': 11486}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 248, 'column': 4, 'index': 11486}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 249, 'column': 4, 'index': 11542}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 249, 'column': 4, 'index': 11542}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 250, 'column': 4, 'index': 11598}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 250, 'column': 4, 'index': 11598}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 267, 'column': 4, 'index': 12290}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 267, 'column': 4, 'index': 12290}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 268, 'column': 4, 'index': 12345}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 268, 'column': 4, 'index': 12345}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 269, 'column': 4, 'index': 12401}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 269, 'column': 4, 'index': 12401}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 270, 'column': 4, 'index': 12457}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 270, 'column': 4, 'index': 12457}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 290, 'column': 4, 'index': 13486}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 290, 'column': 4, 'index': 13486}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 13541}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 13541}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 292, 'column': 4, 'index': 13597}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 292, 'column': 4, 'index': 13597}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 293, 'column': 4, 'index': 13653}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 293, 'column': 4, 'index': 13653}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 309, 'column': 4, 'index': 14186}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 309, 'column': 4, 'index': 14186}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 310, 'column': 4, 'index': 14241}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 310, 'column': 4, 'index': 14241}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 311, 'column': 4, 'index': 14297}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 311, 'column': 4, 'index': 14297}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 312, 'column': 4, 'index': 14353}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 312, 'column': 4, 'index': 14353}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 333, 'column': 4, 'index': 15336}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 333, 'column': 4, 'index': 15336}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 334, 'column': 4, 'index': 15374}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 351, 'column': 4, 'index': 15988}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 351, 'column': 4, 'index': 15988}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 352, 'column': 4, 'index': 16026}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 376, 'column': 4, 'index': 17202}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 377, 'column': 4, 'index': 17258}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Duplicate Assert,"{'line': 377, 'column': 4, 'index': 17258}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 48, 'column': 45, 'index': 2250}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 55, 'column': 52, 'index': 2591}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 68, 'column': 45, 'index': 3103}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 90, 'column': 47, 'index': 3958}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 98, 'column': 45, 'index': 4336}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 99, 'column': 52, 'index': 4393}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 112, 'column': 45, 'index': 5091}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 116, 'column': 55, 'index': 5359}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 117, 'column': 57, 'index': 5420}","it('adds new additional goals without affecting old goals', function() {
    const gm = new GoalManager();
    // Add and complete a regular goal
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    expect(gm.getRemainingGoals().length).toBe(0);

    // Progress to the next capstoneStage without affecting goals
    gm.progressCapstoneStage(session, additionalGoals);
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(session.get('state').capstoneStage).toBe(2);

    // Add additional goals, expecting them to be incomplete while original goals are still complete
    const newGm = new GoalManager(undefined, [killGoal], undefined, { session, additionalGoals });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.Guy1).toBe(undefined);
    expect(goalStates.additionalkillguy.killed.Guy2).toBe(undefined);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    return expect(newGm.getRemainingGoals().length).toBe(1);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 130, 'column': 52, 'index': 5815}","it('does not progress past the same stage twice in one goal manager', function() {
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    stageFinished = gm.finishLevel();
    return expect(session.get('state').capstoneStage).toBe(2);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 133, 'column': 59, 'index': 5917}","it('does not progress past the same stage twice in one goal manager', function() {
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    stageFinished = gm.finishLevel();
    return expect(session.get('state').capstoneStage).toBe(2);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 149, 'column': 45, 'index': 6539}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 150, 'column': 47, 'index': 6591}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 154, 'column': 52, 'index': 6705}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 169, 'column': 55, 'index': 7379}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 184, 'column': 55, 'index': 8268}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 189, 'column': 57, 'index': 8618}","it('adds all additionalGoals for the next stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    expect(goalStates.killguy.keyFrame).toBe(20);
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);

    // Complete all goals for the world, as world generation resets goals
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();
    goalStates = newGm.getGoalStates();

    // Expect all additional goals to be completed
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 201, 'column': 52, 'index': 9114}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 217, 'column': 55, 'index': 9853}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 232, 'column': 55, 'index': 10797}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 237, 'column': 57, 'index': 11147}","it('does not add additionalGoals when they don\'t match the stage', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    gm.worldGenerationEnded();

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [killGoal], {}, {
      session,
      additionalGoals
    });
    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.worldGenerationEnded();

    // Add additional goals and expect them to be incomplete
    let goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(false);
    expect(goalStates.additionalkillguy.keyFrame).toBe(0);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    goalStates = newGm.getGoalStates();
    expect(goalStates.additionalkillguy2).toBeUndefined(); // The goals for the next stage should not be defined yet
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    return expect(newGm.getRemainingGoals().length).toBe(0);
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 254, 'column': 52, 'index': 11757}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 274, 'column': 55, 'index': 12784}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 279, 'column': 50, 'index': 13127}","it('reports that all goals are complete when additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');

    gm.progressCapstoneStage(session, additionalGoals);

    expect(session.get('state').capstoneStage).toBe(2);
    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    // Both original goals (saving saveguy) and additional goals are complete, so the whole world is complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('success');
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy1).toBe(true);
    expect(goalStates.additionalkillguy.killed.AdditionalKillGuy2).toBe(true);
    expect(goalStates.additionalkillguy.keyFrame).toBe(40);
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(0);
    return expect(newGm.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 294, 'column': 47, 'index': 13749}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 297, 'column': 52, 'index': 13862}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 318, 'column': 50, 'index': 14808}","it('reports that not all goals are complete when not all additionalGoals have been completed', function() {
    const gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(gm.getRemainingGoals().length).toBe(0);

    gm.progressCapstoneStage(session, additionalGoals);
    expect(session.get('state').capstoneStage).toBe(2);

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    // No events mean that the save goal is completed
    newGm.worldGenerationWillBegin();
    newGm.worldGenerationEnded();

    // Only the save goal should be complete
    goalStates = newGm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe('end');
    expect(goalStates.additionalkillguy.status).toBe('incomplete');
    expect(goalStates.additionalsaveguy.status).toBe('success');
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy1).toBe(false);
    expect(goalStates.additionalsaveguy.killed.AdditionalSaveGuy2).toBe(false);
    expect(goalStates.additionalsaveguy.keyFrame).toBe('end');
    expect(newGm.getRemainingGoals().length).toBe(1);
    return expect(newGm.checkOverallStatus()).not.toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 334, 'column': 52, 'index': 15422}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 352, 'column': 52, 'index': 16074}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 372, 'column': 56, 'index': 17077}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 376, 'column': 52, 'index': 17250}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.ozar.js,Magic Number,"{'line': 378, 'column': 51, 'index': 17343}","it('progresses to the next capstoneStage when completing all goals', function() {
    // Create the goal manager in the more traditional way with a mocked session
    const gm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();

    // Use goalManager.finishLevel() to progress through capstoneStages
    let stageFinished = gm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(2);

    // The new goal should not exist yet
    let goalStates = gm.getGoalStates();
    expect(goalStates.additionalkillguy).toBeUndefined();

    const newGm = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    newGm.worldGenerationWillBegin();
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm.worldGenerationEnded();

    stageFinished = newGm.finishLevel();
    expect(stageFinished).toBe(true);
    expect(session.get('state').capstoneStage).toBe(3);

    const newGm2 = new GoalManager(null, [saveGoal], {}, {
      session,
      additionalGoals
    });

    // We have to complete all goals as the world resets when worldGenerationWillBegin() runs
    newGm2.worldGenerationWillBegin();
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy1'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy2'}}, 40);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy3'}}, 30);
    newGm2.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'AdditionalKillGuy4'}}, 40);
    newGm2.worldGenerationEnded();

    goalStates = newGm2.getGoalStates();

    expect(goalStates.additionalkillguy2.status).toBe('success');
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy3).toBe(true);
    expect(goalStates.additionalkillguy2.killed.AdditionalKillGuy4).toBe(true);
    expect(goalStates.additionalkillguy2.keyFrame).toBe(40);

    // The level should now stay complete, with no new goals being added
    stageFinished = newGm2.finishLevel();
    expect(session.get('state').capstoneStage).toBe(4);
    expect(stageFinished).toBe(true);
    expect(newGm2.getRemainingGoals().length).toBe(0);
    return expect(newGm2.checkOverallStatus()).toBe('success');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 1403}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 1461}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 1461}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 1516}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 1572}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1741}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1796}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1796}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 1851}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 37, 'column': 11, 'index': 1913}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 2259}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 2314}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 2369}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 2369}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 50, 'column': 4, 'index': 2425}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 2636}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 2691}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 2747}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 2747}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Duplicate Assert,"{'line': 60, 'column': 11, 'index': 2810}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Magic Number,"{'line': 30, 'column': 45, 'index': 1613}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Magic Number,"{'line': 37, 'column': 52, 'index': 1954}","it('handles kill goal', function() {
    const gm = new GoalManager();
    gm.setGoals([killGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('incomplete');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(false);
    expect(goalStates.killguy.keyFrame).toBe(0);

    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy2'}}, 20);
    goalStates = gm.getGoalStates();
    expect(goalStates.killguy.status).toBe('success');
    expect(goalStates.killguy.killed.Guy1).toBe(true);
    expect(goalStates.killguy.killed.Guy2).toBe(true);
    return expect(goalStates.killguy.keyFrame).toBe(20);
  })",steel
/test/app/lib/world/GoalManager.spec.coco.js,Magic Number,"{'line': 50, 'column': 45, 'index': 2466}","it('handles save goal', function() {
    let gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.submitWorldGenerationEvent('world:thang-died', {thang: {id: 'Guy1'}}, 10);
    gm.worldGenerationEnded();
    let goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('failure');
    expect(goalStates.saveguy.killed.Guy1).toBe(true);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    expect(goalStates.saveguy.keyFrame).toBe(10);

    gm = new GoalManager();
    gm.setGoals([saveGoal]);
    gm.worldGenerationWillBegin();
    gm.worldGenerationEnded();
    goalStates = gm.getGoalStates();
    expect(goalStates.saveguy.status).toBe('success');
    expect(goalStates.saveguy.killed.Guy1).toBe(false);
    expect(goalStates.saveguy.killed.Guy2).toBe(false);
    return expect(goalStates.saveguy.keyFrame).toBe('end');
  })",steel
/test/app/lib/surface/SingularSprite.spec.js,Conditional Test Logic,"{'line': 34, 'column': 8, 'index': 1352}","describe('SingularSprite', function() {
  let singularSprite = null;
  let stage = null;

  const showMe = function() {
    const canvas = $('<canvas width=""600"" height=""400""></canvas>').css('position', 'absolute').css('index', 1000).css('background', 'white');
    $('body').append(canvas);
    stage = new createjs.Stage(canvas[0]);
    stage.addChild(singularSprite);
    const scale = 3;
    stage.scaleX = (stage.scaleY = scale);
    stage.regX = -300 / scale;
    stage.regY = -200 / scale;
    window.stage = stage;

    let ticks = 0;
    const listener = {
      handleEvent() {
        if (ticks >= 100) { return; }
        ticks += 1;
        return stage.update();
      }
    };
    return createjs.Ticker.addEventListener(""tick"", listener);
  };

  afterEach(function() {
    const g = new createjs.Graphics();
    g.beginFill(createjs.Graphics.getRGB(64,255,64,0.7));
    g.drawCircle(0, 0, 1);
    const s = new createjs.Shape(g);
    return stage.addChild(s);
  });

  describe('with Tree ThangType', function() {
    beforeEach(function() {
      const layer = new LayerAdapter({webGL:true, name:'Default'});
      layer.buildAutomatically = false;
      layer.buildAsync = false;
      treeThangType.markToRevert();
      treeThangType.set('spriteType', 'singular');
      const sprite = new Lank(treeThangType);
      layer.addLank(sprite);
      const sheet = layer.renderNewSpriteSheet();
      const prefix = layer.renderGroupingKey(treeThangType) + '.';
      window.singularSprite = (singularSprite = new SingularSprite(sheet, treeThangType, prefix));
      singularSprite.x = 0;
      return singularSprite.y = 0;
    });

    it('scales rendered containers to the size of the source container, taking into account ThangType scaling', function() {
      // build a movie clip, put it on top of the singular sprite and make sure
      // they both 'hit' at the same time.

      singularSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(treeThangType);
      const container = builder.buildContainerFromStore('Tree_4');
      container.regX = 59;
      container.regY = 100;
      container.scaleX = (container.scaleY = 0.3);
      showMe();
      stage.addChild(container);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-15, -30, 35, 40));
      return expect(hitRate).toBeGreaterThan(0.92);
    });
//      $('canvas').remove()

    return it('scales placeholder containers to the size of the source container, taking into account ThangType scaling', function() {
      // build a movie clip, put it on top of the singular sprite and make sure
      // they both 'hit' at the same time.

      singularSprite.usePlaceholders = true;
      singularSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(treeThangType);
      const container = builder.buildContainerFromStore('Tree_4');
      container.regX = 59;
      container.regY = 100;
      container.scaleX = (container.scaleY = 0.3);
      showMe();
      stage.addChild(container);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-15, -30, 35, 40));
      return expect(hitRate).toBeGreaterThan(0.73);
    });
  });
//      $('canvas').remove()

  return describe('with Ogre Munchkin ThangType', function() {
    beforeEach(function() {
      const layer = new LayerAdapter({webGL:true, name:'Default'});
      layer.buildAutomatically = false;
      layer.buildAsync = false;
      ogreMunchkinThangType.markToRevert();
      ogreMunchkinThangType.set('spriteType', 'singular');
      const actions = ogreMunchkinThangType.getActions();

      const colorConfig = {team: {hue: 0, saturation: 1, lightness: 0.5}};
      const sprite = new Lank(ogreMunchkinThangType, {colorConfig});
      layer.addLank(sprite);
      const sheet = layer.renderNewSpriteSheet();
      const prefix = layer.renderGroupingKey(ogreMunchkinThangType, null, colorConfig) + '.';
      return window.singularSprite = (singularSprite = new SingularSprite(sheet, ogreMunchkinThangType, prefix));
    });

    afterEach(() => ogreMunchkinThangType.revert());

    it('has the same interface as Sprite for animation', function() {
      singularSprite.gotoAndPlay('move_fore');
      return singularSprite.gotoAndStop('attack');
    });

    it('scales rendered animations like a MovieClip, taking into account ThangType scaling', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      singularSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.91);
      return $('canvas').remove();
    });

    return it('scales placeholder animations like a MovieClip, taking into account ThangType scaling', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      singularSprite.usePlaceholders = true;
      singularSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.71);
      return $('canvas').remove();
    });
  });
})",steel
/test/app/lib/surface/SingularSprite.spec.js,Magic Number,"{'line': 80, 'column': 45, 'index': 3136}","it('scales rendered containers to the size of the source container, taking into account ThangType scaling', function() {
      // build a movie clip, put it on top of the singular sprite and make sure
      // they both 'hit' at the same time.

      singularSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(treeThangType);
      const container = builder.buildContainerFromStore('Tree_4');
      container.regX = 59;
      container.regY = 100;
      container.scaleX = (container.scaleY = 0.3);
      showMe();
      stage.addChild(container);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-15, -30, 35, 40));
      return expect(hitRate).toBeGreaterThan(0.92);
    })",steel
/test/app/lib/surface/SingularSprite.spec.js,Magic Number,"{'line': 99, 'column': 45, 'index': 3967}","it('scales placeholder containers to the size of the source container, taking into account ThangType scaling', function() {
      // build a movie clip, put it on top of the singular sprite and make sure
      // they both 'hit' at the same time.

      singularSprite.usePlaceholders = true;
      singularSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(treeThangType);
      const container = builder.buildContainerFromStore('Tree_4');
      container.regX = 59;
      container.regY = 100;
      container.scaleX = (container.scaleY = 0.3);
      showMe();
      stage.addChild(container);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-15, -30, 35, 40));
      return expect(hitRate).toBeGreaterThan(0.73);
    })",steel
/test/app/lib/surface/SingularSprite.spec.js,Magic Number,"{'line': 143, 'column': 38, 'index': 5827}","it('scales rendered animations like a MovieClip, taking into account ThangType scaling', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      singularSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.91);
      return $('canvas').remove();
    })",steel
/test/app/lib/surface/SingularSprite.spec.js,Magic Number,"{'line': 163, 'column': 38, 'index': 6678}","it('scales placeholder animations like a MovieClip, taking into account ThangType scaling', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      singularSprite.usePlaceholders = true;
      singularSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.71);
      return $('canvas').remove();
    })",steel
/test/app/lib/surface/SingularSprite.spec.js,Unknown Test,"{'column': 4, 'line': 123}","it('has the same interface as Sprite for animation', function() {
      singularSprite.gotoAndPlay('move_fore');
      return singularSprite.gotoAndStop('attack');
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Conditional Test Logic,"{'line': 37, 'column': 8, 'index': 1562}","describe('SegmentedSprite', function() {
  let segmentedSprite = null;
  let stage = null;

  const showMe = function() {
    const canvas = $('<canvas width=""600"" height=""400""></canvas>').css('position', 'absolute').css('index', 1000).css('background', 'white');
    $('body').append(canvas);
    stage = new createjs.Stage(canvas[0]);
    stage.addChild(segmentedSprite);
    const scale = 3;
    stage.scaleX = (stage.scaleY = scale);
    stage.regX = -300 / scale;
    stage.regY = -200 / scale;
    window.stage = stage;

    let ticks = 0;
    const listener = {
      handleEvent() {
        if (ticks >= 100) { return; }
        ticks += 1;
        segmentedSprite.tick(arguments[0].delta);
        return stage.update();
      }
    };
    return createjs.Ticker.addEventListener(""tick"", listener);
  };

  describe('with Tree ThangType', function() {
    beforeEach(function() {
      const layer = new LayerAdapter({webGL:true, name:'Default'});
      layer.buildAutomatically = false;
      layer.buildAsync = false;
      treeThangType.markToRevert();
      treeThangType.set('spriteType', 'segmented');
      const sprite = new Lank(treeThangType);
      layer.addLank(sprite);
      const sheet = layer.renderNewSpriteSheet();
      const prefix = layer.renderGroupingKey(treeThangType) + '.';
      return window.segmentedSprite = (segmentedSprite = new SegmentedSprite(sheet, treeThangType, prefix));
    });

    it('scales rendered containers to the size of the source container', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(treeThangType);
      const container = builder.buildContainerFromStore('Tree_4');
      container.scaleX = (container.scaleY = 0.3);
      container.regX = 59;
      container.regY = 100;
      showMe();
      stage.addChild(container);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-15, -30, 35, 40));
      expect(hitRate).toBeGreaterThan(0.92);
      return $('canvas').remove();
    });

    return it('scales placeholder containers to the size of the source container', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      segmentedSprite.usePlaceholders = true;
      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(treeThangType);
      const container = builder.buildContainerFromStore('Tree_4');
      container.scaleX = (container.scaleY = 0.3);
      container.regX = 59;
      container.regY = 100;
      showMe();
      stage.addChild(container);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-15, -30, 35, 40));
      expect(hitRate).toBeGreaterThan(0.73);
      return $('canvas').remove();
    });
  });

  describe('with Ogre Munchkin ThangType', function() {
    beforeEach(function() {
      const layer = new LayerAdapter({webGL:true, name:'Default'});
      layer.buildAutomatically = false;
      layer.buildAsync = false;
      ogreMunchkinThangType.markToRevert();
      ogreMunchkinThangType.set('spriteType', 'segmented');
      const actions = ogreMunchkinThangType.getActions();

      // couple extra actions for doing some tests
      actions.littledance = {animation:'enemy_small_move_side',framerate:1, frames:'0,6,2,6,2,8,0', name: 'littledance'};
      actions.onestep = {animation:'enemy_small_move_side', loops: false, name:'onestep'};
      actions.head = {container:'head', name:'head'};

      const colorConfig = {team: {hue: 0, saturation: 1, lightness: 0.5}};
      const sprite = new Lank(ogreMunchkinThangType, {colorConfig});
      layer.addLank(sprite);
      const sheet = layer.renderNewSpriteSheet();
      const prefix = layer.renderGroupingKey(ogreMunchkinThangType, null, colorConfig) + '.';
      return window.segmentedSprite = (segmentedSprite = new SegmentedSprite(sheet, ogreMunchkinThangType, prefix));
    });

    afterEach(() => ogreMunchkinThangType.revert());

    it('has gotoAndPlay, gotoAndStop, currentAnimation, and paused like a MovieClip or Sprite', function() {
      segmentedSprite.gotoAndPlay('move_fore');
      expect(segmentedSprite.baseMovieClip).toBeDefined();
      expect(segmentedSprite.paused).toBe(false);
      segmentedSprite.gotoAndStop('move_fore');
      expect(segmentedSprite.paused).toBe(true);
      return expect(segmentedSprite.currentAnimation).toBe('move_fore');
    });

    it('has a tick function which moves the animation forward', function() {
      segmentedSprite.gotoAndPlay('attack');
      segmentedSprite.tick(100); // one hundred milliseconds
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe((segmentedSprite.framerate*100)/1000);
    });

    it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    });

    it('emits animationend for animations where loops is false and there is no goesTo', function(done) {
      let fired = false;
      segmentedSprite.gotoAndPlay('onestep');
      segmentedSprite.on('animationend', () => fired = true);
      segmentedSprite.tick(1000);
      return _.defer(function() { // because the event is deferred
        expect(fired).toBe(true);
        return done();
      });
    });

    it('scales rendered animations like a MovieClip', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);

      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.91);
      expect(segmentedSprite.baseScaleX).toBe(0.3);
      expect(segmentedSprite.baseScaleY).toBe(0.3);
      return $('canvas').remove();
    });

    return it('scales placeholder animations like a MovieClip', function() {
      segmentedSprite.usePlaceholders = true;
      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.96);
      return $('canvas').remove();
    });
  });

  return describe('with Ogre Fangrider ThangType', function() {
    beforeEach(function() {
      const layer = new LayerAdapter({webGL:true});
      layer.buildAutomatically = false;
      layer.buildAsync = false;
      ogreFangriderThangType.markToRevert();
      ogreFangriderThangType.set('spriteType', 'segmented');
      const colorConfig = {team: {hue: 0, saturation: 1, lightness: 0.5}};
      const sprite = new Lank(ogreFangriderThangType, {colorConfig});
      layer.addLank(sprite);
      const sheet = layer.renderNewSpriteSheet();
      const prefix = layer.renderGroupingKey(ogreFangriderThangType, null, colorConfig) + '.';
      return window.segmentedSprite = (segmentedSprite = new SegmentedSprite(sheet, ogreFangriderThangType, prefix));
    });

    afterEach(() => ogreFangriderThangType.revert());

    it('synchronizes animations with child movie clips properly', function() {
      segmentedSprite.gotoAndPlay('die');
      segmentedSprite.tick(100); // one hundred milliseconds
      const expectedFrame = (segmentedSprite.framerate*100)/1000;
      expect(segmentedSprite.currentFrame).toBe(expectedFrame);
      return Array.from(segmentedSprite.childMovieClips).map((movieClip) =>
        expect(movieClip.currentFrame).toBe(expectedFrame));
    });

    it('does not include shapes from the original animation', function() {
      segmentedSprite.gotoAndPlay('attack');
      segmentedSprite.tick(230);
      return Array.from(segmentedSprite.children).map((child) =>
        expect(_.isString(child)).toBe(false));
    });

    return it('maintains the right number of shapes', function() {
      segmentedSprite.gotoAndPlay('idle');
      const lengths = [];
      return (() => {
        const result = [];
        for (var i of Array.from(_.range(10))) {
          segmentedSprite.tick(10);
          result.push(expect(segmentedSprite.children.length).toBe(20));
        }
        return result;
      })();
    });
  });
})",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Conditional Test Logic,"{'line': 238, 'column': 8, 'index': 10139}","it('maintains the right number of shapes', function() {
      segmentedSprite.gotoAndPlay('idle');
      const lengths = [];
      return (() => {
        const result = [];
        for (var i of Array.from(_.range(10))) {
          segmentedSprite.tick(10);
          result.push(expect(segmentedSprite.children.length).toBe(20));
        }
        return result;
      })();
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Duplicate Assert,"{'line': 125, 'column': 6, 'index': 5353}","it('has gotoAndPlay, gotoAndStop, currentAnimation, and paused like a MovieClip or Sprite', function() {
      segmentedSprite.gotoAndPlay('move_fore');
      expect(segmentedSprite.baseMovieClip).toBeDefined();
      expect(segmentedSprite.paused).toBe(false);
      segmentedSprite.gotoAndStop('move_fore');
      expect(segmentedSprite.paused).toBe(true);
      return expect(segmentedSprite.currentAnimation).toBe('move_fore');
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Duplicate Assert,"{'line': 127, 'column': 6, 'index': 5451}","it('has gotoAndPlay, gotoAndStop, currentAnimation, and paused like a MovieClip or Sprite', function() {
      segmentedSprite.gotoAndPlay('move_fore');
      expect(segmentedSprite.baseMovieClip).toBeDefined();
      expect(segmentedSprite.paused).toBe(false);
      segmentedSprite.gotoAndStop('move_fore');
      expect(segmentedSprite.paused).toBe(true);
      return expect(segmentedSprite.currentAnimation).toBe('move_fore');
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Duplicate Assert,"{'line': 140, 'column': 6, 'index': 6043}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Duplicate Assert,"{'line': 140, 'column': 6, 'index': 6043}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Duplicate Assert,"{'line': 142, 'column': 6, 'index': 6143}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Duplicate Assert,"{'line': 144, 'column': 6, 'index': 6242}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Duplicate Assert,"{'line': 146, 'column': 13, 'index': 6348}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Duplicate Assert,"{'line': 146, 'column': 13, 'index': 6348}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Global Variable,"{'line': 238, 'column': 13, 'index': 10144}","it('maintains the right number of shapes', function() {
      segmentedSprite.gotoAndPlay('idle');
      const lengths = [];
      return (() => {
        const result = [];
        for (var i of Array.from(_.range(10))) {
          segmentedSprite.tick(10);
          result.push(expect(segmentedSprite.children.length).toBe(20));
        }
        return result;
      })();
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 74, 'column': 38, 'index': 3077}","it('scales rendered containers to the size of the source container', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(treeThangType);
      const container = builder.buildContainerFromStore('Tree_4');
      container.scaleX = (container.scaleY = 0.3);
      container.regX = 59;
      container.regY = 100;
      showMe();
      stage.addChild(container);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-15, -30, 35, 40));
      expect(hitRate).toBeGreaterThan(0.92);
      return $('canvas').remove();
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 93, 'column': 38, 'index': 3871}","it('scales placeholder containers to the size of the source container', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      segmentedSprite.usePlaceholders = true;
      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(treeThangType);
      const container = builder.buildContainerFromStore('Tree_4');
      container.scaleX = (container.scaleY = 0.3);
      container.regX = 59;
      container.regY = 100;
      showMe();
      stage.addChild(container);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-15, -30, 35, 40));
      expect(hitRate).toBeGreaterThan(0.73);
      return $('canvas').remove();
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 140, 'column': 62, 'index': 6099}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 142, 'column': 62, 'index': 6199}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 144, 'column': 62, 'index': 6298}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 146, 'column': 69, 'index': 6404}","it('will interpolate between frames of a custom frame set', function() {
      segmentedSprite.gotoAndPlay('littledance');
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
      segmentedSprite.tick(1000);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(2);
      segmentedSprite.tick(500);
      expect(segmentedSprite.baseMovieClip.currentFrame).toBe(4);
      segmentedSprite.tick(500);
      return expect(segmentedSprite.baseMovieClip.currentFrame).toBe(6);
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 176, 'column': 38, 'index': 7540}","it('scales rendered animations like a MovieClip', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);

      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.91);
      expect(segmentedSprite.baseScaleX).toBe(0.3);
      expect(segmentedSprite.baseScaleY).toBe(0.3);
      return $('canvas').remove();
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 177, 'column': 46, 'index': 7593}","it('scales rendered animations like a MovieClip', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);

      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.91);
      expect(segmentedSprite.baseScaleX).toBe(0.3);
      expect(segmentedSprite.baseScaleY).toBe(0.3);
      return $('canvas').remove();
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 178, 'column': 46, 'index': 7645}","it('scales rendered animations like a MovieClip', function() {
      // build a movie clip, put it on top of the segmented sprite and make sure
      // they both 'hit' at the same time.

      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);

      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.91);
      expect(segmentedSprite.baseScaleX).toBe(0.3);
      expect(segmentedSprite.baseScaleY).toBe(0.3);
      return $('canvas').remove();
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 195, 'column': 38, 'index': 8333}","it('scales placeholder animations like a MovieClip', function() {
      segmentedSprite.usePlaceholders = true;
      segmentedSprite.gotoAndStop('idle');
      const builder = new SpriteBuilder(ogreMunchkinThangType);
      const movieClip = builder.buildMovieClip('enemy_small_move_side');
      movieClip.scaleX = (movieClip.scaleY = 0.3);
      movieClip.regX = 285;
      movieClip.regY = 300;
      movieClip.stop();
      showMe();
      stage.addChild(movieClip);
      stage.update();
      const hitRate = scaleTestUtils.hitTest(stage, new createjs.Rectangle(-10, -30, 25, 35));
      expect(hitRate).toBeGreaterThan(0.96);
      return $('canvas').remove();
    })",steel
/test/app/lib/surface/SegmentedSprite.spec.js,Magic Number,"{'line': 240, 'column': 67, 'index': 10283}","it('maintains the right number of shapes', function() {
      segmentedSprite.gotoAndPlay('idle');
      const lengths = [];
      return (() => {
        const result = [];
        for (var i of Array.from(_.range(10))) {
          segmentedSprite.tick(10);
          result.push(expect(segmentedSprite.children.length).toBe(20));
        }
        return result;
      })();
    })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Conditional Test Logic,"{'line': 151, 'column': 4, 'index': 7136}","it('recycles *containers* from previous sprite sheets, rather than building repeatedly from raw vector data', function() {
    treeThangType.set('spriteType', 'segmented');
    const sprite = new Lank(treeThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildContainerFromStore').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      var sheet = layer.renderNewSpriteSheet();
    }
    return expect(SpriteBuilder.prototype.buildContainerFromStore.calls.count()).toBe(1);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Conditional Test Logic,"{'line': 162, 'column': 4, 'index': 7652}","it('*does not* recycle *containers* from previous sprite sheets when the resolutionFactor has changed', function() {
    treeThangType.set('spriteType', 'segmented');
    const sprite = new Lank(treeThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildContainerFromStore').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      layer.resolutionFactor *= 1.1;
      var sheet = layer.renderNewSpriteSheet();
    }
    return expect(SpriteBuilder.prototype.buildContainerFromStore.calls.count()).toBe(2);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Conditional Test Logic,"{'line': 175, 'column': 4, 'index': 8245}","it('recycles *animations* from previous sprite sheets, rather than building repeatedly from raw vector data', function() {
    ogreMunchkinThangType.set('spriteType', 'singular');
    const sprite = new Lank(ogreMunchkinThangType);
    layer.addLank(sprite);
    const numFrameses = [];
    spyOn(SpriteBuilder.prototype, 'buildMovieClip').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      var sheet = layer.renderNewSpriteSheet();
      numFrameses.push(sheet.getNumFrames());
    }

    // this process should not have created any new frames
    expect(numFrameses[0]).toBe(numFrameses[1]);

    // one movie clip made for each raw animation: move (3), attack, die
    return expect(SpriteBuilder.prototype.buildMovieClip.calls.count()).toBe(5);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Conditional Test Logic,"{'line': 192, 'column': 4, 'index': 8995}","it('*does not* recycles *animations* from previous sprite sheets when the resolutionFactor has changed', function() {
    ogreMunchkinThangType.set('spriteType', 'singular');
    const sprite = new Lank(ogreMunchkinThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildMovieClip').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      layer.resolutionFactor *= 1.1;
      var sheet = layer.renderNewSpriteSheet();
    }

    return expect(SpriteBuilder.prototype.buildMovieClip.calls.count()).toBe(10);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 112, 'column': 4, 'index': 5168}","it('loads raster images for ThangType', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    spyOn(thangType, 'loadRasterImage');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': bootsThangTypeData});
    spyOn(layer, 'renderNewSpriteSheet');
    expect(layer.numThingsLoading).toBe(1);
    expect(thangType.loadRasterImage).toHaveBeenCalled();
    thangType.loadedRaster = true;
    thangType.trigger('raster-image-loaded', thangType);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer.renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 112, 'column': 4, 'index': 5168}","it('loads raster images for ThangType', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    spyOn(thangType, 'loadRasterImage');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': bootsThangTypeData});
    spyOn(layer, 'renderNewSpriteSheet');
    expect(layer.numThingsLoading).toBe(1);
    expect(thangType.loadRasterImage).toHaveBeenCalled();
    thangType.loadedRaster = true;
    thangType.trigger('raster-image-loaded', thangType);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer.renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 116, 'column': 4, 'index': 5378}","it('loads raster images for ThangType', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    spyOn(thangType, 'loadRasterImage');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': bootsThangTypeData});
    spyOn(layer, 'renderNewSpriteSheet');
    expect(layer.numThingsLoading).toBe(1);
    expect(thangType.loadRasterImage).toHaveBeenCalled();
    thangType.loadedRaster = true;
    thangType.trigger('raster-image-loaded', thangType);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer.renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 116, 'column': 4, 'index': 5378}","it('loads raster images for ThangType', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    spyOn(thangType, 'loadRasterImage');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': bootsThangTypeData});
    spyOn(layer, 'renderNewSpriteSheet');
    expect(layer.numThingsLoading).toBe(1);
    expect(thangType.loadRasterImage).toHaveBeenCalled();
    thangType.loadedRaster = true;
    thangType.trigger('raster-image-loaded', thangType);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer.renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 120, 'column': 4, 'index': 5572}","it('loads raster images for ThangType', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    spyOn(thangType, 'loadRasterImage');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': bootsThangTypeData});
    spyOn(layer, 'renderNewSpriteSheet');
    expect(layer.numThingsLoading).toBe(1);
    expect(thangType.loadRasterImage).toHaveBeenCalled();
    thangType.loadedRaster = true;
    thangType.trigger('raster-image-loaded', thangType);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer.renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 129, 'column': 4, 'index': 5991}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 129, 'column': 4, 'index': 5991}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 131, 'column': 4, 'index': 6076}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 135, 'column': 4, 'index': 6302}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 135, 'column': 4, 'index': 6302}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 6429}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 6429}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 138, 'column': 4, 'index': 6473}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 142, 'column': 4, 'index': 6691}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Duplicate Assert,"{'line': 143, 'column': 11, 'index': 6742}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Global Variable,"{'line': 151, 'column': 9, 'index': 7141}","it('recycles *containers* from previous sprite sheets, rather than building repeatedly from raw vector data', function() {
    treeThangType.set('spriteType', 'segmented');
    const sprite = new Lank(treeThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildContainerFromStore').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      var sheet = layer.renderNewSpriteSheet();
    }
    return expect(SpriteBuilder.prototype.buildContainerFromStore.calls.count()).toBe(1);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Global Variable,"{'line': 152, 'column': 6, 'index': 7182}","it('recycles *containers* from previous sprite sheets, rather than building repeatedly from raw vector data', function() {
    treeThangType.set('spriteType', 'segmented');
    const sprite = new Lank(treeThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildContainerFromStore').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      var sheet = layer.renderNewSpriteSheet();
    }
    return expect(SpriteBuilder.prototype.buildContainerFromStore.calls.count()).toBe(1);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Global Variable,"{'line': 162, 'column': 9, 'index': 7657}","it('*does not* recycle *containers* from previous sprite sheets when the resolutionFactor has changed', function() {
    treeThangType.set('spriteType', 'segmented');
    const sprite = new Lank(treeThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildContainerFromStore').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      layer.resolutionFactor *= 1.1;
      var sheet = layer.renderNewSpriteSheet();
    }
    return expect(SpriteBuilder.prototype.buildContainerFromStore.calls.count()).toBe(2);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Global Variable,"{'line': 164, 'column': 6, 'index': 7735}","it('*does not* recycle *containers* from previous sprite sheets when the resolutionFactor has changed', function() {
    treeThangType.set('spriteType', 'segmented');
    const sprite = new Lank(treeThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildContainerFromStore').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      layer.resolutionFactor *= 1.1;
      var sheet = layer.renderNewSpriteSheet();
    }
    return expect(SpriteBuilder.prototype.buildContainerFromStore.calls.count()).toBe(2);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Global Variable,"{'line': 175, 'column': 9, 'index': 8250}","it('recycles *animations* from previous sprite sheets, rather than building repeatedly from raw vector data', function() {
    ogreMunchkinThangType.set('spriteType', 'singular');
    const sprite = new Lank(ogreMunchkinThangType);
    layer.addLank(sprite);
    const numFrameses = [];
    spyOn(SpriteBuilder.prototype, 'buildMovieClip').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      var sheet = layer.renderNewSpriteSheet();
      numFrameses.push(sheet.getNumFrames());
    }

    // this process should not have created any new frames
    expect(numFrameses[0]).toBe(numFrameses[1]);

    // one movie clip made for each raw animation: move (3), attack, die
    return expect(SpriteBuilder.prototype.buildMovieClip.calls.count()).toBe(5);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Global Variable,"{'line': 176, 'column': 6, 'index': 8291}","it('recycles *animations* from previous sprite sheets, rather than building repeatedly from raw vector data', function() {
    ogreMunchkinThangType.set('spriteType', 'singular');
    const sprite = new Lank(ogreMunchkinThangType);
    layer.addLank(sprite);
    const numFrameses = [];
    spyOn(SpriteBuilder.prototype, 'buildMovieClip').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      var sheet = layer.renderNewSpriteSheet();
      numFrameses.push(sheet.getNumFrames());
    }

    // this process should not have created any new frames
    expect(numFrameses[0]).toBe(numFrameses[1]);

    // one movie clip made for each raw animation: move (3), attack, die
    return expect(SpriteBuilder.prototype.buildMovieClip.calls.count()).toBe(5);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Global Variable,"{'line': 192, 'column': 9, 'index': 9000}","it('*does not* recycles *animations* from previous sprite sheets when the resolutionFactor has changed', function() {
    ogreMunchkinThangType.set('spriteType', 'singular');
    const sprite = new Lank(ogreMunchkinThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildMovieClip').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      layer.resolutionFactor *= 1.1;
      var sheet = layer.renderNewSpriteSheet();
    }

    return expect(SpriteBuilder.prototype.buildMovieClip.calls.count()).toBe(10);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Global Variable,"{'line': 194, 'column': 6, 'index': 9078}","it('*does not* recycles *animations* from previous sprite sheets when the resolutionFactor has changed', function() {
    ogreMunchkinThangType.set('spriteType', 'singular');
    const sprite = new Lank(ogreMunchkinThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildMovieClip').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      layer.resolutionFactor *= 1.1;
      var sheet = layer.renderNewSpriteSheet();
    }

    return expect(SpriteBuilder.prototype.buildMovieClip.calls.count()).toBe(10);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 76, 'column': 35, 'index': 3627}","it('only renders frames used by actions when spriteType=singular', function() {
    const oldDefaults = ThangType.defaultActions;
    ThangType.defaultActions = ['idle']; // uses the move side animation
    ogreMunchkinThangType.set('spriteType', 'singular');
    const colorConfig = {team: {hue: 0, saturation: 1, lightness: 0.5}};
    const sprite = new Lank(ogreMunchkinThangType, {colorConfig});
    layer.addLank(sprite);
    const sheet = layer.renderNewSpriteSheet();
    const key = layer.renderGroupingKey(ogreMunchkinThangType, 'idle', colorConfig);
    const animations = sheet.getAnimations();
    expect(animations.length).toBe(1);
    expect(animations[0]).toBe(key);
    expect(sheet.getNumFrames()).toBe(2); // one idle frame, and the emptiness frame
    return ThangType.defaultActions = oldDefaults;
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 78, 'column': 38, 'index': 3706}","it('only renders frames used by actions when spriteType=singular', function() {
    const oldDefaults = ThangType.defaultActions;
    ThangType.defaultActions = ['idle']; // uses the move side animation
    ogreMunchkinThangType.set('spriteType', 'singular');
    const colorConfig = {team: {hue: 0, saturation: 1, lightness: 0.5}};
    const sprite = new Lank(ogreMunchkinThangType, {colorConfig});
    layer.addLank(sprite);
    const sheet = layer.renderNewSpriteSheet();
    const key = layer.renderGroupingKey(ogreMunchkinThangType, 'idle', colorConfig);
    const animations = sheet.getAnimations();
    expect(animations.length).toBe(1);
    expect(animations[0]).toBe(key);
    expect(sheet.getNumFrames()).toBe(2); // one idle frame, and the emptiness frame
    return ThangType.defaultActions = oldDefaults;
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 103, 'column': 40, 'index': 4840}","it('loads ThangTypes for Lanks that are added to it and need to be loaded', function() {
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    return expect(jasmine.Ajax.requests.count()).toBe(1);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 104, 'column': 54, 'index': 4898}","it('loads ThangTypes for Lanks that are added to it and need to be loaded', function() {
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    return expect(jasmine.Ajax.requests.count()).toBe(1);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 112, 'column': 40, 'index': 5204}","it('loads raster images for ThangType', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    spyOn(thangType, 'loadRasterImage');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': bootsThangTypeData});
    spyOn(layer, 'renderNewSpriteSheet');
    expect(layer.numThingsLoading).toBe(1);
    expect(thangType.loadRasterImage).toHaveBeenCalled();
    thangType.loadedRaster = true;
    thangType.trigger('raster-image-loaded', thangType);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer.renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 116, 'column': 40, 'index': 5414}","it('loads raster images for ThangType', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    spyOn(thangType, 'loadRasterImage');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': bootsThangTypeData});
    spyOn(layer, 'renderNewSpriteSheet');
    expect(layer.numThingsLoading).toBe(1);
    expect(thangType.loadRasterImage).toHaveBeenCalled();
    thangType.loadedRaster = true;
    thangType.trigger('raster-image-loaded', thangType);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer.renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 120, 'column': 40, 'index': 5608}","it('loads raster images for ThangType', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType = new ThangType({_id: 1});
    const sprite = new Lank(thangType);
    layer.addLank(sprite);
    expect(layer.numThingsLoading).toBe(1);
    spyOn(thangType, 'loadRasterImage');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': bootsThangTypeData});
    spyOn(layer, 'renderNewSpriteSheet');
    expect(layer.numThingsLoading).toBe(1);
    expect(thangType.loadRasterImage).toHaveBeenCalled();
    thangType.loadedRaster = true;
    thangType.trigger('raster-image-loaded', thangType);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer.renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 129, 'column': 40, 'index': 6027}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 131, 'column': 40, 'index': 6112}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 135, 'column': 40, 'index': 6338}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 137, 'column': 40, 'index': 6465}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 142, 'column': 40, 'index': 6727}","it('renders a new SpriteSheet only once everything has loaded', function() {
    const bootsThangTypeData = require('test/app/fixtures/leather-boots.thang.type');
    const thangType1 = new ThangType({_id: 1});
    const thangType2 = new ThangType({_id: 2});
    layer.addLank(new Lank(thangType1));
    expect(layer.numThingsLoading).toBe(1);
    layer.addLank(new Lank(thangType2));
    expect(layer.numThingsLoading).toBe(2);
    spyOn(thangType2, 'loadRasterImage');
    spyOn(layer, '_renderNewSpriteSheet');
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/1': ogreMunchkinThangType.attributes});
    expect(layer.numThingsLoading).toBe(1);
    jasmine.Ajax.requests.sendResponses({'/db/thang.type/2': bootsThangTypeData});
    expect(layer.numThingsLoading).toBe(1);
    expect(layer._renderNewSpriteSheet).not.toHaveBeenCalled();
    expect(thangType2.loadRasterImage).toHaveBeenCalled();
    thangType2.loadedRaster = true;
    thangType2.trigger('raster-image-loaded', thangType2);
    expect(layer.numThingsLoading).toBe(0);
    return expect(layer._renderNewSpriteSheet).toHaveBeenCalled();
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 154, 'column': 86, 'index': 7316}","it('recycles *containers* from previous sprite sheets, rather than building repeatedly from raw vector data', function() {
    treeThangType.set('spriteType', 'segmented');
    const sprite = new Lank(treeThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildContainerFromStore').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      var sheet = layer.renderNewSpriteSheet();
    }
    return expect(SpriteBuilder.prototype.buildContainerFromStore.calls.count()).toBe(1);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 166, 'column': 86, 'index': 7869}","it('*does not* recycle *containers* from previous sprite sheets when the resolutionFactor has changed', function() {
    treeThangType.set('spriteType', 'segmented');
    const sprite = new Lank(treeThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildContainerFromStore').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      layer.resolutionFactor *= 1.1;
      var sheet = layer.renderNewSpriteSheet();
    }
    return expect(SpriteBuilder.prototype.buildContainerFromStore.calls.count()).toBe(2);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 184, 'column': 77, 'index': 8645}","it('recycles *animations* from previous sprite sheets, rather than building repeatedly from raw vector data', function() {
    ogreMunchkinThangType.set('spriteType', 'singular');
    const sprite = new Lank(ogreMunchkinThangType);
    layer.addLank(sprite);
    const numFrameses = [];
    spyOn(SpriteBuilder.prototype, 'buildMovieClip').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      var sheet = layer.renderNewSpriteSheet();
      numFrameses.push(sheet.getNumFrames());
    }

    // this process should not have created any new frames
    expect(numFrameses[0]).toBe(numFrameses[1]);

    // one movie clip made for each raw animation: move (3), attack, die
    return expect(SpriteBuilder.prototype.buildMovieClip.calls.count()).toBe(5);
  })",steel
/test/app/lib/surface/LayerAdapter.spec.js,Magic Number,"{'line': 197, 'column': 77, 'index': 9204}","it('*does not* recycles *animations* from previous sprite sheets when the resolutionFactor has changed', function() {
    ogreMunchkinThangType.set('spriteType', 'singular');
    const sprite = new Lank(ogreMunchkinThangType);
    layer.addLank(sprite);
    spyOn(SpriteBuilder.prototype, 'buildMovieClip').and.callThrough();
    for (var i of Array.from(_.range(2))) {
      layer.resolutionFactor *= 1.1;
      var sheet = layer.renderNewSpriteSheet();
    }

    return expect(SpriteBuilder.prototype.buildMovieClip.calls.count()).toBe(10);
  })",steel
/test/app/lib/surface/LankBoss.spec.js,Conditional Test Logic,"{'line': 31, 'column': 4, 'index': 1306}","describe('LankBoss', function() {
  let lankBoss = null;
  let canvas = null;
  let stage = null;
  const midRenderExpectations = []; // bit of a hack to move tests which happen mid-initialization into a separate test

  // This suite just creates and renders the stage once, and then has each of the tests
  // check the resulting data for the whole thing, without changing anything.

  const init = function(done) {
    let thang;
    if (lankBoss) { return done(); }
    const t = new Date();
    canvas = $('<canvas width=""800"" height=""600""></canvas>');
    const camera = new Camera(canvas);

    // Create an initial, simple world with just trees
    const world = new World();
    world.thangs = [
      // Set trees side by side with different render strategies
      {id: 'Segmented Tree', spriteName: 'Segmented Tree', exists: true, shape: 'disc', depth: 2, pos: {x:10, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },
      {id: 'Singular Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },

      // Include a tree whose existence will change so we can test removing sprites
      {id: 'Disappearing Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:0, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true }
    ];
    world.thangMap = {};
    for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }

    // Set up thang types. Mix renderStrategies.
    const fangrider = new ThangType($.extend({}, fangriderData, {spriteType:'segmented', name:'Fangrider', slug:'fangrider'}));
    const segmentedMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'segmented', name:'Segmented Munchkin', slug:'segmented-munchkin'}));
    const singularMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'singular', name:'Singular Munchkin', slug:'singular-munchkin'}));
    const segmentedTree = new ThangType($.extend({}, treeData, {spriteType:'segmented', name:'Segmented Tree', slug: 'segmented-tree'}));
    const singularTree = new ThangType($.extend({}, treeData, {spriteType:'singular', name:'Singular Tree', slug: 'singular-tree'}));

    const thangTypes = [fangrider, segmentedMunchkin, singularMunchkin, segmentedTree, singularTree];

    // Build the Stage and LankBoss.
    window.stage = (stage = new createjs.StageGL(canvas[0]));
    const options = {
      camera,
      webGLStage: stage,
      surfaceTextLayer: new createjs.Container(),
      world,
      thangTypes,
      gameUIState: new GameUIState()
    };

    window.lankBoss = (lankBoss = new LankBoss(options));

    const defaultLayer = lankBoss.layerAdapters.Default;
    defaultLayer.buildAsync = false; // cause faster

    // Sort of an implicit test. By default, all the default actions are always rendered,
    // but I want to make sure the system can dynamically hear about actions it needs to render for
    // as they are used.
    defaultLayer.defaultActions = ['idle'];

    // Render the simple world with just trees
    lankBoss.update(true);

    // Test that the unrendered, static sprites aren't showing anything
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children.length,1,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].currentFrame,0,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].paused,true,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.currentFrame,0,'static singular action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.paused,true,'static singular action']);

    return defaultLayer.once('new-spritesheet', function() {

      // Now make the world a little more complicated.
      world.thangs = world.thangs.concat([
        // four cardinal ogres, to test movement rotation and placement around a center point.
        {id: 'Ogre N', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, scaleFactorX: 1.5, hudProperties: ['health'] },
        {id: 'Ogre W', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:0, z: 1}, action: 'move', health: 8, maxHealth: 10, rotation: 0, acts: true, scaleFactorY: 1.5, hudProperties: ['health'] },
        {id: 'Ogre E', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:0, z: 1}, action: 'move', health: 5, maxHealth: 10, rotation: Math.PI, acts: true, alpha: 0.5, hudProperties: ['health'] },
        {id: 'Ogre S', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:-8, z: 1}, action: 'move', health: 2, maxHealth: 10, rotation: Math.PI/2, acts: true, hudProperties: ['health'], effectNames: ['curse'] },

        // Set ogres side by side with different render strategies
        {id: 'Singular Ogre', spriteName: 'Singular Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-10, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, alpha: 0.5 },
        {id: 'Segmented Ogre', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true },

        // A line of ogres overlapping to test child ordering
        {id: 'Dying Ogre 1', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-14, y:0, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 2', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13.5, y:1, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 3', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13, y:2, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 4', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-12.5, y:3, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },

        // Throw in a ThangType that contains nested MovieClips
        {id: 'Fangrider', spriteName: 'Fangrider', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:8, z: 1}, action: 'move', health: 20, maxHealth: 20, rotation: 0, acts: true, currentEvents: ['aoe-' + JSON.stringify([0, 0, 8, '#00F'])] }
      ]);

      _.find(world.thangs, {id: 'Disappearing Tree'}).exists = false;
      for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }
      lankBoss.update(true);
      jasmine.Ajax.requests.sendResponses({'/db/thang.type/curse': curseData});

      // Test that the unrendered, animated sprites aren't showing anything
      midRenderExpectations.push([lankBoss.lanks['Segmented Ogre'].sprite.children.length,10,'animated segmented action']);
      for (var child of Array.from(lankBoss.lanks['Segmented Ogre'].sprite.children)) {
        midRenderExpectations.push([child.children[0].currentFrame, 0, 'animated segmented action']);
      }
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.currentFrame,0,'animated singular action']);
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.paused,true,'animated singular action']);

      return defaultLayer.once('new-spritesheet', () => //        showMe() # Uncomment to display this world when you run any of these tests.
      done());
    });
  };

  beforeEach(done => init(done));

  const showMe = function() {
    canvas.css('position', 'absolute').css('index', 1000).css('background', 'white');
    $('body').append(canvas);

    let ticks = 0;
    const listener = {
      handleEvent() {
        if (ticks >= 100) { return; }
        ticks += 1;
        if ((ticks % 20) === 0) {
          lankBoss.update(true);
        }
        return stage.update();
      }
    };
    createjs.Ticker.addEventListener(""tick"", listener);
    return $('body').append($('<div style=""position: absolute; top: 295px; left: 395px; height: 10px; width: 10px; background: red;""></div>'));
  };

  it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })());

  it('rotates and animates sprites according to thang rotation', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.currentAnimation).toBe('move_fore');
    expect(lankBoss.lanks['Ogre E'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre W'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre S'].sprite.currentAnimation).toBe('move_back');

    expect(lankBoss.lanks['Ogre E'].sprite.scaleX).toBeLessThan(0);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleX).toBeGreaterThan(0);
  });

  it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  });

  it('scales sprites according to thang scaleFactorX and scaleFactorY', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.scaleX).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleX * 1.5);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleY).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleY * 1.5);
  });

  it('sets alpha based on thang alpha', () => expect(lankBoss.lanks['Ogre E'].sprite.alpha).toBe(0.5));

  return it('orders sprites in the layer based on thang pos.y\'s', function() {
    const {
      container
    } = lankBoss.layerAdapters.Default;
    const l = container.children;
    const i1 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 1'));
    const i2 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 2'));
    const i3 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 3'));
    const i4 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 4'));
    expect(i1).toBeGreaterThan(i2);
    expect(i2).toBeGreaterThan(i3);
    return expect(i3).toBeGreaterThan(i4);
  });
})",steel
/test/app/lib/surface/LankBoss.spec.js,Conditional Test Logic,"{'line': 47, 'column': 4, 'index': 2359}","describe('LankBoss', function() {
  let lankBoss = null;
  let canvas = null;
  let stage = null;
  const midRenderExpectations = []; // bit of a hack to move tests which happen mid-initialization into a separate test

  // This suite just creates and renders the stage once, and then has each of the tests
  // check the resulting data for the whole thing, without changing anything.

  const init = function(done) {
    let thang;
    if (lankBoss) { return done(); }
    const t = new Date();
    canvas = $('<canvas width=""800"" height=""600""></canvas>');
    const camera = new Camera(canvas);

    // Create an initial, simple world with just trees
    const world = new World();
    world.thangs = [
      // Set trees side by side with different render strategies
      {id: 'Segmented Tree', spriteName: 'Segmented Tree', exists: true, shape: 'disc', depth: 2, pos: {x:10, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },
      {id: 'Singular Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },

      // Include a tree whose existence will change so we can test removing sprites
      {id: 'Disappearing Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:0, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true }
    ];
    world.thangMap = {};
    for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }

    // Set up thang types. Mix renderStrategies.
    const fangrider = new ThangType($.extend({}, fangriderData, {spriteType:'segmented', name:'Fangrider', slug:'fangrider'}));
    const segmentedMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'segmented', name:'Segmented Munchkin', slug:'segmented-munchkin'}));
    const singularMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'singular', name:'Singular Munchkin', slug:'singular-munchkin'}));
    const segmentedTree = new ThangType($.extend({}, treeData, {spriteType:'segmented', name:'Segmented Tree', slug: 'segmented-tree'}));
    const singularTree = new ThangType($.extend({}, treeData, {spriteType:'singular', name:'Singular Tree', slug: 'singular-tree'}));

    const thangTypes = [fangrider, segmentedMunchkin, singularMunchkin, segmentedTree, singularTree];

    // Build the Stage and LankBoss.
    window.stage = (stage = new createjs.StageGL(canvas[0]));
    const options = {
      camera,
      webGLStage: stage,
      surfaceTextLayer: new createjs.Container(),
      world,
      thangTypes,
      gameUIState: new GameUIState()
    };

    window.lankBoss = (lankBoss = new LankBoss(options));

    const defaultLayer = lankBoss.layerAdapters.Default;
    defaultLayer.buildAsync = false; // cause faster

    // Sort of an implicit test. By default, all the default actions are always rendered,
    // but I want to make sure the system can dynamically hear about actions it needs to render for
    // as they are used.
    defaultLayer.defaultActions = ['idle'];

    // Render the simple world with just trees
    lankBoss.update(true);

    // Test that the unrendered, static sprites aren't showing anything
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children.length,1,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].currentFrame,0,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].paused,true,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.currentFrame,0,'static singular action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.paused,true,'static singular action']);

    return defaultLayer.once('new-spritesheet', function() {

      // Now make the world a little more complicated.
      world.thangs = world.thangs.concat([
        // four cardinal ogres, to test movement rotation and placement around a center point.
        {id: 'Ogre N', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, scaleFactorX: 1.5, hudProperties: ['health'] },
        {id: 'Ogre W', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:0, z: 1}, action: 'move', health: 8, maxHealth: 10, rotation: 0, acts: true, scaleFactorY: 1.5, hudProperties: ['health'] },
        {id: 'Ogre E', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:0, z: 1}, action: 'move', health: 5, maxHealth: 10, rotation: Math.PI, acts: true, alpha: 0.5, hudProperties: ['health'] },
        {id: 'Ogre S', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:-8, z: 1}, action: 'move', health: 2, maxHealth: 10, rotation: Math.PI/2, acts: true, hudProperties: ['health'], effectNames: ['curse'] },

        // Set ogres side by side with different render strategies
        {id: 'Singular Ogre', spriteName: 'Singular Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-10, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, alpha: 0.5 },
        {id: 'Segmented Ogre', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true },

        // A line of ogres overlapping to test child ordering
        {id: 'Dying Ogre 1', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-14, y:0, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 2', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13.5, y:1, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 3', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13, y:2, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 4', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-12.5, y:3, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },

        // Throw in a ThangType that contains nested MovieClips
        {id: 'Fangrider', spriteName: 'Fangrider', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:8, z: 1}, action: 'move', health: 20, maxHealth: 20, rotation: 0, acts: true, currentEvents: ['aoe-' + JSON.stringify([0, 0, 8, '#00F'])] }
      ]);

      _.find(world.thangs, {id: 'Disappearing Tree'}).exists = false;
      for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }
      lankBoss.update(true);
      jasmine.Ajax.requests.sendResponses({'/db/thang.type/curse': curseData});

      // Test that the unrendered, animated sprites aren't showing anything
      midRenderExpectations.push([lankBoss.lanks['Segmented Ogre'].sprite.children.length,10,'animated segmented action']);
      for (var child of Array.from(lankBoss.lanks['Segmented Ogre'].sprite.children)) {
        midRenderExpectations.push([child.children[0].currentFrame, 0, 'animated segmented action']);
      }
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.currentFrame,0,'animated singular action']);
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.paused,true,'animated singular action']);

      return defaultLayer.once('new-spritesheet', () => //        showMe() # Uncomment to display this world when you run any of these tests.
      done());
    });
  };

  beforeEach(done => init(done));

  const showMe = function() {
    canvas.css('position', 'absolute').css('index', 1000).css('background', 'white');
    $('body').append(canvas);

    let ticks = 0;
    const listener = {
      handleEvent() {
        if (ticks >= 100) { return; }
        ticks += 1;
        if ((ticks % 20) === 0) {
          lankBoss.update(true);
        }
        return stage.update();
      }
    };
    createjs.Ticker.addEventListener(""tick"", listener);
    return $('body').append($('<div style=""position: absolute; top: 295px; left: 395px; height: 10px; width: 10px; background: red;""></div>'));
  };

  it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })());

  it('rotates and animates sprites according to thang rotation', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.currentAnimation).toBe('move_fore');
    expect(lankBoss.lanks['Ogre E'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre W'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre S'].sprite.currentAnimation).toBe('move_back');

    expect(lankBoss.lanks['Ogre E'].sprite.scaleX).toBeLessThan(0);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleX).toBeGreaterThan(0);
  });

  it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  });

  it('scales sprites according to thang scaleFactorX and scaleFactorY', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.scaleX).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleX * 1.5);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleY).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleY * 1.5);
  });

  it('sets alpha based on thang alpha', () => expect(lankBoss.lanks['Ogre E'].sprite.alpha).toBe(0.5));

  return it('orders sprites in the layer based on thang pos.y\'s', function() {
    const {
      container
    } = lankBoss.layerAdapters.Default;
    const l = container.children;
    const i1 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 1'));
    const i2 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 2'));
    const i3 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 3'));
    const i4 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 4'));
    expect(i1).toBeGreaterThan(i2);
    expect(i2).toBeGreaterThan(i3);
    return expect(i3).toBeGreaterThan(i4);
  });
})",steel
/test/app/lib/surface/LankBoss.spec.js,Conditional Test Logic,"{'line': 114, 'column': 6, 'index': 7706}","describe('LankBoss', function() {
  let lankBoss = null;
  let canvas = null;
  let stage = null;
  const midRenderExpectations = []; // bit of a hack to move tests which happen mid-initialization into a separate test

  // This suite just creates and renders the stage once, and then has each of the tests
  // check the resulting data for the whole thing, without changing anything.

  const init = function(done) {
    let thang;
    if (lankBoss) { return done(); }
    const t = new Date();
    canvas = $('<canvas width=""800"" height=""600""></canvas>');
    const camera = new Camera(canvas);

    // Create an initial, simple world with just trees
    const world = new World();
    world.thangs = [
      // Set trees side by side with different render strategies
      {id: 'Segmented Tree', spriteName: 'Segmented Tree', exists: true, shape: 'disc', depth: 2, pos: {x:10, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },
      {id: 'Singular Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },

      // Include a tree whose existence will change so we can test removing sprites
      {id: 'Disappearing Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:0, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true }
    ];
    world.thangMap = {};
    for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }

    // Set up thang types. Mix renderStrategies.
    const fangrider = new ThangType($.extend({}, fangriderData, {spriteType:'segmented', name:'Fangrider', slug:'fangrider'}));
    const segmentedMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'segmented', name:'Segmented Munchkin', slug:'segmented-munchkin'}));
    const singularMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'singular', name:'Singular Munchkin', slug:'singular-munchkin'}));
    const segmentedTree = new ThangType($.extend({}, treeData, {spriteType:'segmented', name:'Segmented Tree', slug: 'segmented-tree'}));
    const singularTree = new ThangType($.extend({}, treeData, {spriteType:'singular', name:'Singular Tree', slug: 'singular-tree'}));

    const thangTypes = [fangrider, segmentedMunchkin, singularMunchkin, segmentedTree, singularTree];

    // Build the Stage and LankBoss.
    window.stage = (stage = new createjs.StageGL(canvas[0]));
    const options = {
      camera,
      webGLStage: stage,
      surfaceTextLayer: new createjs.Container(),
      world,
      thangTypes,
      gameUIState: new GameUIState()
    };

    window.lankBoss = (lankBoss = new LankBoss(options));

    const defaultLayer = lankBoss.layerAdapters.Default;
    defaultLayer.buildAsync = false; // cause faster

    // Sort of an implicit test. By default, all the default actions are always rendered,
    // but I want to make sure the system can dynamically hear about actions it needs to render for
    // as they are used.
    defaultLayer.defaultActions = ['idle'];

    // Render the simple world with just trees
    lankBoss.update(true);

    // Test that the unrendered, static sprites aren't showing anything
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children.length,1,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].currentFrame,0,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].paused,true,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.currentFrame,0,'static singular action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.paused,true,'static singular action']);

    return defaultLayer.once('new-spritesheet', function() {

      // Now make the world a little more complicated.
      world.thangs = world.thangs.concat([
        // four cardinal ogres, to test movement rotation and placement around a center point.
        {id: 'Ogre N', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, scaleFactorX: 1.5, hudProperties: ['health'] },
        {id: 'Ogre W', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:0, z: 1}, action: 'move', health: 8, maxHealth: 10, rotation: 0, acts: true, scaleFactorY: 1.5, hudProperties: ['health'] },
        {id: 'Ogre E', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:0, z: 1}, action: 'move', health: 5, maxHealth: 10, rotation: Math.PI, acts: true, alpha: 0.5, hudProperties: ['health'] },
        {id: 'Ogre S', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:-8, z: 1}, action: 'move', health: 2, maxHealth: 10, rotation: Math.PI/2, acts: true, hudProperties: ['health'], effectNames: ['curse'] },

        // Set ogres side by side with different render strategies
        {id: 'Singular Ogre', spriteName: 'Singular Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-10, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, alpha: 0.5 },
        {id: 'Segmented Ogre', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true },

        // A line of ogres overlapping to test child ordering
        {id: 'Dying Ogre 1', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-14, y:0, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 2', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13.5, y:1, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 3', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13, y:2, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 4', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-12.5, y:3, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },

        // Throw in a ThangType that contains nested MovieClips
        {id: 'Fangrider', spriteName: 'Fangrider', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:8, z: 1}, action: 'move', health: 20, maxHealth: 20, rotation: 0, acts: true, currentEvents: ['aoe-' + JSON.stringify([0, 0, 8, '#00F'])] }
      ]);

      _.find(world.thangs, {id: 'Disappearing Tree'}).exists = false;
      for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }
      lankBoss.update(true);
      jasmine.Ajax.requests.sendResponses({'/db/thang.type/curse': curseData});

      // Test that the unrendered, animated sprites aren't showing anything
      midRenderExpectations.push([lankBoss.lanks['Segmented Ogre'].sprite.children.length,10,'animated segmented action']);
      for (var child of Array.from(lankBoss.lanks['Segmented Ogre'].sprite.children)) {
        midRenderExpectations.push([child.children[0].currentFrame, 0, 'animated segmented action']);
      }
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.currentFrame,0,'animated singular action']);
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.paused,true,'animated singular action']);

      return defaultLayer.once('new-spritesheet', () => //        showMe() # Uncomment to display this world when you run any of these tests.
      done());
    });
  };

  beforeEach(done => init(done));

  const showMe = function() {
    canvas.css('position', 'absolute').css('index', 1000).css('background', 'white');
    $('body').append(canvas);

    let ticks = 0;
    const listener = {
      handleEvent() {
        if (ticks >= 100) { return; }
        ticks += 1;
        if ((ticks % 20) === 0) {
          lankBoss.update(true);
        }
        return stage.update();
      }
    };
    createjs.Ticker.addEventListener(""tick"", listener);
    return $('body').append($('<div style=""position: absolute; top: 295px; left: 395px; height: 10px; width: 10px; background: red;""></div>'));
  };

  it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })());

  it('rotates and animates sprites according to thang rotation', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.currentAnimation).toBe('move_fore');
    expect(lankBoss.lanks['Ogre E'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre W'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre S'].sprite.currentAnimation).toBe('move_back');

    expect(lankBoss.lanks['Ogre E'].sprite.scaleX).toBeLessThan(0);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleX).toBeGreaterThan(0);
  });

  it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  });

  it('scales sprites according to thang scaleFactorX and scaleFactorY', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.scaleX).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleX * 1.5);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleY).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleY * 1.5);
  });

  it('sets alpha based on thang alpha', () => expect(lankBoss.lanks['Ogre E'].sprite.alpha).toBe(0.5));

  return it('orders sprites in the layer based on thang pos.y\'s', function() {
    const {
      container
    } = lankBoss.layerAdapters.Default;
    const l = container.children;
    const i1 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 1'));
    const i2 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 2'));
    const i3 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 3'));
    const i4 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 4'));
    expect(i1).toBeGreaterThan(i2);
    expect(i2).toBeGreaterThan(i3);
    return expect(i3).toBeGreaterThan(i4);
  });
})",steel
/test/app/lib/surface/LankBoss.spec.js,Conditional Test Logic,"{'line': 120, 'column': 6, 'index': 8100}","describe('LankBoss', function() {
  let lankBoss = null;
  let canvas = null;
  let stage = null;
  const midRenderExpectations = []; // bit of a hack to move tests which happen mid-initialization into a separate test

  // This suite just creates and renders the stage once, and then has each of the tests
  // check the resulting data for the whole thing, without changing anything.

  const init = function(done) {
    let thang;
    if (lankBoss) { return done(); }
    const t = new Date();
    canvas = $('<canvas width=""800"" height=""600""></canvas>');
    const camera = new Camera(canvas);

    // Create an initial, simple world with just trees
    const world = new World();
    world.thangs = [
      // Set trees side by side with different render strategies
      {id: 'Segmented Tree', spriteName: 'Segmented Tree', exists: true, shape: 'disc', depth: 2, pos: {x:10, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },
      {id: 'Singular Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },

      // Include a tree whose existence will change so we can test removing sprites
      {id: 'Disappearing Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:0, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true }
    ];
    world.thangMap = {};
    for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }

    // Set up thang types. Mix renderStrategies.
    const fangrider = new ThangType($.extend({}, fangriderData, {spriteType:'segmented', name:'Fangrider', slug:'fangrider'}));
    const segmentedMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'segmented', name:'Segmented Munchkin', slug:'segmented-munchkin'}));
    const singularMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'singular', name:'Singular Munchkin', slug:'singular-munchkin'}));
    const segmentedTree = new ThangType($.extend({}, treeData, {spriteType:'segmented', name:'Segmented Tree', slug: 'segmented-tree'}));
    const singularTree = new ThangType($.extend({}, treeData, {spriteType:'singular', name:'Singular Tree', slug: 'singular-tree'}));

    const thangTypes = [fangrider, segmentedMunchkin, singularMunchkin, segmentedTree, singularTree];

    // Build the Stage and LankBoss.
    window.stage = (stage = new createjs.StageGL(canvas[0]));
    const options = {
      camera,
      webGLStage: stage,
      surfaceTextLayer: new createjs.Container(),
      world,
      thangTypes,
      gameUIState: new GameUIState()
    };

    window.lankBoss = (lankBoss = new LankBoss(options));

    const defaultLayer = lankBoss.layerAdapters.Default;
    defaultLayer.buildAsync = false; // cause faster

    // Sort of an implicit test. By default, all the default actions are always rendered,
    // but I want to make sure the system can dynamically hear about actions it needs to render for
    // as they are used.
    defaultLayer.defaultActions = ['idle'];

    // Render the simple world with just trees
    lankBoss.update(true);

    // Test that the unrendered, static sprites aren't showing anything
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children.length,1,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].currentFrame,0,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].paused,true,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.currentFrame,0,'static singular action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.paused,true,'static singular action']);

    return defaultLayer.once('new-spritesheet', function() {

      // Now make the world a little more complicated.
      world.thangs = world.thangs.concat([
        // four cardinal ogres, to test movement rotation and placement around a center point.
        {id: 'Ogre N', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, scaleFactorX: 1.5, hudProperties: ['health'] },
        {id: 'Ogre W', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:0, z: 1}, action: 'move', health: 8, maxHealth: 10, rotation: 0, acts: true, scaleFactorY: 1.5, hudProperties: ['health'] },
        {id: 'Ogre E', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:0, z: 1}, action: 'move', health: 5, maxHealth: 10, rotation: Math.PI, acts: true, alpha: 0.5, hudProperties: ['health'] },
        {id: 'Ogre S', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:-8, z: 1}, action: 'move', health: 2, maxHealth: 10, rotation: Math.PI/2, acts: true, hudProperties: ['health'], effectNames: ['curse'] },

        // Set ogres side by side with different render strategies
        {id: 'Singular Ogre', spriteName: 'Singular Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-10, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, alpha: 0.5 },
        {id: 'Segmented Ogre', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true },

        // A line of ogres overlapping to test child ordering
        {id: 'Dying Ogre 1', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-14, y:0, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 2', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13.5, y:1, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 3', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13, y:2, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 4', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-12.5, y:3, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },

        // Throw in a ThangType that contains nested MovieClips
        {id: 'Fangrider', spriteName: 'Fangrider', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:8, z: 1}, action: 'move', health: 20, maxHealth: 20, rotation: 0, acts: true, currentEvents: ['aoe-' + JSON.stringify([0, 0, 8, '#00F'])] }
      ]);

      _.find(world.thangs, {id: 'Disappearing Tree'}).exists = false;
      for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }
      lankBoss.update(true);
      jasmine.Ajax.requests.sendResponses({'/db/thang.type/curse': curseData});

      // Test that the unrendered, animated sprites aren't showing anything
      midRenderExpectations.push([lankBoss.lanks['Segmented Ogre'].sprite.children.length,10,'animated segmented action']);
      for (var child of Array.from(lankBoss.lanks['Segmented Ogre'].sprite.children)) {
        midRenderExpectations.push([child.children[0].currentFrame, 0, 'animated segmented action']);
      }
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.currentFrame,0,'animated singular action']);
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.paused,true,'animated singular action']);

      return defaultLayer.once('new-spritesheet', () => //        showMe() # Uncomment to display this world when you run any of these tests.
      done());
    });
  };

  beforeEach(done => init(done));

  const showMe = function() {
    canvas.css('position', 'absolute').css('index', 1000).css('background', 'white');
    $('body').append(canvas);

    let ticks = 0;
    const listener = {
      handleEvent() {
        if (ticks >= 100) { return; }
        ticks += 1;
        if ((ticks % 20) === 0) {
          lankBoss.update(true);
        }
        return stage.update();
      }
    };
    createjs.Ticker.addEventListener(""tick"", listener);
    return $('body').append($('<div style=""position: absolute; top: 295px; left: 395px; height: 10px; width: 10px; background: red;""></div>'));
  };

  it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })());

  it('rotates and animates sprites according to thang rotation', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.currentAnimation).toBe('move_fore');
    expect(lankBoss.lanks['Ogre E'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre W'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre S'].sprite.currentAnimation).toBe('move_back');

    expect(lankBoss.lanks['Ogre E'].sprite.scaleX).toBeLessThan(0);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleX).toBeGreaterThan(0);
  });

  it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  });

  it('scales sprites according to thang scaleFactorX and scaleFactorY', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.scaleX).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleX * 1.5);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleY).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleY * 1.5);
  });

  it('sets alpha based on thang alpha', () => expect(lankBoss.lanks['Ogre E'].sprite.alpha).toBe(0.5));

  return it('orders sprites in the layer based on thang pos.y\'s', function() {
    const {
      container
    } = lankBoss.layerAdapters.Default;
    const l = container.children;
    const i1 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 1'));
    const i2 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 2'));
    const i3 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 3'));
    const i4 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 4'));
    expect(i1).toBeGreaterThan(i2);
    expect(i2).toBeGreaterThan(i3);
    return expect(i3).toBeGreaterThan(i4);
  });
})",steel
/test/app/lib/surface/LankBoss.spec.js,Conditional Test Logic,"{'line': 140, 'column': 8, 'index': 8951}","describe('LankBoss', function() {
  let lankBoss = null;
  let canvas = null;
  let stage = null;
  const midRenderExpectations = []; // bit of a hack to move tests which happen mid-initialization into a separate test

  // This suite just creates and renders the stage once, and then has each of the tests
  // check the resulting data for the whole thing, without changing anything.

  const init = function(done) {
    let thang;
    if (lankBoss) { return done(); }
    const t = new Date();
    canvas = $('<canvas width=""800"" height=""600""></canvas>');
    const camera = new Camera(canvas);

    // Create an initial, simple world with just trees
    const world = new World();
    world.thangs = [
      // Set trees side by side with different render strategies
      {id: 'Segmented Tree', spriteName: 'Segmented Tree', exists: true, shape: 'disc', depth: 2, pos: {x:10, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },
      {id: 'Singular Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },

      // Include a tree whose existence will change so we can test removing sprites
      {id: 'Disappearing Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:0, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true }
    ];
    world.thangMap = {};
    for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }

    // Set up thang types. Mix renderStrategies.
    const fangrider = new ThangType($.extend({}, fangriderData, {spriteType:'segmented', name:'Fangrider', slug:'fangrider'}));
    const segmentedMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'segmented', name:'Segmented Munchkin', slug:'segmented-munchkin'}));
    const singularMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'singular', name:'Singular Munchkin', slug:'singular-munchkin'}));
    const segmentedTree = new ThangType($.extend({}, treeData, {spriteType:'segmented', name:'Segmented Tree', slug: 'segmented-tree'}));
    const singularTree = new ThangType($.extend({}, treeData, {spriteType:'singular', name:'Singular Tree', slug: 'singular-tree'}));

    const thangTypes = [fangrider, segmentedMunchkin, singularMunchkin, segmentedTree, singularTree];

    // Build the Stage and LankBoss.
    window.stage = (stage = new createjs.StageGL(canvas[0]));
    const options = {
      camera,
      webGLStage: stage,
      surfaceTextLayer: new createjs.Container(),
      world,
      thangTypes,
      gameUIState: new GameUIState()
    };

    window.lankBoss = (lankBoss = new LankBoss(options));

    const defaultLayer = lankBoss.layerAdapters.Default;
    defaultLayer.buildAsync = false; // cause faster

    // Sort of an implicit test. By default, all the default actions are always rendered,
    // but I want to make sure the system can dynamically hear about actions it needs to render for
    // as they are used.
    defaultLayer.defaultActions = ['idle'];

    // Render the simple world with just trees
    lankBoss.update(true);

    // Test that the unrendered, static sprites aren't showing anything
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children.length,1,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].currentFrame,0,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].paused,true,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.currentFrame,0,'static singular action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.paused,true,'static singular action']);

    return defaultLayer.once('new-spritesheet', function() {

      // Now make the world a little more complicated.
      world.thangs = world.thangs.concat([
        // four cardinal ogres, to test movement rotation and placement around a center point.
        {id: 'Ogre N', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, scaleFactorX: 1.5, hudProperties: ['health'] },
        {id: 'Ogre W', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:0, z: 1}, action: 'move', health: 8, maxHealth: 10, rotation: 0, acts: true, scaleFactorY: 1.5, hudProperties: ['health'] },
        {id: 'Ogre E', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:0, z: 1}, action: 'move', health: 5, maxHealth: 10, rotation: Math.PI, acts: true, alpha: 0.5, hudProperties: ['health'] },
        {id: 'Ogre S', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:-8, z: 1}, action: 'move', health: 2, maxHealth: 10, rotation: Math.PI/2, acts: true, hudProperties: ['health'], effectNames: ['curse'] },

        // Set ogres side by side with different render strategies
        {id: 'Singular Ogre', spriteName: 'Singular Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-10, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, alpha: 0.5 },
        {id: 'Segmented Ogre', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true },

        // A line of ogres overlapping to test child ordering
        {id: 'Dying Ogre 1', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-14, y:0, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 2', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13.5, y:1, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 3', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13, y:2, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 4', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-12.5, y:3, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },

        // Throw in a ThangType that contains nested MovieClips
        {id: 'Fangrider', spriteName: 'Fangrider', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:8, z: 1}, action: 'move', health: 20, maxHealth: 20, rotation: 0, acts: true, currentEvents: ['aoe-' + JSON.stringify([0, 0, 8, '#00F'])] }
      ]);

      _.find(world.thangs, {id: 'Disappearing Tree'}).exists = false;
      for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }
      lankBoss.update(true);
      jasmine.Ajax.requests.sendResponses({'/db/thang.type/curse': curseData});

      // Test that the unrendered, animated sprites aren't showing anything
      midRenderExpectations.push([lankBoss.lanks['Segmented Ogre'].sprite.children.length,10,'animated segmented action']);
      for (var child of Array.from(lankBoss.lanks['Segmented Ogre'].sprite.children)) {
        midRenderExpectations.push([child.children[0].currentFrame, 0, 'animated segmented action']);
      }
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.currentFrame,0,'animated singular action']);
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.paused,true,'animated singular action']);

      return defaultLayer.once('new-spritesheet', () => //        showMe() # Uncomment to display this world when you run any of these tests.
      done());
    });
  };

  beforeEach(done => init(done));

  const showMe = function() {
    canvas.css('position', 'absolute').css('index', 1000).css('background', 'white');
    $('body').append(canvas);

    let ticks = 0;
    const listener = {
      handleEvent() {
        if (ticks >= 100) { return; }
        ticks += 1;
        if ((ticks % 20) === 0) {
          lankBoss.update(true);
        }
        return stage.update();
      }
    };
    createjs.Ticker.addEventListener(""tick"", listener);
    return $('body').append($('<div style=""position: absolute; top: 295px; left: 395px; height: 10px; width: 10px; background: red;""></div>'));
  };

  it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })());

  it('rotates and animates sprites according to thang rotation', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.currentAnimation).toBe('move_fore');
    expect(lankBoss.lanks['Ogre E'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre W'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre S'].sprite.currentAnimation).toBe('move_back');

    expect(lankBoss.lanks['Ogre E'].sprite.scaleX).toBeLessThan(0);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleX).toBeGreaterThan(0);
  });

  it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  });

  it('scales sprites according to thang scaleFactorX and scaleFactorY', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.scaleX).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleX * 1.5);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleY).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleY * 1.5);
  });

  it('sets alpha based on thang alpha', () => expect(lankBoss.lanks['Ogre E'].sprite.alpha).toBe(0.5));

  return it('orders sprites in the layer based on thang pos.y\'s', function() {
    const {
      container
    } = lankBoss.layerAdapters.Default;
    const l = container.children;
    const i1 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 1'));
    const i2 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 2'));
    const i3 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 3'));
    const i4 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 4'));
    expect(i1).toBeGreaterThan(i2);
    expect(i2).toBeGreaterThan(i3);
    return expect(i3).toBeGreaterThan(i4);
  });
})",steel
/test/app/lib/surface/LankBoss.spec.js,Conditional Test Logic,"{'line': 142, 'column': 8, 'index': 9009}","describe('LankBoss', function() {
  let lankBoss = null;
  let canvas = null;
  let stage = null;
  const midRenderExpectations = []; // bit of a hack to move tests which happen mid-initialization into a separate test

  // This suite just creates and renders the stage once, and then has each of the tests
  // check the resulting data for the whole thing, without changing anything.

  const init = function(done) {
    let thang;
    if (lankBoss) { return done(); }
    const t = new Date();
    canvas = $('<canvas width=""800"" height=""600""></canvas>');
    const camera = new Camera(canvas);

    // Create an initial, simple world with just trees
    const world = new World();
    world.thangs = [
      // Set trees side by side with different render strategies
      {id: 'Segmented Tree', spriteName: 'Segmented Tree', exists: true, shape: 'disc', depth: 2, pos: {x:10, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },
      {id: 'Singular Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },

      // Include a tree whose existence will change so we can test removing sprites
      {id: 'Disappearing Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:0, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true }
    ];
    world.thangMap = {};
    for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }

    // Set up thang types. Mix renderStrategies.
    const fangrider = new ThangType($.extend({}, fangriderData, {spriteType:'segmented', name:'Fangrider', slug:'fangrider'}));
    const segmentedMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'segmented', name:'Segmented Munchkin', slug:'segmented-munchkin'}));
    const singularMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'singular', name:'Singular Munchkin', slug:'singular-munchkin'}));
    const segmentedTree = new ThangType($.extend({}, treeData, {spriteType:'segmented', name:'Segmented Tree', slug: 'segmented-tree'}));
    const singularTree = new ThangType($.extend({}, treeData, {spriteType:'singular', name:'Singular Tree', slug: 'singular-tree'}));

    const thangTypes = [fangrider, segmentedMunchkin, singularMunchkin, segmentedTree, singularTree];

    // Build the Stage and LankBoss.
    window.stage = (stage = new createjs.StageGL(canvas[0]));
    const options = {
      camera,
      webGLStage: stage,
      surfaceTextLayer: new createjs.Container(),
      world,
      thangTypes,
      gameUIState: new GameUIState()
    };

    window.lankBoss = (lankBoss = new LankBoss(options));

    const defaultLayer = lankBoss.layerAdapters.Default;
    defaultLayer.buildAsync = false; // cause faster

    // Sort of an implicit test. By default, all the default actions are always rendered,
    // but I want to make sure the system can dynamically hear about actions it needs to render for
    // as they are used.
    defaultLayer.defaultActions = ['idle'];

    // Render the simple world with just trees
    lankBoss.update(true);

    // Test that the unrendered, static sprites aren't showing anything
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children.length,1,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].currentFrame,0,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].paused,true,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.currentFrame,0,'static singular action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.paused,true,'static singular action']);

    return defaultLayer.once('new-spritesheet', function() {

      // Now make the world a little more complicated.
      world.thangs = world.thangs.concat([
        // four cardinal ogres, to test movement rotation and placement around a center point.
        {id: 'Ogre N', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, scaleFactorX: 1.5, hudProperties: ['health'] },
        {id: 'Ogre W', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:0, z: 1}, action: 'move', health: 8, maxHealth: 10, rotation: 0, acts: true, scaleFactorY: 1.5, hudProperties: ['health'] },
        {id: 'Ogre E', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:0, z: 1}, action: 'move', health: 5, maxHealth: 10, rotation: Math.PI, acts: true, alpha: 0.5, hudProperties: ['health'] },
        {id: 'Ogre S', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:-8, z: 1}, action: 'move', health: 2, maxHealth: 10, rotation: Math.PI/2, acts: true, hudProperties: ['health'], effectNames: ['curse'] },

        // Set ogres side by side with different render strategies
        {id: 'Singular Ogre', spriteName: 'Singular Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-10, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, alpha: 0.5 },
        {id: 'Segmented Ogre', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true },

        // A line of ogres overlapping to test child ordering
        {id: 'Dying Ogre 1', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-14, y:0, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 2', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13.5, y:1, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 3', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13, y:2, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 4', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-12.5, y:3, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },

        // Throw in a ThangType that contains nested MovieClips
        {id: 'Fangrider', spriteName: 'Fangrider', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:8, z: 1}, action: 'move', health: 20, maxHealth: 20, rotation: 0, acts: true, currentEvents: ['aoe-' + JSON.stringify([0, 0, 8, '#00F'])] }
      ]);

      _.find(world.thangs, {id: 'Disappearing Tree'}).exists = false;
      for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }
      lankBoss.update(true);
      jasmine.Ajax.requests.sendResponses({'/db/thang.type/curse': curseData});

      // Test that the unrendered, animated sprites aren't showing anything
      midRenderExpectations.push([lankBoss.lanks['Segmented Ogre'].sprite.children.length,10,'animated segmented action']);
      for (var child of Array.from(lankBoss.lanks['Segmented Ogre'].sprite.children)) {
        midRenderExpectations.push([child.children[0].currentFrame, 0, 'animated segmented action']);
      }
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.currentFrame,0,'animated singular action']);
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.paused,true,'animated singular action']);

      return defaultLayer.once('new-spritesheet', () => //        showMe() # Uncomment to display this world when you run any of these tests.
      done());
    });
  };

  beforeEach(done => init(done));

  const showMe = function() {
    canvas.css('position', 'absolute').css('index', 1000).css('background', 'white');
    $('body').append(canvas);

    let ticks = 0;
    const listener = {
      handleEvent() {
        if (ticks >= 100) { return; }
        ticks += 1;
        if ((ticks % 20) === 0) {
          lankBoss.update(true);
        }
        return stage.update();
      }
    };
    createjs.Ticker.addEventListener(""tick"", listener);
    return $('body').append($('<div style=""position: absolute; top: 295px; left: 395px; height: 10px; width: 10px; background: red;""></div>'));
  };

  it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })());

  it('rotates and animates sprites according to thang rotation', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.currentAnimation).toBe('move_fore');
    expect(lankBoss.lanks['Ogre E'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre W'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre S'].sprite.currentAnimation).toBe('move_back');

    expect(lankBoss.lanks['Ogre E'].sprite.scaleX).toBeLessThan(0);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleX).toBeGreaterThan(0);
  });

  it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  });

  it('scales sprites according to thang scaleFactorX and scaleFactorY', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.scaleX).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleX * 1.5);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleY).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleY * 1.5);
  });

  it('sets alpha based on thang alpha', () => expect(lankBoss.lanks['Ogre E'].sprite.alpha).toBe(0.5));

  return it('orders sprites in the layer based on thang pos.y\'s', function() {
    const {
      container
    } = lankBoss.layerAdapters.Default;
    const l = container.children;
    const i1 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 1'));
    const i2 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 2'));
    const i3 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 3'));
    const i4 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 4'));
    expect(i1).toBeGreaterThan(i2);
    expect(i2).toBeGreaterThan(i3);
    return expect(i3).toBeGreaterThan(i4);
  });
})",steel
/test/app/lib/surface/LankBoss.spec.js,Conditional Test Logic,"{'line': 154, 'column': 4, 'index': 9476}","it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })())",steel
/test/app/lib/surface/LankBoss.spec.js,Conditional Test Logic,"{'line': 155, 'column': 6, 'index': 9543}","it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })())",steel
/test/app/lib/surface/LankBoss.spec.js,Global Variable,"{'line': 120, 'column': 11, 'index': 8105}","describe('LankBoss', function() {
  let lankBoss = null;
  let canvas = null;
  let stage = null;
  const midRenderExpectations = []; // bit of a hack to move tests which happen mid-initialization into a separate test

  // This suite just creates and renders the stage once, and then has each of the tests
  // check the resulting data for the whole thing, without changing anything.

  const init = function(done) {
    let thang;
    if (lankBoss) { return done(); }
    const t = new Date();
    canvas = $('<canvas width=""800"" height=""600""></canvas>');
    const camera = new Camera(canvas);

    // Create an initial, simple world with just trees
    const world = new World();
    world.thangs = [
      // Set trees side by side with different render strategies
      {id: 'Segmented Tree', spriteName: 'Segmented Tree', exists: true, shape: 'disc', depth: 2, pos: {x:10, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },
      {id: 'Singular Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:-8, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true },

      // Include a tree whose existence will change so we can test removing sprites
      {id: 'Disappearing Tree', spriteName: 'Singular Tree', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:0, z: 1}, action: 'idle', health: 20, maxHealth: 20, rotation: Math.PI/2, acts: true }
    ];
    world.thangMap = {};
    for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }

    // Set up thang types. Mix renderStrategies.
    const fangrider = new ThangType($.extend({}, fangriderData, {spriteType:'segmented', name:'Fangrider', slug:'fangrider'}));
    const segmentedMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'segmented', name:'Segmented Munchkin', slug:'segmented-munchkin'}));
    const singularMunchkin = new ThangType($.extend({}, munchkinData, {spriteType:'singular', name:'Singular Munchkin', slug:'singular-munchkin'}));
    const segmentedTree = new ThangType($.extend({}, treeData, {spriteType:'segmented', name:'Segmented Tree', slug: 'segmented-tree'}));
    const singularTree = new ThangType($.extend({}, treeData, {spriteType:'singular', name:'Singular Tree', slug: 'singular-tree'}));

    const thangTypes = [fangrider, segmentedMunchkin, singularMunchkin, segmentedTree, singularTree];

    // Build the Stage and LankBoss.
    window.stage = (stage = new createjs.StageGL(canvas[0]));
    const options = {
      camera,
      webGLStage: stage,
      surfaceTextLayer: new createjs.Container(),
      world,
      thangTypes,
      gameUIState: new GameUIState()
    };

    window.lankBoss = (lankBoss = new LankBoss(options));

    const defaultLayer = lankBoss.layerAdapters.Default;
    defaultLayer.buildAsync = false; // cause faster

    // Sort of an implicit test. By default, all the default actions are always rendered,
    // but I want to make sure the system can dynamically hear about actions it needs to render for
    // as they are used.
    defaultLayer.defaultActions = ['idle'];

    // Render the simple world with just trees
    lankBoss.update(true);

    // Test that the unrendered, static sprites aren't showing anything
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children.length,1,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].currentFrame,0,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Segmented Tree'].sprite.children[0].paused,true,'static segmented action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.currentFrame,0,'static singular action']);
    midRenderExpectations.push([lankBoss.lanks['Singular Tree'].sprite.paused,true,'static singular action']);

    return defaultLayer.once('new-spritesheet', function() {

      // Now make the world a little more complicated.
      world.thangs = world.thangs.concat([
        // four cardinal ogres, to test movement rotation and placement around a center point.
        {id: 'Ogre N', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, scaleFactorX: 1.5, hudProperties: ['health'] },
        {id: 'Ogre W', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:0, z: 1}, action: 'move', health: 8, maxHealth: 10, rotation: 0, acts: true, scaleFactorY: 1.5, hudProperties: ['health'] },
        {id: 'Ogre E', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:0, z: 1}, action: 'move', health: 5, maxHealth: 10, rotation: Math.PI, acts: true, alpha: 0.5, hudProperties: ['health'] },
        {id: 'Ogre S', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:0, y:-8, z: 1}, action: 'move', health: 2, maxHealth: 10, rotation: Math.PI/2, acts: true, hudProperties: ['health'], effectNames: ['curse'] },

        // Set ogres side by side with different render strategies
        {id: 'Singular Ogre', spriteName: 'Singular Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-10, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true, alpha: 0.5 },
        {id: 'Segmented Ogre', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-8, y:-8, z: 1}, action: 'move', health: 10, maxHealth: 10, rotation: -Math.PI/2, acts: true },

        // A line of ogres overlapping to test child ordering
        {id: 'Dying Ogre 1', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-14, y:0, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 2', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13.5, y:1, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 3', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-13, y:2, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },
        {id: 'Dying Ogre 4', spriteName: 'Segmented Munchkin', exists: true, shape: 'disc', depth: 2, pos: {x:-12.5, y:3, z: 1}, action: 'die', health: 5, maxHealth: 10, rotation: 0, acts: true },

        // Throw in a ThangType that contains nested MovieClips
        {id: 'Fangrider', spriteName: 'Fangrider', exists: true, shape: 'disc', depth: 2, pos: {x:8, y:8, z: 1}, action: 'move', health: 20, maxHealth: 20, rotation: 0, acts: true, currentEvents: ['aoe-' + JSON.stringify([0, 0, 8, '#00F'])] }
      ]);

      _.find(world.thangs, {id: 'Disappearing Tree'}).exists = false;
      for (thang of Array.from(world.thangs)) { world.thangMap[thang.id] = thang; }
      lankBoss.update(true);
      jasmine.Ajax.requests.sendResponses({'/db/thang.type/curse': curseData});

      // Test that the unrendered, animated sprites aren't showing anything
      midRenderExpectations.push([lankBoss.lanks['Segmented Ogre'].sprite.children.length,10,'animated segmented action']);
      for (var child of Array.from(lankBoss.lanks['Segmented Ogre'].sprite.children)) {
        midRenderExpectations.push([child.children[0].currentFrame, 0, 'animated segmented action']);
      }
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.currentFrame,0,'animated singular action']);
      midRenderExpectations.push([lankBoss.lanks['Singular Ogre'].sprite.paused,true,'animated singular action']);

      return defaultLayer.once('new-spritesheet', () => //        showMe() # Uncomment to display this world when you run any of these tests.
      done());
    });
  };

  beforeEach(done => init(done));

  const showMe = function() {
    canvas.css('position', 'absolute').css('index', 1000).css('background', 'white');
    $('body').append(canvas);

    let ticks = 0;
    const listener = {
      handleEvent() {
        if (ticks >= 100) { return; }
        ticks += 1;
        if ((ticks % 20) === 0) {
          lankBoss.update(true);
        }
        return stage.update();
      }
    };
    createjs.Ticker.addEventListener(""tick"", listener);
    return $('body').append($('<div style=""position: absolute; top: 295px; left: 395px; height: 10px; width: 10px; background: red;""></div>'));
  };

  it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })());

  it('rotates and animates sprites according to thang rotation', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.currentAnimation).toBe('move_fore');
    expect(lankBoss.lanks['Ogre E'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre W'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre S'].sprite.currentAnimation).toBe('move_back');

    expect(lankBoss.lanks['Ogre E'].sprite.scaleX).toBeLessThan(0);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleX).toBeGreaterThan(0);
  });

  it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  });

  it('scales sprites according to thang scaleFactorX and scaleFactorY', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.scaleX).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleX * 1.5);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleY).toBe(lankBoss.lanks['Ogre N'].sprite.baseScaleY * 1.5);
  });

  it('sets alpha based on thang alpha', () => expect(lankBoss.lanks['Ogre E'].sprite.alpha).toBe(0.5));

  return it('orders sprites in the layer based on thang pos.y\'s', function() {
    const {
      container
    } = lankBoss.layerAdapters.Default;
    const l = container.children;
    const i1 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 1'));
    const i2 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 2'));
    const i3 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 3'));
    const i4 = container.getChildIndex(_.find(container.children, c => c.lank.thang.id === 'Dying Ogre 4'));
    expect(i1).toBeGreaterThan(i2);
    expect(i2).toBeGreaterThan(i3);
    return expect(i3).toBeGreaterThan(i4);
  });
})",steel
/test/app/lib/surface/LankBoss.spec.js,Global Variable,"{'line': 154, 'column': 9, 'index': 9481}","it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })())",steel
/test/app/lib/surface/LankBoss.spec.js,Magic Number,"{'line': 169, 'column': 64, 'index': 10232}","it('rotates and animates sprites according to thang rotation', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.currentAnimation).toBe('move_fore');
    expect(lankBoss.lanks['Ogre E'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre W'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre S'].sprite.currentAnimation).toBe('move_back');

    expect(lankBoss.lanks['Ogre E'].sprite.scaleX).toBeLessThan(0);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleX).toBeGreaterThan(0);
  })",steel
/test/app/lib/surface/LankBoss.spec.js,Magic Number,"{'line': 170, 'column': 74, 'index': 10310}","it('rotates and animates sprites according to thang rotation', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.currentAnimation).toBe('move_fore');
    expect(lankBoss.lanks['Ogre E'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre W'].sprite.currentAnimation).toBe('move_side');
    expect(lankBoss.lanks['Ogre S'].sprite.currentAnimation).toBe('move_back');

    expect(lankBoss.lanks['Ogre E'].sprite.scaleX).toBeLessThan(0);
    return expect(lankBoss.lanks['Ogre W'].sprite.scaleX).toBeGreaterThan(0);
  })",steel
/test/app/lib/surface/LankBoss.spec.js,Magic Number,"{'line': 174, 'column': 51, 'index': 10434}","it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  })",steel
/test/app/lib/surface/LankBoss.spec.js,Magic Number,"{'line': 176, 'column': 58, 'index': 10560}","it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  })",steel
/test/app/lib/surface/LankBoss.spec.js,Magic Number,"{'line': 177, 'column': 51, 'index': 10616}","it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  })",steel
/test/app/lib/surface/LankBoss.spec.js,Magic Number,"{'line': 179, 'column': 58, 'index': 10735}","it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  })",steel
/test/app/lib/surface/LankBoss.spec.js,Magic Number,"{'line': 180, 'column': 51, 'index': 10790}","it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  })",steel
/test/app/lib/surface/LankBoss.spec.js,Magic Number,"{'line': 181, 'column': 65, 'index': 10859}","it('positions sprites according to thang pos', function() {
    expect(lankBoss.lanks['Ogre N'].sprite.x).toBe(0);
    expect(lankBoss.lanks['Ogre N'].sprite.y).toBeCloseTo(-60);
    expect(lankBoss.lanks['Ogre E'].sprite.x).toBeCloseTo(80);
    expect(lankBoss.lanks['Ogre E'].sprite.y).toBe(0);
    expect(lankBoss.lanks['Ogre W'].sprite.x).toBe(-80);
    expect(lankBoss.lanks['Ogre W'].sprite.y).toBeCloseTo(0);
    expect(lankBoss.lanks['Ogre S'].sprite.x).toBe(0);
    return expect(lankBoss.lanks['Ogre S'].sprite.y).toBeCloseTo(60);
  })",steel
/test/app/lib/surface/LankBoss.spec.js,Magic Number,"{'line': 189, 'column': 97, 'index': 11281}","it('sets alpha based on thang alpha', () => expect(lankBoss.lanks['Ogre E'].sprite.alpha).toBe(0.5))",steel
/test/app/lib/surface/LankBoss.spec.js,Redundant Print,"{'line': 156, 'column': 8, 'index': 9592}","it('does not display anything for sprites whose animations or containers have not been rendered yet', () => (() => {
    const result = [];
    for (var expectation of Array.from(midRenderExpectations)) {
      if (expectation[0] !== expectation[1]) {
        console.error('This type of action display failed:', expectation[2]);
      }
      result.push(expect(expectation[0]).toBe(expectation[1]));
    }
    return result;
  })())",steel
/test/app/lib/surface/Camera.spec.js,Conditional Test Logic,"{'line': 15, 'column': 4, 'index': 582}","describe('Camera (Surface point of view)', function() {
  const Camera = require('lib/surface/Camera');

  const expectPositionsEqual = function(p1, p2) {
    expect(p1.x).toBeCloseTo(p2.x);
    expect(p1.y).toBeCloseTo(p2.y);
    if (p2.z != null) { return expect(p1.z).toBeCloseTo(p2.z); }
  };

  const checkConversionsFromWorldPos = function(wop, cam) {
    // wop = world pos
    // sup = surface pos
    // cap = canvas pos
    // scp = screen pos

    const sup = cam.worldToSurface(wop);
    expect(sup.x).toBeCloseTo(wop.x * Camera.PPM);
    expect(sup.y).toBeCloseTo(-(wop.y + (wop.z * cam.z2y)) * cam.y2x * Camera.PPM);

    const cap = cam.worldToCanvas(wop);
    expect(cap.x).toBeCloseTo((sup.x - cam.surfaceViewport.x) * cam.zoom);
    expect(cap.y).toBeCloseTo((sup.y - cam.surfaceViewport.y) * cam.zoom);

    const scp = cam.worldToScreen(wop);
    // If we ever want to use screen conversion, then make it and add this test
    //expect(scp.x).toBeCloseTo cap.x * @someCanvasToScreenXScaleFactor
    //expect(scp.y).toBeCloseTo cap.y * @someCanvasToScreenYScaleFactor

    const wop2 = cam.surfaceToWorld(sup);
    expect(wop2.x).toBeCloseTo(wop.x);
    expect(wop2.y).toBeCloseTo(wop.y + (wop.z * cam.z2y));

    // Make sure to call all twelve conversions in here. Can be redundant.
    expectPositionsEqual(sup,  cam.worldToSurface(wop2));  // 0
    expectPositionsEqual(cap,  cam.surfaceToCanvas(sup));  // 1
    expectPositionsEqual(scp,  cam.canvasToScreen(cap));   // 2
    expectPositionsEqual(cap,  cam.screenToCanvas(scp));   // 3
    expectPositionsEqual(sup,  cam.canvasToSurface(cap));  // 4
    expectPositionsEqual(wop2, cam.surfaceToWorld(sup));   // 5
    expectPositionsEqual(wop2, cam.canvasToWorld(cap));    // 6
    expectPositionsEqual(cap,  cam.worldToCanvas(wop));    // 7
    expectPositionsEqual(scp,  cam.worldToScreen(wop));    // 8
    expectPositionsEqual(scp,  cam.surfaceToScreen(sup));  // 9
    expectPositionsEqual(sup,  cam.screenToSurface(scp));  // 10
    return expectPositionsEqual(wop2, cam.screenToWorld(scp));    // 11
  };

  const checkCameraPos = function(cam, wop) {
    const botFOV = (cam.x2y * cam.vFOV) / (cam.y2x + cam.x2y);
    const botDist = ((cam.worldViewport.height) * Math.sin(cam.angle)) / Math.sin(botFOV);
    const camDist = ((cam.worldViewport.height / 2) * Math.sin(Math.PI - cam.angle - botFOV)) / Math.sin(botFOV);
    const targetPos = {
      x: cam.worldViewport.cx,
      y: cam.worldViewport.cy - (camDist * cam.y2x * cam.z2y),
      z: camDist * cam.z2x * cam.y2z
    };
    //console.log 'botFOV', botFOV * 180 / Math.PI, 'botDist', botDist, 'camDist', camDist, 'target pos', targetPos, 'actual pos', cam.cameraWorldPos()
    expectPositionsEqual(cam.cameraWorldPos(), targetPos);

    if (wop) {
      const dx = targetPos.x - wop.x;
      const dy = targetPos.y - wop.y;
      const dz = targetPos.z - wop.z;
      const d = cam.distanceTo(wop);
      expect(d).toBeCloseTo(Math.sqrt((dx * dx) + (dy * dy) + (dz * dz)));
      // This is fairly vulnerable to numerical instability, so we limit the number of digits to consider.
      const decimalPlaces = 3 - Math.floor(Math.log(d / camDist) / Math.log(10));
      return expect(cam.distanceRatioTo(wop)).toBeCloseTo(d / camDist, decimalPlaces);
    }
  };

  const testWops = [
    {x: 3, y: 4, z: 7},
    {x: -4, y: 12, z: 2},
    {x: 0, y: 0, z: 0}
  ];
  const testCanvasSizes = [
    {width: 100, height: 100},
    {width: 200, height: 50}
  ];
  const testLayer = {scaleX: 1, scaleY: 1, regX: 0, regY: 0};
  const testZooms = [0.5, 1, 2];
  const testZoomTargets = [
    null,
    {x: 50, y: 50},
    {x: 0, y: 150}
  ];
  const testAngles = [0, Math.PI / 4, null, Math.PI / 2];
  const testFOVs = [Math.PI / 6, Math.PI / 3, Math.PI / 2, Math.PI];

  it('handles lots of different cases correctly', () => Array.from(testWops).map((wop) =>
    Array.from(testCanvasSizes).map((size) =>
      Array.from(testZooms).map((zoom) =>
        Array.from(testZoomTargets).map((target) =>
          Array.from(testAngles).map((angle) =>
            (() => {
              const result = [];
              for (var fov of Array.from(testFOVs)) {
                var cam = new Camera({attr(attr) { if ('attr' === 'width') { return size.width; } else { return size.height; } }}, angle, fov);
                checkCameraPos(cam, wop);
                cam.zoomTo(target, zoom, 0);
                checkConversionsFromWorldPos(wop, cam);
                result.push(checkCameraPos(cam, wop));
              }
              return result;
            })()))))));

  it('works at default angle of asin(0.75) ~= 48.9 degrees', function() {
    const cam = new Camera({attr(attr) { return 100; }}, null);
    const angle = Math.asin(3 / 4);
    expect(cam.angle).toBeCloseTo(angle);
    expect(cam.x2y).toBeCloseTo(4 / 3);
    expect(cam.x2z).toBeCloseTo(1 / Math.cos(angle));
    return expect(cam.z2y).toBeCloseTo((4 / 3) * Math.cos(angle));
  });

  xit('works at 2x zoom, 90 degrees', function() {
    const cam = new Camera({attr(attr) { return 100; }}, Math.PI / 2);
    cam.zoomTo(null, 2, 0);
    checkCameraPos(cam);
    const wop = {x: 5, y: 2.5, z: 7};
    let cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 50, y: 100});
    cam.zoomTo({x: 50, y: 75}, 2, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 50, y: 50});
    cam.zoomTo({x: 50, y: 75}, 4, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 50, y: 50});
    // Now let's try zooming on the edge of the screen; we should be bounded to the surface viewport
    cam.zoomTo({x: 100, y: 100}, 2, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    return expectPositionsEqual(cap, {x: 0, y: 50});
});

  xit('works at 2x zoom, 30 degrees', function() {
    const cam = new Camera({attr(attr) { return 100; }}, Math.PI / 6);
    cam.zoomTo(null, 2, 0);
    expect(cam.x2y).toBeCloseTo(1);
    expect(cam.x2z).toBeGreaterThan(9001);
    checkCameraPos(cam);
    const wop = {x: 5, y: 4, z: 6 * cam.y2z};  // like x: 5, y: 10 out of world width: 10, height: 20
    const sup = cam.worldToSurface(wop);
    expect(cam.surfaceToWorld(sup).y).toBeCloseTo(10);
    expectPositionsEqual(sup, {x: 50, y: 50});
    let cap = cam.surfaceToCanvas(sup);
    expectPositionsEqual(cap, {x: 50, y: 50});
    // Zoom to bottom edge of screen
    cam.zoomTo({x: 50, y: 100}, 2, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 50, y: 0});
    cam.zoomTo({x: 50, y: 100}, 4, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    return expectPositionsEqual(cap, {x: 50, y: -100});
});

  it('works at 2x zoom, 60 degree hFOV', function() {
    const cam = new Camera({attr(attr) { return 100; }}, null, Math.PI / 3);
    cam.zoomTo(null, 2, 0);
    return checkCameraPos(cam);
  });

  it('works at 2x zoom, 60 degree hFOV, 40 degree vFOV', function() {
    const cam = new Camera({attr(attr) { if (attr === 'height') { return 63.041494; } else { return 100; } }}, null, Math.PI / 3);
    cam.zoomTo(null, 2, 0);
    return checkCameraPos(cam);
  });

  return xit('works at 2x zoom on a surface wider than it is tall, 30 degrees, default viewing upper left corner', function() {
    const cam = new Camera({attr(attr) { return 100; }}, Math.PI / 6);  // 200 * Camera.MPP, 2 * 50 * Camera.MPP
    cam.zoomTo(null, 2, 0);
    checkCameraPos(cam);
    expect(cam.zoom).toBeCloseTo(2);
    const wop = {x: 5, y: 4, z: 6 * cam.y2z};  // like x: 5, y: 10 out of world width: 20, height: 10
    let cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 100, y: 0});
    // Zoom to far right edge of screen and try to zoom out
    cam.zoomTo({x: 9001, y: 25}, 0.1, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    return expectPositionsEqual(cap, {x: -200, y: 0});
});
})",steel
/test/app/lib/surface/Camera.spec.js,Conditional Test Logic,"{'line': 68, 'column': 4, 'index': 3130}","describe('Camera (Surface point of view)', function() {
  const Camera = require('lib/surface/Camera');

  const expectPositionsEqual = function(p1, p2) {
    expect(p1.x).toBeCloseTo(p2.x);
    expect(p1.y).toBeCloseTo(p2.y);
    if (p2.z != null) { return expect(p1.z).toBeCloseTo(p2.z); }
  };

  const checkConversionsFromWorldPos = function(wop, cam) {
    // wop = world pos
    // sup = surface pos
    // cap = canvas pos
    // scp = screen pos

    const sup = cam.worldToSurface(wop);
    expect(sup.x).toBeCloseTo(wop.x * Camera.PPM);
    expect(sup.y).toBeCloseTo(-(wop.y + (wop.z * cam.z2y)) * cam.y2x * Camera.PPM);

    const cap = cam.worldToCanvas(wop);
    expect(cap.x).toBeCloseTo((sup.x - cam.surfaceViewport.x) * cam.zoom);
    expect(cap.y).toBeCloseTo((sup.y - cam.surfaceViewport.y) * cam.zoom);

    const scp = cam.worldToScreen(wop);
    // If we ever want to use screen conversion, then make it and add this test
    //expect(scp.x).toBeCloseTo cap.x * @someCanvasToScreenXScaleFactor
    //expect(scp.y).toBeCloseTo cap.y * @someCanvasToScreenYScaleFactor

    const wop2 = cam.surfaceToWorld(sup);
    expect(wop2.x).toBeCloseTo(wop.x);
    expect(wop2.y).toBeCloseTo(wop.y + (wop.z * cam.z2y));

    // Make sure to call all twelve conversions in here. Can be redundant.
    expectPositionsEqual(sup,  cam.worldToSurface(wop2));  // 0
    expectPositionsEqual(cap,  cam.surfaceToCanvas(sup));  // 1
    expectPositionsEqual(scp,  cam.canvasToScreen(cap));   // 2
    expectPositionsEqual(cap,  cam.screenToCanvas(scp));   // 3
    expectPositionsEqual(sup,  cam.canvasToSurface(cap));  // 4
    expectPositionsEqual(wop2, cam.surfaceToWorld(sup));   // 5
    expectPositionsEqual(wop2, cam.canvasToWorld(cap));    // 6
    expectPositionsEqual(cap,  cam.worldToCanvas(wop));    // 7
    expectPositionsEqual(scp,  cam.worldToScreen(wop));    // 8
    expectPositionsEqual(scp,  cam.surfaceToScreen(sup));  // 9
    expectPositionsEqual(sup,  cam.screenToSurface(scp));  // 10
    return expectPositionsEqual(wop2, cam.screenToWorld(scp));    // 11
  };

  const checkCameraPos = function(cam, wop) {
    const botFOV = (cam.x2y * cam.vFOV) / (cam.y2x + cam.x2y);
    const botDist = ((cam.worldViewport.height) * Math.sin(cam.angle)) / Math.sin(botFOV);
    const camDist = ((cam.worldViewport.height / 2) * Math.sin(Math.PI - cam.angle - botFOV)) / Math.sin(botFOV);
    const targetPos = {
      x: cam.worldViewport.cx,
      y: cam.worldViewport.cy - (camDist * cam.y2x * cam.z2y),
      z: camDist * cam.z2x * cam.y2z
    };
    //console.log 'botFOV', botFOV * 180 / Math.PI, 'botDist', botDist, 'camDist', camDist, 'target pos', targetPos, 'actual pos', cam.cameraWorldPos()
    expectPositionsEqual(cam.cameraWorldPos(), targetPos);

    if (wop) {
      const dx = targetPos.x - wop.x;
      const dy = targetPos.y - wop.y;
      const dz = targetPos.z - wop.z;
      const d = cam.distanceTo(wop);
      expect(d).toBeCloseTo(Math.sqrt((dx * dx) + (dy * dy) + (dz * dz)));
      // This is fairly vulnerable to numerical instability, so we limit the number of digits to consider.
      const decimalPlaces = 3 - Math.floor(Math.log(d / camDist) / Math.log(10));
      return expect(cam.distanceRatioTo(wop)).toBeCloseTo(d / camDist, decimalPlaces);
    }
  };

  const testWops = [
    {x: 3, y: 4, z: 7},
    {x: -4, y: 12, z: 2},
    {x: 0, y: 0, z: 0}
  ];
  const testCanvasSizes = [
    {width: 100, height: 100},
    {width: 200, height: 50}
  ];
  const testLayer = {scaleX: 1, scaleY: 1, regX: 0, regY: 0};
  const testZooms = [0.5, 1, 2];
  const testZoomTargets = [
    null,
    {x: 50, y: 50},
    {x: 0, y: 150}
  ];
  const testAngles = [0, Math.PI / 4, null, Math.PI / 2];
  const testFOVs = [Math.PI / 6, Math.PI / 3, Math.PI / 2, Math.PI];

  it('handles lots of different cases correctly', () => Array.from(testWops).map((wop) =>
    Array.from(testCanvasSizes).map((size) =>
      Array.from(testZooms).map((zoom) =>
        Array.from(testZoomTargets).map((target) =>
          Array.from(testAngles).map((angle) =>
            (() => {
              const result = [];
              for (var fov of Array.from(testFOVs)) {
                var cam = new Camera({attr(attr) { if ('attr' === 'width') { return size.width; } else { return size.height; } }}, angle, fov);
                checkCameraPos(cam, wop);
                cam.zoomTo(target, zoom, 0);
                checkConversionsFromWorldPos(wop, cam);
                result.push(checkCameraPos(cam, wop));
              }
              return result;
            })()))))));

  it('works at default angle of asin(0.75) ~= 48.9 degrees', function() {
    const cam = new Camera({attr(attr) { return 100; }}, null);
    const angle = Math.asin(3 / 4);
    expect(cam.angle).toBeCloseTo(angle);
    expect(cam.x2y).toBeCloseTo(4 / 3);
    expect(cam.x2z).toBeCloseTo(1 / Math.cos(angle));
    return expect(cam.z2y).toBeCloseTo((4 / 3) * Math.cos(angle));
  });

  xit('works at 2x zoom, 90 degrees', function() {
    const cam = new Camera({attr(attr) { return 100; }}, Math.PI / 2);
    cam.zoomTo(null, 2, 0);
    checkCameraPos(cam);
    const wop = {x: 5, y: 2.5, z: 7};
    let cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 50, y: 100});
    cam.zoomTo({x: 50, y: 75}, 2, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 50, y: 50});
    cam.zoomTo({x: 50, y: 75}, 4, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 50, y: 50});
    // Now let's try zooming on the edge of the screen; we should be bounded to the surface viewport
    cam.zoomTo({x: 100, y: 100}, 2, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    return expectPositionsEqual(cap, {x: 0, y: 50});
});

  xit('works at 2x zoom, 30 degrees', function() {
    const cam = new Camera({attr(attr) { return 100; }}, Math.PI / 6);
    cam.zoomTo(null, 2, 0);
    expect(cam.x2y).toBeCloseTo(1);
    expect(cam.x2z).toBeGreaterThan(9001);
    checkCameraPos(cam);
    const wop = {x: 5, y: 4, z: 6 * cam.y2z};  // like x: 5, y: 10 out of world width: 10, height: 20
    const sup = cam.worldToSurface(wop);
    expect(cam.surfaceToWorld(sup).y).toBeCloseTo(10);
    expectPositionsEqual(sup, {x: 50, y: 50});
    let cap = cam.surfaceToCanvas(sup);
    expectPositionsEqual(cap, {x: 50, y: 50});
    // Zoom to bottom edge of screen
    cam.zoomTo({x: 50, y: 100}, 2, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 50, y: 0});
    cam.zoomTo({x: 50, y: 100}, 4, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    return expectPositionsEqual(cap, {x: 50, y: -100});
});

  it('works at 2x zoom, 60 degree hFOV', function() {
    const cam = new Camera({attr(attr) { return 100; }}, null, Math.PI / 3);
    cam.zoomTo(null, 2, 0);
    return checkCameraPos(cam);
  });

  it('works at 2x zoom, 60 degree hFOV, 40 degree vFOV', function() {
    const cam = new Camera({attr(attr) { if (attr === 'height') { return 63.041494; } else { return 100; } }}, null, Math.PI / 3);
    cam.zoomTo(null, 2, 0);
    return checkCameraPos(cam);
  });

  return xit('works at 2x zoom on a surface wider than it is tall, 30 degrees, default viewing upper left corner', function() {
    const cam = new Camera({attr(attr) { return 100; }}, Math.PI / 6);  // 200 * Camera.MPP, 2 * 50 * Camera.MPP
    cam.zoomTo(null, 2, 0);
    checkCameraPos(cam);
    expect(cam.zoom).toBeCloseTo(2);
    const wop = {x: 5, y: 4, z: 6 * cam.y2z};  // like x: 5, y: 10 out of world width: 20, height: 10
    let cap = cam.worldToCanvas(wop);
    expectPositionsEqual(cap, {x: 100, y: 0});
    // Zoom to far right edge of screen and try to zoom out
    cam.zoomTo({x: 9001, y: 25}, 0.1, 0);
    checkCameraPos(cam);
    cap = cam.worldToCanvas(wop);
    return expectPositionsEqual(cap, {x: -200, y: 0});
});
})",steel
/test/app/lib/surface/Camera.spec.js,Conditional Test Logic,"{'line': 106, 'column': 14, 'index': 4498}","it('handles lots of different cases correctly', () => Array.from(testWops).map((wop) =>
    Array.from(testCanvasSizes).map((size) =>
      Array.from(testZooms).map((zoom) =>
        Array.from(testZoomTargets).map((target) =>
          Array.from(testAngles).map((angle) =>
            (() => {
              const result = [];
              for (var fov of Array.from(testFOVs)) {
                var cam = new Camera({attr(attr) { if ('attr' === 'width') { return size.width; } else { return size.height; } }}, angle, fov);
                checkCameraPos(cam, wop);
                cam.zoomTo(target, zoom, 0);
                checkConversionsFromWorldPos(wop, cam);
                result.push(checkCameraPos(cam, wop));
              }
              return result;
            })()))))))",steel
/test/app/lib/surface/Camera.spec.js,Conditional Test Logic,"{'line': 107, 'column': 51, 'index': 4589}","it('handles lots of different cases correctly', () => Array.from(testWops).map((wop) =>
    Array.from(testCanvasSizes).map((size) =>
      Array.from(testZooms).map((zoom) =>
        Array.from(testZoomTargets).map((target) =>
          Array.from(testAngles).map((angle) =>
            (() => {
              const result = [];
              for (var fov of Array.from(testFOVs)) {
                var cam = new Camera({attr(attr) { if ('attr' === 'width') { return size.width; } else { return size.height; } }}, angle, fov);
                checkCameraPos(cam, wop);
                cam.zoomTo(target, zoom, 0);
                checkConversionsFromWorldPos(wop, cam);
                result.push(checkCameraPos(cam, wop));
              }
              return result;
            })()))))))",steel
/test/app/lib/surface/Camera.spec.js,Conditional Test Logic,"{'line': 177, 'column': 41, 'index': 7414}","it('works at 2x zoom, 60 degree hFOV, 40 degree vFOV', function() {
    const cam = new Camera({attr(attr) { if (attr === 'height') { return 63.041494; } else { return 100; } }}, null, Math.PI / 3);
    cam.zoomTo(null, 2, 0);
    return checkCameraPos(cam);
  })",steel
/test/app/lib/surface/Camera.spec.js,Global Variable,"{'line': 106, 'column': 19, 'index': 4503}","it('handles lots of different cases correctly', () => Array.from(testWops).map((wop) =>
    Array.from(testCanvasSizes).map((size) =>
      Array.from(testZooms).map((zoom) =>
        Array.from(testZoomTargets).map((target) =>
          Array.from(testAngles).map((angle) =>
            (() => {
              const result = [];
              for (var fov of Array.from(testFOVs)) {
                var cam = new Camera({attr(attr) { if ('attr' === 'width') { return size.width; } else { return size.height; } }}, angle, fov);
                checkCameraPos(cam, wop);
                cam.zoomTo(target, zoom, 0);
                checkConversionsFromWorldPos(wop, cam);
                result.push(checkCameraPos(cam, wop));
              }
              return result;
            })()))))))",steel
/test/app/lib/surface/Camera.spec.js,Global Variable,"{'line': 107, 'column': 16, 'index': 4554}","it('handles lots of different cases correctly', () => Array.from(testWops).map((wop) =>
    Array.from(testCanvasSizes).map((size) =>
      Array.from(testZooms).map((zoom) =>
        Array.from(testZoomTargets).map((target) =>
          Array.from(testAngles).map((angle) =>
            (() => {
              const result = [];
              for (var fov of Array.from(testFOVs)) {
                var cam = new Camera({attr(attr) { if ('attr' === 'width') { return size.width; } else { return size.height; } }}, angle, fov);
                checkCameraPos(cam, wop);
                cam.zoomTo(target, zoom, 0);
                checkConversionsFromWorldPos(wop, cam);
                result.push(checkCameraPos(cam, wop));
              }
              return result;
            })()))))))",steel
/test/app/lib/surface/Camera.spec.js,Unknown Test,"{'column': 2, 'line': 170}","it('works at 2x zoom, 60 degree hFOV', function() {
    const cam = new Camera({attr(attr) { return 100; }}, null, Math.PI / 3);
    cam.zoomTo(null, 2, 0);
    return checkCameraPos(cam);
  })",steel
/test/app/lib/surface/Camera.spec.js,Unknown Test,"{'column': 2, 'line': 176}","it('works at 2x zoom, 60 degree hFOV, 40 degree vFOV', function() {
    const cam = new Camera({attr(attr) { if (attr === 'height') { return 63.041494; } else { return 100; } }}, null, Math.PI / 3);
    cam.zoomTo(null, 2, 0);
    return checkCameraPos(cam);
  })",steel
/test/app/lib/cinematic/commandRunner.spec.js,Conditional Test Logic,"{'line': 20, 'column': 4, 'index': 643}",Unknown,steel
/test/app/lib/cinematic/commandRunner.spec.js,Conditional Test Logic,"{'line': 37, 'column': 4, 'index': 1115}","it('runs all commands provided', utils.wrapJasmine(async () => {
    const spy = jasmine.createSpy('commandPromiseSpy')
    const cancelSpy = jasmine.createSpy('cancelSpy')

    const commands = []
    const commandLength = 5 + Math.floor((Math.random() * 10))
    for (let i = 0; i < commandLength; i++) {
      commands.push(new SpyCommand(spy, 100, cancelSpy))
    }
    const c = new CommandRunner(commands)
    await c.run()

    expect(spy).toHaveBeenCalledTimes(commandLength)
    expect(cancelSpy).not.toHaveBeenCalled()
  }))",steel
/test/app/lib/cinematic/commandRunner.spec.js,Conditional Test Logic,"{'line': 53, 'column': 4, 'index': 1665}","it('cancels commands immediately correctly', utils.wrapJasmine(async () => {
    const spy = jasmine.createSpy('commandPromiseSpy')
    const cancelSpy = jasmine.createSpy('cancelSpy')

    const commands = []
    const commandLength = 1 + Math.floor((Math.random() * 10))
    for (let i = 0; i < commandLength; i++) {
      commands.push(new SpyCommand(spy, 100, cancelSpy))
    }
    const c = new CommandRunner(commands)
    c.cancel()
    await c.run()

    expect(spy).not.toHaveBeenCalled()
    expect(cancelSpy).toHaveBeenCalledTimes(commandLength)
  }))",steel
/test/app/lib/cinematic/commandRunner.spec.js,Conditional Test Logic,"{'line': 74, 'column': 4, 'index': 2375}","it('can cancel commands midway', utils.wrapJasmine(async () => {
    const spy = jasmine.createSpy('commandPromiseSpy')
    const cancelSpy = jasmine.createSpy('cancelSpy')

    const commands = []

    // Then number of commands before and after the cancellation point.
    const beforeCancel = 2 + Math.floor((Math.random() * 3))
    const afterCancel = 2 + Math.floor((Math.random() * 3))
    const sleepTime = 150
    for (let i = 0; i < (beforeCancel + afterCancel); i++) {
      commands.push(new SpyCommand(spy, sleepTime, cancelSpy))
    }
    const c = new CommandRunner(commands)

    sleep((sleepTime * beforeCancel) + (sleepTime / 2)).then(() => c.cancel())
    await c.run()

    expect(spy).toHaveBeenCalledTimes(beforeCancel)
    expect(cancelSpy).toHaveBeenCalledTimes(afterCancel)
  }))",steel
/test/app/lib/cinematic/commandRunner.spec.js,Conditional Test Logic,"{'line': 94, 'column': 4, 'index': 3068}","it('late cancel doesn\'t disrupt command running', utils.wrapJasmine(async () => {
    const spy = jasmine.createSpy('commandPromiseSpy')
    const cancelSpy = jasmine.createSpy('cancelSpy')

    const commands = []

    const beforeCancel = 2 + Math.floor((Math.random() * 3))
    const sleepTime = 150
    for (let i = 0; i < (beforeCancel); i++) {
      commands.push(new SpyCommand(spy, sleepTime, cancelSpy))
    }
    const c = new CommandRunner(commands)

    sleep((sleepTime * beforeCancel) + (sleepTime / 2)).then(() => c.cancel())
    await c.run()

    expect(spy).toHaveBeenCalledTimes(beforeCancel)
    expect(cancelSpy).not.toHaveBeenCalled()
  }))",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Conditional Test Logic,"{'line': 13, 'column': 6, 'index': 524}","it('letters wrapped with ""<l>"" and words wrapped with ""<x>""', () => {
      const tests = [
        ['<div>hi</div>', '<div><x><l>h</l><l>i</l></x></div>'],
        ['<div>hi world</div>', `<div><x><l>h</l><l>i</l></x> <x><l>w</l><l>o</l><l>r</l><l>l</l><l>d</l></x></div>`]
      ]
      for (const [input, expected] of tests) {
        expect(wrapText(input, l => `<l>${l}</l>`, s => `<x>${s}</x>`)).toEqual(expected)
      }
    })",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Conditional Test Logic,"{'line': 23, 'column': 6, 'index': 898}","it('simple word wrapping with ""<x><word></x>', () => {
      const tests = [
        ['<div>hi</div>', `<div><x>hi</x></div>`],
        ['<span>hello, world</span>', '<span><x>hello,</x> <x>world</x></span>']
      ]
      for (const [input, expected] of tests) {
        expect(wrapText(input, l => l, s => `<x>${s}</x>`)).toEqual(expected)
      }
    })",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Conditional Test Logic,"{'line': 36, 'column': 6, 'index': 1179}","it('non html strings ignore', () => {
      const tests = [
        '',
        'a',
        'abcd',
        '<no<closing<tag'
      ]

      for (const test of tests) {
        expect(wrapText(test)).toEqual(test)
      }
    })",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Conditional Test Logic,"{'line': 51, 'column': 6, 'index': 3641}","it('simple text interpolation', () => {
      const name = 'Test User Name'
      const context = ({ name })
      const tests = [
        [`Hello, {%=o.name%}`, `<div><p><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">H</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">o</span><span class=""letter"" style=""display: inline-block; opacity:0"">,</span></span> <span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">T</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">s</span><span class=""letter"" style=""display: inline-block; opacity:0"">t</span></span> <span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">U</span><span class=""letter"" style=""display: inline-block; opacity:0"">s</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">r</span></span> <span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">N</span><span class=""letter"" style=""display: inline-block; opacity:0"">a</span><span class=""letter"" style=""display: inline-block; opacity:0"">m</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span></span></p></div>`],
        [`Hello, {%=o.unfound%}`, `<div><p><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">H</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">o</span><span class=""letter"" style=""display: inline-block; opacity:0"">,</span></span> </p></div>`]
      ]

      for (const [template, expected] of tests) {
        expect(processText(dialogNode(template), context)).toEqual(expected)
      }
    })",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Conditional Test Logic,"{'line': 63, 'column': 6, 'index': 6255}","it('handle markdown', () => {
      const tests = [
        [`Hey *italic*!`, `<div><p><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">H</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">y</span></span> <em><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">i</span><span class=""letter"" style=""display: inline-block; opacity:0"">t</span><span class=""letter"" style=""display: inline-block; opacity:0"">a</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">i</span><span class=""letter"" style=""display: inline-block; opacity:0"">c</span></span></em><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">!</span></span></p></div>`],
        [`# A heading!!!`, `<div><h1 id=""a-heading-""><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">A</span></span> <span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">h</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">a</span><span class=""letter"" style=""display: inline-block; opacity:0"">d</span><span class=""letter"" style=""display: inline-block; opacity:0"">i</span><span class=""letter"" style=""display: inline-block; opacity:0"">n</span><span class=""letter"" style=""display: inline-block; opacity:0"">g</span><span class=""letter"" style=""display: inline-block; opacity:0"">!</span><span class=""letter"" style=""display: inline-block; opacity:0"">!</span><span class=""letter"" style=""display: inline-block; opacity:0"">!</span></span></h1></div>`],
        [`**bold**`, `<div><p><strong><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">b</span><span class=""letter"" style=""display: inline-block; opacity:0"">o</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">d</span></span></strong></p></div>`]
      ]

      for (const [template, expected] of tests) {
        expect(processText(dialogNode(template), {})).toEqual(expected)
      }
    })",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Lazy Test,"{'line': 14, 'column': 15, 'index': 580}","it('letters wrapped with ""<l>"" and words wrapped with ""<x>""', () => {
      const tests = [
        ['<div>hi</div>', '<div><x><l>h</l><l>i</l></x></div>'],
        ['<div>hi world</div>', `<div><x><l>h</l><l>i</l></x> <x><l>w</l><l>o</l><l>r</l><l>l</l><l>d</l></x></div>`]
      ]
      for (const [input, expected] of tests) {
        expect(wrapText(input, l => `<l>${l}</l>`, s => `<x>${s}</x>`)).toEqual(expected)
      }
    })",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Lazy Test,"{'line': 24, 'column': 15, 'index': 954}","it('simple word wrapping with ""<x><word></x>', () => {
      const tests = [
        ['<div>hi</div>', `<div><x>hi</x></div>`],
        ['<span>hello, world</span>', '<span><x>hello,</x> <x>world</x></span>']
      ]
      for (const [input, expected] of tests) {
        expect(wrapText(input, l => l, s => `<x>${s}</x>`)).toEqual(expected)
      }
    })",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Lazy Test,"{'line': 37, 'column': 15, 'index': 1222}","it('non html strings ignore', () => {
      const tests = [
        '',
        'a',
        'abcd',
        '<no<closing<tag'
      ]

      for (const test of tests) {
        expect(wrapText(test)).toEqual(test)
      }
    })",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Lazy Test,"{'line': 52, 'column': 15, 'index': 3700}","it('simple text interpolation', () => {
      const name = 'Test User Name'
      const context = ({ name })
      const tests = [
        [`Hello, {%=o.name%}`, `<div><p><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">H</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">o</span><span class=""letter"" style=""display: inline-block; opacity:0"">,</span></span> <span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">T</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">s</span><span class=""letter"" style=""display: inline-block; opacity:0"">t</span></span> <span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">U</span><span class=""letter"" style=""display: inline-block; opacity:0"">s</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">r</span></span> <span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">N</span><span class=""letter"" style=""display: inline-block; opacity:0"">a</span><span class=""letter"" style=""display: inline-block; opacity:0"">m</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span></span></p></div>`],
        [`Hello, {%=o.unfound%}`, `<div><p><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">H</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">o</span><span class=""letter"" style=""display: inline-block; opacity:0"">,</span></span> </p></div>`]
      ]

      for (const [template, expected] of tests) {
        expect(processText(dialogNode(template), context)).toEqual(expected)
      }
    })",steel
/test/app/lib/cinematic/DialogSystem.spec.js,Lazy Test,"{'line': 64, 'column': 15, 'index': 6314}","it('handle markdown', () => {
      const tests = [
        [`Hey *italic*!`, `<div><p><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">H</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">y</span></span> <em><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">i</span><span class=""letter"" style=""display: inline-block; opacity:0"">t</span><span class=""letter"" style=""display: inline-block; opacity:0"">a</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">i</span><span class=""letter"" style=""display: inline-block; opacity:0"">c</span></span></em><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">!</span></span></p></div>`],
        [`# A heading!!!`, `<div><h1 id=""a-heading-""><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">A</span></span> <span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">h</span><span class=""letter"" style=""display: inline-block; opacity:0"">e</span><span class=""letter"" style=""display: inline-block; opacity:0"">a</span><span class=""letter"" style=""display: inline-block; opacity:0"">d</span><span class=""letter"" style=""display: inline-block; opacity:0"">i</span><span class=""letter"" style=""display: inline-block; opacity:0"">n</span><span class=""letter"" style=""display: inline-block; opacity:0"">g</span><span class=""letter"" style=""display: inline-block; opacity:0"">!</span><span class=""letter"" style=""display: inline-block; opacity:0"">!</span><span class=""letter"" style=""display: inline-block; opacity:0"">!</span></span></h1></div>`],
        [`**bold**`, `<div><p><strong><span class=""word"" style=""display: inline-block; whites-space: nowrap""><span class=""letter"" style=""display: inline-block; opacity:0"">b</span><span class=""letter"" style=""display: inline-block; opacity:0"">o</span><span class=""letter"" style=""display: inline-block; opacity:0"">l</span><span class=""letter"" style=""display: inline-block; opacity:0"">d</span></span></strong></p></div>`]
      ]

      for (const [template, expected] of tests) {
        expect(processText(dialogNode(template), {})).toEqual(expected)
      }
    })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Conditional Test Logic,"{'line': 44, 'column': 4, 'index': 1130}","it('run must return a promise', () => {
    for (const fn of simpleRunFunctions) {
      expect(() => (new PassInRunCommand(fn))[run]()).toThrow()
    }
  })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Conditional Test Logic,"{'line': 52, 'column': 4, 'index': 1329}","it('runs any function passed in', () => {
    for (const fn of simpleRunFunctions) {
      expect(() => (new SyncFunction(fn))[run]()).not.toThrow()
    }
  })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1583}","it('correctly calls function', () => {
    const functionSpy = jasmine.createSpy()
    const command = new SyncFunction(functionSpy)
    expect(functionSpy).not.toHaveBeenCalled()
    command[run]()
    expect(functionSpy).toHaveBeenCalledTimes(1)
  })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1649}","it('correctly calls function', () => {
    const functionSpy = jasmine.createSpy()
    const command = new SyncFunction(functionSpy)
    expect(functionSpy).not.toHaveBeenCalled()
    command[run]()
    expect(functionSpy).toHaveBeenCalledTimes(1)
  })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Duplicate Assert,"{'line': 79, 'column': 8, 'index': 2110}","it('runs commands sequentially', done => {
    const functionSpy = jasmine.createSpy()
    const commands = [
      () => {
        expect(functionSpy).not.toHaveBeenCalled()
      },
      functionSpy,
      () => {
        expect(functionSpy).toHaveBeenCalledTimes(1)
      },
      done
    ]

    const commands2 = commands.map(f => new SyncFunction(f));

    (new SequentialCommands(commands2))[run]()
  })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Duplicate Assert,"{'line': 83, 'column': 8, 'index': 2203}","it('runs commands sequentially', done => {
    const functionSpy = jasmine.createSpy()
    const commands = [
      () => {
        expect(functionSpy).not.toHaveBeenCalled()
      },
      functionSpy,
      () => {
        expect(functionSpy).toHaveBeenCalledTimes(1)
      },
      done
    ]

    const commands2 = commands.map(f => new SyncFunction(f));

    (new SequentialCommands(commands2))[run]()
  })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Duplicate Assert,"{'line': 99, 'column': 29, 'index': 2575}","it('runs commands concurrently', done => {
    const functionSpy = jasmine.createSpy()

    const commands = [
      new SyncFunction(() => expect(functionSpy).not.toHaveBeenCalled()),
      new SequentialCommands([new Sleep(100), new SyncFunction(functionSpy)]),
      new SequentialCommands([
        new Sleep(300),
        new SyncFunction(() => {
          expect(functionSpy).toHaveBeenCalledTimes(1)
          done()
        })
      ])
    ]

    const concurrentCommands = new ConcurrentCommands(commands)
    concurrentCommands[run]()
  })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Duplicate Assert,"{'line': 104, 'column': 10, 'index': 2797}","it('runs commands concurrently', done => {
    const functionSpy = jasmine.createSpy()

    const commands = [
      new SyncFunction(() => expect(functionSpy).not.toHaveBeenCalled()),
      new SequentialCommands([new Sleep(100), new SyncFunction(functionSpy)]),
      new SequentialCommands([
        new Sleep(300),
        new SyncFunction(() => {
          expect(functionSpy).toHaveBeenCalledTimes(1)
          done()
        })
      ])
    ]

    const concurrentCommands = new ConcurrentCommands(commands)
    concurrentCommands[run]()
  })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Duplicate Assert,"{'line': 122, 'column': 10, 'index': 3324}","it('running commands concurrently still works when commands not in array order', done => {
    const functionSpy = jasmine.createSpy()

    const commands = [
      new SequentialCommands([new Sleep(100), new SyncFunction(functionSpy)]),
      new SequentialCommands([
        new Sleep(300),
        new SyncFunction(() => {
          expect(functionSpy).toHaveBeenCalledTimes(1)
          done()
        })
      ]),
      new SyncFunction(() => expect(functionSpy).not.toHaveBeenCalled())
    ]

    const concurrentCommands = new ConcurrentCommands(commands)
    concurrentCommands[run]()
  })",steel
/test/app/lib/cinematic/AbstractCommand.spec.js,Duplicate Assert,"{'line': 126, 'column': 29, 'index': 3436}","it('running commands concurrently still works when commands not in array order', done => {
    const functionSpy = jasmine.createSpy()

    const commands = [
      new SequentialCommands([new Sleep(100), new SyncFunction(functionSpy)]),
      new SequentialCommands([
        new Sleep(300),
        new SyncFunction(() => {
          expect(functionSpy).toHaveBeenCalledTimes(1)
          done()
        })
      ]),
      new SyncFunction(() => expect(functionSpy).not.toHaveBeenCalled())
    ]

    const concurrentCommands = new ConcurrentCommands(commands)
    concurrentCommands[run]()
  })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 80, 'column': 12, 'index': 3387}","it('if born after 9/1/2009, should be 0-11', function() {
          const now = new Date('2021-1-1');
          const end = new Date('2021-4-30');
          const birthDates = [
            '2009-9-1',
            '2009-10-1',
            '2010-1-1',
            '2010-8-31',
            '2010-9-1',
            '2011-09-01'
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('0-11');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('0-11'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 105, 'column': 12, 'index': 4241}","it('if born during 9/1/2006 to 8/31/2009, should be 11-14', function() {
          const now = new Date('2021-1-1');
          const end = new Date('2021-4-30');
          const birthDates = [
            '2006-9-1',
            '2006-10-1',
            '2007-1-1',
            '2007-9-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('11-14');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('11-14'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 130, 'column': 12, 'index': 5097}","it('if born during 9/1/2002 to 8/31/2006, should be 14-18', function() {
          const now = new Date('2021-1-1');
          const end = new Date('2021-4-30');
          const birthDates = [
            '2002-9-1',
            '2002-10-1',
            '2003-1-1',
            '2003-9-1',
            '2004-1-1',
            '2005-9-1',
            '2006-1-1',
            '2006-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('14-18');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('14-18'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 149, 'column': 12, 'index': 5803}","it('if born before 8/31/2002, should be open', function() {
          const now = new Date('2021-1-1');
          const end = new Date('2021-4-30');
          const birthDates = [
            '2002-8-31',
            '2001-10-1',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('open');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('open'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 175, 'column': 12, 'index': 6694}","xit('if born after 9/1/2009, should be 0-11', function() {
          const now = new Date('2021-5-1');
          const end = new Date('2021-8-31');
          const birthDates = [
            '2009-9-1',
            '2009-10-1',
            '2010-1-1',
            '2010-8-31',
            '2010-9-1',
            '2011-09-01'
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('0-11');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('0-11'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 201, 'column': 12, 'index': 7580}","xit('if born during 9/1/2006 to 8/31/2009, should be 11-14', function() {
          const now = new Date('2021-5-1');
          const end = new Date('2021-8-31');
          const birthDates = [
            '2006-9-1',
            '2006-10-1',
            '2007-1-1',
            '2007-9-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('11-14');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('11-14'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 227, 'column': 12, 'index': 8468}","xit('if born during 9/1/2002 to 8/31/2006, should be 14-18', function() {
          const now = new Date('2021-5-1');
          const end = new Date('2021-8-31');
          const birthDates = [
            '2002-9-1',
            '2002-10-1',
            '2003-1-1',
            '2003-9-1',
            '2004-1-1',
            '2005-9-1',
            '2006-1-1',
            '2006-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('14-18');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('14-18'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 246, 'column': 12, 'index': 9174}","it('if born before 8/31/2002, should be open', function() {
          const now = new Date('2021-5-1');
          const end = new Date('2021-8-31');
          const birthDates = [
            '2002-8-31',
            '2001-10-1',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('open');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('open'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 271, 'column': 12, 'index': 10041}","it('if born after 9/1/2010, should be 0-11', function() {
          const now = new Date('2021-9-1');
          const end = new Date('2021-12-31');
          const birthDates = [
            '2010-9-1',
            '2010-10-1',
            '2011-1-1',
            '2011-8-31',
            '2011-9-1',
            '2012-09-01'
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('0-11');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('0-11'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 296, 'column': 12, 'index': 10896}","it('if born during 9/1/2007 to 8/31/2010, should be 11-14', function() {
          const now = new Date('2021-9-1');
          const end = new Date('2021-12-31');
          const birthDates = [
            '2007-9-1',
            '2007-10-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-9-1',
            '2010-1-1',
            '2010-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('11-14');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('11-14'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 321, 'column': 12, 'index': 11753}","it('if born during 9/1/2003 to 8/31/2007, should be 14-18', function() {
          const now = new Date('2021-9-1');
          const end = new Date('2021-12-31');
          const birthDates = [
            '2003-9-1',
            '2003-10-1',
            '2004-1-1',
            '2004-9-1',
            '2005-1-1',
            '2006-9-1',
            '2007-1-1',
            '2007-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('14-18');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('14-18'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 340, 'column': 12, 'index': 12460}","it('if born before 8/31/2003, should be open', function() {
          const now = new Date('2021-9-1');
          const end = new Date('2021-12-31');
          const birthDates = [
            '2003-8-31',
            '2002-10-1',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('open');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('open'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 477, 'column': 8, 'index': 18612}","it('returns correct map for r', function() {
      const levels = [
        { key: 1, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1']);
    })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 492, 'column': 8, 'index': 19082}","it('returns correct map for r r', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '2']);
    })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 506, 'column': 8, 'index': 19517}","it('returns correct map for p', function() {
      const levels = [
        { key: 1, practice: true }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['0a']);
    })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 522, 'column': 8, 'index': 20026}","it('returns correct map for r p r', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '1a', '2']);
    })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 539, 'column': 8, 'index': 20582}","it('returns correct map for r p p p', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: true },
        { key: 4, practice: true }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '1a', '1b', '1c']);
    })",steel
/test/app/core/utils.spec.ozar.js,Conditional Test Logic,"{'line': 563, 'column': 8, 'index': 21424}","it('returns correct map for r p p p r p p r r p r', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: true },
        { key: 4, practice: true },
        { key: 5, practice: false },
        { key: 6, practice: true },
        { key: 7, practice: true },
        { key: 8, practice: false },
        { key: 9, practice: false },
        { key: 10, practice: true },
        { key: 11, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '1a', '1b', '1c', '2', '2a', '2b', '3', '4', '4a', '5']);
    })",steel
/test/app/core/utils.spec.ozar.js,Duplicate Assert,"{'line': 424, 'column': 6, 'index': 15825}","it('i18n falls back to the default text, even for other targets (like blurb)', function() {
      delete this.fixture1.i18n['en'];
      expect(utils.i18n(this.fixture1, 'text', 'en')).toEqual(this.fixture1.text);
      expect(utils.i18n(this.fixture1, 'blurb', 'en')).toEqual(this.fixture1.blurb);
      delete this.fixture1.blurb;
      return expect(utils.i18n(this.fixture1, 'blurb', 'en')).toEqual(null);
    })",steel
/test/app/core/utils.spec.ozar.js,Duplicate Assert,"{'line': 426, 'column': 13, 'index': 15951}","it('i18n falls back to the default text, even for other targets (like blurb)', function() {
      delete this.fixture1.i18n['en'];
      expect(utils.i18n(this.fixture1, 'text', 'en')).toEqual(this.fixture1.text);
      expect(utils.i18n(this.fixture1, 'blurb', 'en')).toEqual(this.fixture1.blurb);
      delete this.fixture1.blurb;
      return expect(utils.i18n(this.fixture1, 'blurb', 'en')).toEqual(null);
    })",steel
/test/app/core/utils.spec.ozar.js,Exception Handling,"{'line': 437, 'column': 6, 'index': 16667}","it('EU countries return true', function() {
      const euCountries = ['Austria', 'Belgium', 'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'Estonia', 'Finland', 'France', 'Germany', 'Greece', 'Hungary', 'Ireland', 'Italy', 'Latvia', 'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Poland', 'Portugal', 'Romania', 'Slovakia', 'Slovenia', 'Spain', 'Sweden', 'United Kingdom'];
      try {
        return euCountries.forEach(c => expect(utils.inEU(c)).toEqual(true));
      } catch (err) {
// NOTE: without try/catch, exceptions do not yield failed tests.
// E.g. utils.inEU used to call Array.find which isn't supported in IE11, try/catch required to register test fail
        return expect(err).not.toBeDefined();
      }
    })",steel
/test/app/core/utils.spec.ozar.js,Exception Handling,"{'line': 447, 'column': 6, 'index': 17149}","it('non-EU countries return false', function() {
      const nonEuCountries = ['united-states', 'peru', 'vietnam'];
      try {
        return nonEuCountries.forEach(c => expect(utils.inEU(c)).toEqual(false));
      } catch (err) {
        return expect(err).not.toBeDefined();
      }
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 80, 'column': 17, 'index': 3392}","it('if born after 9/1/2009, should be 0-11', function() {
          const now = new Date('2021-1-1');
          const end = new Date('2021-4-30');
          const birthDates = [
            '2009-9-1',
            '2009-10-1',
            '2010-1-1',
            '2010-8-31',
            '2010-9-1',
            '2011-09-01'
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('0-11');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('0-11'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 105, 'column': 17, 'index': 4246}","it('if born during 9/1/2006 to 8/31/2009, should be 11-14', function() {
          const now = new Date('2021-1-1');
          const end = new Date('2021-4-30');
          const birthDates = [
            '2006-9-1',
            '2006-10-1',
            '2007-1-1',
            '2007-9-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('11-14');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('11-14'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 130, 'column': 17, 'index': 5102}","it('if born during 9/1/2002 to 8/31/2006, should be 14-18', function() {
          const now = new Date('2021-1-1');
          const end = new Date('2021-4-30');
          const birthDates = [
            '2002-9-1',
            '2002-10-1',
            '2003-1-1',
            '2003-9-1',
            '2004-1-1',
            '2005-9-1',
            '2006-1-1',
            '2006-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('14-18');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('14-18'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 149, 'column': 17, 'index': 5808}","it('if born before 8/31/2002, should be open', function() {
          const now = new Date('2021-1-1');
          const end = new Date('2021-4-30');
          const birthDates = [
            '2002-8-31',
            '2001-10-1',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('open');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('open'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 175, 'column': 17, 'index': 6699}","xit('if born after 9/1/2009, should be 0-11', function() {
          const now = new Date('2021-5-1');
          const end = new Date('2021-8-31');
          const birthDates = [
            '2009-9-1',
            '2009-10-1',
            '2010-1-1',
            '2010-8-31',
            '2010-9-1',
            '2011-09-01'
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('0-11');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('0-11'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 201, 'column': 17, 'index': 7585}","xit('if born during 9/1/2006 to 8/31/2009, should be 11-14', function() {
          const now = new Date('2021-5-1');
          const end = new Date('2021-8-31');
          const birthDates = [
            '2006-9-1',
            '2006-10-1',
            '2007-1-1',
            '2007-9-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('11-14');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('11-14'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 227, 'column': 17, 'index': 8473}","xit('if born during 9/1/2002 to 8/31/2006, should be 14-18', function() {
          const now = new Date('2021-5-1');
          const end = new Date('2021-8-31');
          const birthDates = [
            '2002-9-1',
            '2002-10-1',
            '2003-1-1',
            '2003-9-1',
            '2004-1-1',
            '2005-9-1',
            '2006-1-1',
            '2006-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('14-18');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('14-18'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 246, 'column': 17, 'index': 9179}","it('if born before 8/31/2002, should be open', function() {
          const now = new Date('2021-5-1');
          const end = new Date('2021-8-31');
          const birthDates = [
            '2002-8-31',
            '2001-10-1',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('open');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('open'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 271, 'column': 17, 'index': 10046}","it('if born after 9/1/2010, should be 0-11', function() {
          const now = new Date('2021-9-1');
          const end = new Date('2021-12-31');
          const birthDates = [
            '2010-9-1',
            '2010-10-1',
            '2011-1-1',
            '2011-8-31',
            '2011-9-1',
            '2012-09-01'
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('0-11');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('0-11'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 296, 'column': 17, 'index': 10901}","it('if born during 9/1/2007 to 8/31/2010, should be 11-14', function() {
          const now = new Date('2021-9-1');
          const end = new Date('2021-12-31');
          const birthDates = [
            '2007-9-1',
            '2007-10-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-9-1',
            '2010-1-1',
            '2010-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('11-14');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('11-14'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 321, 'column': 17, 'index': 11758}","it('if born during 9/1/2003 to 8/31/2007, should be 14-18', function() {
          const now = new Date('2021-9-1');
          const end = new Date('2021-12-31');
          const birthDates = [
            '2003-9-1',
            '2003-10-1',
            '2004-1-1',
            '2004-9-1',
            '2005-1-1',
            '2006-9-1',
            '2007-1-1',
            '2007-8-31',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('14-18');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('14-18'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 340, 'column': 17, 'index': 12465}","it('if born before 8/31/2003, should be open', function() {
          const now = new Date('2021-9-1');
          const end = new Date('2021-12-31');
          const birthDates = [
            '2003-8-31',
            '2002-10-1',
          ];
          return (() => {
            const result = [];
            for (var birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now);
              expect(utils.ageToBracket(getAge(now,birthDate))).toBe('open');
              jasmine.clock().mockDate(end);
              result.push(expect(utils.ageToBracket(getAge(end,birthDate))).toBe('open'));
            }
            return result;
          })();
        })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 477, 'column': 13, 'index': 18617}","it('returns correct map for r', function() {
      const levels = [
        { key: 1, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 478, 'column': 10, 'index': 18656}","it('returns correct map for r', function() {
      const levels = [
        { key: 1, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 492, 'column': 13, 'index': 19087}","it('returns correct map for r r', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '2']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 493, 'column': 10, 'index': 19126}","it('returns correct map for r r', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '2']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 506, 'column': 13, 'index': 19522}","it('returns correct map for p', function() {
      const levels = [
        { key: 1, practice: true }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['0a']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 507, 'column': 10, 'index': 19561}","it('returns correct map for p', function() {
      const levels = [
        { key: 1, practice: true }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['0a']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 522, 'column': 13, 'index': 20031}","it('returns correct map for r p r', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '1a', '2']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 523, 'column': 10, 'index': 20070}","it('returns correct map for r p r', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '1a', '2']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 539, 'column': 13, 'index': 20587}","it('returns correct map for r p p p', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: true },
        { key: 4, practice: true }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '1a', '1b', '1c']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 540, 'column': 10, 'index': 20626}","it('returns correct map for r p p p', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: true },
        { key: 4, practice: true }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '1a', '1b', '1c']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 563, 'column': 13, 'index': 21429}","it('returns correct map for r p p p r p p r r p r', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: true },
        { key: 4, practice: true },
        { key: 5, practice: false },
        { key: 6, practice: true },
        { key: 7, practice: true },
        { key: 8, practice: false },
        { key: 9, practice: false },
        { key: 10, practice: true },
        { key: 11, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '1a', '1b', '1c', '2', '2a', '2b', '3', '4', '4a', '5']);
    })",steel
/test/app/core/utils.spec.ozar.js,Global Variable,"{'line': 564, 'column': 10, 'index': 21468}","it('returns correct map for r p p p r p p r r p r', function() {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: true },
        { key: 4, practice: true },
        { key: 5, practice: false },
        { key: 6, practice: true },
        { key: 7, practice: true },
        { key: 8, practice: false },
        { key: 9, practice: false },
        { key: 10, practice: true },
        { key: 11, practice: false }
      ];
      const levelNumberMap = utils.createLevelNumberMap(levels);
      return expect(((() => {
        const result = [];
        for (var key in levelNumberMap) {
          var val = levelNumberMap[key];
          result.push(val.toString());
        }
        return result;
      })())).toEqual(['1', '1a', '1b', '1c', '2', '2a', '2b', '3', '4', '4a', '5']);
    })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 21, 'column': 64, 'index': 1022}","it('0 for same date', function() {
        jasmine.clock().mockDate(new Date(2020, 0, 1));
        return expect(utils.yearsSinceMonth('2020-01-01')).toBe(0);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 25, 'column': 64, 'index': 1201}","it('1 for previous year', function() {
        jasmine.clock().mockDate(new Date(2020, 0, 1));
        return expect(utils.yearsSinceMonth('2019-01-01')).toBe(1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 29, 'column': 64, 'index': 1384}","it('100 for previous decade', function() {
        jasmine.clock().mockDate(new Date(2020, 0, 1));
        return expect(utils.yearsSinceMonth('1920-01-01')).toBe(100);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 33, 'column': 64, 'index': 1587}","it('Jan 1 2012 to Jan 1 2013 should be 1 year', function() {
        jasmine.clock().mockDate(new Date(2013, 0, 1));
        return expect(utils.yearsSinceMonth('2012-01-01')).toBe(1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 37, 'column': 64, 'index': 1791}","it('Feb 28 2012 to Feb 28 2013 should be 1 year', function() {
        jasmine.clock().mockDate(new Date(2013, 1, 28));
        return expect(utils.yearsSinceMonth('2012-02-28')).toBe(1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 41, 'column': 64, 'index': 1992}","it('Mar 1 2012 to Mar 1 2013 should be 1 year', function() {
        jasmine.clock().mockDate(new Date(2013, 2, 1));
        return expect(utils.yearsSinceMonth('2012-03-01')).toBe(1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 45, 'column': 64, 'index': 2194}","it('Dec 1 2012 to Dec 1 2013 should be 1 year', function() {
        jasmine.clock().mockDate(new Date(2013, 11, 1));
        return expect(utils.yearsSinceMonth('2012-12-01')).toBe(1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 49, 'column': 64, 'index': 2406}","it('Dec 31 2012 to Dec 31 2013 should be 1 year', function() {
        jasmine.clock().mockDate(new Date(2013, 11, 31));
        return expect(utils.yearsSinceMonth('2012-12-31')).toBe(1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 456, 'column': 77, 'index': 17445}","it('US is 13', () => expect(utils.ageOfConsent('united-states')).toEqual(13))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 457, 'column': 74, 'index': 17525}","it('Latvia is 13', () => expect(utils.ageOfConsent('latvia')).toEqual(13))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 458, 'column': 76, 'index': 17607}","it('Austria is 14', () => expect(utils.ageOfConsent('austria')).toEqual(14))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 459, 'column': 74, 'index': 17687}","it('Greece is 15', () => expect(utils.ageOfConsent('greece')).toEqual(15))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 460, 'column': 78, 'index': 17771}","it('Slovakia is 16', () => expect(utils.ageOfConsent('slovakia')).toEqual(16))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 461, 'column': 89, 'index': 17866}","it('default for EU countries 16', () => expect(utils.ageOfConsent('israel')).toEqual(16))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 462, 'column': 97, 'index': 17969}","it('default for other countries is 0', () => expect(utils.ageOfConsent('hong-kong')).toEqual(0))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 463, 'column': 100, 'index': 18074}","it('default for unknown countries is 0', () => expect(utils.ageOfConsent('codecombat')).toEqual(0))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 464, 'column': 99, 'index': 18178}","it('default for undefined countries is 0', () => expect(utils.ageOfConsent(undefined)).toEqual(0))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 465, 'column': 96, 'index': 18279}","it('defaultIfUnknown works', () => expect(utils.ageOfConsent(undefined, 13)).toEqual(13))",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 590, 'column': 70, 'index': 22668}","it('returns correct next levels when rc* p', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false }
        ];
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(2);
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 599, 'column': 70, 'index': 23089}","it('returns correct next levels when pc* p r', function() {
        const levels = [
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(2);
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 608, 'column': 70, 'index': 23509}","it('returns correct next levels when pc* p p', function() {
        const levels = [
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false }
        ];
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(3);
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 617, 'column': 70, 'index': 23931}","it('returns correct next levels when rc* p rc', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true }
        ];
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(3);
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 628, 'column': 70, 'index': 24472}","it('returns correct next levels when rc rc rc* a r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 629, 'column': 90, 'index': 24566}","it('returns correct next levels when rc rc rc* a r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 647, 'column': 70, 'index': 25390}","it('returns correct next levels when rc* r p p p a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(1);
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 666, 'column': 70, 'index': 26309}","it('returns correct next levels when rc rc* p p p a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 1, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 1, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 667, 'column': 90, 'index': 26403}","it('returns correct next levels when rc rc* p p p a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 1, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 1, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 685, 'column': 70, 'index': 27227}","it('returns correct next levels when rc rc pc* p p a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 686, 'column': 90, 'index': 27321}","it('returns correct next levels when rc rc pc* p p a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 704, 'column': 70, 'index': 28145}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 705, 'column': 90, 'index': 28239}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 723, 'column': 70, 'index': 29063}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 742, 'column': 70, 'index': 29982}","it('returns correct next levels when rc rc pc pc pc ac rc* p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 6, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 6, needsPractice)).toEqual(10);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 743, 'column': 90, 'index': 30077}","it('returns correct next levels when rc rc pc pc pc ac rc* p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 6, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 6, needsPractice)).toEqual(10);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 761, 'column': 70, 'index': 30902}","it('returns correct next levels when rc rc* p p p a rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 762, 'column': 90, 'index': 30997}","it('returns correct next levels when rc rc* p p p a rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 780, 'column': 70, 'index': 31821}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 781, 'column': 90, 'index': 31916}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 799, 'column': 70, 'index': 32740}","it('returns correct next levels when rc rc* p p p ac rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 818, 'column': 70, 'index': 33666}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 830, 'column': 70, 'index': 34138}","it('returns correct next levels when rc* p', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false }
        ];
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(1);
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 838, 'column': 70, 'index': 34511}","it('returns correct next levels when rc* rc', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true }
        ];
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(2);
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 847, 'column': 70, 'index': 34933}","it('returns correct next levels when rc p rc*', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(1);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 857, 'column': 70, 'index': 35404}","it('returns correct next levels when rc pc p rc*', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true }
        ];
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(2);
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 868, 'column': 70, 'index': 35945}","it('returns correct next levels when rc rc rc* a r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 869, 'column': 90, 'index': 36039}","it('returns correct next levels when rc rc rc* a r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 879, 'column': 70, 'index': 36464}","it('returns correct next levels when rc pc p rc* p', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false }
        ];
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(4);
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 890, 'column': 70, 'index': 36984}","it('returns correct next levels when rc pc p rc* pc', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true }
        ];
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(5);
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 902, 'column': 70, 'index': 37553}","it('returns correct next levels when rc pc p rc* pc p', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false }
        ];
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(5);
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 914, 'column': 70, 'index': 38123}","it('returns correct next levels when rc pc p rc* pc r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(5);
        return expect(utils.findNextAssessmentForLevel(levels, 3)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 927, 'column': 70, 'index': 38727}","it('returns correct next levels when rc pc p rc* pc p r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(5);
        return expect(utils.findNextAssessmentForLevel(levels, 3)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 939, 'column': 70, 'index': 39282}","it('returns correct next levels when rc pc pc rc* r p', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false }
        ];
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(4);
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 948, 'column': 70, 'index': 39704}","it('returns correct next levels when rc* pc rc', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: false, complete: true }
        ];
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(3);
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 960, 'column': 70, 'index': 40274}","it('returns correct next levels when rc pc p rc* r p', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false }
        ];
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(2);
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 973, 'column': 70, 'index': 40912}","it('returns correct next levels when rc pc p a rc* r p', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(2);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 987, 'column': 70, 'index': 41582}","it('returns correct next levels when rc pc p a rc* pc p r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1006, 'column': 70, 'index': 42501}","it('returns correct next levels when rc rc* p p p a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 1, needsPractice)).toEqual(2);
        return expect(utils.findNextAssessmentForLevel(levels, 1, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1025, 'column': 70, 'index': 43420}","it('returns correct next levels when rc rc pc* p p a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(3);
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1044, 'column': 70, 'index': 44339}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1045, 'column': 90, 'index': 44433}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1063, 'column': 70, 'index': 45257}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1082, 'column': 70, 'index': 46176}","it('returns correct next levels when rc rc pc pc pc ac rc* p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 6, needsPractice)).toEqual(7);
        return expect(utils.findNextAssessmentForLevel(levels, 6, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1101, 'column': 70, 'index': 47095}","it('returns correct next levels when rc rc pc pc pc* ac rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(7);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1120, 'column': 70, 'index': 48014}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(7);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1121, 'column': 90, 'index': 48108}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(7);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1139, 'column': 70, 'index': 48932}","it('returns correct next levels when rc rc pc pc pc* ac rc pc pc pc a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11);
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.ozar.js,Magic Number,"{'line': 1158, 'column': 70, 'index': 49859}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function() {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ];
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6);
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1);
      })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 81, 'column': 12, 'index': 3398}","it('if born after 9/1/2009, should be 0-11', function () {
          const now = new Date(2021, 0, 1)
          const end = new Date(2021, 3, 30)
          const birthDates = [
            '2009-9-1',
            '2009-10-1',
            '2010-1-1',
            '2010-8-31',
            '2010-9-1',
            '2011-09-01'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('0-11')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('0-11'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 106, 'column': 12, 'index': 4245}","it('if born during 9/1/2006 to 8/31/2009, should be 11-14', function () {
          const now = new Date(2021, 0, 1)
          const end = new Date(2021, 3, 30)
          const birthDates = [
            '2006-9-1',
            '2006-10-1',
            '2007-1-1',
            '2007-9-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-8-31'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('11-14')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('11-14'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 131, 'column': 12, 'index': 5094}","it('if born during 9/1/2002 to 8/31/2006, should be 14-18', function () {
          const now = new Date(2021, 0, 1)
          const end = new Date(2021, 3, 30)
          const birthDates = [
            '2002-9-1',
            '2002-10-1',
            '2003-1-1',
            '2003-9-1',
            '2004-1-1',
            '2005-9-1',
            '2006-1-1',
            '2006-8-31'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('14-18')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('14-18'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 150, 'column': 12, 'index': 5793}","it('if born before 8/31/2002, should be open', function () {
          const now = new Date(2021, 0, 1)
          const end = new Date(2021, 3, 30)
          const birthDates = [
            '2002-8-31',
            '2001-10-1'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('open')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('open'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 175, 'column': 12, 'index': 6646}","it('if born after 9/1/2009, should be 0-11', function () {
          const now = new Date(2021, 4, 1)
          const end = new Date(2021, 7, 31)
          const birthDates = [
            '2009-9-1',
            '2009-10-1',
            '2010-1-1',
            '2010-8-31',
            '2010-9-1',
            '2011-09-01'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('0-11')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('0-11'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 200, 'column': 12, 'index': 7493}","it('if born during 9/1/2006 to 8/31/2009, should be 11-14', function () {
          const now = new Date(2021, 4, 1)
          const end = new Date(2021, 7, 31)
          const birthDates = [
            '2006-9-1',
            '2006-10-1',
            '2007-1-1',
            '2007-9-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-8-31'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('11-14')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('11-14'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 225, 'column': 12, 'index': 8342}","it('if born during 9/1/2002 to 8/31/2006, should be 14-18', function () {
          const now = new Date(2021, 4, 1)
          const end = new Date(2021, 7, 31)
          const birthDates = [
            '2002-9-1',
            '2002-10-1',
            '2003-1-1',
            '2003-9-1',
            '2004-1-1',
            '2005-9-1',
            '2006-1-1',
            '2006-8-31'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('14-18')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('14-18'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 244, 'column': 12, 'index': 9041}","it('if born before 8/31/2002, should be open', function () {
          const now = new Date(2021, 4, 1)
          const end = new Date(2021, 7, 31)
          const birthDates = [
            '2002-8-31',
            '2001-10-1'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('open')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('open'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 269, 'column': 12, 'index': 9902}","it('if born after 9/1/2010, should be 0-11', function () {
          const now = new Date(2021, 8, 1)
          const end = new Date(2021, 11, 31)
          const birthDates = [
            '2010-9-1',
            '2010-10-1',
            '2011-1-1',
            '2011-8-31',
            '2011-9-1',
            '2012-09-01'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('0-11')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('0-11'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 294, 'column': 12, 'index': 10750}","it('if born during 9/1/2007 to 8/31/2010, should be 11-14', function () {
          const now = new Date(2021, 8, 1)
          const end = new Date(2021, 11, 31)
          const birthDates = [
            '2007-9-1',
            '2007-10-1',
            '2008-1-1',
            '2008-9-1',
            '2009-1-1',
            '2009-9-1',
            '2010-1-1',
            '2010-8-31'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('11-14')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('11-14'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 319, 'column': 12, 'index': 11600}","it('if born during 9/1/2003 to 8/31/2007, should be 14-18', function () {
          const now = new Date(2021, 8, 1)
          const end = new Date(2021, 11, 31)
          const birthDates = [
            '2003-9-1',
            '2003-10-1',
            '2004-1-1',
            '2004-9-1',
            '2005-1-1',
            '2006-9-1',
            '2007-1-1',
            '2007-8-31'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('14-18')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('14-18'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 338, 'column': 12, 'index': 12300}","it('if born before 8/31/2003, should be open', function () {
          const now = new Date(2021, 8, 1)
          const end = new Date(2021, 11, 31)
          const birthDates = [
            '2003-8-31',
            '2002-10-1'
          ]
          return (() => {
            const result = []
            for (const birthDate of Array.from(birthDates)) {
              jasmine.clock().mockDate(now)
              expect(utils.ageToBracket(getAge(now, birthDate))).toBe('open')
              jasmine.clock().mockDate(end)
              result.push(expect(utils.ageToBracket(getAge(end, birthDate))).toBe('open'))
            }
            return result
          })()
        })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 475, 'column': 8, 'index': 18383}","it('returns correct map for r', function () {
      const levels = [
        { key: 1, practice: false }
      ]
      const levelNumberMap = utils.createLevelNumberMap(levels)
      return expect(((() => {
        const result = []
        for (const key in levelNumberMap) {
          const val = levelNumberMap[key]
          result.push(val.toString())
        }
        return result
      })())).toEqual(['1'])
    })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 490, 'column': 8, 'index': 18850}","it('returns correct map for r r', function () {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: false }
      ]
      const levelNumberMap = utils.createLevelNumberMap(levels)
      return expect(((() => {
        const result = []
        for (const key in levelNumberMap) {
          const val = levelNumberMap[key]
          result.push(val.toString())
        }
        return result
      })())).toEqual(['1', '2'])
    })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 504, 'column': 8, 'index': 19282}","it('returns correct map for p', function () {
      const levels = [
        { key: 1, practice: true }
      ]
      const levelNumberMap = utils.createLevelNumberMap(levels)
      return expect(((() => {
        const result = []
        for (const key in levelNumberMap) {
          const val = levelNumberMap[key]
          result.push(val.toString())
        }
        return result
      })())).toEqual(['0a'])
    })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 520, 'column': 8, 'index': 19788}","it('returns correct map for r p r', function () {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: false }
      ]
      const levelNumberMap = utils.createLevelNumberMap(levels)
      return expect(((() => {
        const result = []
        for (const key in levelNumberMap) {
          const val = levelNumberMap[key]
          result.push(val.toString())
        }
        return result
      })())).toEqual(['1', '1a', '2'])
    })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 537, 'column': 8, 'index': 20341}","it('returns correct map for r p p p', function () {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: true },
        { key: 4, practice: true }
      ]
      const levelNumberMap = utils.createLevelNumberMap(levels)
      return expect(((() => {
        const result = []
        for (const key in levelNumberMap) {
          const val = levelNumberMap[key]
          result.push(val.toString())
        }
        return result
      })())).toEqual(['1', '1a', '1b', '1c'])
    })",steel
/test/app/core/utils.spec.coco.js,Conditional Test Logic,"{'line': 561, 'column': 8, 'index': 21180}","it('returns correct map for r p p p r p p r r p r', function () {
      const levels = [
        { key: 1, practice: false },
        { key: 2, practice: true },
        { key: 3, practice: true },
        { key: 4, practice: true },
        { key: 5, practice: false },
        { key: 6, practice: true },
        { key: 7, practice: true },
        { key: 8, practice: false },
        { key: 9, practice: false },
        { key: 10, practice: true },
        { key: 11, practice: false }
      ]
      const levelNumberMap = utils.createLevelNumberMap(levels)
      return expect(((() => {
        const result = []
        for (const key in levelNumberMap) {
          const val = levelNumberMap[key]
          result.push(val.toString())
        }
        return result
      })())).toEqual(['1', '1a', '1b', '1c', '2', '2a', '2b', '3', '4', '4a', '5'])
    })",steel
/test/app/core/utils.spec.coco.js,Duplicate Assert,"{'line': 422, 'column': 6, 'index': 15599}","it('i18n falls back to the default text, even for other targets (like blurb)', function () {
      delete this.fixture1.i18n.en
      expect(utils.i18n(this.fixture1, 'text', 'en')).toEqual(this.fixture1.text)
      expect(utils.i18n(this.fixture1, 'blurb', 'en')).toEqual(this.fixture1.blurb)
      delete this.fixture1.blurb
      return expect(utils.i18n(this.fixture1, 'blurb', 'en')).toEqual(null)
    })",steel
/test/app/core/utils.spec.coco.js,Duplicate Assert,"{'line': 424, 'column': 13, 'index': 15723}","it('i18n falls back to the default text, even for other targets (like blurb)', function () {
      delete this.fixture1.i18n.en
      expect(utils.i18n(this.fixture1, 'text', 'en')).toEqual(this.fixture1.text)
      expect(utils.i18n(this.fixture1, 'blurb', 'en')).toEqual(this.fixture1.blurb)
      delete this.fixture1.blurb
      return expect(utils.i18n(this.fixture1, 'blurb', 'en')).toEqual(null)
    })",steel
/test/app/core/utils.spec.coco.js,Exception Handling,"{'line': 435, 'column': 6, 'index': 16436}","it('EU countries return true', function () {
      const euCountries = ['Austria', 'Belgium', 'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'Estonia', 'Finland', 'France', 'Germany', 'Greece', 'Hungary', 'Ireland', 'Italy', 'Latvia', 'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Poland', 'Portugal', 'Romania', 'Slovakia', 'Slovenia', 'Spain', 'Sweden', 'United Kingdom']
      try {
        return euCountries.forEach(c => expect(utils.inEU(c)).toEqual(true))
      } catch (err) {
        // NOTE: without try/catch, exceptions do not yield failed tests.
        // E.g. utils.inEU used to call Array.find which isn't supported in IE11, try/catch required to register test fail
        return expect(err).not.toBeDefined()
      }
    })",steel
/test/app/core/utils.spec.coco.js,Exception Handling,"{'line': 445, 'column': 6, 'index': 16931}","it('non-EU countries return false', function () {
      const nonEuCountries = ['united-states', 'peru', 'vietnam']
      try {
        return nonEuCountries.forEach(c => expect(utils.inEU(c)).toEqual(false))
      } catch (err) {
        return expect(err).not.toBeDefined()
      }
    })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 23, 'column': 64, 'index': 1057}","it('0 for same date', function () {
        jasmine.clock().mockDate(new Date(2020, 0, 1))
        return expect(utils.yearsSinceMonth('2020-01-01')).toBe(0)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 27, 'column': 64, 'index': 1234}","it('1 for previous year', function () {
        jasmine.clock().mockDate(new Date(2020, 0, 1))
        return expect(utils.yearsSinceMonth('2019-01-01')).toBe(1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 31, 'column': 64, 'index': 1415}","it('100 for previous decade', function () {
        jasmine.clock().mockDate(new Date(2020, 0, 1))
        return expect(utils.yearsSinceMonth('1920-01-01')).toBe(100)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 35, 'column': 64, 'index': 1616}","it('Jan 1 2012 to Jan 1 2013 should be 1 year', function () {
        jasmine.clock().mockDate(new Date(2013, 0, 1))
        return expect(utils.yearsSinceMonth('2012-01-01')).toBe(1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 39, 'column': 64, 'index': 1818}","it('Feb 28 2012 to Feb 28 2013 should be 1 year', function () {
        jasmine.clock().mockDate(new Date(2013, 1, 28))
        return expect(utils.yearsSinceMonth('2012-02-28')).toBe(1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 43, 'column': 64, 'index': 2017}","it('Mar 1 2012 to Mar 1 2013 should be 1 year', function () {
        jasmine.clock().mockDate(new Date(2013, 2, 1))
        return expect(utils.yearsSinceMonth('2012-03-01')).toBe(1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 47, 'column': 64, 'index': 2217}","it('Dec 1 2012 to Dec 1 2013 should be 1 year', function () {
        jasmine.clock().mockDate(new Date(2013, 11, 1))
        return expect(utils.yearsSinceMonth('2012-12-01')).toBe(1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 51, 'column': 64, 'index': 2427}","it('Dec 31 2012 to Dec 31 2013 should be 1 year', function () {
        jasmine.clock().mockDate(new Date(2013, 11, 31))
        return expect(utils.yearsSinceMonth('2012-12-31')).toBe(1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 454, 'column': 77, 'index': 17224}","it('US is 13', () => expect(utils.ageOfConsent('united-states')).toEqual(13))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 455, 'column': 74, 'index': 17303}","it('Latvia is 13', () => expect(utils.ageOfConsent('latvia')).toEqual(13))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 456, 'column': 76, 'index': 17384}","it('Austria is 14', () => expect(utils.ageOfConsent('austria')).toEqual(14))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 457, 'column': 74, 'index': 17463}","it('Greece is 15', () => expect(utils.ageOfConsent('greece')).toEqual(15))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 458, 'column': 78, 'index': 17546}","it('Slovakia is 16', () => expect(utils.ageOfConsent('slovakia')).toEqual(16))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 459, 'column': 89, 'index': 17640}","it('default for EU countries 16', () => expect(utils.ageOfConsent('israel')).toEqual(16))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 460, 'column': 97, 'index': 17742}","it('default for other countries is 0', () => expect(utils.ageOfConsent('hong-kong')).toEqual(0))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 461, 'column': 100, 'index': 17846}","it('default for unknown countries is 0', () => expect(utils.ageOfConsent('codecombat')).toEqual(0))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 462, 'column': 99, 'index': 17949}","it('default for undefined countries is 0', () => expect(utils.ageOfConsent(undefined)).toEqual(0))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 463, 'column': 96, 'index': 18049}","it('defaultIfUnknown works', () => expect(utils.ageOfConsent(undefined, 13)).toEqual(13))",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 588, 'column': 70, 'index': 22516}","it('returns correct next levels when required complete level followed by optional locked practice level', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false, optional: true, locked: true }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 598, 'column': 70, 'index': 23046}","it('returns correct next levels when completed practice level followed by optional locked practice level and incomplete level', function () {
        const levels = [
          { practice: true, complete: true },
          { practice: true, complete: false, optional: true, locked: true },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 608, 'column': 70, 'index': 23587}","it('returns correct next levels when completed practice level followed by optional unlocked practice level and incomplete practice level', function () {
        const levels = [
          { practice: true, complete: true },
          { practice: true, complete: false, optional: true, locked: false },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(3)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 618, 'column': 70, 'index': 24123}","it('returns correct next levels when required complete level followed by optional locked practice level and required complete level', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false, optional: true, locked: true },
          { practice: false, complete: true }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(3)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 630, 'column': 70, 'index': 24773}","it('returns correct next levels when sequence of required complete levels followed by optional unlocked level and assessment level', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true, optional: true, locked: false },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 631, 'column': 90, 'index': 24866}","it('returns correct next levels when sequence of required complete levels followed by optional unlocked level and assessment level', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true, optional: true, locked: false },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 654, 'column': 70, 'index': 26045}","it('returns correct next levels when sequence of normal levels with an optional locked level in between', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true, locked: true, optional: true },
          { practice: false, complete: true },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 666, 'column': 70, 'index': 26705}","it('returns correct next levels when sequence of normal/complete levels with an optional unlocked level in between', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true, locked: false, optional: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 675, 'column': 70, 'index': 27075}","it('returns correct next levels when rc* p', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 684, 'column': 70, 'index': 27493}","it('returns correct next levels when pc* p r', function () {
        const levels = [
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 693, 'column': 70, 'index': 27910}","it('returns correct next levels when pc* p p', function () {
        const levels = [
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(3)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 702, 'column': 70, 'index': 28329}","it('returns correct next levels when rc* p rc', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(3)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 713, 'column': 70, 'index': 28867}","it('returns correct next levels when rc rc rc* a r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 714, 'column': 90, 'index': 28960}","it('returns correct next levels when rc rc rc* a r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 732, 'column': 70, 'index': 29782}","it('returns correct next levels when rc* r p p p a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(1)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 751, 'column': 70, 'index': 30698}","it('returns correct next levels when rc rc* p p p a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 1, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 1, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 752, 'column': 90, 'index': 30791}","it('returns correct next levels when rc rc* p p p a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 1, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 1, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 770, 'column': 70, 'index': 31613}","it('returns correct next levels when rc rc pc* p p a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 771, 'column': 90, 'index': 31706}","it('returns correct next levels when rc rc pc* p p a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 789, 'column': 70, 'index': 32528}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 790, 'column': 90, 'index': 32621}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 808, 'column': 70, 'index': 33443}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 827, 'column': 70, 'index': 34359}","it('returns correct next levels when rc rc pc pc pc ac rc* p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 6, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 6, needsPractice)).toEqual(10)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 828, 'column': 90, 'index': 34453}","it('returns correct next levels when rc rc pc pc pc ac rc* p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 6, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 6, needsPractice)).toEqual(10)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 846, 'column': 70, 'index': 35276}","it('returns correct next levels when rc rc* p p p a rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 847, 'column': 90, 'index': 35370}","it('returns correct next levels when rc rc* p p p a rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 865, 'column': 70, 'index': 36192}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 866, 'column': 90, 'index': 36286}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 884, 'column': 70, 'index': 37108}","it('returns correct next levels when rc rc* p p p ac rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 903, 'column': 70, 'index': 38024}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 926, 'column': 70, 'index': 39034}","it('returns correct next levels when rc* p', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(1)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 934, 'column': 70, 'index': 39404}","it('returns correct next levels when rc* rc', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 943, 'column': 70, 'index': 39823}","it('returns correct next levels when rc p rc*', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(1)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 953, 'column': 70, 'index': 40291}","it('returns correct next levels when rc pc p rc*', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 964, 'column': 70, 'index': 40829}","it('returns correct next levels when rc rc rc* a r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 965, 'column': 90, 'index': 40922}","it('returns correct next levels when rc rc rc* a r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(3)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 975, 'column': 70, 'index': 41345}","it('returns correct next levels when rc pc p rc* p', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 986, 'column': 70, 'index': 41862}","it('returns correct next levels when rc pc p rc* pc', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(5)
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 998, 'column': 70, 'index': 42428}","it('returns correct next levels when rc pc p rc* pc p', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(5)
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1010, 'column': 70, 'index': 42995}","it('returns correct next levels when rc pc p rc* pc r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(5)
        return expect(utils.findNextAssessmentForLevel(levels, 3)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1023, 'column': 70, 'index': 43596}","it('returns correct next levels when rc pc p rc* pc p r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(5)
        return expect(utils.findNextAssessmentForLevel(levels, 3)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1035, 'column': 70, 'index': 44148}","it('returns correct next levels when rc pc pc rc* r p', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: false, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(4)
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1044, 'column': 70, 'index': 44567}","it('returns correct next levels when rc* pc rc', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: false, complete: true }
        ]
        expect(utils.findNextLevel(levels, 0, needsPractice)).toEqual(3)
        return expect(utils.findNextAssessmentForLevel(levels, 0, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1056, 'column': 70, 'index': 45134}","it('returns correct next levels when rc pc p rc* r p', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 3, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 3, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1069, 'column': 70, 'index': 45769}","it('returns correct next levels when rc pc p a rc* r p', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: false, assessment: true },
          { practice: false, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1083, 'column': 70, 'index': 46436}","it('returns correct next levels when rc pc p a rc* pc p r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1102, 'column': 70, 'index': 47352}","it('returns correct next levels when rc rc* p p p a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 1, needsPractice)).toEqual(2)
        return expect(utils.findNextAssessmentForLevel(levels, 1, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1121, 'column': 70, 'index': 48268}","it('returns correct next levels when rc rc pc* p p a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 2, needsPractice)).toEqual(3)
        return expect(utils.findNextAssessmentForLevel(levels, 2, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1140, 'column': 70, 'index': 49184}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1141, 'column': 90, 'index': 49277}","it('returns correct next levels when rc rc pc pc pc* a r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1159, 'column': 70, 'index': 50099}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1178, 'column': 70, 'index': 51015}","it('returns correct next levels when rc rc pc pc pc ac rc* p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 6, needsPractice)).toEqual(7)
        return expect(utils.findNextAssessmentForLevel(levels, 6, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1197, 'column': 70, 'index': 51931}","it('returns correct next levels when rc rc pc pc pc* ac rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(7)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1216, 'column': 70, 'index': 52847}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(7)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1217, 'column': 90, 'index': 52940}","it('returns correct next levels when rc rc pc pc pc* a rc p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: true },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(7)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(5)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1235, 'column': 70, 'index': 53762}","it('returns correct next levels when rc rc pc pc pc* ac rc pc pc pc a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 4, needsPractice)).toEqual(11)
        return expect(utils.findNextAssessmentForLevel(levels, 4, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/utils.spec.coco.js,Magic Number,"{'line': 1254, 'column': 70, 'index': 54679}","it('returns correct next levels when rc rc pc pc pc ac* r p p p a r r', function () {
        const levels = [
          { practice: false, complete: true },
          { practice: false, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { practice: true, complete: true },
          { assessment: true, complete: true },
          { practice: false, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { practice: true, complete: false },
          { assessment: true, complete: false },
          { practice: false, complete: false },
          { practice: false, complete: false }
        ]
        expect(utils.findNextLevel(levels, 5, needsPractice)).toEqual(6)
        return expect(utils.findNextAssessmentForLevel(levels, 5, needsPractice)).toEqual(-1)
      })",steel
/test/app/core/locale.spec.coco.js,Conditional Test Logic,"{'line': 23, 'column': 8, 'index': 1165}","it('should have numbered placeholders $1 through $N', function() {
        const placeholders = (esper[key].match(/\$\d/g) || []).sort();
        const expectedPlaceholders = (Array.from(placeholders).map((val, index) => `$${index+1}`));
        if (!_.isEqual(placeholders, expectedPlaceholders)) {
          return fail(`\
Some placeholders were skipped: ${placeholders}
Translated string: ${esper[key]}\
`
          );
        }
      })",steel
/test/app/core/locale.spec.coco.js,Conditional Test Logic,"{'line': 33, 'column': 8, 'index': 1464}","it('should have the same placeholders in each entry as in English', function() {
        if (!englishEsper[key]) {
          return fail(`Expected English to have a corresponding key for ${key}`);
        }
        const englishPlaceholders = (englishEsper[key].match(/\$\d/g) || []).sort();
        const placeholders = (esper[key].match(/\$\d/g) || []).sort();
        if (!_.isEqual(placeholders, englishPlaceholders)) {
          return fail(`\
Expected translated placeholders: [${placeholders}] (${esper[key]})
To match English placeholders: [${englishPlaceholders}] (${englishEsper[key]})\
`
          );
        }
      })",steel
/test/app/core/locale.spec.coco.js,Conditional Test Logic,"{'line': 38, 'column': 8, 'index': 1746}","it('should have the same placeholders in each entry as in English', function() {
        if (!englishEsper[key]) {
          return fail(`Expected English to have a corresponding key for ${key}`);
        }
        const englishPlaceholders = (englishEsper[key].match(/\$\d/g) || []).sort();
        const placeholders = (esper[key].match(/\$\d/g) || []).sort();
        if (!_.isEqual(placeholders, englishPlaceholders)) {
          return fail(`\
Expected translated placeholders: [${placeholders}] (${esper[key]})
To match English placeholders: [${englishPlaceholders}] (${englishEsper[key]})\
`
          );
        }
      })",steel
/test/app/core/locale.spec.coco.js,Conditional Test Logic,"{'line': 54, 'column': 4, 'index': 2157}","describe('Check keys', function() {
  let section, key;
  const enKeysFlattened = _.flatten(((() => {
    const result = [];
    for (section in english.translation) {
      result.push((() => {
        const result1 = [];
        for (key in english.translation[section]) {
          result1.push(section + '.' + key);
        }
        return result1;
      })());
    }
    return result;
  })()));
  return langs.forEach(language => {
    let key;
    const langKeysFlattened = _.flatten(((() => {
      const result2 = [];
      for (section in language.translation) {
        result2.push((() => {
          const result3 = [];
          for (key in language.translation[section]) {
            result3.push(section + '.' + key);
          }
          return result3;
        })());
      }
      return result2;
    })()));
    const diff = _.difference(langKeysFlattened, enKeysFlattened);
    return describe(`when language is ${language.englishDescription}`, () => it('should have the same keys in each entry as in English', function() {
      if (diff.length) {
        return diff.slice(0, 100).forEach(key => fail(`\
Expected english to have translation '${key}'
This can occur when:
* Parent key for '${key.split('.')[0]}' is accidentally commented.
* English translation for '${key}' has been deleted.
You may need to run copy-i18n-tags.js\
`
        ));
      } else {
        return expect(diff.length).toBe(0);
      }
    }));
  });
})",steel
/test/app/core/locale.spec.coco.js,Conditional Test Logic,"{'line': 57, 'column': 8, 'index': 2259}","describe('Check keys', function() {
  let section, key;
  const enKeysFlattened = _.flatten(((() => {
    const result = [];
    for (section in english.translation) {
      result.push((() => {
        const result1 = [];
        for (key in english.translation[section]) {
          result1.push(section + '.' + key);
        }
        return result1;
      })());
    }
    return result;
  })()));
  return langs.forEach(language => {
    let key;
    const langKeysFlattened = _.flatten(((() => {
      const result2 = [];
      for (section in language.translation) {
        result2.push((() => {
          const result3 = [];
          for (key in language.translation[section]) {
            result3.push(section + '.' + key);
          }
          return result3;
        })());
      }
      return result2;
    })()));
    const diff = _.difference(langKeysFlattened, enKeysFlattened);
    return describe(`when language is ${language.englishDescription}`, () => it('should have the same keys in each entry as in English', function() {
      if (diff.length) {
        return diff.slice(0, 100).forEach(key => fail(`\
Expected english to have translation '${key}'
This can occur when:
* Parent key for '${key.split('.')[0]}' is accidentally commented.
* English translation for '${key}' has been deleted.
You may need to run copy-i18n-tags.js\
`
        ));
      } else {
        return expect(diff.length).toBe(0);
      }
    }));
  });
})",steel
/test/app/core/locale.spec.coco.js,Conditional Test Logic,"{'line': 69, 'column': 6, 'index': 2562}","describe('Check keys', function() {
  let section, key;
  const enKeysFlattened = _.flatten(((() => {
    const result = [];
    for (section in english.translation) {
      result.push((() => {
        const result1 = [];
        for (key in english.translation[section]) {
          result1.push(section + '.' + key);
        }
        return result1;
      })());
    }
    return result;
  })()));
  return langs.forEach(language => {
    let key;
    const langKeysFlattened = _.flatten(((() => {
      const result2 = [];
      for (section in language.translation) {
        result2.push((() => {
          const result3 = [];
          for (key in language.translation[section]) {
            result3.push(section + '.' + key);
          }
          return result3;
        })());
      }
      return result2;
    })()));
    const diff = _.difference(langKeysFlattened, enKeysFlattened);
    return describe(`when language is ${language.englishDescription}`, () => it('should have the same keys in each entry as in English', function() {
      if (diff.length) {
        return diff.slice(0, 100).forEach(key => fail(`\
Expected english to have translation '${key}'
This can occur when:
* Parent key for '${key.split('.')[0]}' is accidentally commented.
* English translation for '${key}' has been deleted.
You may need to run copy-i18n-tags.js\
`
        ));
      } else {
        return expect(diff.length).toBe(0);
      }
    }));
  });
})",steel
/test/app/core/locale.spec.coco.js,Conditional Test Logic,"{'line': 72, 'column': 10, 'index': 2672}","describe('Check keys', function() {
  let section, key;
  const enKeysFlattened = _.flatten(((() => {
    const result = [];
    for (section in english.translation) {
      result.push((() => {
        const result1 = [];
        for (key in english.translation[section]) {
          result1.push(section + '.' + key);
        }
        return result1;
      })());
    }
    return result;
  })()));
  return langs.forEach(language => {
    let key;
    const langKeysFlattened = _.flatten(((() => {
      const result2 = [];
      for (section in language.translation) {
        result2.push((() => {
          const result3 = [];
          for (key in language.translation[section]) {
            result3.push(section + '.' + key);
          }
          return result3;
        })());
      }
      return result2;
    })()));
    const diff = _.difference(langKeysFlattened, enKeysFlattened);
    return describe(`when language is ${language.englishDescription}`, () => it('should have the same keys in each entry as in English', function() {
      if (diff.length) {
        return diff.slice(0, 100).forEach(key => fail(`\
Expected english to have translation '${key}'
This can occur when:
* Parent key for '${key.split('.')[0]}' is accidentally commented.
* English translation for '${key}' has been deleted.
You may need to run copy-i18n-tags.js\
`
        ));
      } else {
        return expect(diff.length).toBe(0);
      }
    }));
  });
})",steel
/test/app/core/locale.spec.coco.js,Conditional Test Logic,"{'line': 82, 'column': 6, 'index': 3082}","it('should have the same keys in each entry as in English', function() {
      if (diff.length) {
        return diff.slice(0, 100).forEach(key => fail(`\
Expected english to have translation '${key}'
This can occur when:
* Parent key for '${key.split('.')[0]}' is accidentally commented.
* English translation for '${key}' has been deleted.
You may need to run copy-i18n-tags.js\
`
        ));
      } else {
        return expect(diff.length).toBe(0);
      }
    })",steel
/test/app/core/locale.spec.coco.js,Magic Number,"{'line': 92, 'column': 40, 'index': 3453}","it('should have the same keys in each entry as in English', function() {
      if (diff.length) {
        return diff.slice(0, 100).forEach(key => fail(`\
Expected english to have translation '${key}'
This can occur when:
* Parent key for '${key.split('.')[0]}' is accidentally commented.
* English translation for '${key}' has been deleted.
You may need to run copy-i18n-tags.js\
`
        ));
      } else {
        return expect(diff.length).toBe(0);
      }
    })",steel
/test/app/core/locale.spec.coco.js,Unknown Test,"{'column': 6, 'line': 20}","it('should have numbered placeholders $1 through $N', function() {
        const placeholders = (esper[key].match(/\$\d/g) || []).sort();
        const expectedPlaceholders = (Array.from(placeholders).map((val, index) => `$${index+1}`));
        if (!_.isEqual(placeholders, expectedPlaceholders)) {
          return fail(`\
Some placeholders were skipped: ${placeholders}
Translated string: ${esper[key]}\
`
          );
        }
      })",steel
/test/app/core/locale.spec.coco.js,Unknown Test,"{'column': 13, 'line': 32}","it('should have the same placeholders in each entry as in English', function() {
        if (!englishEsper[key]) {
          return fail(`Expected English to have a corresponding key for ${key}`);
        }
        const englishPlaceholders = (englishEsper[key].match(/\$\d/g) || []).sort();
        const placeholders = (esper[key].match(/\$\d/g) || []).sort();
        if (!_.isEqual(placeholders, englishPlaceholders)) {
          return fail(`\
Expected translated placeholders: [${placeholders}] (${esper[key]})
To match English placeholders: [${englishPlaceholders}] (${englishEsper[key]})\
`
          );
        }
      })",steel
/test/app/core/deltas.spec.js,Magic Number,"{'line': 37, 'column': 38, 'index': 1538}","it('should not be confused by array index changes', function() {
    const copy = x => JSON.parse(JSON.stringify(x));
    const x = ([0, 1, 2, 3, 4, 5, 6, 7].map((y) => ({value: y, id: `ID:${y}`, squared: y*y})));
    x[3].target = 1;
    const x1 = copy(x);
    x[3].target = -1;
    x.splice(0, 0, {id: 'New'});
    const x2 = copy(x);

    const differ = deltas.makeJSONDiffer();
    const delta = deltas.expandDelta(differ.diff({V: x1},  {V: x2}), {V: x1});

    expect(delta[1].humanPath).toEqual(""V :: ID:3 :: Target"");
    expect(delta[1].oldValue).toEqual(1);
    return expect(delta[1].newValue).toEqual(-1);
  })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 627, 'column': 8, 'index': 19963}","it('Fades a track and returns promise that resolves when complete', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'background')

        const sounds = store.getters['audio/getTrackSounds']('background')
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { track: 'background', from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeTrack', fadeConfig)

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 634, 'column': 8, 'index': 20202}","it('Fades a track and returns promise that resolves when complete', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'background')

        const sounds = store.getters['audio/getTrackSounds']('background')
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { track: 'background', from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeTrack', fadeConfig)

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 651, 'column': 8, 'index': 20777}","it('Only fades and stops songs present when fadeAndStopTrack dispatched', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'background')

        const sounds = store.getters['audio/getTrackSounds']('background')
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { track: 'background', from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeTrack', fadeConfig)

        const { sound: lateSound } = await playSound(store, 'background')
        spyOn(lateSound, 'stop')

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(lateSound.stop.calls.count()).toEqual(0)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 661, 'column': 8, 'index': 21124}","it('Only fades and stops songs present when fadeAndStopTrack dispatched', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'background')

        const sounds = store.getters['audio/getTrackSounds']('background')
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { track: 'background', from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeTrack', fadeConfig)

        const { sound: lateSound } = await playSound(store, 'background')
        spyOn(lateSound, 'stop')

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(lateSound.stop.calls.count()).toEqual(0)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 680, 'column': 8, 'index': 21729}","it('Fades all sounds and returns promise that resolves when complete', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'ui')

        const sounds = store.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAll', fadeConfig)

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 687, 'column': 8, 'index': 21945}","it('Fades all sounds and returns promise that resolves when complete', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'ui')

        const sounds = store.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAll', fadeConfig)

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 757, 'column': 8, 'index': 24253}","it('Fades and stops a track', async (done) => {
        const { sound: sound1, id: id1 } = await playSound(store, 'background')
        const { sound: sound2, id: id2 } = await playSound(store, 'background')

        const startVol = 0.11
        const sounds = store.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAndStopTrack', { track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound2.stop.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 766, 'column': 8, 'index': 24585}","it('Fades and stops a track', async (done) => {
        const { sound: sound1, id: id1 } = await playSound(store, 'background')
        const { sound: sound2, id: id2 } = await playSound(store, 'background')

        const startVol = 0.11
        const sounds = store.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAndStopTrack', { track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound2.stop.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 795, 'column': 8, 'index': 25441}","it('Fades stops and unloads a track', async (done) => {
        const wtf = new Vuex.Store({
          strict: false,

          modules: {
            audio: AudioModule
          }
        })

        const { sound: sound1, id: id1 } = await playSound(wtf, 'background')
        const { sound: sound2, id: id2 } = await playSound(wtf, 'background')

        const startVol = 0.11
        const sounds = wtf.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'unload')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = wtf.dispatch('audio/fadeAndStopTrack', { unload: true, track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound1.unload.calls.count()).toEqual(1)

        expect(sound2.stop.calls.count()).toEqual(1)
        expect(sound2.unload.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Conditional Test Logic,"{'line': 805, 'column': 8, 'index': 25818}","it('Fades stops and unloads a track', async (done) => {
        const wtf = new Vuex.Store({
          strict: false,

          modules: {
            audio: AudioModule
          }
        })

        const { sound: sound1, id: id1 } = await playSound(wtf, 'background')
        const { sound: sound2, id: id2 } = await playSound(wtf, 'background')

        const startVol = 0.11
        const sounds = wtf.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'unload')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = wtf.dispatch('audio/fadeAndStopTrack', { unload: true, track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound1.unload.calls.count()).toEqual(1)

        expect(sound2.stop.calls.count()).toEqual(1)
        expect(sound2.unload.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Empty Test,"{'line': 823, 'column': 6, 'index': 26338}","it('Fades and stops a track', () => {

      })",steel
/test/app/core/store/modules/audio.spec.js,Exception Handling,"{'line': 85, 'column': 6, 'index': 2448}","it('Requires a track to play a sound', async (done) => {
      try {
        await store.dispatch('audio/playSound', { ...BASE_SOUND_OPTIONS })
        fail('Expected to throw')
      } catch (e) {}

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 104, 'column': 48, 'index': 3032}","it('Starts playing a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'play')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'play')

      await store.dispatch('audio/playTrack', 'background')
      expect(sound1.play.calls.count()).toEqual(1)
      expect(sound2.play.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 105, 'column': 48, 'index': 3083}","it('Starts playing a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'play')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'play')

      await store.dispatch('audio/playTrack', 'background')
      expect(sound1.play.calls.count()).toEqual(1)
      expect(sound2.play.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 121, 'column': 57, 'index': 3566}","it('Starts playing all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'play')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'play')

      await store.dispatch('audio/playAll', 'background')
      expect(backgroundSound.play.calls.count()).toEqual(1)
      expect(uiSound.play.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 122, 'column': 49, 'index': 3618}","it('Starts playing all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'play')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'play')

      await store.dispatch('audio/playAll', 'background')
      expect(backgroundSound.play.calls.count()).toEqual(1)
      expect(uiSound.play.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 134, 'column': 47, 'index': 3929}","it('Starts playing an existing sound', async (done) => {
      const { sound, id } = await playSound(store, 'background')

      expect(sound).toBeDefined()
      spyOn(sound, 'play')

      await store.dispatch('audio/playSound', id)
      expect(sound.play.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 152, 'column': 39, 'index': 4604}","it('Automatically cleans up sound from state when non looping sound stops', async (done) => {
      const { id, sound } = await playSound(store, 'background', { loop: false })

      const numPlayingSounds = Array.from(store.state.audio.tracks['background'].values()).length
      expect(numPlayingSounds).toEqual(1)

      sound._emit('stop', id)

      // Allow events listeners to fire
      setTimeout(() => {
        const numPlayingSoundsPostStop = Array.from(store.state.audio.tracks['background'].values()).length
        expect(numPlayingSoundsPostStop).toEqual(0)

        done()
      }, 0)
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 159, 'column': 49, 'index': 4861}","it('Automatically cleans up sound from state when non looping sound stops', async (done) => {
      const { id, sound } = await playSound(store, 'background', { loop: false })

      const numPlayingSounds = Array.from(store.state.audio.tracks['background'].values()).length
      expect(numPlayingSounds).toEqual(1)

      sound._emit('stop', id)

      // Allow events listeners to fire
      setTimeout(() => {
        const numPlayingSoundsPostStop = Array.from(store.state.audio.tracks['background'].values()).length
        expect(numPlayingSoundsPostStop).toEqual(0)

        done()
      }, 0)
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 194, 'column': 42, 'index': 6311}","it('Plays the sound after a unique key has been stopped and unloaded', async (done) => {
        const { id: origId } = await playSound(store, 'background', { unique: 'test' })

        const numPrePlayingSounds = Array.from(store.state.audio.tracks['background'].values()).length

        const { id: noPlayId } = await playSound(store, 'background', { unique: 'test' })
        expect(noPlayId).toBeUndefined()

        const numPostPlayingSounds = Array.from(store.state.audio.tracks['background'].values()).length
        expect(numPostPlayingSounds).toEqual(numPrePlayingSounds)

        store.dispatch('audio/stopSound', { id: origId, unload: true })

        const numPostStopSounds= Array.from(store.state.audio.tracks['background'].values()).length
        expect(numPostStopSounds).toEqual(0)

        const { id: nextPlayId} = await playSound(store, 'background', { unique: 'test' })
        expect(nextPlayId).toBeDefined()

        const numSecondPlaySounds = Array.from(store.state.audio.tracks['background'].values()).length
        expect(numSecondPlaySounds).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 200, 'column': 44, 'index': 6595}","it('Plays the sound after a unique key has been stopped and unloaded', async (done) => {
        const { id: origId } = await playSound(store, 'background', { unique: 'test' })

        const numPrePlayingSounds = Array.from(store.state.audio.tracks['background'].values()).length

        const { id: noPlayId } = await playSound(store, 'background', { unique: 'test' })
        expect(noPlayId).toBeUndefined()

        const numPostPlayingSounds = Array.from(store.state.audio.tracks['background'].values()).length
        expect(numPostPlayingSounds).toEqual(numPrePlayingSounds)

        store.dispatch('audio/stopSound', { id: origId, unload: true })

        const numPostStopSounds= Array.from(store.state.audio.tracks['background'].values()).length
        expect(numPostStopSounds).toEqual(0)

        const { id: nextPlayId} = await playSound(store, 'background', { unique: 'test' })
        expect(nextPlayId).toBeDefined()

        const numSecondPlaySounds = Array.from(store.state.audio.tracks['background'].values()).length
        expect(numSecondPlaySounds).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 213, 'column': 48, 'index': 6910}","it('Pauses a playing sound', async (done) => {
      const { sound, id } = await playSound(store, 'background')

      spyOn(sound, 'pause')
      await store.dispatch('audio/pauseSound', id)
      expect(sound.pause.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 229, 'column': 49, 'index': 7357}","it('Pauses a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'pause')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'pause')

      await store.dispatch('audio/pauseTrack', 'background')
      expect(sound1.pause.calls.count()).toEqual(1)
      expect(sound2.pause.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 230, 'column': 49, 'index': 7409}","it('Pauses a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'pause')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'pause')

      await store.dispatch('audio/pauseTrack', 'background')
      expect(sound1.pause.calls.count()).toEqual(1)
      expect(sound2.pause.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 246, 'column': 58, 'index': 7888}","it('Pauses all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'pause')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'pause')

      await store.dispatch('audio/pauseAll', 'background')
      expect(backgroundSound.pause.calls.count()).toEqual(1)
      expect(uiSound.pause.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 247, 'column': 50, 'index': 7941}","it('Pauses all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'pause')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'pause')

      await store.dispatch('audio/pauseAll', 'background')
      expect(backgroundSound.pause.calls.count()).toEqual(1)
      expect(uiSound.pause.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 259, 'column': 47, 'index': 8242}","it('Stops a playing sound', async (done) => {
      const { sound, id } = await playSound(store, 'background')

      spyOn(sound, 'stop')
      await store.dispatch('audio/stopSound', id)
      expect(sound.stop.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 275, 'column': 48, 'index': 8684}","it('Stops a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'stop')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'stop')

      await store.dispatch('audio/stopTrack', 'background')
      expect(sound1.stop.calls.count()).toEqual(1)
      expect(sound2.stop.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 276, 'column': 48, 'index': 8735}","it('Stops a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'stop')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'stop')

      await store.dispatch('audio/stopTrack', 'background')
      expect(sound1.stop.calls.count()).toEqual(1)
      expect(sound2.stop.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 292, 'column': 57, 'index': 9195}","it('Stops all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'stop')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'stop')

      await store.dispatch('audio/stopAll')
      expect(backgroundSound.stop.calls.count()).toEqual(1)
      expect(uiSound.stop.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 293, 'column': 49, 'index': 9247}","it('Stops all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'stop')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'stop')

      await store.dispatch('audio/stopAll')
      expect(backgroundSound.stop.calls.count()).toEqual(1)
      expect(uiSound.stop.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 306, 'column': 47, 'index': 9573}","it('Stops and unloads a playing sound', async (done) => {
      const { sound, id } = await playSound(store, 'background')

      spyOn(sound, 'stop')
      spyOn(sound, 'unload')

      await store.dispatch('audio/stopSound', { id, unload: true })

      expect(sound.stop.calls.count()).toEqual(1)
      expect(sound.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 307, 'column': 49, 'index': 9625}","it('Stops and unloads a playing sound', async (done) => {
      const { sound, id } = await playSound(store, 'background')

      spyOn(sound, 'stop')
      spyOn(sound, 'unload')

      await store.dispatch('audio/stopSound', { id, unload: true })

      expect(sound.stop.calls.count()).toEqual(1)
      expect(sound.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 326, 'column': 48, 'index': 10165}","it('Stops and unloads a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'stop')
      spyOn(sound1, 'unload')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'stop')
      spyOn(sound2, 'unload')

      await store.dispatch('audio/stopTrack', { track: 'background', unload: true })

      expect(sound1.stop.calls.count()).toEqual(1)
      expect(sound2.stop.calls.count()).toEqual(1)

      expect(sound1.unload.calls.count()).toEqual(1)
      expect(sound2.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 327, 'column': 48, 'index': 10216}","it('Stops and unloads a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'stop')
      spyOn(sound1, 'unload')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'stop')
      spyOn(sound2, 'unload')

      await store.dispatch('audio/stopTrack', { track: 'background', unload: true })

      expect(sound1.stop.calls.count()).toEqual(1)
      expect(sound2.stop.calls.count()).toEqual(1)

      expect(sound1.unload.calls.count()).toEqual(1)
      expect(sound2.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 329, 'column': 50, 'index': 10270}","it('Stops and unloads a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'stop')
      spyOn(sound1, 'unload')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'stop')
      spyOn(sound2, 'unload')

      await store.dispatch('audio/stopTrack', { track: 'background', unload: true })

      expect(sound1.stop.calls.count()).toEqual(1)
      expect(sound2.stop.calls.count()).toEqual(1)

      expect(sound1.unload.calls.count()).toEqual(1)
      expect(sound2.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 330, 'column': 50, 'index': 10323}","it('Stops and unloads a track', async (done) => {
      const { sound: sound1 } = await playSound(store, 'background')
      const { sound: sound2 } = await playSound(store, 'background')

      expect(sound1).toBeDefined()
      spyOn(sound1, 'stop')
      spyOn(sound1, 'unload')

      expect(sound2).toBeDefined()
      spyOn(sound2, 'stop')
      spyOn(sound2, 'unload')

      await store.dispatch('audio/stopTrack', { track: 'background', unload: true })

      expect(sound1.stop.calls.count()).toEqual(1)
      expect(sound2.stop.calls.count()).toEqual(1)

      expect(sound1.unload.calls.count()).toEqual(1)
      expect(sound2.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 349, 'column': 57, 'index': 10884}","it('Stops and unloads all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'stop')
      spyOn(backgroundSound, 'unload')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'stop')
      spyOn(uiSound, 'unload')

      await store.dispatch('audio/stopAll', { unload: true })

      expect(backgroundSound.stop.calls.count()).toEqual(1)
      expect(uiSound.stop.calls.count()).toEqual(1)

      expect(backgroundSound.unload.calls.count()).toEqual(1)
      expect(uiSound.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 350, 'column': 49, 'index': 10936}","it('Stops and unloads all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'stop')
      spyOn(backgroundSound, 'unload')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'stop')
      spyOn(uiSound, 'unload')

      await store.dispatch('audio/stopAll', { unload: true })

      expect(backgroundSound.stop.calls.count()).toEqual(1)
      expect(uiSound.stop.calls.count()).toEqual(1)

      expect(backgroundSound.unload.calls.count()).toEqual(1)
      expect(uiSound.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 352, 'column': 59, 'index': 10999}","it('Stops and unloads all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'stop')
      spyOn(backgroundSound, 'unload')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'stop')
      spyOn(uiSound, 'unload')

      await store.dispatch('audio/stopAll', { unload: true })

      expect(backgroundSound.stop.calls.count()).toEqual(1)
      expect(uiSound.stop.calls.count()).toEqual(1)

      expect(backgroundSound.unload.calls.count()).toEqual(1)
      expect(uiSound.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 353, 'column': 51, 'index': 11053}","it('Stops and unloads all sounds', async (done) => {
      const { sound: backgroundSound } = await playSound(store, 'background')
      const { sound: uiSound } = await playSound(store, 'ui')

      expect(backgroundSound).toBeDefined()
      spyOn(backgroundSound, 'stop')
      spyOn(backgroundSound, 'unload')

      expect(uiSound).toBeDefined()
      spyOn(uiSound, 'stop')
      spyOn(uiSound, 'unload')

      await store.dispatch('audio/stopAll', { unload: true })

      expect(backgroundSound.stop.calls.count()).toEqual(1)
      expect(uiSound.stop.calls.count()).toEqual(1)

      expect(backgroundSound.unload.calls.count()).toEqual(1)
      expect(uiSound.unload.calls.count()).toEqual(1)

      done()
    })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 400, 'column': 51, 'index': 12616}","it('Sets a sound volume', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        spyOn(sound, 'volume')

        const vol = 0.5
        await store.dispatch('audio/setSoundVolume', { id, volume: vol })

        expect(sound.volume.calls.count()).toEqual(1)
        expect(sound.volume.calls.first().args[0]).toEqual(vol)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 419, 'column': 52, 'index': 13210}","it('Sets a track volume', async (done) => {
        const { sound: sound1 } = await playSound(store, 'background')
        const { sound: sound2 } = await playSound(store, 'background')

        expect(sound1).toBeDefined()
        spyOn(sound1, 'volume')

        expect(sound2).toBeDefined()
        spyOn(sound2, 'volume')

        const vol = 0.5
        await store.dispatch('audio/setTrackVolume', { track: 'background', volume: vol })

        expect(sound1.volume.calls.count()).toEqual(1)
        expect(sound1.volume.calls.first().args[0]).toEqual(vol)

        expect(sound2.volume.calls.count()).toEqual(1)
        expect(sound2.volume.calls.first().args[0]).toEqual(vol)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 422, 'column': 52, 'index': 13331}","it('Sets a track volume', async (done) => {
        const { sound: sound1 } = await playSound(store, 'background')
        const { sound: sound2 } = await playSound(store, 'background')

        expect(sound1).toBeDefined()
        spyOn(sound1, 'volume')

        expect(sound2).toBeDefined()
        spyOn(sound2, 'volume')

        const vol = 0.5
        await store.dispatch('audio/setTrackVolume', { track: 'background', volume: vol })

        expect(sound1.volume.calls.count()).toEqual(1)
        expect(sound1.volume.calls.first().args[0]).toEqual(vol)

        expect(sound2.volume.calls.count()).toEqual(1)
        expect(sound2.volume.calls.first().args[0]).toEqual(vol)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 441, 'column': 61, 'index': 13916}","it('Sets all volumes', async (done) => {
        const { sound: backgroundSound } = await playSound(store, 'background')
        const { sound: uiSound } = await playSound(store, 'ui')

        expect(backgroundSound).toBeDefined()
        spyOn(backgroundSound, 'volume')

        expect(uiSound).toBeDefined()
        spyOn(uiSound, 'volume')

        const vol = 0.5
        await store.dispatch('audio/setVolume', vol)

        expect(backgroundSound.volume.calls.count()).toEqual(1)
        expect(backgroundSound.volume.calls.first().args[0]).toEqual(vol)

        expect(uiSound.volume.calls.count()).toEqual(1)
        expect(uiSound.volume.calls.first().args[0]).toEqual(vol)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 444, 'column': 53, 'index': 14047}","it('Sets all volumes', async (done) => {
        const { sound: backgroundSound } = await playSound(store, 'background')
        const { sound: uiSound } = await playSound(store, 'ui')

        expect(backgroundSound).toBeDefined()
        spyOn(backgroundSound, 'volume')

        expect(uiSound).toBeDefined()
        spyOn(uiSound, 'volume')

        const vol = 0.5
        await store.dispatch('audio/setVolume', vol)

        expect(backgroundSound.volume.calls.count()).toEqual(1)
        expect(backgroundSound.volume.calls.first().args[0]).toEqual(vol)

        expect(uiSound.volume.calls.count()).toEqual(1)
        expect(uiSound.volume.calls.first().args[0]).toEqual(vol)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 459, 'column': 49, 'index': 14423}","it('Mutes a sound', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        spyOn(sound, 'mute')

        await store.dispatch('audio/muteSound', id)

        expect(sound.mute.calls.count()).toEqual(1)
        expect(sound.mute.calls.first().args[0]).toEqual(true)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 477, 'column': 50, 'index': 14974}","it('Mutes a track and updates mute state', async (done) => {
        const { sound: sound1 } = await playSound(store, 'background')
        const { sound: sound2 } = await playSound(store, 'background')

        expect(sound1).toBeDefined()
        spyOn(sound1, 'mute')

        expect(sound2).toBeDefined()
        spyOn(sound2, 'mute')

        await store.dispatch('audio/muteTrack', 'background')

        expect(sound1.mute.calls.count()).toEqual(1)
        expect(sound1.mute.calls.first().args[0]).toEqual(true)

        expect(sound2.mute.calls.count()).toEqual(1)
        expect(sound2.mute.calls.first().args[0]).toEqual(true)

        expect(store.state.audio.muted.background).toEqual(true)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 480, 'column': 50, 'index': 15092}","it('Mutes a track and updates mute state', async (done) => {
        const { sound: sound1 } = await playSound(store, 'background')
        const { sound: sound2 } = await playSound(store, 'background')

        expect(sound1).toBeDefined()
        spyOn(sound1, 'mute')

        expect(sound2).toBeDefined()
        spyOn(sound2, 'mute')

        await store.dispatch('audio/muteTrack', 'background')

        expect(sound1.mute.calls.count()).toEqual(1)
        expect(sound1.mute.calls.first().args[0]).toEqual(true)

        expect(sound2.mute.calls.count()).toEqual(1)
        expect(sound2.mute.calls.first().args[0]).toEqual(true)

        expect(store.state.audio.muted.background).toEqual(true)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 500, 'column': 59, 'index': 15723}","it('Mutes all sounds and updates state', async (done) => {
        const { sound: backgroundSound } = await playSound(store, 'background')
        const { sound: uiSound } = await playSound(store, 'ui')

        expect(backgroundSound).toBeDefined()
        spyOn(backgroundSound, 'mute')

        expect(uiSound).toBeDefined()
        spyOn(uiSound, 'mute')

        await store.dispatch('audio/muteAll')

        expect(backgroundSound.mute.calls.count()).toEqual(1)
        expect(backgroundSound.mute.calls.first().args[0]).toEqual(true)

        expect(uiSound.mute.calls.count()).toEqual(1)
        expect(uiSound.mute.calls.first().args[0]).toEqual(true)

        expect(store.state.audio.muted.all).toEqual(true)
        expect(store.state.audio.muted.background).toEqual(true)
        expect(store.state.audio.muted.ui).toEqual(true)
        expect(store.state.audio.muted.soundEffects).toEqual(true)


        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 503, 'column': 51, 'index': 15851}","it('Mutes all sounds and updates state', async (done) => {
        const { sound: backgroundSound } = await playSound(store, 'background')
        const { sound: uiSound } = await playSound(store, 'ui')

        expect(backgroundSound).toBeDefined()
        spyOn(backgroundSound, 'mute')

        expect(uiSound).toBeDefined()
        spyOn(uiSound, 'mute')

        await store.dispatch('audio/muteAll')

        expect(backgroundSound.mute.calls.count()).toEqual(1)
        expect(backgroundSound.mute.calls.first().args[0]).toEqual(true)

        expect(uiSound.mute.calls.count()).toEqual(1)
        expect(uiSound.mute.calls.first().args[0]).toEqual(true)

        expect(store.state.audio.muted.all).toEqual(true)
        expect(store.state.audio.muted.background).toEqual(true)
        expect(store.state.audio.muted.ui).toEqual(true)
        expect(store.state.audio.muted.soundEffects).toEqual(true)


        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 525, 'column': 49, 'index': 16496}","it('Unmutes a sound', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        await store.dispatch('audio/muteSound', id)

        spyOn(sound, 'mute')

        await store.dispatch('audio/unmuteSound', id)

        expect(sound.mute.calls.count()).toEqual(1)
        expect(sound.mute.calls.first().args[0]).toEqual(false)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 545, 'column': 50, 'index': 17115}","it('Unmutes a track and updates mute state', async (done) => {
        const { sound: sound1 } = await playSound(store, 'background')
        const { sound: sound2 } = await playSound(store, 'background')

        await store.dispatch('audio/muteTrack', 'background')

        expect(sound1).toBeDefined()
        spyOn(sound1, 'mute')

        expect(sound2).toBeDefined()
        spyOn(sound2, 'mute')

        await store.dispatch('audio/unmuteTrack', 'background')

        expect(sound1.mute.calls.count()).toEqual(1)
        expect(sound1.mute.calls.first().args[0]).toEqual(false)

        expect(sound2.mute.calls.count()).toEqual(1)
        expect(sound2.mute.calls.first().args[0]).toEqual(false)

        expect(store.state.audio.muted.background).toEqual(false)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 548, 'column': 50, 'index': 17234}","it('Unmutes a track and updates mute state', async (done) => {
        const { sound: sound1 } = await playSound(store, 'background')
        const { sound: sound2 } = await playSound(store, 'background')

        await store.dispatch('audio/muteTrack', 'background')

        expect(sound1).toBeDefined()
        spyOn(sound1, 'mute')

        expect(sound2).toBeDefined()
        spyOn(sound2, 'mute')

        await store.dispatch('audio/unmuteTrack', 'background')

        expect(sound1.mute.calls.count()).toEqual(1)
        expect(sound1.mute.calls.first().args[0]).toEqual(false)

        expect(sound2.mute.calls.count()).toEqual(1)
        expect(sound2.mute.calls.first().args[0]).toEqual(false)

        expect(store.state.audio.muted.background).toEqual(false)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 570, 'column': 59, 'index': 17918}","it('Unmutes all sounds and updates state', async (done) => {
        const { sound: backgroundSound } = await playSound(store, 'background')
        const { sound: uiSound } = await playSound(store, 'ui')

        await store.dispatch('audio/muteAll')

        expect(backgroundSound).toBeDefined()
        spyOn(backgroundSound, 'mute')

        expect(uiSound).toBeDefined()
        spyOn(uiSound, 'mute')

        await store.dispatch('audio/unmuteAll')

        expect(backgroundSound.mute.calls.count()).toEqual(1)
        expect(backgroundSound.mute.calls.first().args[0]).toEqual(false)

        expect(uiSound.mute.calls.count()).toEqual(1)
        expect(uiSound.mute.calls.first().args[0]).toEqual(false)

        expect(store.state.audio.muted.all).toEqual(false)
        expect(store.state.audio.muted.background).toEqual(false)
        expect(store.state.audio.muted.ui).toEqual(false)
        expect(store.state.audio.muted.soundEffects).toEqual(false)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 573, 'column': 51, 'index': 18047}","it('Unmutes all sounds and updates state', async (done) => {
        const { sound: backgroundSound } = await playSound(store, 'background')
        const { sound: uiSound } = await playSound(store, 'ui')

        await store.dispatch('audio/muteAll')

        expect(backgroundSound).toBeDefined()
        spyOn(backgroundSound, 'mute')

        expect(uiSound).toBeDefined()
        spyOn(uiSound, 'mute')

        await store.dispatch('audio/unmuteAll')

        expect(backgroundSound.mute.calls.count()).toEqual(1)
        expect(backgroundSound.mute.calls.first().args[0]).toEqual(false)

        expect(uiSound.mute.calls.count()).toEqual(1)
        expect(uiSound.mute.calls.first().args[0]).toEqual(false)

        expect(store.state.audio.muted.all).toEqual(false)
        expect(store.state.audio.muted.background).toEqual(false)
        expect(store.state.audio.muted.ui).toEqual(false)
        expect(store.state.audio.muted.soundEffects).toEqual(false)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 597, 'column': 49, 'index': 18871}","it('Fades a sound and returns promise that resolves when complete', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        spyOn(sound, 'fade')

        const fadeConfig = { id, from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeSound', fadeConfig)

        sound._emit('fade', id)
        await fadePromise

        expect(sound.fade.calls.count()).toEqual(1)
        expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration])

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 616, 'column': 49, 'index': 19565}","it('Fades a sound from current volume when not specified and returns promise that resolves when complete', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        const startVol = 0.11
        spyOn(sound, 'fade')
        spyOn(sound, 'volume').and.returnValue(startVol)

        const fadeConfig = { id, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeSound', fadeConfig)

        sound._emit('fade', id)
        await fadePromise

        expect(sound.fade.calls.count()).toEqual(1)
        expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration])

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 635, 'column': 51, 'index': 20283}","it('Fades a track and returns promise that resolves when complete', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'background')

        const sounds = store.getters['audio/getTrackSounds']('background')
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { track: 'background', from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeTrack', fadeConfig)

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 662, 'column': 51, 'index': 21205}","it('Only fades and stops songs present when fadeAndStopTrack dispatched', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'background')

        const sounds = store.getters['audio/getTrackSounds']('background')
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { track: 'background', from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeTrack', fadeConfig)

        const { sound: lateSound } = await playSound(store, 'background')
        spyOn(lateSound, 'stop')

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(lateSound.stop.calls.count()).toEqual(0)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 670, 'column': 53, 'index': 21455}","it('Only fades and stops songs present when fadeAndStopTrack dispatched', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'background')

        const sounds = store.getters['audio/getTrackSounds']('background')
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { track: 'background', from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeTrack', fadeConfig)

        const { sound: lateSound } = await playSound(store, 'background')
        spyOn(lateSound, 'stop')

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(lateSound.stop.calls.count()).toEqual(0)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 688, 'column': 51, 'index': 22026}","it('Fades all sounds and returns promise that resolves when complete', async (done) => {
        await playSound(store, 'background')
        await playSound(store, 'ui')

        const sounds = store.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
        }

        const fadeConfig = { from: 0.5, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAll', fadeConfig)

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ fadeConfig.from, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 715, 'column': 49, 'index': 22807}","it('Fades and stops a sound', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        const startVol = 0.11
        spyOn(sound, 'fade')
        spyOn(sound, 'stop')
        spyOn(sound, 'volume').and.returnValue(startVol)

        const fadeConfig = { id, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAndStopSound', fadeConfig)

        sound._emit('fade', id)
        await fadePromise

        expect(sound.fade.calls.count()).toEqual(1)
        expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ])

        expect(sound.stop.calls.count()).toEqual(1)
        expect(sound.stop.calls.first().args)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 718, 'column': 49, 'index': 22964}","it('Fades and stops a sound', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        const startVol = 0.11
        spyOn(sound, 'fade')
        spyOn(sound, 'stop')
        spyOn(sound, 'volume').and.returnValue(startVol)

        const fadeConfig = { id, to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAndStopSound', fadeConfig)

        sound._emit('fade', id)
        await fadePromise

        expect(sound.fade.calls.count()).toEqual(1)
        expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ])

        expect(sound.stop.calls.count()).toEqual(1)
        expect(sound.stop.calls.first().args)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 739, 'column': 49, 'index': 23606}","it('Fades stops and unloads a sound', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        const startVol = 0.11
        spyOn(sound, 'fade')
        spyOn(sound, 'stop')
        spyOn(sound, 'unload')
        spyOn(sound, 'volume').and.returnValue(startVol)

        const fadeConfig = { id, to: 1, duration: 100, unload: true }
        const fadePromise = store.dispatch('audio/fadeAndStopSound', fadeConfig)

        sound._emit('fade', id)
        await fadePromise

        expect(sound.fade.calls.count()).toEqual(1)
        expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ])

        expect(sound.stop.calls.count()).toEqual(1)
        expect(sound.stop.calls.first().args)

        expect(sound.unload.calls.count()).toEqual(1)
        expect(sound.unload.calls.first().args)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 742, 'column': 49, 'index': 23763}","it('Fades stops and unloads a sound', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        const startVol = 0.11
        spyOn(sound, 'fade')
        spyOn(sound, 'stop')
        spyOn(sound, 'unload')
        spyOn(sound, 'volume').and.returnValue(startVol)

        const fadeConfig = { id, to: 1, duration: 100, unload: true }
        const fadePromise = store.dispatch('audio/fadeAndStopSound', fadeConfig)

        sound._emit('fade', id)
        await fadePromise

        expect(sound.fade.calls.count()).toEqual(1)
        expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ])

        expect(sound.stop.calls.count()).toEqual(1)
        expect(sound.stop.calls.first().args)

        expect(sound.unload.calls.count()).toEqual(1)
        expect(sound.unload.calls.first().args)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 745, 'column': 51, 'index': 23864}","it('Fades stops and unloads a sound', async (done) => {
        const { sound, id } = await playSound(store, 'background')

        const startVol = 0.11
        spyOn(sound, 'fade')
        spyOn(sound, 'stop')
        spyOn(sound, 'unload')
        spyOn(sound, 'volume').and.returnValue(startVol)

        const fadeConfig = { id, to: 1, duration: 100, unload: true }
        const fadePromise = store.dispatch('audio/fadeAndStopSound', fadeConfig)

        sound._emit('fade', id)
        await fadePromise

        expect(sound.fade.calls.count()).toEqual(1)
        expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ])

        expect(sound.stop.calls.count()).toEqual(1)
        expect(sound.stop.calls.first().args)

        expect(sound.unload.calls.count()).toEqual(1)
        expect(sound.unload.calls.first().args)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 767, 'column': 51, 'index': 24666}","it('Fades and stops a track', async (done) => {
        const { sound: sound1, id: id1 } = await playSound(store, 'background')
        const { sound: sound2, id: id2 } = await playSound(store, 'background')

        const startVol = 0.11
        const sounds = store.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAndStopTrack', { track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound2.stop.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 775, 'column': 50, 'index': 24906}","it('Fades and stops a track', async (done) => {
        const { sound: sound1, id: id1 } = await playSound(store, 'background')
        const { sound: sound2, id: id2 } = await playSound(store, 'background')

        const startVol = 0.11
        const sounds = store.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAndStopTrack', { track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound2.stop.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 776, 'column': 50, 'index': 24959}","it('Fades and stops a track', async (done) => {
        const { sound: sound1, id: id1 } = await playSound(store, 'background')
        const { sound: sound2, id: id2 } = await playSound(store, 'background')

        const startVol = 0.11
        const sounds = store.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = store.dispatch('audio/fadeAndStopTrack', { track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound2.stop.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 806, 'column': 51, 'index': 25899}","it('Fades stops and unloads a track', async (done) => {
        const wtf = new Vuex.Store({
          strict: false,

          modules: {
            audio: AudioModule
          }
        })

        const { sound: sound1, id: id1 } = await playSound(wtf, 'background')
        const { sound: sound2, id: id2 } = await playSound(wtf, 'background')

        const startVol = 0.11
        const sounds = wtf.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'unload')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = wtf.dispatch('audio/fadeAndStopTrack', { unload: true, track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound1.unload.calls.count()).toEqual(1)

        expect(sound2.stop.calls.count()).toEqual(1)
        expect(sound2.unload.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 814, 'column': 50, 'index': 26139}","it('Fades stops and unloads a track', async (done) => {
        const wtf = new Vuex.Store({
          strict: false,

          modules: {
            audio: AudioModule
          }
        })

        const { sound: sound1, id: id1 } = await playSound(wtf, 'background')
        const { sound: sound2, id: id2 } = await playSound(wtf, 'background')

        const startVol = 0.11
        const sounds = wtf.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'unload')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = wtf.dispatch('audio/fadeAndStopTrack', { unload: true, track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound1.unload.calls.count()).toEqual(1)

        expect(sound2.stop.calls.count()).toEqual(1)
        expect(sound2.unload.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 815, 'column': 52, 'index': 26194}","it('Fades stops and unloads a track', async (done) => {
        const wtf = new Vuex.Store({
          strict: false,

          modules: {
            audio: AudioModule
          }
        })

        const { sound: sound1, id: id1 } = await playSound(wtf, 'background')
        const { sound: sound2, id: id2 } = await playSound(wtf, 'background')

        const startVol = 0.11
        const sounds = wtf.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'unload')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = wtf.dispatch('audio/fadeAndStopTrack', { unload: true, track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound1.unload.calls.count()).toEqual(1)

        expect(sound2.stop.calls.count()).toEqual(1)
        expect(sound2.unload.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 817, 'column': 50, 'index': 26248}","it('Fades stops and unloads a track', async (done) => {
        const wtf = new Vuex.Store({
          strict: false,

          modules: {
            audio: AudioModule
          }
        })

        const { sound: sound1, id: id1 } = await playSound(wtf, 'background')
        const { sound: sound2, id: id2 } = await playSound(wtf, 'background')

        const startVol = 0.11
        const sounds = wtf.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'unload')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = wtf.dispatch('audio/fadeAndStopTrack', { unload: true, track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound1.unload.calls.count()).toEqual(1)

        expect(sound2.stop.calls.count()).toEqual(1)
        expect(sound2.unload.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Magic Number,"{'line': 818, 'column': 52, 'index': 26303}","it('Fades stops and unloads a track', async (done) => {
        const wtf = new Vuex.Store({
          strict: false,

          modules: {
            audio: AudioModule
          }
        })

        const { sound: sound1, id: id1 } = await playSound(wtf, 'background')
        const { sound: sound2, id: id2 } = await playSound(wtf, 'background')

        const startVol = 0.11
        const sounds = wtf.getters['audio/getAllSounds']
        for (const sound of sounds) {
          spyOn(sound, 'fade')
          spyOn(sound, 'stop')
          spyOn(sound, 'unload')
          spyOn(sound, 'volume').and.returnValue(startVol)
        }

        const fadeConfig = { to: 1, duration: 100 }
        const fadePromise = wtf.dispatch('audio/fadeAndStopTrack', { unload: true, track: 'background', ...fadeConfig })

        for (const sound of sounds) {
          expect(sound.fade.calls.count()).toEqual(1)
          expect(sound.fade.calls.first().args).toEqual([ startVol, fadeConfig.to, fadeConfig.duration ] )

          sound._emit('fade', sound._id)
        }

        await fadePromise

        expect(sound1.stop.calls.count()).toEqual(1)
        expect(sound1.unload.calls.count()).toEqual(1)

        expect(sound2.stop.calls.count()).toEqual(1)
        expect(sound2.unload.calls.count()).toEqual(1)

        done()
      })",steel
/test/app/core/store/modules/audio.spec.js,Sleepy Test,"{'line': 157, 'column': 6, 'index': 4685}","it('Automatically cleans up sound from state when non looping sound stops', async (done) => {
      const { id, sound } = await playSound(store, 'background', { loop: false })

      const numPlayingSounds = Array.from(store.state.audio.tracks['background'].values()).length
      expect(numPlayingSounds).toEqual(1)

      sound._emit('stop', id)

      // Allow events listeners to fire
      setTimeout(() => {
        const numPlayingSoundsPostStop = Array.from(store.state.audio.tracks['background'].values()).length
        expect(numPlayingSoundsPostStop).toEqual(0)

        done()
      }, 0)
    })",steel
/test/app/core/store/modules/audio.spec.js,Unknown Test,"{'column': 4, 'line': 84}","it('Requires a track to play a sound', async (done) => {
      try {
        await store.dispatch('audio/playSound', { ...BASE_SOUND_OPTIONS })
        fail('Expected to throw')
      } catch (e) {}

      done()
    })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 24, 'column': 4, 'index': 691}","it('should set importedToOzaria=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 766}","it('should set importedToOzaria=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 766}","it('should set importedToOzaria=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 28, 'column': 6, 'index': 922}","it('should set importedToOzaria=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 29, 'column': 6, 'index': 997}","it('should set importedToOzaria=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 30, 'column': 6, 'index': 1069}","it('should set importedToOzaria=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 30, 'column': 6, 'index': 1069}","it('should set importedToOzaria=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1373}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1373}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1448}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1448}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 46, 'column': 6, 'index': 1682}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 46, 'column': 6, 'index': 1682}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 47, 'column': 6, 'index': 1759}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 47, 'column': 6, 'index': 1759}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 2438}","it('adds googleClassrooms to the `me` object', async function(done) {
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(gClassrooms))
    expect(me.get('googleClassrooms')).toBeUndefined()
    try {
      await GoogleClassroomHandler.importClassrooms()
      expect(me.get('googleClassrooms')).toBeDefined()
      expect(me.get('googleClassrooms').length).toBe(gClassrooms.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 75, 'column': 6, 'index': 2559}","it('adds googleClassrooms to the `me` object', async function(done) {
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(gClassrooms))
    expect(me.get('googleClassrooms')).toBeUndefined()
    try {
      await GoogleClassroomHandler.importClassrooms()
      expect(me.get('googleClassrooms')).toBeDefined()
      expect(me.get('googleClassrooms').length).toBe(gClassrooms.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 3149}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 3149}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 3203}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 3203}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 94, 'column': 4, 'index': 3300}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 3417}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 3417}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 3528}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 3528}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 97, 'column': 4, 'index': 3625}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 3778}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 3778}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 114, 'column': 6, 'index': 4391}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 114, 'column': 6, 'index': 4391}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 115, 'column': 6, 'index': 4447}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 115, 'column': 6, 'index': 4447}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 116, 'column': 6, 'index': 4546}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 117, 'column': 6, 'index': 4704}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 117, 'column': 6, 'index': 4704}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 118, 'column': 6, 'index': 4817}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 118, 'column': 6, 'index': 4817}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 119, 'column': 6, 'index': 4916}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 120, 'column': 6, 'index': 5074}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 120, 'column': 6, 'index': 5074}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 134, 'column': 4, 'index': 5695}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(1)

    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Duplicate Assert,"{'line': 146, 'column': 6, 'index': 6214}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(1)

    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Exception Handling,"{'line': 26, 'column': 4, 'index': 841}","it('should set importedToOzaria=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Exception Handling,"{'line': 41, 'column': 4, 'index': 1523}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToOzaria).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Exception Handling,"{'line': 73, 'column': 4, 'index': 2493}","it('adds googleClassrooms to the `me` object', async function(done) {
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(gClassrooms))
    expect(me.get('googleClassrooms')).toBeUndefined()
    try {
      await GoogleClassroomHandler.importClassrooms()
      expect(me.get('googleClassrooms')).toBeDefined()
      expect(me.get('googleClassrooms').length).toBe(gClassrooms.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Exception Handling,"{'line': 111, 'column': 4, 'index': 4225}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Exception Handling,"{'line': 143, 'column': 4, 'index': 6048}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(1)

    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Exception Handling,"{'line': 210, 'column': 4, 'index': 8628}","it('signs up the imported students on codecombat with their google id and adds them to the classroom', async function(done) {
    const users = gcStudents.map((s) => {
      return factories.makeUser({
        gplusID: s.userId,
        firstName: s.profile.givenName,
        lastName: s.profile.familyName,
        email: s.profile.emailAddress,
        role: 'student'
      })
    })
    spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
      return Promise.resolve(users.find((u) => u.get('gplusID')==attrs.gplusID))
    })

    const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: users.map((u) => u._id)})
    spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers))

    try {
      const cocoClassroom = factories.makeClassroom({googleClassroomId: ""id1""})
      const classroomNewMembers = await GoogleClassroomHandler.importStudentsToClassroom(cocoClassroom)
      expect(api.users.signupFromGoogleClassroom).toHaveBeenCalled()
      expect(api.users.signupFromGoogleClassroom.calls.count()).toEqual(gcStudents.length)
      expect(api.classrooms.addMembers).toHaveBeenCalled()
      expect(classroomNewMembers.length).toEqual(gcStudents.length)
      expect(classroomNewMembers[0].get('gplusID')).toBe(gcStudents[0].userId)
      expect(classroomNewMembers[1].get('gplusID')).toBe(gcStudents[1].userId)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Exception Handling,"{'line': 249, 'column': 6, 'index': 10375}","it('does not add students if already exist in the classroom', async function(done) {
      const signUpResult = gcStudents.map((s) => {
        let user = factories.makeUser({
          gplusID: s.userId,
          firstName: s.profile.givenName,
          lastName: s.profile.familyName,
          email: s.profile.emailAddress,
          role: 'student'
        }).attributes
        return {
          isError: true,
          errorID: 'student-account-exists',
          error: user
        }
      })
      spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
        return Promise.resolve(signUpResult.find((r) => r.error.gplusID==attrs.gplusID))
      })

      const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: signUpResult.map((r) => r.error._id)})
      spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers))

      try {
        await GoogleClassroomHandler.importStudentsToClassroom(classroomWithNewMembers)
        expect(api.users.signupFromGoogleClassroom).toHaveBeenCalled()
        expect(api.users.signupFromGoogleClassroom.calls.count()).toEqual(gcStudents.length)
        expect(api.classrooms.addMembers).not.toHaveBeenCalled()
        done()
      }
      catch (err) {
        done.fail(new Error(""This should not have been called""))
      }
    })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Exception Handling,"{'line': 283, 'column': 6, 'index': 11754}","it('adds students to classroom if do not exist already', async function(done) {
      const signUpResult = gcStudents.map((s) => {
        let user = factories.makeUser({
          gplusID: s.userId,
          firstName: s.profile.givenName,
          lastName: s.profile.familyName,
          email: s.profile.emailAddress,
          role: 'student'
        }).attributes
        return {
          isError: true,
          errorID: 'student-account-exists',
          error: user
        }
      })
      spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
        return Promise.resolve(signUpResult.find((r) => r.error.gplusID==attrs.gplusID))
      })

      const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: signUpResult.map((r) => r.error._id)})
      spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers))

      try {
        const cocoClassroom = factories.makeClassroom({googleClassroomId: ""id1""})
        const newMembers = await GoogleClassroomHandler.importStudentsToClassroom(cocoClassroom)
        expect(api.users.signupFromGoogleClassroom).toHaveBeenCalled()
        expect(api.users.signupFromGoogleClassroom.calls.count()).toEqual(gcStudents.length)
        expect(api.classrooms.addMembers).toHaveBeenCalled()
        expect(newMembers.length).toEqual(gcStudents.length)
        done()
      }
      catch (err) {
        done.fail(new Error(""This should not have been called""))
      }
    })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Exception Handling,"{'line': 320, 'column': 4, 'index': 13455}","it('calls `loadStudentsFromAPI` multiple times until previous api call returns nextPageToken', async function(done) {
    me.set(factories.makeUser({role: 'teacher'}).attributes)
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadStudentsFromAPI').and.returnValues(Promise.resolve({students: gcStudents[0], nextPageToken: 'abcd'}), Promise.resolve({students: gcStudents[1]}))

    const users = gcStudents.map((s) => {
      return factories.makeUser({
        gplusID: s.userId,
        firstName: s.profile.givenName,
        lastName: s.profile.familyName,
        email: s.profile.emailAddress,
        role: 'student'
      })
    })
    spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
      return Promise.resolve(users.find((u) => u.get('gplusID')==attrs.gplusID))
    })

    const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: users.map((u) => u._id)})
    spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers))

    try {
      const cocoClassroom = factories.makeClassroom({googleClassroomId: ""id1""})
      const classroomNewMembers = await GoogleClassroomHandler.importStudentsToClassroom(cocoClassroom)
      expect(GoogleClassroomHandler.gcApiHandler.loadStudentsFromAPI.calls.count()).toEqual(2)
      expect(classroomNewMembers.length).toEqual(gcStudents.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Global Variable,"{'line': 5, 'column': 0, 'index': 152}",Unknown,steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Magic Number,"{'line': 92, 'column': 51, 'index': 3196}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Magic Number,"{'line': 114, 'column': 53, 'index': 4438}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToOzaria value', async function(done) {

    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToOzaria field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Magic Number,"{'line': 134, 'column': 51, 'index': 5742}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(1)

    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Magic Number,"{'line': 146, 'column': 53, 'index': 6261}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToOzaria = true

    expect(me.get('googleClassrooms').length).toBe(1)

    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToOzaria).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToOzaria).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.ozar.js,Magic Number,"{'line': 323, 'column': 92, 'index': 13737}","it('calls `loadStudentsFromAPI` multiple times until previous api call returns nextPageToken', async function(done) {
    me.set(factories.makeUser({role: 'teacher'}).attributes)
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadStudentsFromAPI').and.returnValues(Promise.resolve({students: gcStudents[0], nextPageToken: 'abcd'}), Promise.resolve({students: gcStudents[1]}))

    const users = gcStudents.map((s) => {
      return factories.makeUser({
        gplusID: s.userId,
        firstName: s.profile.givenName,
        lastName: s.profile.familyName,
        email: s.profile.emailAddress,
        role: 'student'
      })
    })
    spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
      return Promise.resolve(users.find((u) => u.get('gplusID')==attrs.gplusID))
    })

    const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: users.map((u) => u._id)})
    spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers))

    try {
      const cocoClassroom = factories.makeClassroom({googleClassroomId: ""id1""})
      const classroomNewMembers = await GoogleClassroomHandler.importStudentsToClassroom(cocoClassroom)
      expect(GoogleClassroomHandler.gcApiHandler.loadStudentsFromAPI.calls.count()).toEqual(2)
      expect(classroomNewMembers.length).toEqual(gcStudents.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 24, 'column': 4, 'index': 689}","it('should set importedToCoco=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToCoco).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 762}","it('should set importedToCoco=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToCoco).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 762}","it('should set importedToCoco=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToCoco).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 28, 'column': 6, 'index': 916}","it('should set importedToCoco=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToCoco).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 29, 'column': 6, 'index': 989}","it('should set importedToCoco=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToCoco).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 30, 'column': 6, 'index': 1059}","it('should set importedToCoco=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToCoco).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 30, 'column': 6, 'index': 1059}","it('should set importedToCoco=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToCoco).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1361}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1361}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1434}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1434}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 46, 'column': 6, 'index': 1666}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 46, 'column': 6, 'index': 1666}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 47, 'column': 6, 'index': 1741}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 47, 'column': 6, 'index': 1741}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 2418}","it('adds googleClassrooms to the `me` object', async function(done) {
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(gClassrooms))
    expect(me.get('googleClassrooms')).toBeUndefined()
    try {
      await GoogleClassroomHandler.importClassrooms()
      expect(me.get('googleClassrooms')).toBeDefined()
      expect(me.get('googleClassrooms').length).toBe(gClassrooms.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 75, 'column': 6, 'index': 2539}","it('adds googleClassrooms to the `me` object', async function(done) {
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(gClassrooms))
    expect(me.get('googleClassrooms')).toBeUndefined()
    try {
      await GoogleClassroomHandler.importClassrooms()
      expect(me.get('googleClassrooms')).toBeDefined()
      expect(me.get('googleClassrooms').length).toBe(gClassrooms.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 3129}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 3129}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 3183}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 3183}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 94, 'column': 4, 'index': 3280}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 3397}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 3397}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 3506}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 3506}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 97, 'column': 4, 'index': 3603}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 3756}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 3756}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 114, 'column': 6, 'index': 4365}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 114, 'column': 6, 'index': 4365}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 115, 'column': 6, 'index': 4421}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 115, 'column': 6, 'index': 4421}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 116, 'column': 6, 'index': 4520}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 117, 'column': 6, 'index': 4678}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 117, 'column': 6, 'index': 4678}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 118, 'column': 6, 'index': 4789}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 118, 'column': 6, 'index': 4789}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 119, 'column': 6, 'index': 4888}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 120, 'column': 6, 'index': 5046}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 120, 'column': 6, 'index': 5046}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 134, 'column': 4, 'index': 5663}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(1)
    
    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))
  
    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Duplicate Assert,"{'line': 146, 'column': 6, 'index': 6188}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(1)
    
    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))
  
    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Exception Handling,"{'line': 26, 'column': 4, 'index': 835}","it('should set importedToCoco=true for gcId in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(gClassrooms[0].id)
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeDefined()
      expect(me.get('googleClassrooms')[0].importedToCoco).toBe(true)
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Exception Handling,"{'line': 41, 'column': 4, 'index': 1507}","it('should throw error if the google classroom id does not exist in me.googleClassrooms', async function (done) {
    expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
    expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
    try {
      await GoogleClassroomHandler.markAsImported(""new-id"")
      done.fail(new Error(""This should not have been called""))
    }
    catch (err) {
      expect(me.get('googleClassrooms')[0].importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms')[1].importedToCoco).toBeUndefined()
      done()
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Exception Handling,"{'line': 73, 'column': 4, 'index': 2473}","it('adds googleClassrooms to the `me` object', async function(done) {
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(gClassrooms))
    expect(me.get('googleClassrooms')).toBeUndefined()
    try {
      await GoogleClassroomHandler.importClassrooms()
      expect(me.get('googleClassrooms')).toBeDefined()
      expect(me.get('googleClassrooms').length).toBe(gClassrooms.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Exception Handling,"{'line': 111, 'column': 4, 'index': 4201}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Exception Handling,"{'line': 143, 'column': 4, 'index': 6022}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(1)
    
    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))
  
    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Exception Handling,"{'line': 210, 'column': 4, 'index': 8604}","it('signs up the imported students on codecombat with their google id and adds them to the classroom', async function(done) {
    const users = gcStudents.map((s) => {
      return factories.makeUser({
        gplusID: s.userId,
        firstName: s.profile.givenName,
        lastName: s.profile.familyName,
        email: s.profile.emailAddress,
        role: 'student'
      })
    })
    spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
      return Promise.resolve(users.find((u) => u.get('gplusID')==attrs.gplusID))
    })

    const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: users.map((u) => u._id)})
    spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers)) 
    
    try {
      const cocoClassroom = factories.makeClassroom({googleClassroomId: ""id1""})
      const classroomNewMembers = await GoogleClassroomHandler.importStudentsToClassroom(cocoClassroom)
      expect(api.users.signupFromGoogleClassroom).toHaveBeenCalled()
      expect(api.users.signupFromGoogleClassroom.calls.count()).toEqual(gcStudents.length)
      expect(api.classrooms.addMembers).toHaveBeenCalled()
      expect(classroomNewMembers.length).toEqual(gcStudents.length)
      expect(classroomNewMembers[0].get('gplusID')).toBe(gcStudents[0].userId)
      expect(classroomNewMembers[1].get('gplusID')).toBe(gcStudents[1].userId)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Exception Handling,"{'line': 249, 'column': 6, 'index': 10351}","it('does not add students if already exist in the classroom', async function(done) {
      const signUpResult = gcStudents.map((s) => {
        let user = factories.makeUser({
          gplusID: s.userId,
          firstName: s.profile.givenName,
          lastName: s.profile.familyName,
          email: s.profile.emailAddress,
          role: 'student'
        }).attributes
        return {
          isError: true,
          errorID: 'student-account-exists',
          error: user
        }
      })
      spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
        return Promise.resolve(signUpResult.find((r) => r.error.gplusID==attrs.gplusID))
      })

      const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: signUpResult.map((r) => r.error._id)})
      spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers))

      try {
        await GoogleClassroomHandler.importStudentsToClassroom(classroomWithNewMembers)
        done.fail(new Error(""This should not have been called""))
      }
      catch (err) {
        expect(api.users.signupFromGoogleClassroom).toHaveBeenCalled()
        expect(api.users.signupFromGoogleClassroom.calls.count()).toEqual(gcStudents.length)
        expect(api.classrooms.addMembers).not.toHaveBeenCalled()
        done()
      }
    })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Exception Handling,"{'line': 283, 'column': 6, 'index': 11730}","it('adds students to classroom if do not exist already', async function(done) {
      const signUpResult = gcStudents.map((s) => {
        let user = factories.makeUser({
          gplusID: s.userId,
          firstName: s.profile.givenName,
          lastName: s.profile.familyName,
          email: s.profile.emailAddress,
          role: 'student'
        }).attributes
        return {
          isError: true,
          errorID: 'student-account-exists',
          error: user
        }
      })
      spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
        return Promise.resolve(signUpResult.find((r) => r.error.gplusID==attrs.gplusID))
      })

      const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: signUpResult.map((r) => r.error._id)})
      spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers))

      try {
        const cocoClassroom = factories.makeClassroom({googleClassroomId: ""id1""})
        const newMembers = await GoogleClassroomHandler.importStudentsToClassroom(cocoClassroom)
        expect(api.users.signupFromGoogleClassroom).toHaveBeenCalled()
        expect(api.users.signupFromGoogleClassroom.calls.count()).toEqual(gcStudents.length)
        expect(api.classrooms.addMembers).toHaveBeenCalled()
        expect(newMembers.length).toEqual(gcStudents.length)
        done()
      }
      catch (err) {
        done.fail(new Error(""This should not have been called""))
      }
    })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Exception Handling,"{'line': 320, 'column': 4, 'index': 13441}","it('calls `loadStudentsFromAPI` multiple times until previous api call returns nextPageToken', async function(done) {
    me.set(factories.makeUser({role: 'teacher'}).attributes)
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadStudentsFromAPI').and.returnValues(Promise.resolve({students: gcStudents[0], nextPageToken: 'abcd'}), Promise.resolve({students: gcStudents[1]})) 
    
    const users = gcStudents.map((s) => {
      return factories.makeUser({
        gplusID: s.userId,
        firstName: s.profile.givenName,
        lastName: s.profile.familyName,
        email: s.profile.emailAddress,
        role: 'student'
      })
    })
    spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
      return Promise.resolve(users.find((u) => u.get('gplusID')==attrs.gplusID))
    })

    const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: users.map((u) => u._id)})
    spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers)) 
    
    try {
      const cocoClassroom = factories.makeClassroom({googleClassroomId: ""id1""})
      const classroomNewMembers = await GoogleClassroomHandler.importStudentsToClassroom(cocoClassroom)
      expect(GoogleClassroomHandler.gcApiHandler.loadStudentsFromAPI.calls.count()).toEqual(2)
      expect(classroomNewMembers.length).toEqual(gcStudents.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Global Variable,"{'line': 5, 'column': 0, 'index': 152}",Unknown,steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Magic Number,"{'line': 92, 'column': 51, 'index': 3176}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Magic Number,"{'line': 114, 'column': 53, 'index': 4412}","it('updates the linked classrooms in me.googleClassrooms while keeping the importedToCoco value', async function(done) {
    
    me.set('googleClassrooms', gClassrooms)

    // mark gClassrooms[0] as imported
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(2)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(importedClassroom.name)
    expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(gClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
    expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()

    // new classrooms data recieved from google classroom API
    const newGClassrooms = [{
      id: ""id1"",
      name: ""test class 1-new""
    },
    {
      id: ""id2"",
      name: ""test class 2-new""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))

    try {
      await GoogleClassroomHandler.importClassrooms()
      // names of linked classroom should be updated, and importedToCoco field should remain same
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id==importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms.find((gc) => gc.id!=importedClassroom.id).name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Magic Number,"{'line': 134, 'column': 51, 'index': 5710}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(1)
    
    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))
  
    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Magic Number,"{'line': 146, 'column': 53, 'index': 6235}","it('does not remove an already imported classroom from me.googleClassrooms if deleted from google classroom, and sets deletedFromGC flag', async function(done) {
    // mark gClassrooms[0] as imported
    me.set('googleClassrooms', [gClassrooms[0]])
    let importedClassroom = me.get('googleClassrooms').find((c) => c.id == gClassrooms[0].id)
    importedClassroom.importedToCoco = true

    expect(me.get('googleClassrooms').length).toBe(1)
    
    // new classrooms data recieved from google classroom API - does not contain classroom id1
    const newGClassrooms = [{
      id: ""id2"",
      name: ""test class 2""
    }]
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadClassroomsFromAPI').and.returnValue(Promise.resolve(newGClassrooms))
  
    try {
      await GoogleClassroomHandler.importClassrooms()
      // me.googleClassrooms should contain old imported classroom id1 as well as new classroom id2
      expect(me.get('googleClassrooms').length).toBe(2)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).importedToCoco).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id == importedClassroom.id).deletedFromGC).toBe(true)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id)).toBeDefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).name).toBe(newGClassrooms[0].name)
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).importedToCoco).toBeUndefined()
      expect(me.get('googleClassrooms').find((gc) => gc.id != importedClassroom.id).deletedFromGC).toBeUndefined()
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/social-handlers/GoogleClassroomHandler.spec.coco.js,Magic Number,"{'line': 323, 'column': 92, 'index': 13723}","it('calls `loadStudentsFromAPI` multiple times until previous api call returns nextPageToken', async function(done) {
    me.set(factories.makeUser({role: 'teacher'}).attributes)
    spyOn(GoogleClassroomHandler.gcApiHandler, 'loadStudentsFromAPI').and.returnValues(Promise.resolve({students: gcStudents[0], nextPageToken: 'abcd'}), Promise.resolve({students: gcStudents[1]})) 
    
    const users = gcStudents.map((s) => {
      return factories.makeUser({
        gplusID: s.userId,
        firstName: s.profile.givenName,
        lastName: s.profile.familyName,
        email: s.profile.emailAddress,
        role: 'student'
      })
    })
    spyOn(api.users, 'signupFromGoogleClassroom').and.callFake(function(attrs) {
      return Promise.resolve(users.find((u) => u.get('gplusID')==attrs.gplusID))
    })

    const classroomWithNewMembers = factories.makeClassroom({googleClassroomId: ""id1"", members: users.map((u) => u._id)})
    spyOn(api.classrooms, 'addMembers').and.returnValue(Promise.resolve(classroomWithNewMembers)) 
    
    try {
      const cocoClassroom = factories.makeClassroom({googleClassroomId: ""id1""})
      const classroomNewMembers = await GoogleClassroomHandler.importStudentsToClassroom(cocoClassroom)
      expect(GoogleClassroomHandler.gcApiHandler.loadStudentsFromAPI.calls.count()).toEqual(2)
      expect(classroomNewMembers.length).toEqual(gcStudents.length)
      done()
    }
    catch (err) {
      done.fail(new Error(""This should not have been called""))
    }
  })",steel
/test/app/core/api/fetch-json.spec.js,Conditional Test Logic,"{'line': 15, 'column': 8, 'index': 471}","beforeEach(() => spyOn(window, 'fetch').and.returnValue(Promise.resolve({
    status: 200,
    json() { return {}; },
    text() { return '{}'; },
    headers: {
      get(attr) {
        if (attr === 'content-type') {
          return 'application/json';
        } else {
          throw new Error(""Tried to access a value on the response that we didn't stub!"");
        }
      }
      }
    })))",steel
/test/app/collections/Products.spec.js,Conditional Test Logic,"{'line': 14, 'column': 4, 'index': 649}","it('basic_subscription products have payPalBillingPlanID set', done => $.ajax(""/db/products"")
  .done((data, textStatus, jqXHR) => {
    for (var product of Array.from(data)) {
      if (!/basic_subscription/.test(product.name)) { continue; }
      expect(product.payPalBillingPlanID).toBeDefined();
    }
    return done();
}).fail((jqXHR, textStatus, errorThrown) => {
    console.error(jqXHR, textStatus, errorThrown);
    return done(textStatus);
  }))",steel
/test/app/collections/Products.spec.js,Conditional Test Logic,"{'line': 15, 'column': 6, 'index': 695}","it('basic_subscription products have payPalBillingPlanID set', done => $.ajax(""/db/products"")
  .done((data, textStatus, jqXHR) => {
    for (var product of Array.from(data)) {
      if (!/basic_subscription/.test(product.name)) { continue; }
      expect(product.payPalBillingPlanID).toBeDefined();
    }
    return done();
}).fail((jqXHR, textStatus, errorThrown) => {
    console.error(jqXHR, textStatus, errorThrown);
    return done(textStatus);
  }))",steel
/test/app/collections/Products.spec.js,Global Variable,"{'line': 14, 'column': 9, 'index': 654}","it('basic_subscription products have payPalBillingPlanID set', done => $.ajax(""/db/products"")
  .done((data, textStatus, jqXHR) => {
    for (var product of Array.from(data)) {
      if (!/basic_subscription/.test(product.name)) { continue; }
      expect(product.payPalBillingPlanID).toBeDefined();
    }
    return done();
}).fail((jqXHR, textStatus, errorThrown) => {
    console.error(jqXHR, textStatus, errorThrown);
    return done(textStatus);
  }))",steel
/test/app/collections/Products.spec.js,Redundant Print,"{'line': 20, 'column': 4, 'index': 887}","it('basic_subscription products have payPalBillingPlanID set', done => $.ajax(""/db/products"")
  .done((data, textStatus, jqXHR) => {
    for (var product of Array.from(data)) {
      if (!/basic_subscription/.test(product.name)) { continue; }
      expect(product.payPalBillingPlanID).toBeDefined();
    }
    return done();
}).fail((jqXHR, textStatus, errorThrown) => {
    console.error(jqXHR, textStatus, errorThrown);
    return done(textStatus);
  }))",steel
