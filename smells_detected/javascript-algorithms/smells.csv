file,type,line,method,source
/src/data-structures/trie/__test__/Trie.test.js,VerboseStatement,"{'startLine':26,'endLine':63}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",snuts
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,VerboseStatement,"{'startLine':76,'endLine':107}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",snuts
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,VerboseStatement,"{'startLine':109,'endLine':146}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",snuts
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,VerboseStatement,"{'startLine':177,'endLine':198}","it('should be possible to create node with object as a value', () => {
    const obj1 = { key: 'object_1', toString: () => 'object_1' };
    const obj2 = { key: 'object_2' };

    const node1 = new BinaryTreeNode(obj1);
    const node2 = new BinaryTreeNode(obj2);

    node1.setLeft(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left.value).toEqual(obj2);

    node1.removeChild(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left).toBeNull();

    expect(node1.toString()).toBe('object_1');
    expect(node2.toString()).toBe('[object Object]');
  })",snuts
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,VerboseStatement,"{'startLine':211,'endLine':234}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",snuts
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,VerboseStatement,"{'startLine':236,'endLine':259}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,VerboseStatement,"{'startLine':4,'endLine':24}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,VerboseStatement,"{'startLine':26,'endLine':45}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,VerboseStatement,"{'startLine':47,'endLine':71}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,VerboseStatement,"{'startLine':73,'endLine':93}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,VerboseStatement,"{'startLine':121,'endLine':147}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCache.test.js,VerboseStatement,"{'startLine':4,'endLine':24}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCache.test.js,VerboseStatement,"{'startLine':26,'endLine':45}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCache.test.js,VerboseStatement,"{'startLine':47,'endLine':73}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCache.test.js,VerboseStatement,"{'startLine':75,'endLine':95}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",snuts
/src/data-structures/lru-cache/__test__/LRUCache.test.js,VerboseStatement,"{'startLine':123,'endLine':149}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",snuts
/src/data-structures/linked-list/__test__/LinkedList.test.js,ConditionalTestLogic,"{'startLine':212,'endLine':214}","it('should find node by means of custom compare function', () => {
    const comparatorFunction = (a, b) => {
      if (a.customValue === b.customValue) {
        return 0;
      }

      return a.customValue < b.customValue ? -1 : 1;
    };

    const linkedList = new LinkedList(comparatorFunction);

    linkedList
      .append({ value: 1, customValue: 'test1' })
      .append({ value: 2, customValue: 'test2' })
      .append({ value: 3, customValue: 'test3' });

    const node = linkedList.find({
      value: { value: 2, customValue: 'test2' },
    });

    expect(node).toBeDefined();
    expect(node.value.value).toBe(2);
    expect(node.value.customValue).toBe('test2');
    expect(linkedList.find({ value: { value: 2, customValue: 'test5' } })).toBeNull();
  })",snuts
/src/data-structures/linked-list/__test__/LinkedList.test.js,VerboseStatement,"{'startLine':50,'endLine':94}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",snuts
/src/data-structures/linked-list/__test__/LinkedList.test.js,VerboseStatement,"{'startLine':96,'endLine':126}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",snuts
/src/data-structures/linked-list/__test__/LinkedList.test.js,VerboseStatement,"{'startLine':128,'endLine':152}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",snuts
/src/data-structures/hash-table/__test__/HashTable.test.js,SubOptimalAssert,"{'startLine':6,'endLine':6}","it('should create hash table of certain size', () => {
    const defaultHashTable = new HashTable();
    expect(defaultHashTable.buckets.length).toBe(32);

    const biggerHashTable = new HashTable(64);
    expect(biggerHashTable.buckets.length).toBe(64);
  })",snuts
/src/data-structures/hash-table/__test__/HashTable.test.js,SubOptimalAssert,"{'startLine':9,'endLine':9}","it('should create hash table of certain size', () => {
    const defaultHashTable = new HashTable();
    expect(defaultHashTable.buckets.length).toBe(32);

    const biggerHashTable = new HashTable(64);
    expect(biggerHashTable.buckets.length).toBe(64);
  })",snuts
/src/data-structures/hash-table/__test__/HashTable.test.js,VerboseStatement,"{'startLine':20,'endLine':57}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",snuts
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,SubOptimalAssert,"{'startLine':8,'endLine':8}","it('should create an empty min heap', () => {
    const minHeap = new MinHeapAdhoc();

    expect(minHeap).toBeDefined();
    expect(minHeap.peek()).toBe(undefined);
    expect(minHeap.isEmpty()).toBe(true);
  })",snuts
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,SubOptimalAssert,"{'startLine':72,'endLine':72}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",snuts
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,VerboseStatement,"{'startLine':12,'endLine':44}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",snuts
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,VerboseStatement,"{'startLine':46,'endLine':74}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",snuts
/src/data-structures/heap/__test__/MinHeap.test.js,ConditionalTestLogic,"{'startLine':162,'endLine':164}","it('should be possible to remove items from heap with custom finding comparator', () => {
    const minHeap = new MinHeap();
    minHeap.add('dddd');
    minHeap.add('ccc');
    minHeap.add('bb');
    minHeap.add('a');

    expect(minHeap.toString()).toBe('a,bb,ccc,dddd');

    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    minHeap.remove('hey', comparator);
    expect(minHeap.toString()).toBe('a,bb,dddd');
  })",snuts
/src/data-structures/heap/__test__/MinHeap.test.js,VerboseStatement,"{'startLine':13,'endLine':45}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",snuts
/src/data-structures/heap/__test__/MinHeap.test.js,VerboseStatement,"{'startLine':47,'endLine':75}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",snuts
/src/data-structures/heap/__test__/MinHeap.test.js,VerboseStatement,"{'startLine':126,'endLine':150}","it('should be possible to remove items from heap with heapify up', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(5);
    minHeap.add(6);
    minHeap.add(7);
    minHeap.add(4);
    minHeap.add(6);
    minHeap.add(8);
    minHeap.add(2);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,2,4,6,3,5,6,10,8,7');
    expect(minHeap.remove(8).toString()).toEqual('1,2,4,6,3,5,6,10,7');
    expect(minHeap.remove(7).toString()).toEqual('1,2,4,6,3,5,6,10');
    expect(minHeap.remove(1).toString()).toEqual('2,3,4,6,10,5,6');
    expect(minHeap.remove(2).toString()).toEqual('3,6,4,6,10,5');
    expect(minHeap.remove(6).toString()).toEqual('3,5,4,10');
    expect(minHeap.remove(10).toString()).toEqual('3,5,4');
    expect(minHeap.remove(5).toString()).toEqual('3,4');
    expect(minHeap.remove(3).toString()).toEqual('4');
    expect(minHeap.remove(4).toString()).toEqual('');
  })",snuts
/src/data-structures/heap/__test__/MinHeap.test.js,VerboseStatement,"{'startLine':173,'endLine':193}","it('should remove values from heap and correctly re-order the tree', () => {
    const minHeap = new MinHeap();

    minHeap.add(1);
    minHeap.add(2);
    minHeap.add(3);
    minHeap.add(4);
    minHeap.add(5);
    minHeap.add(6);
    minHeap.add(7);
    minHeap.add(8);
    minHeap.add(9);

    expect(minHeap.toString()).toBe('1,2,3,4,5,6,7,8,9');

    minHeap.remove(2);
    expect(minHeap.toString()).toBe('1,4,3,8,5,6,7,9');

    minHeap.remove(4);
    expect(minHeap.toString()).toBe('1,5,3,8,9,6,7');
  })",snuts
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,SubOptimalAssert,"{'startLine':8,'endLine':8}","it('should create an empty max heap', () => {
    const maxHeap = new MaxHeap();

    expect(maxHeap).toBeDefined();
    expect(maxHeap.peek()).toBe(undefined);
    expect(maxHeap.isEmpty()).toBe(true);
  })",snuts
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,SubOptimalAssert,"{'startLine':72,'endLine':72}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",snuts
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,VerboseStatement,"{'startLine':12,'endLine':44}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",snuts
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,VerboseStatement,"{'startLine':46,'endLine':74}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",snuts
/src/data-structures/heap/__test__/MaxHeap.test.js,ConditionalTestLogic,"{'startLine':162,'endLine':164}","it('should be possible to remove items from heap with custom finding comparator', () => {
    const maxHeap = new MaxHeap();
    maxHeap.add('a');
    maxHeap.add('bb');
    maxHeap.add('ccc');
    maxHeap.add('dddd');

    expect(maxHeap.toString()).toBe('dddd,ccc,bb,a');

    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    maxHeap.remove('hey', comparator);
    expect(maxHeap.toString()).toBe('dddd,a,bb');
  })",snuts
/src/data-structures/heap/__test__/MaxHeap.test.js,VerboseStatement,"{'startLine':13,'endLine':45}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",snuts
/src/data-structures/heap/__test__/MaxHeap.test.js,VerboseStatement,"{'startLine':47,'endLine':75}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",snuts
/src/data-structures/heap/__test__/MaxHeap.test.js,VerboseStatement,"{'startLine':126,'endLine':150}","it('should be possible to remove items from heap with heapify up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(5);
    maxHeap.add(6);
    maxHeap.add(7);
    maxHeap.add(4);
    maxHeap.add(6);
    maxHeap.add(8);
    maxHeap.add(2);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('10,8,6,7,6,4,5,3,2,1');
    expect(maxHeap.remove(4).toString()).toEqual('10,8,6,7,6,1,5,3,2');
    expect(maxHeap.remove(3).toString()).toEqual('10,8,6,7,6,1,5,2');
    expect(maxHeap.remove(5).toString()).toEqual('10,8,6,7,6,1,2');
    expect(maxHeap.remove(10).toString()).toEqual('8,7,6,2,6,1');
    expect(maxHeap.remove(6).toString()).toEqual('8,7,1,2');
    expect(maxHeap.remove(2).toString()).toEqual('8,7,1');
    expect(maxHeap.remove(1).toString()).toEqual('8,7');
    expect(maxHeap.remove(7).toString()).toEqual('8');
    expect(maxHeap.remove(8).toString()).toEqual('');
  })",snuts
/src/data-structures/graph/__test__/GraphVertex.test.js,SubOptimalAssert,"{'startLine':36,'endLine':36}","it('should add edges to vertex and check if it exists', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.getEdges().length).toBe(1);
    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
  })",snuts
/src/data-structures/graph/__test__/GraphVertex.test.js,SubOptimalAssert,"{'startLine':57,'endLine':57}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",snuts
/src/data-structures/graph/__test__/GraphVertex.test.js,SubOptimalAssert,"{'startLine':70,'endLine':70}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",snuts
/src/data-structures/graph/__test__/GraphVertex.test.js,SubOptimalAssert,"{'startLine':90,'endLine':90}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",snuts
/src/data-structures/graph/__test__/GraphVertex.test.js,SubOptimalAssert,"{'startLine':100,'endLine':100}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",snuts
/src/data-structures/graph/__test__/GraphVertex.test.js,SubOptimalAssert,"{'startLine':118,'endLine':118}","it('should return vertex neighbors in case if current node is start one', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexB.getNeighbors()).toEqual([]);

    const neighbors = vertexA.getNeighbors();

    expect(neighbors.length).toBe(2);
    expect(neighbors[0]).toEqual(vertexB);
    expect(neighbors[1]).toEqual(vertexC);
  })",snuts
/src/data-structures/graph/__test__/GraphVertex.test.js,SubOptimalAssert,"{'startLine':138,'endLine':138}","it('should return vertex neighbors in case if current node is end one', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeBA = new GraphEdge(vertexB, vertexA);
    const edgeCA = new GraphEdge(vertexC, vertexA);
    vertexA
      .addEdge(edgeBA)
      .addEdge(edgeCA);

    expect(vertexB.getNeighbors()).toEqual([]);

    const neighbors = vertexA.getNeighbors();

    expect(neighbors.length).toBe(2);
    expect(neighbors[0]).toEqual(vertexB);
    expect(neighbors[1]).toEqual(vertexC);
  })",snuts
/src/data-structures/graph/__test__/GraphVertex.test.js,VerboseStatement,"{'startLine':40,'endLine':71}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",snuts
/src/data-structures/graph/__test__/GraphVertex.test.js,VerboseStatement,"{'startLine':73,'endLine':101}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':31,'endLine':31}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':44,'endLine':44}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':48,'endLine':48}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':70,'endLine':70}","it('should add edges to directed graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(0);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':74,'endLine':74}","it('should add edges to directed graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(0);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':139,'endLine':139}","it('should return vertex neighbors', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    const neighbors = graph.getNeighbors(vertexA);

    expect(neighbors.length).toBe(2);
    expect(neighbors[0]).toEqual(vertexB);
    expect(neighbors[1]).toEqual(vertexC);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':177,'endLine':177}","it('should return the list of all added edges', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC);

    const edges = graph.getAllEdges();

    expect(edges.length).toBe(2);
    expect(edges[0]).toEqual(edgeAB);
    expect(edges[1]).toEqual(edgeBC);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':242,'endLine':242}","it('should be possible to delete edges from graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC);

    expect(graph.getAllEdges().length).toBe(3);

    graph.deleteEdge(edgeAB);

    expect(graph.getAllEdges().length).toBe(2);
    expect(graph.getAllEdges()[0].getKey()).toBe(edgeBC.getKey());
    expect(graph.getAllEdges()[1].getKey()).toBe(edgeAC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':246,'endLine':246}","it('should be possible to delete edges from graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC);

    expect(graph.getAllEdges().length).toBe(3);

    graph.deleteEdge(edgeAB);

    expect(graph.getAllEdges().length).toBe(2);
    expect(graph.getAllEdges()[0].getKey()).toBe(edgeBC.getKey());
    expect(graph.getAllEdges()[1].getKey()).toBe(edgeAC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':286,'endLine':286}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':287,'endLine':287}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':290,'endLine':290}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':291,'endLine':291}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':293,'endLine':293}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':298,'endLine':298}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':299,'endLine':299}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':300,'endLine':300}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':302,'endLine':302}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,SubOptimalAssert,"{'startLine':304,'endLine':304}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,VerboseStatement,"{'startLine':21,'endLine':51}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,VerboseStatement,"{'startLine':53,'endLine':75}","it('should add edges to directed graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(0);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,VerboseStatement,"{'startLine':77,'endLine':98}","it('should find edge by vertices in undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB, 10);

    graph.addEdge(edgeAB);

    const graphEdgeAB = graph.findEdge(vertexA, vertexB);
    const graphEdgeBA = graph.findEdge(vertexB, vertexA);
    const graphEdgeAC = graph.findEdge(vertexA, vertexC);
    const graphEdgeCA = graph.findEdge(vertexC, vertexA);

    expect(graphEdgeAC).toBeNull();
    expect(graphEdgeCA).toBeNull();
    expect(graphEdgeAB).toEqual(edgeAB);
    expect(graphEdgeBA).toEqual(edgeAB);
    expect(graphEdgeAB.weight).toBe(10);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,VerboseStatement,"{'startLine':100,'endLine':121}","it('should find edge by vertices in directed graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB, 10);

    graph.addEdge(edgeAB);

    const graphEdgeAB = graph.findEdge(vertexA, vertexB);
    const graphEdgeBA = graph.findEdge(vertexB, vertexA);
    const graphEdgeAC = graph.findEdge(vertexA, vertexC);
    const graphEdgeCA = graph.findEdge(vertexC, vertexA);

    expect(graphEdgeAC).toBeNull();
    expect(graphEdgeCA).toBeNull();
    expect(graphEdgeBA).toBeNull();
    expect(graphEdgeAB).toEqual(edgeAB);
    expect(graphEdgeAB.weight).toBe(10);
  })",snuts
/src/data-structures/graph/__test__/Graph.test.js,VerboseStatement,"{'startLine':269,'endLine':306}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,ConditionalTestLogic,"{'startLine':208,'endLine':210}","it('should find node by means of custom compare function', () => {
    const comparatorFunction = (a, b) => {
      if (a.customValue === b.customValue) {
        return 0;
      }

      return a.customValue < b.customValue ? -1 : 1;
    };

    const linkedList = new DoublyLinkedList(comparatorFunction);

    linkedList
      .append({ value: 1, customValue: 'test1' })
      .append({ value: 2, customValue: 'test2' })
      .append({ value: 3, customValue: 'test3' });

    const node = linkedList.find({
      value: { value: 2, customValue: 'test2' },
    });

    expect(node).toBeDefined();
    expect(node.value.value).toBe(2);
    expect(node.value.customValue).toBe('test2');
    expect(linkedList.find({ value: 2, customValue: 'test5' })).toBeNull();
  })",snuts
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,VerboseStatement,"{'startLine':46,'endLine':94}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",snuts
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,VerboseStatement,"{'startLine':96,'endLine':128}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",snuts
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,VerboseStatement,"{'startLine':130,'endLine':155}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",snuts
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,VerboseStatement,"{'startLine':232,'endLine':279}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,SubOptimalAssert,"{'startLine':26,'endLine':26}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,SubOptimalAssert,"{'startLine':27,'endLine':27}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,SubOptimalAssert,"{'startLine':32,'endLine':32}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,SubOptimalAssert,"{'startLine':33,'endLine':33}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,SubOptimalAssert,"{'startLine':84,'endLine':84}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,SubOptimalAssert,"{'startLine':85,'endLine':85}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,SubOptimalAssert,"{'startLine':90,'endLine':90}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,SubOptimalAssert,"{'startLine':91,'endLine':91}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,VerboseStatement,"{'startLine':4,'endLine':56}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,VerboseStatement,"{'startLine':58,'endLine':114}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSetAdhoc.test.js,VerboseStatement,"{'startLine':4,'endLine':32}","it('should create unions and find connected elements', () => {
    const set = new DisjointSetAdhoc(10);

    // 1-2-5-6-7 3-8-9 4
    set.union(1, 2);
    set.union(2, 5);
    set.union(5, 6);
    set.union(6, 7);

    set.union(3, 8);
    set.union(8, 9);

    expect(set.connected(1, 5)).toBe(true);
    expect(set.connected(5, 7)).toBe(true);
    expect(set.connected(3, 8)).toBe(true);

    expect(set.connected(4, 9)).toBe(false);
    expect(set.connected(4, 7)).toBe(false);

    // 1-2-5-6-7 3-8-9-4
    set.union(9, 4);

    expect(set.connected(4, 9)).toBe(true);
    expect(set.connected(4, 3)).toBe(true);
    expect(set.connected(8, 4)).toBe(true);

    expect(set.connected(8, 7)).toBe(false);
    expect(set.connected(2, 3)).toBe(false);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,VerboseStatement,"{'startLine':21,'endLine':81}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",snuts
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,VerboseStatement,"{'startLine':96,'endLine':139}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",snuts
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,SubOptimalAssert,"{'startLine':49,'endLine':49}","it('should create an array with 3 hash values', () => {
    expect(bloomFilter.getHashValues('abc').length).toBe(3);
    expect(bloomFilter.getHashValues('abc')).toEqual([66, 63, 54]);
  })",snuts
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,VerboseStatement,"{'startLine':26,'endLine':46}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",snuts
/src/utils/comparator/__test__/Comparator.test.js,ConditionalTestLogic,"{'startLine':27,'endLine':29}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",snuts
/src/utils/comparator/__test__/Comparator.test.js,VerboseStatement,"{'startLine':4,'endLine':23}","it('should compare with default comparator function', () => {
    const comparator = new Comparator();

    expect(comparator.equal(0, 0)).toBe(true);
    expect(comparator.equal(0, 1)).toBe(false);
    expect(comparator.equal('a', 'a')).toBe(true);
    expect(comparator.lessThan(1, 2)).toBe(true);
    expect(comparator.lessThan(-1, 2)).toBe(true);
    expect(comparator.lessThan('a', 'b')).toBe(true);
    expect(comparator.lessThan('a', 'ab')).toBe(true);
    expect(comparator.lessThan(10, 2)).toBe(false);
    expect(comparator.lessThanOrEqual(10, 2)).toBe(false);
    expect(comparator.lessThanOrEqual(1, 1)).toBe(true);
    expect(comparator.lessThanOrEqual(0, 0)).toBe(true);
    expect(comparator.greaterThan(0, 0)).toBe(false);
    expect(comparator.greaterThan(10, 0)).toBe(true);
    expect(comparator.greaterThanOrEqual(10, 0)).toBe(true);
    expect(comparator.greaterThanOrEqual(10, 10)).toBe(true);
    expect(comparator.greaterThanOrEqual(0, 10)).toBe(false);
  })",snuts
/src/utils/comparator/__test__/Comparator.test.js,VerboseStatement,"{'startLine':25,'endLine':49}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",snuts
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,SubOptimalAssert,"{'startLine':9,'endLine':9}","it('should build tree for input array #0 with length of power of two', () => {
    const array = [-1, 2];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.segmentTree).toEqual([-1, -1, 2]);
    expect(segmentTree.segmentTree.length).toBe((2 * array.length) - 1);
  })",snuts
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,SubOptimalAssert,"{'startLine':17,'endLine':17}","it('should build tree for input array #1 with length of power of two', () => {
    const array = [-1, 2, 4, 0];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.segmentTree).toEqual([-1, -1, 0, -1, 2, 4, 0]);
    expect(segmentTree.segmentTree.length).toBe((2 * array.length) - 1);
  })",snuts
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,SubOptimalAssert,"{'startLine':25,'endLine':25}","it('should build tree for input array #0 with length not of power of two', () => {
    const array = [0, 1, 2];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.segmentTree).toEqual([0, 0, 2, 0, 1, null, null]);
    expect(segmentTree.segmentTree.length).toBe((2 * 4) - 1);
  })",snuts
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,SubOptimalAssert,"{'startLine':35,'endLine':35}","it('should build tree for input array #1 with length not of power of two', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.segmentTree).toEqual([
      -1, -1, 0, -1, 4, 0, 1, -1, 3, null, null, 0, 2, null, null,
    ]);
    expect(segmentTree.segmentTree.length).toBe((2 * 8) - 1);
  })",snuts
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,SubOptimalAssert,"{'startLine':43,'endLine':43}","it('should build max array', () => {
    const array = [-1, 2, 4, 0];
    const segmentTree = new SegmentTree(array, Math.max, -Infinity);

    expect(segmentTree.segmentTree).toEqual([4, 2, 4, -1, 2, 4, 0]);
    expect(segmentTree.segmentTree.length).toBe((2 * array.length) - 1);
  })",snuts
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,SubOptimalAssert,"{'startLine':51,'endLine':51}","it('should build sum array', () => {
    const array = [-1, 2, 4, 0];
    const segmentTree = new SegmentTree(array, (a, b) => (a + b), 0);

    expect(segmentTree.segmentTree).toEqual([5, 1, 4, -1, 2, 4, 0]);
    expect(segmentTree.segmentTree.length).toBe((2 * array.length) - 1);
  })",snuts
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,VerboseStatement,"{'startLine':46,'endLine':106}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",snuts
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,VerboseStatement,"{'startLine':108,'endLine':151}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",snuts
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,VerboseStatement,"{'startLine':153,'endLine':182}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",snuts
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,VerboseStatement,"{'startLine':184,'endLine':213}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",snuts
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,VerboseStatement,"{'startLine':215,'endLine':245}","it('should do recoloring, left-left and left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(30);
    const node8 = tree.insert(1);
    const node9 = tree.insert(9);

    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);
  })",snuts
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,VerboseStatement,"{'startLine':247,'endLine':287}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",snuts
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,SubOptimalAssert,"{'startLine':6,'endLine':6}","it('should create empty fenwick tree of correct size', () => {
    const tree1 = new FenwickTree(5);
    expect(tree1.treeArray.length).toBe(5 + 1);

    for (let i = 0; i < 5; i += 1) {
      expect(tree1.treeArray[i]).toBe(0);
    }

    const tree2 = new FenwickTree(50);
    expect(tree2.treeArray.length).toBe(50 + 1);
  })",snuts
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,SubOptimalAssert,"{'startLine':13,'endLine':13}","it('should create empty fenwick tree of correct size', () => {
    const tree1 = new FenwickTree(5);
    expect(tree1.treeArray.length).toBe(5 + 1);

    for (let i = 0; i < 5; i += 1) {
      expect(tree1.treeArray[i]).toBe(0);
    }

    const tree2 = new FenwickTree(50);
    expect(tree2.treeArray.length).toBe(50 + 1);
  })",snuts
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,SubOptimalAssert,"{'startLine':20,'endLine':20}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",snuts
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,VerboseStatement,"{'startLine':16,'endLine':63}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",snuts
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,ConditionalTestLogic,"{'startLine':221,'endLine':223}","it('should be possible to use objects as node values', () => {
    const nodeValueComparatorCallback = (a, b) => {
      const normalizedA = a || { value: null };
      const normalizedB = b || { value: null };

      if (normalizedA.value === normalizedB.value) {
        return 0;
      }

      return normalizedA.value < normalizedB.value ? -1 : 1;
    };

    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };

    const bstNode = new BinarySearchTreeNode(obj2, nodeValueComparatorCallback);
    bstNode.insert(obj1);

    expect(bstNode.toString()).toBe('obj1,obj2');
    expect(bstNode.contains(obj1)).toBe(true);
    expect(bstNode.contains(obj3)).toBe(false);

    bstNode.insert(obj3);

    expect(bstNode.toString()).toBe('obj1,obj2,obj3');
    expect(bstNode.contains(obj3)).toBe(true);

    expect(bstNode.findMin().value).toEqual(obj1);
  })",snuts
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,VerboseStatement,"{'startLine':21,'endLine':54}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",snuts
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,VerboseStatement,"{'startLine':84,'endLine':103}","it('should be possible to attach meta information to binary search tree nodes', () => {
    const node = new BinarySearchTreeNode(10);

    node.insert(20);
    const node1 = node.insert(30);
    node.insert(5);
    node.insert(40);
    const node2 = node.insert(1);

    node.meta.set('color', 'red');
    node1.meta.set('color', 'black');
    node2.meta.set('color', 'white');

    expect(node.meta.get('color')).toBe('red');

    expect(node.findMin()).not.toBeNull();
    expect(node.findMin().value).toBe(1);
    expect(node.findMin().meta.get('color')).toBe('white');
    expect(node.find(30).meta.get('color')).toBe('black');
  })",snuts
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,VerboseStatement,"{'startLine':157,'endLine':186}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",snuts
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,ConditionalTestLogic,"{'startLine':60,'endLine':62}","it('should insert object values', () => {
    const nodeValueCompareFunction = (a, b) => {
      const normalizedA = a || { value: null };
      const normalizedB = b || { value: null };

      if (normalizedA.value === normalizedB.value) {
        return 0;
      }

      return normalizedA.value < normalizedB.value ? -1 : 1;
    };

    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };

    const bst = new BinarySearchTree(nodeValueCompareFunction);

    bst.insert(obj2);
    bst.insert(obj3);
    bst.insert(obj1);

    expect(bst.toString()).toBe('obj1,obj2,obj3');
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,IdenticalTestDescription,"{'startLine':211,'endLine':231}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,VerboseStatement,"{'startLine':4,'endLine':27}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,VerboseStatement,"{'startLine':29,'endLine':50}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,VerboseStatement,"{'startLine':52,'endLine':75}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,VerboseStatement,"{'startLine':77,'endLine':98}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,VerboseStatement,"{'startLine':124,'endLine':165}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,VerboseStatement,"{'startLine':167,'endLine':187}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,VerboseStatement,"{'startLine':189,'endLine':209}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(5);
    tree.insert(12);

    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);

    tree.insert(11);

    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,VerboseStatement,"{'startLine':211,'endLine':231}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",snuts
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,VerboseStatement,"{'startLine':271,'endLine':302}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",snuts
/src/algorithms/tree/depth-first-search/__test__/depthFirstSearch.test.js,OvercommentedTest,"{'startLine':55,'endLine':101}","it('allow users to redefine node visiting logic', () => {
    const nodeA = new BinaryTreeNode('A');
    const nodeB = new BinaryTreeNode('B');
    const nodeC = new BinaryTreeNode('C');
    const nodeD = new BinaryTreeNode('D');
    const nodeE = new BinaryTreeNode('E');
    const nodeF = new BinaryTreeNode('F');
    const nodeG = new BinaryTreeNode('G');

    nodeA.setLeft(nodeB).setRight(nodeC);
    nodeB.setLeft(nodeD).setRight(nodeE);
    nodeC.setLeft(nodeF).setRight(nodeG);

    // In-order traversing.
    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');

    const enterNodeCallback = jest.fn();
    const leaveNodeCallback = jest.fn();

    // Traverse tree without callbacks first to check default ones.
    depthFirstSearch(nodeA);

    // Traverse tree with callbacks.
    depthFirstSearch(nodeA, {
      allowTraversal: (node, child) => {
        // Forbid traversing left part of the tree.
        return child.value !== 'B';
      },
      enterNode: enterNodeCallback,
      leaveNode: leaveNodeCallback,
    });

    expect(enterNodeCallback).toHaveBeenCalledTimes(4);
    expect(leaveNodeCallback).toHaveBeenCalledTimes(4);

    // Check node entering.
    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('C');
    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('F');
    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('G');

    // Check node leaving.
    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('F');
    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('G');
    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('C');
    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('A');
  })",snuts
/src/algorithms/tree/depth-first-search/__test__/depthFirstSearch.test.js,VerboseStatement,"{'startLine':5,'endLine':53}","it('should perform DFS operation on tree', () => {
    const nodeA = new BinaryTreeNode('A');
    const nodeB = new BinaryTreeNode('B');
    const nodeC = new BinaryTreeNode('C');
    const nodeD = new BinaryTreeNode('D');
    const nodeE = new BinaryTreeNode('E');
    const nodeF = new BinaryTreeNode('F');
    const nodeG = new BinaryTreeNode('G');

    nodeA.setLeft(nodeB).setRight(nodeC);
    nodeB.setLeft(nodeD).setRight(nodeE);
    nodeC.setLeft(nodeF).setRight(nodeG);

    // In-order traversing.
    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');

    const enterNodeCallback = jest.fn();
    const leaveNodeCallback = jest.fn();

    // Traverse tree without callbacks first to check default ones.
    depthFirstSearch(nodeA);

    // Traverse tree with callbacks.
    depthFirstSearch(nodeA, {
      enterNode: enterNodeCallback,
      leaveNode: leaveNodeCallback,
    });

    expect(enterNodeCallback).toHaveBeenCalledTimes(7);
    expect(leaveNodeCallback).toHaveBeenCalledTimes(7);

    // Check node entering.
    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('B');
    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('D');
    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('E');
    expect(enterNodeCallback.mock.calls[4][0].value).toEqual('C');
    expect(enterNodeCallback.mock.calls[5][0].value).toEqual('F');
    expect(enterNodeCallback.mock.calls[6][0].value).toEqual('G');

    // Check node leaving.
    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('D');
    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('E');
    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('B');
    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('F');
    expect(leaveNodeCallback.mock.calls[4][0].value).toEqual('G');
    expect(leaveNodeCallback.mock.calls[5][0].value).toEqual('C');
    expect(leaveNodeCallback.mock.calls[6][0].value).toEqual('A');
  })",snuts
/src/algorithms/tree/depth-first-search/__test__/depthFirstSearch.test.js,VerboseStatement,"{'startLine':55,'endLine':101}","it('allow users to redefine node visiting logic', () => {
    const nodeA = new BinaryTreeNode('A');
    const nodeB = new BinaryTreeNode('B');
    const nodeC = new BinaryTreeNode('C');
    const nodeD = new BinaryTreeNode('D');
    const nodeE = new BinaryTreeNode('E');
    const nodeF = new BinaryTreeNode('F');
    const nodeG = new BinaryTreeNode('G');

    nodeA.setLeft(nodeB).setRight(nodeC);
    nodeB.setLeft(nodeD).setRight(nodeE);
    nodeC.setLeft(nodeF).setRight(nodeG);

    // In-order traversing.
    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');

    const enterNodeCallback = jest.fn();
    const leaveNodeCallback = jest.fn();

    // Traverse tree without callbacks first to check default ones.
    depthFirstSearch(nodeA);

    // Traverse tree with callbacks.
    depthFirstSearch(nodeA, {
      allowTraversal: (node, child) => {
        // Forbid traversing left part of the tree.
        return child.value !== 'B';
      },
      enterNode: enterNodeCallback,
      leaveNode: leaveNodeCallback,
    });

    expect(enterNodeCallback).toHaveBeenCalledTimes(4);
    expect(leaveNodeCallback).toHaveBeenCalledTimes(4);

    // Check node entering.
    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('C');
    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('F');
    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('G');

    // Check node leaving.
    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('F');
    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('G');
    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('C');
    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('A');
  })",snuts
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,VerboseStatement,"{'startLine':4,'endLine':20}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",snuts
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,VerboseStatement,"{'startLine':4,'endLine':20}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",snuts
/src/algorithms/tree/breadth-first-search/__test__/breadthFirstSearch.test.js,OvercommentedTest,"{'startLine':55,'endLine':101}","it('allow users to redefine node visiting logic', () => {
    const nodeA = new BinaryTreeNode('A');
    const nodeB = new BinaryTreeNode('B');
    const nodeC = new BinaryTreeNode('C');
    const nodeD = new BinaryTreeNode('D');
    const nodeE = new BinaryTreeNode('E');
    const nodeF = new BinaryTreeNode('F');
    const nodeG = new BinaryTreeNode('G');

    nodeA.setLeft(nodeB).setRight(nodeC);
    nodeB.setLeft(nodeD).setRight(nodeE);
    nodeC.setLeft(nodeF).setRight(nodeG);

    // In-order traversing.
    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');

    const enterNodeCallback = jest.fn();
    const leaveNodeCallback = jest.fn();

    // Traverse tree without callbacks first to check default ones.
    breadthFirstSearch(nodeA);

    // Traverse tree with callbacks.
    breadthFirstSearch(nodeA, {
      allowTraversal: (node, child) => {
        // Forbid traversing left half of the tree.
        return child.value !== 'B';
      },
      enterNode: enterNodeCallback,
      leaveNode: leaveNodeCallback,
    });

    expect(enterNodeCallback).toHaveBeenCalledTimes(4);
    expect(leaveNodeCallback).toHaveBeenCalledTimes(4);

    // Check node entering.
    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('C');
    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('F');
    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('G');

    // Check node leaving.
    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('A');
    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('C');
    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('F');
    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('G');
  })",snuts
/src/algorithms/tree/breadth-first-search/__test__/breadthFirstSearch.test.js,VerboseStatement,"{'startLine':5,'endLine':53}","it('should perform BFS operation on tree', () => {
    const nodeA = new BinaryTreeNode('A');
    const nodeB = new BinaryTreeNode('B');
    const nodeC = new BinaryTreeNode('C');
    const nodeD = new BinaryTreeNode('D');
    const nodeE = new BinaryTreeNode('E');
    const nodeF = new BinaryTreeNode('F');
    const nodeG = new BinaryTreeNode('G');

    nodeA.setLeft(nodeB).setRight(nodeC);
    nodeB.setLeft(nodeD).setRight(nodeE);
    nodeC.setLeft(nodeF).setRight(nodeG);

    // In-order traversing.
    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');

    const enterNodeCallback = jest.fn();
    const leaveNodeCallback = jest.fn();

    // Traverse tree without callbacks first to check default ones.
    breadthFirstSearch(nodeA);

    // Traverse tree with callbacks.
    breadthFirstSearch(nodeA, {
      enterNode: enterNodeCallback,
      leaveNode: leaveNodeCallback,
    });

    expect(enterNodeCallback).toHaveBeenCalledTimes(7);
    expect(leaveNodeCallback).toHaveBeenCalledTimes(7);

    // Check node entering.
    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('B');
    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('C');
    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('D');
    expect(enterNodeCallback.mock.calls[4][0].value).toEqual('E');
    expect(enterNodeCallback.mock.calls[5][0].value).toEqual('F');
    expect(enterNodeCallback.mock.calls[6][0].value).toEqual('G');

    // Check node leaving.
    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('A');
    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('B');
    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('C');
    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('D');
    expect(leaveNodeCallback.mock.calls[4][0].value).toEqual('E');
    expect(leaveNodeCallback.mock.calls[5][0].value).toEqual('F');
    expect(leaveNodeCallback.mock.calls[6][0].value).toEqual('G');
  })",snuts
/src/algorithms/tree/breadth-first-search/__test__/breadthFirstSearch.test.js,VerboseStatement,"{'startLine':55,'endLine':101}","it('allow users to redefine node visiting logic', () => {
    const nodeA = new BinaryTreeNode('A');
    const nodeB = new BinaryTreeNode('B');
    const nodeC = new BinaryTreeNode('C');
    const nodeD = new BinaryTreeNode('D');
    const nodeE = new BinaryTreeNode('E');
    const nodeF = new BinaryTreeNode('F');
    const nodeG = new BinaryTreeNode('G');

    nodeA.setLeft(nodeB).setRight(nodeC);
    nodeB.setLeft(nodeD).setRight(nodeE);
    nodeC.setLeft(nodeF).setRight(nodeG);

    // In-order traversing.
    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');

    const enterNodeCallback = jest.fn();
    const leaveNodeCallback = jest.fn();

    // Traverse tree without callbacks first to check default ones.
    breadthFirstSearch(nodeA);

    // Traverse tree with callbacks.
    breadthFirstSearch(nodeA, {
      allowTraversal: (node, child) => {
        // Forbid traversing left half of the tree.
        return child.value !== 'B';
      },
      enterNode: enterNodeCallback,
      leaveNode: leaveNodeCallback,
    });

    expect(enterNodeCallback).toHaveBeenCalledTimes(4);
    expect(leaveNodeCallback).toHaveBeenCalledTimes(4);

    // Check node entering.
    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('C');
    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('F');
    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('G');

    // Check node leaving.
    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('A');
    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('C');
    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('F');
    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('G');
  })",snuts
/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js,SubOptimalAssert,"{'startLine':6,'endLine':6}","it('should not hae solution for 3 queens', () => {
    const solutions = nQueens(3);
    expect(solutions.length).toBe(0);
  })",snuts
/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js,SubOptimalAssert,"{'startLine':11,'endLine':11}","it('should solve n-queens problem for 4 queens', () => {
    const solutions = nQueens(4);
    expect(solutions.length).toBe(2);

    // First solution.
    expect(solutions[0][0].toString()).toBe('0,1');
    expect(solutions[0][1].toString()).toBe('1,3');
    expect(solutions[0][2].toString()).toBe('2,0');
    expect(solutions[0][3].toString()).toBe('3,2');

    // Second solution (mirrored).
    expect(solutions[1][0].toString()).toBe('0,2');
    expect(solutions[1][1].toString()).toBe('1,0');
    expect(solutions[1][2].toString()).toBe('2,3');
    expect(solutions[1][3].toString()).toBe('3,1');
  })",snuts
/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js,SubOptimalAssert,"{'startLine':28,'endLine':28}","it('should solve n-queens problem for 6 queens', () => {
    const solutions = nQueens(6);
    expect(solutions.length).toBe(4);

    // First solution.
    expect(solutions[0][0].toString()).toBe('0,1');
    expect(solutions[0][1].toString()).toBe('1,3');
    expect(solutions[0][2].toString()).toBe('2,5');
    expect(solutions[0][3].toString()).toBe('3,0');
    expect(solutions[0][4].toString()).toBe('4,2');
    expect(solutions[0][5].toString()).toBe('5,4');
  })",snuts
/src/algorithms/uncategorized/hanoi-tower/__test__/hanoiTower.test.js,VerboseStatement,"{'startLine':5,'endLine':37}","it('should solve tower of hanoi puzzle with 2 discs', () => {
    const moveCallback = jest.fn();
    const numberOfDiscs = 2;

    const fromPole = new Stack();
    const withPole = new Stack();
    const toPole = new Stack();

    hanoiTower({
      numberOfDiscs,
      moveCallback,
      fromPole,
      withPole,
      toPole,
    });

    expect(moveCallback).toHaveBeenCalledTimes((2 ** numberOfDiscs) - 1);

    expect(fromPole.toArray()).toEqual([]);
    expect(toPole.toArray()).toEqual([1, 2]);

    expect(moveCallback.mock.calls[0][0]).toBe(1);
    expect(moveCallback.mock.calls[0][1]).toEqual([1, 2]);
    expect(moveCallback.mock.calls[0][2]).toEqual([]);

    expect(moveCallback.mock.calls[1][0]).toBe(2);
    expect(moveCallback.mock.calls[1][1]).toEqual([2]);
    expect(moveCallback.mock.calls[1][2]).toEqual([]);

    expect(moveCallback.mock.calls[2][0]).toBe(1);
    expect(moveCallback.mock.calls[2][1]).toEqual([1]);
    expect(moveCallback.mock.calls[2][2]).toEqual([2]);
  })",snuts
/src/algorithms/uncategorized/knight-tour/__test__/knightTour.test.js,SubOptimalAssert,"{'startLine':7,'endLine':7}","it('should not find solution on 3x3 board', () => {
    const moves = knightTour(3);

    expect(moves.length).toBe(0);
  })",snuts
/src/algorithms/uncategorized/knight-tour/__test__/knightTour.test.js,SubOptimalAssert,"{'startLine':13,'endLine':13}","it('should find one solution to do knight tour on 5x5 board', () => {
    const moves = knightTour(5);

    expect(moves.length).toBe(25);

    expect(moves).toEqual([
      [0, 0],
      [1, 2],
      [2, 0],
      [0, 1],
      [1, 3],
      [3, 4],
      [2, 2],
      [4, 1],
      [3, 3],
      [1, 4],
      [0, 2],
      [1, 0],
      [3, 1],
      [4, 3],
      [2, 4],
      [0, 3],
      [1, 1],
      [3, 0],
      [4, 2],
      [2, 1],
      [4, 0],
      [3, 2],
      [4, 4],
      [2, 3],
      [0, 4],
    ]);
  })",snuts
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,VerboseStatement,"{'startLine':4,'endLine':47}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",snuts
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,VerboseStatement,"{'startLine':4,'endLine':47}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",snuts
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,VerboseStatement,"{'startLine':4,'endLine':47}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",snuts
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,VerboseStatement,"{'startLine':4,'endLine':47}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",snuts
/src/algorithms/string/regular-expression-matching/__test__/regularExpressionMatching.test.js,VerboseStatement,"{'startLine':4,'endLine':33}","it('should match regular expressions in a string', () => {
    expect(regularExpressionMatching('', '')).toBe(true);
    expect(regularExpressionMatching('a', 'a')).toBe(true);
    expect(regularExpressionMatching('aa', 'aa')).toBe(true);
    expect(regularExpressionMatching('aab', 'aab')).toBe(true);
    expect(regularExpressionMatching('aab', 'aa.')).toBe(true);
    expect(regularExpressionMatching('aab', '.a.')).toBe(true);
    expect(regularExpressionMatching('aab', '...')).toBe(true);
    expect(regularExpressionMatching('a', 'a*')).toBe(true);
    expect(regularExpressionMatching('aaa', 'a*')).toBe(true);
    expect(regularExpressionMatching('aaab', 'a*b')).toBe(true);
    expect(regularExpressionMatching('aaabb', 'a*b*')).toBe(true);
    expect(regularExpressionMatching('aaabb', 'a*b*c*')).toBe(true);
    expect(regularExpressionMatching('', 'a*')).toBe(true);
    expect(regularExpressionMatching('xaabyc', 'xa*b.c')).toBe(true);
    expect(regularExpressionMatching('aab', 'c*a*b*')).toBe(true);
    expect(regularExpressionMatching('mississippi', 'mis*is*.p*.')).toBe(true);
    expect(regularExpressionMatching('ab', '.*')).toBe(true);

    expect(regularExpressionMatching('', 'a')).toBe(false);
    expect(regularExpressionMatching('a', '')).toBe(false);
    expect(regularExpressionMatching('aab', 'aa')).toBe(false);
    expect(regularExpressionMatching('aab', 'baa')).toBe(false);
    expect(regularExpressionMatching('aabc', '...')).toBe(false);
    expect(regularExpressionMatching('aaabbdd', 'a*b*c*')).toBe(false);
    expect(regularExpressionMatching('mississippi', 'mis*is*p*.')).toBe(false);
    expect(regularExpressionMatching('ab', 'a*')).toBe(false);
    expect(regularExpressionMatching('abba', 'a*b*.c')).toBe(false);
    expect(regularExpressionMatching('abba', '.*c')).toBe(false);
  })",snuts
/src/algorithms/string/levenshtein-distance/__test__/levenshteinDistance.test.js,OvercommentedTest,"{'startLine':4,'endLine':28}","it('should calculate edit distance between two strings', () => {
    expect(levenshteinDistance('', '')).toBe(0);
    expect(levenshteinDistance('a', '')).toBe(1);
    expect(levenshteinDistance('', 'a')).toBe(1);
    expect(levenshteinDistance('abc', '')).toBe(3);
    expect(levenshteinDistance('', 'abc')).toBe(3);

    // Should just add I to the beginning.
    expect(levenshteinDistance('islander', 'slander')).toBe(1);

    // Needs to substitute M by K, T by M and add an A to the end
    expect(levenshteinDistance('mart', 'karma')).toBe(3);

    // Substitute K by S, E by I and insert G at the end.
    expect(levenshteinDistance('kitten', 'sitting')).toBe(3);

    // Should add 4 letters FOOT at the beginning.
    expect(levenshteinDistance('ball', 'football')).toBe(4);

    // Should delete 4 letters FOOT at the beginning.
    expect(levenshteinDistance('football', 'foot')).toBe(4);

    // Needs to substitute the first 5 chars: INTEN by EXECU
    expect(levenshteinDistance('intention', 'execution')).toBe(5);
  })",snuts
/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js,OvercommentedTest,"{'startLine':27,'endLine':63}","it('should correctly do random selection based on wights', () => {
    // Number of times we're going to select the random items based on their weights.
    const ATTEMPTS_NUM = 1000;
    // The +/- delta in the number of times each item has been actually selected.
    // I.e. if we want the item 'a' to be selected 300 times out of 1000 cases (30%)
    // then 267 times is acceptable since it is bigger that 250 (which is 300 - 50)
    // ans smaller than 350 (which is 300 + 50)
    const THRESHOLD = 50;

    const items = ['a', 'b', 'c']; // The actual items values don't matter.
    const weights = [0.1, 0.3, 0.6];

    const counter = [];
    for (let i = 0; i < ATTEMPTS_NUM; i += 1) {
      const randomItem = weightedRandom(items, weights);
      if (!counter[randomItem.index]) {
        counter[randomItem.index] = 1;
      } else {
        counter[randomItem.index] += 1;
      }
    }

    for (let itemIndex = 0; itemIndex < items.length; itemIndex += 1) {
      /*
        i.e. item with the index of 0 must be selected 100 times (ideally)
        or with the threshold of [100 - 50, 100 + 50] times.

        i.e. item with the index of 1 must be selected 300 times (ideally)
        or with the threshold of [300 - 50, 300 + 50] times.

        i.e. item with the index of 2 must be selected 600 times (ideally)
        or with the threshold of [600 - 50, 600 + 50] times.
       */
      expect(counter[itemIndex]).toBeGreaterThan(ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD);
      expect(counter[itemIndex]).toBeLessThan(ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD);
    }
  })",snuts
/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js,ConditionalTestLogic,"{'startLine':42,'endLine':46}","it('should correctly do random selection based on wights', () => {
    // Number of times we're going to select the random items based on their weights.
    const ATTEMPTS_NUM = 1000;
    // The +/- delta in the number of times each item has been actually selected.
    // I.e. if we want the item 'a' to be selected 300 times out of 1000 cases (30%)
    // then 267 times is acceptable since it is bigger that 250 (which is 300 - 50)
    // ans smaller than 350 (which is 300 + 50)
    const THRESHOLD = 50;

    const items = ['a', 'b', 'c']; // The actual items values don't matter.
    const weights = [0.1, 0.3, 0.6];

    const counter = [];
    for (let i = 0; i < ATTEMPTS_NUM; i += 1) {
      const randomItem = weightedRandom(items, weights);
      if (!counter[randomItem.index]) {
        counter[randomItem.index] = 1;
      } else {
        counter[randomItem.index] += 1;
      }
    }

    for (let itemIndex = 0; itemIndex < items.length; itemIndex += 1) {
      /*
        i.e. item with the index of 0 must be selected 100 times (ideally)
        or with the threshold of [100 - 50, 100 + 50] times.

        i.e. item with the index of 1 must be selected 300 times (ideally)
        or with the threshold of [300 - 50, 300 + 50] times.

        i.e. item with the index of 2 must be selected 600 times (ideally)
        or with the threshold of [600 - 50, 600 + 50] times.
       */
      expect(counter[itemIndex]).toBeGreaterThan(ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD);
      expect(counter[itemIndex]).toBeLessThan(ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD);
    }
  })",snuts
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,ConditionalTestLogic,"{'startLine':29,'endLine':29}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(jumpSearch([], { key: 1 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(jumpSearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",snuts
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,VerboseStatement,"{'startLine':4,'endLine':19}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",snuts
/src/algorithms/search/linear-search/__test__/linearSearch.test.js,ConditionalTestLogic,"{'startLine':22,'endLine':24}","it('should search through objects as well', () => {
    const comparatorCallback = (a, b) => {
      if (a.key === b.key) {
        return 0;
      }

      return a.key <= b.key ? -1 : 1;
    };

    const array = [
      { key: 5 },
      { key: 6 },
      { key: 7 },
      { key: 6 },
    ];

    expect(linearSearch(array, { key: 10 }, comparatorCallback)).toEqual([]);
    expect(linearSearch(array, { key: 5 }, comparatorCallback)).toEqual([0]);
    expect(linearSearch(array, { key: 6 }, comparatorCallback)).toEqual([1, 3]);
  })",snuts
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,VerboseStatement,"{'startLine':4,'endLine':23}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",snuts
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,ConditionalTestLogic,"{'startLine':24,'endLine':24}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(binarySearch([], { key: 1 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(binarySearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(binarySearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",snuts
/src/algorithms/ml/knn/__test__/knn.test.js,IdenticalTestDescription,"{'startLine':24,'endLine':29}","it('should throw an error on not giving classification vector', () => {
    const inconsistent = () => {
      kNN([[1, 1]], [1], [1]);
    };
    expect(inconsistent).toThrowError('Matrices have different shapes');
  })",snuts
/src/algorithms/ml/knn/__test__/knn.test.js,VerboseStatement,"{'startLine':31,'endLine':54}","it('should find the nearest neighbour', () => {
    let dataSet;
    let labels;
    let toClassify;
    let expectedClass;

    dataSet = [[1, 1], [2, 2]];
    labels = [1, 2];
    toClassify = [1, 1];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 2;
    expect(kNN(dataSet, labels, toClassify, 5)).toBe(expectedClass);
  })",snuts
/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js,SubOptimalAssert,"{'startLine':12,'endLine':12}","it('should permutate string', () => {
    const permutations1 = permutateWithoutRepetitions(['A']);
    expect(permutations1).toEqual([
      ['A'],
    ]);

    const permutations2 = permutateWithoutRepetitions(['A', 'B']);
    expect(permutations2.length).toBe(2);
    expect(permutations2).toEqual([
      ['A', 'B'],
      ['B', 'A'],
    ]);

    const permutations6 = permutateWithoutRepetitions(['A', 'A']);
    expect(permutations6.length).toBe(2);
    expect(permutations6).toEqual([
      ['A', 'A'],
      ['A', 'A'],
    ]);

    const permutations3 = permutateWithoutRepetitions(['A', 'B', 'C']);
    expect(permutations3.length).toBe(factorial(3));
    expect(permutations3).toEqual([
      ['A', 'B', 'C'],
      ['B', 'A', 'C'],
      ['B', 'C', 'A'],
      ['A', 'C', 'B'],
      ['C', 'A', 'B'],
      ['C', 'B', 'A'],
    ]);

    const permutations4 = permutateWithoutRepetitions(['A', 'B', 'C', 'D']);
    expect(permutations4.length).toBe(factorial(4));
    expect(permutations4).toEqual([
      ['A', 'B', 'C', 'D'],
      ['B', 'A', 'C', 'D'],
      ['B', 'C', 'A', 'D'],
      ['B', 'C', 'D', 'A'],
      ['A', 'C', 'B', 'D'],
      ['C', 'A', 'B', 'D'],
      ['C', 'B', 'A', 'D'],
      ['C', 'B', 'D', 'A'],
      ['A', 'C', 'D', 'B'],
      ['C', 'A', 'D', 'B'],
      ['C', 'D', 'A', 'B'],
      ['C', 'D', 'B', 'A'],
      ['A', 'B', 'D', 'C'],
      ['B', 'A', 'D', 'C'],
      ['B', 'D', 'A', 'C'],
      ['B', 'D', 'C', 'A'],
      ['A', 'D', 'B', 'C'],
      ['D', 'A', 'B', 'C'],
      ['D', 'B', 'A', 'C'],
      ['D', 'B', 'C', 'A'],
      ['A', 'D', 'C', 'B'],
      ['D', 'A', 'C', 'B'],
      ['D', 'C', 'A', 'B'],
      ['D', 'C', 'B', 'A'],
    ]);

    const permutations5 = permutateWithoutRepetitions(['A', 'B', 'C', 'D', 'E', 'F']);
    expect(permutations5.length).toBe(factorial(6));
  })",snuts
/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js,SubOptimalAssert,"{'startLine':19,'endLine':19}","it('should permutate string', () => {
    const permutations1 = permutateWithoutRepetitions(['A']);
    expect(permutations1).toEqual([
      ['A'],
    ]);

    const permutations2 = permutateWithoutRepetitions(['A', 'B']);
    expect(permutations2.length).toBe(2);
    expect(permutations2).toEqual([
      ['A', 'B'],
      ['B', 'A'],
    ]);

    const permutations6 = permutateWithoutRepetitions(['A', 'A']);
    expect(permutations6.length).toBe(2);
    expect(permutations6).toEqual([
      ['A', 'A'],
      ['A', 'A'],
    ]);

    const permutations3 = permutateWithoutRepetitions(['A', 'B', 'C']);
    expect(permutations3.length).toBe(factorial(3));
    expect(permutations3).toEqual([
      ['A', 'B', 'C'],
      ['B', 'A', 'C'],
      ['B', 'C', 'A'],
      ['A', 'C', 'B'],
      ['C', 'A', 'B'],
      ['C', 'B', 'A'],
    ]);

    const permutations4 = permutateWithoutRepetitions(['A', 'B', 'C', 'D']);
    expect(permutations4.length).toBe(factorial(4));
    expect(permutations4).toEqual([
      ['A', 'B', 'C', 'D'],
      ['B', 'A', 'C', 'D'],
      ['B', 'C', 'A', 'D'],
      ['B', 'C', 'D', 'A'],
      ['A', 'C', 'B', 'D'],
      ['C', 'A', 'B', 'D'],
      ['C', 'B', 'A', 'D'],
      ['C', 'B', 'D', 'A'],
      ['A', 'C', 'D', 'B'],
      ['C', 'A', 'D', 'B'],
      ['C', 'D', 'A', 'B'],
      ['C', 'D', 'B', 'A'],
      ['A', 'B', 'D', 'C'],
      ['B', 'A', 'D', 'C'],
      ['B', 'D', 'A', 'C'],
      ['B', 'D', 'C', 'A'],
      ['A', 'D', 'B', 'C'],
      ['D', 'A', 'B', 'C'],
      ['D', 'B', 'A', 'C'],
      ['D', 'B', 'C', 'A'],
      ['A', 'D', 'C', 'B'],
      ['D', 'A', 'C', 'B'],
      ['D', 'C', 'A', 'B'],
      ['D', 'C', 'B', 'A'],
    ]);

    const permutations5 = permutateWithoutRepetitions(['A', 'B', 'C', 'D', 'E', 'F']);
    expect(permutations5.length).toBe(factorial(6));
  })",snuts
/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js,SubOptimalAssert,"{'startLine':26,'endLine':26}","it('should permutate string', () => {
    const permutations1 = permutateWithoutRepetitions(['A']);
    expect(permutations1).toEqual([
      ['A'],
    ]);

    const permutations2 = permutateWithoutRepetitions(['A', 'B']);
    expect(permutations2.length).toBe(2);
    expect(permutations2).toEqual([
      ['A', 'B'],
      ['B', 'A'],
    ]);

    const permutations6 = permutateWithoutRepetitions(['A', 'A']);
    expect(permutations6.length).toBe(2);
    expect(permutations6).toEqual([
      ['A', 'A'],
      ['A', 'A'],
    ]);

    const permutations3 = permutateWithoutRepetitions(['A', 'B', 'C']);
    expect(permutations3.length).toBe(factorial(3));
    expect(permutations3).toEqual([
      ['A', 'B', 'C'],
      ['B', 'A', 'C'],
      ['B', 'C', 'A'],
      ['A', 'C', 'B'],
      ['C', 'A', 'B'],
      ['C', 'B', 'A'],
    ]);

    const permutations4 = permutateWithoutRepetitions(['A', 'B', 'C', 'D']);
    expect(permutations4.length).toBe(factorial(4));
    expect(permutations4).toEqual([
      ['A', 'B', 'C', 'D'],
      ['B', 'A', 'C', 'D'],
      ['B', 'C', 'A', 'D'],
      ['B', 'C', 'D', 'A'],
      ['A', 'C', 'B', 'D'],
      ['C', 'A', 'B', 'D'],
      ['C', 'B', 'A', 'D'],
      ['C', 'B', 'D', 'A'],
      ['A', 'C', 'D', 'B'],
      ['C', 'A', 'D', 'B'],
      ['C', 'D', 'A', 'B'],
      ['C', 'D', 'B', 'A'],
      ['A', 'B', 'D', 'C'],
      ['B', 'A', 'D', 'C'],
      ['B', 'D', 'A', 'C'],
      ['B', 'D', 'C', 'A'],
      ['A', 'D', 'B', 'C'],
      ['D', 'A', 'B', 'C'],
      ['D', 'B', 'A', 'C'],
      ['D', 'B', 'C', 'A'],
      ['A', 'D', 'C', 'B'],
      ['D', 'A', 'C', 'B'],
      ['D', 'C', 'A', 'B'],
      ['D', 'C', 'B', 'A'],
    ]);

    const permutations5 = permutateWithoutRepetitions(['A', 'B', 'C', 'D', 'E', 'F']);
    expect(permutations5.length).toBe(factorial(6));
  })",snuts
/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js,SubOptimalAssert,"{'startLine':37,'endLine':37}","it('should permutate string', () => {
    const permutations1 = permutateWithoutRepetitions(['A']);
    expect(permutations1).toEqual([
      ['A'],
    ]);

    const permutations2 = permutateWithoutRepetitions(['A', 'B']);
    expect(permutations2.length).toBe(2);
    expect(permutations2).toEqual([
      ['A', 'B'],
      ['B', 'A'],
    ]);

    const permutations6 = permutateWithoutRepetitions(['A', 'A']);
    expect(permutations6.length).toBe(2);
    expect(permutations6).toEqual([
      ['A', 'A'],
      ['A', 'A'],
    ]);

    const permutations3 = permutateWithoutRepetitions(['A', 'B', 'C']);
    expect(permutations3.length).toBe(factorial(3));
    expect(permutations3).toEqual([
      ['A', 'B', 'C'],
      ['B', 'A', 'C'],
      ['B', 'C', 'A'],
      ['A', 'C', 'B'],
      ['C', 'A', 'B'],
      ['C', 'B', 'A'],
    ]);

    const permutations4 = permutateWithoutRepetitions(['A', 'B', 'C', 'D']);
    expect(permutations4.length).toBe(factorial(4));
    expect(permutations4).toEqual([
      ['A', 'B', 'C', 'D'],
      ['B', 'A', 'C', 'D'],
      ['B', 'C', 'A', 'D'],
      ['B', 'C', 'D', 'A'],
      ['A', 'C', 'B', 'D'],
      ['C', 'A', 'B', 'D'],
      ['C', 'B', 'A', 'D'],
      ['C', 'B', 'D', 'A'],
      ['A', 'C', 'D', 'B'],
      ['C', 'A', 'D', 'B'],
      ['C', 'D', 'A', 'B'],
      ['C', 'D', 'B', 'A'],
      ['A', 'B', 'D', 'C'],
      ['B', 'A', 'D', 'C'],
      ['B', 'D', 'A', 'C'],
      ['B', 'D', 'C', 'A'],
      ['A', 'D', 'B', 'C'],
      ['D', 'A', 'B', 'C'],
      ['D', 'B', 'A', 'C'],
      ['D', 'B', 'C', 'A'],
      ['A', 'D', 'C', 'B'],
      ['D', 'A', 'C', 'B'],
      ['D', 'C', 'A', 'B'],
      ['D', 'C', 'B', 'A'],
    ]);

    const permutations5 = permutateWithoutRepetitions(['A', 'B', 'C', 'D', 'E', 'F']);
    expect(permutations5.length).toBe(factorial(6));
  })",snuts
/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js,SubOptimalAssert,"{'startLine':66,'endLine':66}","it('should permutate string', () => {
    const permutations1 = permutateWithoutRepetitions(['A']);
    expect(permutations1).toEqual([
      ['A'],
    ]);

    const permutations2 = permutateWithoutRepetitions(['A', 'B']);
    expect(permutations2.length).toBe(2);
    expect(permutations2).toEqual([
      ['A', 'B'],
      ['B', 'A'],
    ]);

    const permutations6 = permutateWithoutRepetitions(['A', 'A']);
    expect(permutations6.length).toBe(2);
    expect(permutations6).toEqual([
      ['A', 'A'],
      ['A', 'A'],
    ]);

    const permutations3 = permutateWithoutRepetitions(['A', 'B', 'C']);
    expect(permutations3.length).toBe(factorial(3));
    expect(permutations3).toEqual([
      ['A', 'B', 'C'],
      ['B', 'A', 'C'],
      ['B', 'C', 'A'],
      ['A', 'C', 'B'],
      ['C', 'A', 'B'],
      ['C', 'B', 'A'],
    ]);

    const permutations4 = permutateWithoutRepetitions(['A', 'B', 'C', 'D']);
    expect(permutations4.length).toBe(factorial(4));
    expect(permutations4).toEqual([
      ['A', 'B', 'C', 'D'],
      ['B', 'A', 'C', 'D'],
      ['B', 'C', 'A', 'D'],
      ['B', 'C', 'D', 'A'],
      ['A', 'C', 'B', 'D'],
      ['C', 'A', 'B', 'D'],
      ['C', 'B', 'A', 'D'],
      ['C', 'B', 'D', 'A'],
      ['A', 'C', 'D', 'B'],
      ['C', 'A', 'D', 'B'],
      ['C', 'D', 'A', 'B'],
      ['C', 'D', 'B', 'A'],
      ['A', 'B', 'D', 'C'],
      ['B', 'A', 'D', 'C'],
      ['B', 'D', 'A', 'C'],
      ['B', 'D', 'C', 'A'],
      ['A', 'D', 'B', 'C'],
      ['D', 'A', 'B', 'C'],
      ['D', 'B', 'A', 'C'],
      ['D', 'B', 'C', 'A'],
      ['A', 'D', 'C', 'B'],
      ['D', 'A', 'C', 'B'],
      ['D', 'C', 'A', 'B'],
      ['D', 'C', 'B', 'A'],
    ]);

    const permutations5 = permutateWithoutRepetitions(['A', 'B', 'C', 'D', 'E', 'F']);
    expect(permutations5.length).toBe(factorial(6));
  })",snuts
/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js,VerboseStatement,"{'startLine':5,'endLine':67}","it('should permutate string', () => {
    const permutations1 = permutateWithoutRepetitions(['A']);
    expect(permutations1).toEqual([
      ['A'],
    ]);

    const permutations2 = permutateWithoutRepetitions(['A', 'B']);
    expect(permutations2.length).toBe(2);
    expect(permutations2).toEqual([
      ['A', 'B'],
      ['B', 'A'],
    ]);

    const permutations6 = permutateWithoutRepetitions(['A', 'A']);
    expect(permutations6.length).toBe(2);
    expect(permutations6).toEqual([
      ['A', 'A'],
      ['A', 'A'],
    ]);

    const permutations3 = permutateWithoutRepetitions(['A', 'B', 'C']);
    expect(permutations3.length).toBe(factorial(3));
    expect(permutations3).toEqual([
      ['A', 'B', 'C'],
      ['B', 'A', 'C'],
      ['B', 'C', 'A'],
      ['A', 'C', 'B'],
      ['C', 'A', 'B'],
      ['C', 'B', 'A'],
    ]);

    const permutations4 = permutateWithoutRepetitions(['A', 'B', 'C', 'D']);
    expect(permutations4.length).toBe(factorial(4));
    expect(permutations4).toEqual([
      ['A', 'B', 'C', 'D'],
      ['B', 'A', 'C', 'D'],
      ['B', 'C', 'A', 'D'],
      ['B', 'C', 'D', 'A'],
      ['A', 'C', 'B', 'D'],
      ['C', 'A', 'B', 'D'],
      ['C', 'B', 'A', 'D'],
      ['C', 'B', 'D', 'A'],
      ['A', 'C', 'D', 'B'],
      ['C', 'A', 'D', 'B'],
      ['C', 'D', 'A', 'B'],
      ['C', 'D', 'B', 'A'],
      ['A', 'B', 'D', 'C'],
      ['B', 'A', 'D', 'C'],
      ['B', 'D', 'A', 'C'],
      ['B', 'D', 'C', 'A'],
      ['A', 'D', 'B', 'C'],
      ['D', 'A', 'B', 'C'],
      ['D', 'B', 'A', 'C'],
      ['D', 'B', 'C', 'A'],
      ['A', 'D', 'C', 'B'],
      ['D', 'A', 'C', 'B'],
      ['D', 'C', 'A', 'B'],
      ['D', 'C', 'B', 'A'],
    ]);

    const permutations5 = permutateWithoutRepetitions(['A', 'B', 'C', 'D', 'E', 'F']);
    expect(permutations5.length).toBe(factorial(6));
  })",snuts
/src/algorithms/sets/permutations/__test__/permutateWithRepetitions.test.js,SubOptimalAssert,"{'startLine':50,'endLine':50}","it('should permutate string with repetition', () => {
    const permutations1 = permutateWithRepetitions(['A']);
    expect(permutations1).toEqual([
      ['A'],
    ]);

    const permutations2 = permutateWithRepetitions(['A', 'B']);
    expect(permutations2).toEqual([
      ['A', 'A'],
      ['A', 'B'],
      ['B', 'A'],
      ['B', 'B'],
    ]);

    const permutations3 = permutateWithRepetitions(['A', 'B', 'C']);
    expect(permutations3).toEqual([
      ['A', 'A', 'A'],
      ['A', 'A', 'B'],
      ['A', 'A', 'C'],
      ['A', 'B', 'A'],
      ['A', 'B', 'B'],
      ['A', 'B', 'C'],
      ['A', 'C', 'A'],
      ['A', 'C', 'B'],
      ['A', 'C', 'C'],
      ['B', 'A', 'A'],
      ['B', 'A', 'B'],
      ['B', 'A', 'C'],
      ['B', 'B', 'A'],
      ['B', 'B', 'B'],
      ['B', 'B', 'C'],
      ['B', 'C', 'A'],
      ['B', 'C', 'B'],
      ['B', 'C', 'C'],
      ['C', 'A', 'A'],
      ['C', 'A', 'B'],
      ['C', 'A', 'C'],
      ['C', 'B', 'A'],
      ['C', 'B', 'B'],
      ['C', 'B', 'C'],
      ['C', 'C', 'A'],
      ['C', 'C', 'B'],
      ['C', 'C', 'C'],
    ]);

    const permutations4 = permutateWithRepetitions(['A', 'B', 'C', 'D']);
    expect(permutations4.length).toBe(4 * 4 * 4 * 4);
  })",snuts
/src/algorithms/sets/longest-increasing-subsequence/__test__/dpLongestIncreasingSubsequence.test.js,OvercommentedTest,"{'startLine':4,'endLine':35}","it('should find longest increasing subsequence length', () => {
    // Should be:
    // 9 or
    // 8 or
    // 7 or
    // 6 or
    // ...
    expect(dpLongestIncreasingSubsequence([
      9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
    ])).toBe(1);

    // Should be:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
    expect(dpLongestIncreasingSubsequence([
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    ])).toBe(10);

    // Should be:
    // -1, 0, 2, 3
    expect(dpLongestIncreasingSubsequence([
      3, 4, -1, 0, 6, 2, 3,
    ])).toBe(4);

    // Should be:
    // 0, 2, 6, 9, 11, 15 or
    // 0, 4, 6, 9, 11, 15 or
    // 0, 2, 6, 9, 13, 15 or
    // 0, 4, 6, 9, 13, 15
    expect(dpLongestIncreasingSubsequence([
      0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15,
    ])).toBe(6);
  })",snuts
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,VerboseStatement,"{'startLine':4,'endLine':34}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",snuts
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,SubOptimalAssert,"{'startLine':21,'endLine':21}","it('should solve 0/1 knapsack problem', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 3 }),
      new KnapsackItem({ value: 5, weight: 4 }),
      new KnapsackItem({ value: 7, weight: 5 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(9);
    expect(knapsack.totalWeight).toBe(7);
    expect(knapsack.selectedItems.length).toBe(2);
    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
  })",snuts
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,SubOptimalAssert,"{'startLine':42,'endLine':42}","it('should solve 0/1 knapsack problem regardless of items order', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 4 }),
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 7, weight: 5 }),
      new KnapsackItem({ value: 4, weight: 3 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(9);
    expect(knapsack.totalWeight).toBe(7);
    expect(knapsack.selectedItems.length).toBe(2);
    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
  })",snuts
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,SubOptimalAssert,"{'startLine':63,'endLine':63}","it('should solve 0/1 knapsack problem with impossible items set', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 40 }),
      new KnapsackItem({ value: 1, weight: 10 }),
      new KnapsackItem({ value: 7, weight: 50 }),
      new KnapsackItem({ value: 4, weight: 30 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(0);
    expect(knapsack.totalWeight).toBe(0);
    expect(knapsack.selectedItems.length).toBe(0);
  })",snuts
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,SubOptimalAssert,"{'startLine':84,'endLine':84}","it('should solve 0/1 knapsack problem with all equal weights', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 1 }),
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 7, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
    ];

    const maxKnapsackWeight = 3;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(16);
    expect(knapsack.totalWeight).toBe(3);
    expect(knapsack.selectedItems.length).toBe(3);
    expect(knapsack.selectedItems[0].toString()).toBe('v4 w1 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v5 w1 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v7 w1 x 1');
  })",snuts
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,SubOptimalAssert,"{'startLine':107,'endLine':107}","it('should solve unbound knapsack problem', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 84, weight: 7 }), // v/w ratio is 12
      new KnapsackItem({ value: 5, weight: 2 }), // v/w ratio is 2.5
      new KnapsackItem({ value: 12, weight: 3 }), // v/w ratio is 4
      new KnapsackItem({ value: 10, weight: 1 }), // v/w ratio is 10
      new KnapsackItem({ value: 20, weight: 2 }), // v/w ratio is 10
    ];

    const maxKnapsackWeight = 15;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveUnboundedKnapsackProblem();

    expect(knapsack.totalValue).toBe(84 + 20 + 12 + 10 + 5);
    expect(knapsack.totalWeight).toBe(15);
    expect(knapsack.selectedItems.length).toBe(5);
    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 1');
    expect(knapsack.selectedItems[3].toString()).toBe('v12 w3 x 1');
    expect(knapsack.selectedItems[4].toString()).toBe('v5 w2 x 1');
  })",snuts
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,SubOptimalAssert,"{'startLine':132,'endLine':132}","it('should solve unbound knapsack problem with items in stock', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 84, weight: 7, itemsInStock: 3 }), // v/w ratio is 12
      new KnapsackItem({ value: 5, weight: 2, itemsInStock: 2 }), // v/w ratio is 2.5
      new KnapsackItem({ value: 12, weight: 3, itemsInStock: 1 }), // v/w ratio is 4
      new KnapsackItem({ value: 10, weight: 1, itemsInStock: 6 }), // v/w ratio is 10
      new KnapsackItem({ value: 20, weight: 2, itemsInStock: 8 }), // v/w ratio is 10
    ];

    const maxKnapsackWeight = 17;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveUnboundedKnapsackProblem();

    expect(knapsack.totalValue).toBe(84 + 84 + 20 + 10);
    expect(knapsack.totalWeight).toBe(17);
    expect(knapsack.selectedItems.length).toBe(3);
    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 2');
    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 1');
  })",snuts
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,SubOptimalAssert,"{'startLine':155,'endLine':155}","it('should solve unbound knapsack problem with items in stock and max weight more than sum of all items', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 84, weight: 7, itemsInStock: 3 }), // v/w ratio is 12
      new KnapsackItem({ value: 5, weight: 2, itemsInStock: 2 }), // v/w ratio is 2.5
      new KnapsackItem({ value: 12, weight: 3, itemsInStock: 1 }), // v/w ratio is 4
      new KnapsackItem({ value: 10, weight: 1, itemsInStock: 6 }), // v/w ratio is 10
      new KnapsackItem({ value: 20, weight: 2, itemsInStock: 8 }), // v/w ratio is 10
    ];

    const maxKnapsackWeight = 60;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveUnboundedKnapsackProblem();

    expect(knapsack.totalValue).toBe((3 * 84) + (2 * 5) + (1 * 12) + (6 * 10) + (8 * 20));
    expect(knapsack.totalWeight).toBe((3 * 7) + (2 * 2) + (1 * 3) + (6 * 1) + (8 * 2));
    expect(knapsack.selectedItems.length).toBe(5);
    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 3');
    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 8');
    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 6');
    expect(knapsack.selectedItems[3].toString()).toBe('v12 w3 x 1');
    expect(knapsack.selectedItems[4].toString()).toBe('v5 w2 x 2');
  })",snuts
/src/algorithms/sets/fisher-yates/__test__/fisherYates.test.js,SubOptimalAssert,"{'startLine':15,'endLine':15}","it('should shuffle array randomly', () => {
    const shuffledArray = fisherYates(sortedArr);
    const sorter = new QuickSort();

    expect(shuffledArray.length).toBe(sortedArr.length);
    expect(shuffledArray).not.toEqual(sortedArr);
    expect(sorter.sort(shuffledArray)).toEqual(sortedArr);
  })",snuts
/src/algorithms/sets/combinations/__test__/combineWithoutRepetitions.test.js,SubOptimalAssert,"{'startLine':59,'endLine':59}","it('should combine string without repetitions', () => {
    expect(combineWithoutRepetitions(['A', 'B'], 3)).toEqual([]);

    expect(combineWithoutRepetitions(['A', 'B'], 1)).toEqual([
      ['A'],
      ['B'],
    ]);

    expect(combineWithoutRepetitions(['A'], 1)).toEqual([
      ['A'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B'], 2)).toEqual([
      ['A', 'B'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 2)).toEqual([
      ['A', 'B'],
      ['A', 'C'],
      ['B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 3)).toEqual([
      ['A', 'B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'C', 'D'],
      ['B', 'C', 'D'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D', 'E'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'B', 'E'],
      ['A', 'C', 'D'],
      ['A', 'C', 'E'],
      ['A', 'D', 'E'],
      ['B', 'C', 'D'],
      ['B', 'C', 'E'],
      ['B', 'D', 'E'],
      ['C', 'D', 'E'],
    ]);

    const combinationOptions = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
    const combinationSlotsNumber = 4;
    const combinations = combineWithoutRepetitions(combinationOptions, combinationSlotsNumber);
    const n = combinationOptions.length;
    const r = combinationSlotsNumber;
    const expectedNumberOfCombinations = factorial(n) / (factorial(r) * factorial(n - r));

    expect(combinations.length).toBe(expectedNumberOfCombinations);

    // This one is just to see one of the way of Pascal's triangle application.
    expect(combinations.length).toBe(pascalTriangle(n)[r]);
  })",snuts
/src/algorithms/sets/combinations/__test__/combineWithoutRepetitions.test.js,SubOptimalAssert,"{'startLine':62,'endLine':62}","it('should combine string without repetitions', () => {
    expect(combineWithoutRepetitions(['A', 'B'], 3)).toEqual([]);

    expect(combineWithoutRepetitions(['A', 'B'], 1)).toEqual([
      ['A'],
      ['B'],
    ]);

    expect(combineWithoutRepetitions(['A'], 1)).toEqual([
      ['A'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B'], 2)).toEqual([
      ['A', 'B'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 2)).toEqual([
      ['A', 'B'],
      ['A', 'C'],
      ['B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 3)).toEqual([
      ['A', 'B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'C', 'D'],
      ['B', 'C', 'D'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D', 'E'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'B', 'E'],
      ['A', 'C', 'D'],
      ['A', 'C', 'E'],
      ['A', 'D', 'E'],
      ['B', 'C', 'D'],
      ['B', 'C', 'E'],
      ['B', 'D', 'E'],
      ['C', 'D', 'E'],
    ]);

    const combinationOptions = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
    const combinationSlotsNumber = 4;
    const combinations = combineWithoutRepetitions(combinationOptions, combinationSlotsNumber);
    const n = combinationOptions.length;
    const r = combinationSlotsNumber;
    const expectedNumberOfCombinations = factorial(n) / (factorial(r) * factorial(n - r));

    expect(combinations.length).toBe(expectedNumberOfCombinations);

    // This one is just to see one of the way of Pascal's triangle application.
    expect(combinations.length).toBe(pascalTriangle(n)[r]);
  })",snuts
/src/algorithms/sets/combinations/__test__/combineWithoutRepetitions.test.js,VerboseStatement,"{'startLine':6,'endLine':63}","it('should combine string without repetitions', () => {
    expect(combineWithoutRepetitions(['A', 'B'], 3)).toEqual([]);

    expect(combineWithoutRepetitions(['A', 'B'], 1)).toEqual([
      ['A'],
      ['B'],
    ]);

    expect(combineWithoutRepetitions(['A'], 1)).toEqual([
      ['A'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B'], 2)).toEqual([
      ['A', 'B'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 2)).toEqual([
      ['A', 'B'],
      ['A', 'C'],
      ['B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 3)).toEqual([
      ['A', 'B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'C', 'D'],
      ['B', 'C', 'D'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D', 'E'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'B', 'E'],
      ['A', 'C', 'D'],
      ['A', 'C', 'E'],
      ['A', 'D', 'E'],
      ['B', 'C', 'D'],
      ['B', 'C', 'E'],
      ['B', 'D', 'E'],
      ['C', 'D', 'E'],
    ]);

    const combinationOptions = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
    const combinationSlotsNumber = 4;
    const combinations = combineWithoutRepetitions(combinationOptions, combinationSlotsNumber);
    const n = combinationOptions.length;
    const r = combinationSlotsNumber;
    const expectedNumberOfCombinations = factorial(n) / (factorial(r) * factorial(n - r));

    expect(combinations.length).toBe(expectedNumberOfCombinations);

    // This one is just to see one of the way of Pascal's triangle application.
    expect(combinations.length).toBe(pascalTriangle(n)[r]);
  })",snuts
/src/algorithms/sets/combinations/__test__/combineWithRepetitions.test.js,SubOptimalAssert,"{'startLine':57,'endLine':57}","it('should combine string with repetitions', () => {
    expect(combineWithRepetitions(['A'], 1)).toEqual([
      ['A'],
    ]);

    expect(combineWithRepetitions(['A', 'B'], 1)).toEqual([
      ['A'],
      ['B'],
    ]);

    expect(combineWithRepetitions(['A', 'B'], 2)).toEqual([
      ['A', 'A'],
      ['A', 'B'],
      ['B', 'B'],
    ]);

    expect(combineWithRepetitions(['A', 'B'], 3)).toEqual([
      ['A', 'A', 'A'],
      ['A', 'A', 'B'],
      ['A', 'B', 'B'],
      ['B', 'B', 'B'],
    ]);

    expect(combineWithRepetitions(['A', 'B', 'C'], 2)).toEqual([
      ['A', 'A'],
      ['A', 'B'],
      ['A', 'C'],
      ['B', 'B'],
      ['B', 'C'],
      ['C', 'C'],
    ]);

    expect(combineWithRepetitions(['A', 'B', 'C'], 3)).toEqual([
      ['A', 'A', 'A'],
      ['A', 'A', 'B'],
      ['A', 'A', 'C'],
      ['A', 'B', 'B'],
      ['A', 'B', 'C'],
      ['A', 'C', 'C'],
      ['B', 'B', 'B'],
      ['B', 'B', 'C'],
      ['B', 'C', 'C'],
      ['C', 'C', 'C'],
    ]);

    const combinationOptions = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
    const combinationSlotsNumber = 4;
    const combinations = combineWithRepetitions(combinationOptions, combinationSlotsNumber);
    const n = combinationOptions.length;
    const r = combinationSlotsNumber;
    const expectedNumberOfCombinations = factorial((r + n) - 1) / (factorial(r) * factorial(n - 1));

    expect(combinations.length).toBe(expectedNumberOfCombinations);
  })",snuts
/src/algorithms/math/square-root/__test__/squareRoot.test.js,IdenticalTestDescription,"{'startLine':65,'endLine':68}","it('should correctly calculate square root for integers with custom tolerance', () => {
    expect(squareRoot(4.5, 10)).toBe(2.1213203436);
    expect(squareRoot(217.534, 10)).toBe(14.7490338667);
  })",snuts
/src/algorithms/math/square-root/__test__/squareRoot.test.js,VerboseStatement,"{'startLine':24,'endLine':63}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",snuts
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,VerboseStatement,"{'startLine':17,'endLine':37}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",snuts
/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwoBitwise.test.js,VerboseStatement,"{'startLine':4,'endLine':22}","it('should check if the number is made by multiplying twos', () => {
    expect(isPowerOfTwoBitwise(-1)).toBe(false);
    expect(isPowerOfTwoBitwise(0)).toBe(false);
    expect(isPowerOfTwoBitwise(1)).toBe(true);
    expect(isPowerOfTwoBitwise(2)).toBe(true);
    expect(isPowerOfTwoBitwise(3)).toBe(false);
    expect(isPowerOfTwoBitwise(4)).toBe(true);
    expect(isPowerOfTwoBitwise(5)).toBe(false);
    expect(isPowerOfTwoBitwise(6)).toBe(false);
    expect(isPowerOfTwoBitwise(7)).toBe(false);
    expect(isPowerOfTwoBitwise(8)).toBe(true);
    expect(isPowerOfTwoBitwise(10)).toBe(false);
    expect(isPowerOfTwoBitwise(12)).toBe(false);
    expect(isPowerOfTwoBitwise(16)).toBe(true);
    expect(isPowerOfTwoBitwise(31)).toBe(false);
    expect(isPowerOfTwoBitwise(64)).toBe(true);
    expect(isPowerOfTwoBitwise(1024)).toBe(true);
    expect(isPowerOfTwoBitwise(1023)).toBe(false);
  })",snuts
/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwo.test.js,VerboseStatement,"{'startLine':4,'endLine':22}","it('should check if the number is made by multiplying twos', () => {
    expect(isPowerOfTwo(-1)).toBe(false);
    expect(isPowerOfTwo(0)).toBe(false);
    expect(isPowerOfTwo(1)).toBe(true);
    expect(isPowerOfTwo(2)).toBe(true);
    expect(isPowerOfTwo(3)).toBe(false);
    expect(isPowerOfTwo(4)).toBe(true);
    expect(isPowerOfTwo(5)).toBe(false);
    expect(isPowerOfTwo(6)).toBe(false);
    expect(isPowerOfTwo(7)).toBe(false);
    expect(isPowerOfTwo(8)).toBe(true);
    expect(isPowerOfTwo(10)).toBe(false);
    expect(isPowerOfTwo(12)).toBe(false);
    expect(isPowerOfTwo(16)).toBe(true);
    expect(isPowerOfTwo(31)).toBe(false);
    expect(isPowerOfTwo(64)).toBe(true);
    expect(isPowerOfTwo(1024)).toBe(true);
    expect(isPowerOfTwo(1023)).toBe(false);
  })",snuts
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,VerboseStatement,"{'startLine':4,'endLine':22}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",snuts
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,VerboseStatement,"{'startLine':4,'endLine':25}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",snuts
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,VerboseStatement,"{'startLine':4,'endLine':25}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",snuts
/src/algorithms/math/bits/__test__/isPowerOfTwo.test.js,VerboseStatement,"{'startLine':4,'endLine':19}","it('should detect if the number is power of two', () => {
    expect(isPowerOfTwo(1)).toBe(true);
    expect(isPowerOfTwo(2)).toBe(true);
    expect(isPowerOfTwo(3)).toBe(false);
    expect(isPowerOfTwo(4)).toBe(true);
    expect(isPowerOfTwo(5)).toBe(false);
    expect(isPowerOfTwo(6)).toBe(false);
    expect(isPowerOfTwo(7)).toBe(false);
    expect(isPowerOfTwo(8)).toBe(true);
    expect(isPowerOfTwo(9)).toBe(false);
    expect(isPowerOfTwo(16)).toBe(true);
    expect(isPowerOfTwo(23)).toBe(false);
    expect(isPowerOfTwo(32)).toBe(true);
    expect(isPowerOfTwo(127)).toBe(false);
    expect(isPowerOfTwo(128)).toBe(true);
  })",snuts
/src/algorithms/math/bits/__test__/countSetBits.test.js,VerboseStatement,"{'startLine':4,'endLine':19}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",snuts
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,VerboseStatement,"{'startLine':4,'endLine':22}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",snuts
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,VerboseStatement,"{'startLine':130,'endLine':180}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",snuts
/src/algorithms/math/binary-floating-point/__tests__/floatAsBinaryString.test.js,IdenticalTestDescription,"{'startLine':14,'endLine':19}","it('should create a binary representation of the floating numbers', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases64Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases64Bits[testCaseIndex];
      expect(floatAs64BinaryString(decimal)).toBe(binary);
    }
  })",snuts
/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js,IdenticalTestDescription,"{'startLine':15,'endLine':21}","it('should convert floating point binary bits to floating point decimal number', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases32Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases32Bits[testCaseIndex];
      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
      expect(bitsToFloat32(bits)).toBeCloseTo(decimal, 7);
    }
  })",snuts
/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js,IdenticalTestDescription,"{'startLine':25,'endLine':31}","it('should convert floating point binary bits to floating point decimal number', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases64Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases64Bits[testCaseIndex];
      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
      expect(bitsToFloat64(bits)).toBeCloseTo(decimal, 14);
    }
  })",snuts
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,OvercommentedTest,"{'startLine':4,'endLine':42}","it('should calculate new hash based on previous one', () => {
    const bases = [3, 79, 101, 3251, 13229, 122743, 3583213];
    const mods = [79, 101];
    const frameSizes = [5, 20];

    // @TODO: Provide Unicode support.
    const text = 'Lorem Ipsum is simply dummy text of the printing and '
      + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
      + 'galley of type and \u{ffff} scrambled it to make a type specimen book. It '
      + 'electronic  typesetting, remaining essentially unchanged. It was '
      // + 'popularised in the \u{20005} \u{20000}1960s with the release of Letraset sheets '
      + 'publishing software like Aldus PageMaker  including versions of Lorem.';

    // Check hashing for different prime base.
    bases.forEach((base) => {
      mods.forEach((modulus) => {
        const polynomialHash = new PolynomialHash({ base, modulus });

        // Check hashing for different word lengths.
        frameSizes.forEach((frameSize) => {
          let previousWord = text.substr(0, frameSize);
          let previousHash = polynomialHash.hash(previousWord);

          // Shift frame through the whole text.
          for (let frameShift = 1; frameShift < (text.length - frameSize); frameShift += 1) {
            const currentWord = text.substr(frameShift, frameSize);
            const currentHash = polynomialHash.hash(currentWord);
            const currentRollingHash = polynomialHash.roll(previousHash, previousWord, currentWord);

            // Check that rolling hash is the same as directly calculated hash.
            expect(currentRollingHash).toBe(currentHash);

            previousWord = currentWord;
            previousHash = currentHash;
          }
        });
      });
    });
  })",snuts
/src/algorithms/graph/topological-sorting/__test__/topologicalSort.test.js,SubOptimalAssert,"{'startLine':41,'endLine':41}","it('should do topological sorting on graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeDF = new GraphEdge(vertexD, vertexF);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeEH = new GraphEdge(vertexE, vertexH);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCE)
      .addEdge(edgeDF)
      .addEdge(edgeEF)
      .addEdge(edgeEH)
      .addEdge(edgeFG);

    const sortedVertices = topologicalSort(graph);

    expect(sortedVertices).toBeDefined();
    expect(sortedVertices.length).toBe(graph.getAllVertices().length);
    expect(sortedVertices).toEqual([
      vertexB,
      vertexD,
      vertexA,
      vertexC,
      vertexE,
      vertexH,
      vertexF,
      vertexG,
    ]);
  })",snuts
/src/algorithms/graph/topological-sorting/__test__/topologicalSort.test.js,VerboseStatement,"{'startLine':7,'endLine':52}","it('should do topological sorting on graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeDF = new GraphEdge(vertexD, vertexF);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeEH = new GraphEdge(vertexE, vertexH);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCE)
      .addEdge(edgeDF)
      .addEdge(edgeEF)
      .addEdge(edgeEH)
      .addEdge(edgeFG);

    const sortedVertices = topologicalSort(graph);

    expect(sortedVertices).toBeDefined();
    expect(sortedVertices.length).toBe(graph.getAllVertices().length);
    expect(sortedVertices).toEqual([
      vertexB,
      vertexD,
      vertexA,
      vertexC,
      vertexE,
      vertexH,
      vertexF,
      vertexG,
    ]);
  })",snuts
/src/algorithms/graph/travelling-salesman/__test__/bfTravellingSalesman.test.js,SubOptimalAssert,"{'startLine':44,'endLine':44}","it('should solve problem for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 1);
    const edgeDC = new GraphEdge(vertexD, vertexC, 1);
    const edgeCA = new GraphEdge(vertexC, vertexA, 1);

    const edgeBA = new GraphEdge(vertexB, vertexA, 5);
    const edgeDB = new GraphEdge(vertexD, vertexB, 8);
    const edgeCD = new GraphEdge(vertexC, vertexD, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 4);
    const edgeAD = new GraphEdge(vertexA, vertexD, 2);
    const edgeDA = new GraphEdge(vertexD, vertexA, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 3);
    const edgeCB = new GraphEdge(vertexC, vertexB, 9);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBD)
      .addEdge(edgeDC)
      .addEdge(edgeCA)
      .addEdge(edgeBA)
      .addEdge(edgeDB)
      .addEdge(edgeCD)
      .addEdge(edgeAC)
      .addEdge(edgeAD)
      .addEdge(edgeDA)
      .addEdge(edgeBC)
      .addEdge(edgeCB);

    const salesmanPath = bfTravellingSalesman(graph);

    expect(salesmanPath.length).toBe(4);

    expect(salesmanPath[0].getKey()).toEqual(vertexA.getKey());
    expect(salesmanPath[1].getKey()).toEqual(vertexB.getKey());
    expect(salesmanPath[2].getKey()).toEqual(vertexD.getKey());
    expect(salesmanPath[3].getKey()).toEqual(vertexC.getKey());
  })",snuts
/src/algorithms/graph/travelling-salesman/__test__/bfTravellingSalesman.test.js,VerboseStatement,"{'startLine':7,'endLine':50}","it('should solve problem for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 1);
    const edgeDC = new GraphEdge(vertexD, vertexC, 1);
    const edgeCA = new GraphEdge(vertexC, vertexA, 1);

    const edgeBA = new GraphEdge(vertexB, vertexA, 5);
    const edgeDB = new GraphEdge(vertexD, vertexB, 8);
    const edgeCD = new GraphEdge(vertexC, vertexD, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 4);
    const edgeAD = new GraphEdge(vertexA, vertexD, 2);
    const edgeDA = new GraphEdge(vertexD, vertexA, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 3);
    const edgeCB = new GraphEdge(vertexC, vertexB, 9);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBD)
      .addEdge(edgeDC)
      .addEdge(edgeCA)
      .addEdge(edgeBA)
      .addEdge(edgeDB)
      .addEdge(edgeCD)
      .addEdge(edgeAC)
      .addEdge(edgeAD)
      .addEdge(edgeDA)
      .addEdge(edgeBC)
      .addEdge(edgeCB);

    const salesmanPath = bfTravellingSalesman(graph);

    expect(salesmanPath.length).toBe(4);

    expect(salesmanPath[0].getKey()).toEqual(vertexA.getKey());
    expect(salesmanPath[1].getKey()).toEqual(vertexB.getKey());
    expect(salesmanPath[2].getKey()).toEqual(vertexD.getKey());
    expect(salesmanPath[3].getKey()).toEqual(vertexC.getKey());
  })",snuts
/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js,SubOptimalAssert,"{'startLine':29,'endLine':29}","it('should detect strongly connected components in simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCA = new GraphEdge(vertexC, vertexA);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeCD);

    const components = stronglyConnectedComponents(graph);

    expect(components).toBeDefined();
    expect(components.length).toBe(2);

    expect(components[0][0].getKey()).toBe(vertexA.getKey());
    expect(components[0][1].getKey()).toBe(vertexC.getKey());
    expect(components[0][2].getKey()).toBe(vertexB.getKey());

    expect(components[1][0].getKey()).toBe(vertexD.getKey());
  })",snuts
/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js,SubOptimalAssert,"{'startLine':85,'endLine':85}","it('should detect strongly connected components in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');
    const vertexI = new GraphVertex('I');
    const vertexJ = new GraphVertex('J');
    const vertexK = new GraphVertex('K');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCA = new GraphEdge(vertexC, vertexA);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeGH = new GraphEdge(vertexG, vertexH);
    const edgeHI = new GraphEdge(vertexH, vertexI);
    const edgeIJ = new GraphEdge(vertexI, vertexJ);
    const edgeJG = new GraphEdge(vertexJ, vertexG);
    const edgeJK = new GraphEdge(vertexJ, vertexK);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeBD)
      .addEdge(edgeDE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeGF)
      .addEdge(edgeGH)
      .addEdge(edgeHI)
      .addEdge(edgeIJ)
      .addEdge(edgeJG)
      .addEdge(edgeJK);

    const components = stronglyConnectedComponents(graph);

    expect(components).toBeDefined();
    expect(components.length).toBe(4);

    expect(components[0][0].getKey()).toBe(vertexG.getKey());
    expect(components[0][1].getKey()).toBe(vertexJ.getKey());
    expect(components[0][2].getKey()).toBe(vertexI.getKey());
    expect(components[0][3].getKey()).toBe(vertexH.getKey());

    expect(components[1][0].getKey()).toBe(vertexK.getKey());

    expect(components[2][0].getKey()).toBe(vertexA.getKey());
    expect(components[2][1].getKey()).toBe(vertexC.getKey());
    expect(components[2][2].getKey()).toBe(vertexB.getKey());

    expect(components[3][0].getKey()).toBe(vertexD.getKey());
    expect(components[3][1].getKey()).toBe(vertexF.getKey());
    expect(components[3][2].getKey()).toBe(vertexE.getKey());
  })",snuts
/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js,VerboseStatement,"{'startLine':7,'endLine':36}","it('should detect strongly connected components in simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCA = new GraphEdge(vertexC, vertexA);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeCD);

    const components = stronglyConnectedComponents(graph);

    expect(components).toBeDefined();
    expect(components.length).toBe(2);

    expect(components[0][0].getKey()).toBe(vertexA.getKey());
    expect(components[0][1].getKey()).toBe(vertexC.getKey());
    expect(components[0][2].getKey()).toBe(vertexB.getKey());

    expect(components[1][0].getKey()).toBe(vertexD.getKey());
  })",snuts
/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js,VerboseStatement,"{'startLine':38,'endLine':101}","it('should detect strongly connected components in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');
    const vertexI = new GraphVertex('I');
    const vertexJ = new GraphVertex('J');
    const vertexK = new GraphVertex('K');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCA = new GraphEdge(vertexC, vertexA);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeGH = new GraphEdge(vertexG, vertexH);
    const edgeHI = new GraphEdge(vertexH, vertexI);
    const edgeIJ = new GraphEdge(vertexI, vertexJ);
    const edgeJG = new GraphEdge(vertexJ, vertexG);
    const edgeJK = new GraphEdge(vertexJ, vertexK);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeBD)
      .addEdge(edgeDE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeGF)
      .addEdge(edgeGH)
      .addEdge(edgeHI)
      .addEdge(edgeIJ)
      .addEdge(edgeJG)
      .addEdge(edgeJK);

    const components = stronglyConnectedComponents(graph);

    expect(components).toBeDefined();
    expect(components.length).toBe(4);

    expect(components[0][0].getKey()).toBe(vertexG.getKey());
    expect(components[0][1].getKey()).toBe(vertexJ.getKey());
    expect(components[0][2].getKey()).toBe(vertexI.getKey());
    expect(components[0][3].getKey()).toBe(vertexH.getKey());

    expect(components[1][0].getKey()).toBe(vertexK.getKey());

    expect(components[2][0].getKey()).toBe(vertexA.getKey());
    expect(components[2][1].getKey()).toBe(vertexC.getKey());
    expect(components[2][2].getKey()).toBe(vertexB.getKey());

    expect(components[3][0].getKey()).toBe(vertexD.getKey());
    expect(components[3][1].getKey()).toBe(vertexF.getKey());
    expect(components[3][2].getKey()).toBe(vertexE.getKey());
  })",snuts
/src/algorithms/graph/prim/__test__/prim.test.js,SubOptimalAssert,"{'startLine':56,'endLine':56}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,E,D,F,G');
  })",snuts
/src/algorithms/graph/prim/__test__/prim.test.js,SubOptimalAssert,"{'startLine':57,'endLine':57}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,E,D,F,G');
  })",snuts
/src/algorithms/graph/prim/__test__/prim.test.js,SubOptimalAssert,"{'startLine':87,'endLine':87}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",snuts
/src/algorithms/graph/prim/__test__/prim.test.js,SubOptimalAssert,"{'startLine':88,'endLine':88}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",snuts
/src/algorithms/graph/prim/__test__/prim.test.js,VerboseStatement,"{'startLine':17,'endLine':59}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,E,D,F,G');
  })",snuts
/src/algorithms/graph/prim/__test__/prim.test.js,VerboseStatement,"{'startLine':61,'endLine':90}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",snuts
/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js,SubOptimalAssert,"{'startLine':36,'endLine':36}","it('should find hamiltonian paths in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD)
      .addEdge(edgeDE);

    const hamiltonianCycleSet = hamiltonianCycle(graph);

    expect(hamiltonianCycleSet.length).toBe(8);

    expect(hamiltonianCycleSet[0][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[0][1].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[0][2].getKey()).toBe(vertexE.getKey());
    expect(hamiltonianCycleSet[0][3].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[0][4].getKey()).toBe(vertexC.getKey());

    expect(hamiltonianCycleSet[1][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[1][1].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[1][2].getKey()).toBe(vertexC.getKey());
    expect(hamiltonianCycleSet[1][3].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[1][4].getKey()).toBe(vertexE.getKey());

    expect(hamiltonianCycleSet[2][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[2][1].getKey()).toBe(vertexE.getKey());
    expect(hamiltonianCycleSet[2][2].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[2][3].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[2][4].getKey()).toBe(vertexC.getKey());

    expect(hamiltonianCycleSet[3][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[3][1].getKey()).toBe(vertexE.getKey());
    expect(hamiltonianCycleSet[3][2].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[3][3].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[3][4].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js,SubOptimalAssert,"{'startLine':88,'endLine':88}","it('should return false for graph without Hamiltonian path', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    const hamiltonianCycleSet = hamiltonianCycle(graph);

    expect(hamiltonianCycleSet.length).toBe(0);
  })",snuts
/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js,VerboseStatement,"{'startLine':7,'endLine':61}","it('should find hamiltonian paths in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD)
      .addEdge(edgeDE);

    const hamiltonianCycleSet = hamiltonianCycle(graph);

    expect(hamiltonianCycleSet.length).toBe(8);

    expect(hamiltonianCycleSet[0][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[0][1].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[0][2].getKey()).toBe(vertexE.getKey());
    expect(hamiltonianCycleSet[0][3].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[0][4].getKey()).toBe(vertexC.getKey());

    expect(hamiltonianCycleSet[1][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[1][1].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[1][2].getKey()).toBe(vertexC.getKey());
    expect(hamiltonianCycleSet[1][3].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[1][4].getKey()).toBe(vertexE.getKey());

    expect(hamiltonianCycleSet[2][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[2][1].getKey()).toBe(vertexE.getKey());
    expect(hamiltonianCycleSet[2][2].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[2][3].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[2][4].getKey()).toBe(vertexC.getKey());

    expect(hamiltonianCycleSet[3][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[3][1].getKey()).toBe(vertexE.getKey());
    expect(hamiltonianCycleSet[3][2].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[3][3].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[3][4].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js,VerboseStatement,"{'startLine':63,'endLine':89}","it('should return false for graph without Hamiltonian path', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    const hamiltonianCycleSet = hamiltonianCycle(graph);

    expect(hamiltonianCycleSet.length).toBe(0);
  })",snuts
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,SubOptimalAssert,"{'startLine':56,'endLine':56}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('E,C,A,B,D,F,G');
  })",snuts
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,SubOptimalAssert,"{'startLine':57,'endLine':57}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('E,C,A,B,D,F,G');
  })",snuts
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,SubOptimalAssert,"{'startLine':87,'endLine':87}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",snuts
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,SubOptimalAssert,"{'startLine':88,'endLine':88}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",snuts
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,VerboseStatement,"{'startLine':17,'endLine':59}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('E,C,A,B,D,F,G');
  })",snuts
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,VerboseStatement,"{'startLine':61,'endLine':90}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",snuts
/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycleUsingDisjointSet.test.js,VerboseStatement,"{'startLine':7,'endLine':35}","it('should detect undirected cycle', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');

    const edgeAF = new GraphEdge(vertexA, vertexF);
    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();
    graph
      .addEdge(edgeAF)
      .addEdge(edgeAB)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    expect(detectUndirectedCycleUsingDisjointSet(graph)).toBe(false);

    graph.addEdge(edgeDE);

    expect(detectUndirectedCycleUsingDisjointSet(graph)).toBe(true);
  })",snuts
/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycle.test.js,VerboseStatement,"{'startLine':7,'endLine':40}","it('should detect undirected cycle', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');

    const edgeAF = new GraphEdge(vertexA, vertexF);
    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();
    graph
      .addEdge(edgeAF)
      .addEdge(edgeAB)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    expect(detectUndirectedCycle(graph)).toBeNull();

    graph.addEdge(edgeDE);

    expect(detectUndirectedCycle(graph)).toEqual({
      B: vertexC,
      C: vertexD,
      D: vertexE,
      E: vertexB,
    });
  })",snuts
/src/algorithms/graph/detect-cycle/__test__/detectDirectedCycle.test.js,VerboseStatement,"{'startLine':7,'endLine':41}","it('should detect directed cycle', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeDA = new GraphEdge(vertexD, vertexA);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeDA)
      .addEdge(edgeDE)
      .addEdge(edgeEF);

    expect(detectDirectedCycle(graph)).toBeNull();

    graph.addEdge(edgeFD);

    expect(detectDirectedCycle(graph)).toEqual({
      D: vertexF,
      F: vertexE,
      E: vertexD,
    });
  })",snuts
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,VerboseStatement,"{'startLine':7,'endLine':85}","it('should perform DFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first to check default ones.
    depthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",snuts
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,VerboseStatement,"{'startLine':87,'endLine':164}","it('allow users to redefine vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexG, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",snuts
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,VerboseStatement,"{'startLine':7,'endLine':90}","it('should perform BFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first.
    breadthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(8);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(8);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",snuts
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,VerboseStatement,"{'startLine':92,'endLine':173}","it('should allow to create custom vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",snuts
/src/algorithms/graph/bellman-ford/__test__/bellmanFord.test.js,VerboseStatement,"{'startLine':7,'endLine':66}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();
    graph
      .addVertex(vertexH)
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, previousVertices } = bellmanFord(graph, vertexA);

    expect(distances).toEqual({
      H: Infinity,
      A: 0,
      B: 4,
      E: 7,
      C: 3,
      D: 9,
      G: 12,
      F: 11,
    });

    expect(previousVertices.F.getKey()).toBe('D');
    expect(previousVertices.D.getKey()).toBe('B');
    expect(previousVertices.B.getKey()).toBe('A');
    expect(previousVertices.G.getKey()).toBe('E');
    expect(previousVertices.C.getKey()).toBe('A');
    expect(previousVertices.A).toBeNull();
    expect(previousVertices.H).toBeNull();
  })",snuts
/src/algorithms/graph/bellman-ford/__test__/bellmanFord.test.js,VerboseStatement,"{'startLine':68,'endLine':116}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexS = new GraphVertex('S');
    const vertexE = new GraphVertex('E');
    const vertexA = new GraphVertex('A');
    const vertexD = new GraphVertex('D');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexH = new GraphVertex('H');

    const edgeSE = new GraphEdge(vertexS, vertexE, 8);
    const edgeSA = new GraphEdge(vertexS, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);
    graph
      .addVertex(vertexH)
      .addEdge(edgeSE)
      .addEdge(edgeSA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, previousVertices } = bellmanFord(graph, vertexS);

    expect(distances).toEqual({
      H: Infinity,
      S: 0,
      A: 5,
      B: 5,
      C: 7,
      D: 9,
      E: 8,
    });

    expect(previousVertices.H).toBeNull();
    expect(previousVertices.S).toBeNull();
    expect(previousVertices.B.getKey()).toBe('C');
    expect(previousVertices.C.getKey()).toBe('A');
    expect(previousVertices.A.getKey()).toBe('D');
    expect(previousVertices.D.getKey()).toBe('E');
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,SubOptimalAssert,"{'startLine':26,'endLine':26}","it('should find bridges in simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(3);
    expect(bridges[0].getKey()).toBe(edgeCD.getKey());
    expect(bridges[1].getKey()).toBe(edgeBC.getKey());
    expect(bridges[2].getKey()).toBe(edgeAB.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,SubOptimalAssert,"{'startLine':53,'endLine':53}","it('should find bridges in simple graph with back edge', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(1);
    expect(bridges[0].getKey()).toBe(edgeCD.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,SubOptimalAssert,"{'startLine':92,'endLine':92}","it('should find bridges in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeDE)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(3);
    expect(bridges[0].getKey()).toBe(edgeFH.getKey());
    expect(bridges[1].getKey()).toBe(edgeDE.getKey());
    expect(bridges[2].getKey()).toBe(edgeCD.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,SubOptimalAssert,"{'startLine':133,'endLine':133}","it('should find bridges in graph starting with different root vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeDE)
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(3);
    expect(bridges[0].getKey()).toBe(edgeFH.getKey());
    expect(bridges[1].getKey()).toBe(edgeDE.getKey());
    expect(bridges[2].getKey()).toBe(edgeCD.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,SubOptimalAssert,"{'startLine':163,'endLine':163}","it('should find bridges in yet another graph #1', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeDE);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(2);
    expect(bridges[0].getKey()).toBe(edgeDE.getKey());
    expect(bridges[1].getKey()).toBe(edgeCD.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,SubOptimalAssert,"{'startLine':200,'endLine':200}","it('should find bridges in yet another graph #2', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeCF = new GraphEdge(vertexC, vertexF);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeCE)
      .addEdge(edgeCF)
      .addEdge(edgeEG)
      .addEdge(edgeFG);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(1);
    expect(bridges[0].getKey()).toBe(edgeCD.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,VerboseStatement,"{'startLine':7,'endLine':30}","it('should find bridges in simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(3);
    expect(bridges[0].getKey()).toBe(edgeCD.getKey());
    expect(bridges[1].getKey()).toBe(edgeBC.getKey());
    expect(bridges[2].getKey()).toBe(edgeAB.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,VerboseStatement,"{'startLine':57,'endLine':96}","it('should find bridges in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeDE)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(3);
    expect(bridges[0].getKey()).toBe(edgeFH.getKey());
    expect(bridges[1].getKey()).toBe(edgeDE.getKey());
    expect(bridges[2].getKey()).toBe(edgeCD.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,VerboseStatement,"{'startLine':98,'endLine':137}","it('should find bridges in graph starting with different root vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeDE)
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(3);
    expect(bridges[0].getKey()).toBe(edgeFH.getKey());
    expect(bridges[1].getKey()).toBe(edgeDE.getKey());
    expect(bridges[2].getKey()).toBe(edgeCD.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,VerboseStatement,"{'startLine':139,'endLine':166}","it('should find bridges in yet another graph #1', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeDE);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(2);
    expect(bridges[0].getKey()).toBe(edgeDE.getKey());
    expect(bridges[1].getKey()).toBe(edgeCD.getKey());
  })",snuts
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,VerboseStatement,"{'startLine':168,'endLine':202}","it('should find bridges in yet another graph #2', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeCF = new GraphEdge(vertexC, vertexF);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeCE)
      .addEdge(edgeCF)
      .addEdge(edgeEG)
      .addEdge(edgeFG);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(1);
    expect(bridges[0].getKey()).toBe(edgeCD.getKey());
  })",snuts
/src/algorithms/graph/eulerian-path/__test__/eulerianPath.test.js,SubOptimalAssert,"{'startLine':74,'endLine':74}","it('should find Eulerian Circuit in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeAF = new GraphEdge(vertexA, vertexF);
    const edgeAG = new GraphEdge(vertexA, vertexG);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeEB = new GraphEdge(vertexE, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeED = new GraphEdge(vertexE, vertexD);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAF)
      .addEdge(edgeAG)
      .addEdge(edgeGF)
      .addEdge(edgeBE)
      .addEdge(edgeEB)
      .addEdge(edgeBC)
      .addEdge(edgeED)
      .addEdge(edgeCD);

    const graphEdgesCount = graph.getAllEdges().length;

    const eulerianPathSet = eulerianPath(graph);

    expect(eulerianPathSet.length).toBe(graphEdgesCount + 1);

    expect(eulerianPathSet[0].getKey()).toBe(vertexA.getKey());
    expect(eulerianPathSet[1].getKey()).toBe(vertexB.getKey());
    expect(eulerianPathSet[2].getKey()).toBe(vertexE.getKey());
    expect(eulerianPathSet[3].getKey()).toBe(vertexB.getKey());
    expect(eulerianPathSet[4].getKey()).toBe(vertexC.getKey());
    expect(eulerianPathSet[5].getKey()).toBe(vertexD.getKey());
    expect(eulerianPathSet[6].getKey()).toBe(vertexE.getKey());
    expect(eulerianPathSet[7].getKey()).toBe(vertexA.getKey());
    expect(eulerianPathSet[8].getKey()).toBe(vertexF.getKey());
    expect(eulerianPathSet[9].getKey()).toBe(vertexG.getKey());
    expect(eulerianPathSet[10].getKey()).toBe(vertexA.getKey());
  })",snuts
/src/algorithms/graph/eulerian-path/__test__/eulerianPath.test.js,SubOptimalAssert,"{'startLine':126,'endLine':126}","it('should find Eulerian Path in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeDC = new GraphEdge(vertexD, vertexC);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);
    const edgeFG = new GraphEdge(vertexF, vertexG);
    const edgeHG = new GraphEdge(vertexH, vertexG);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBD)
      .addEdge(edgeDC)
      .addEdge(edgeCE)
      .addEdge(edgeEF)
      .addEdge(edgeFH)
      .addEdge(edgeFG)
      .addEdge(edgeHG);

    const graphEdgesCount = graph.getAllEdges().length;

    const eulerianPathSet = eulerianPath(graph);

    expect(eulerianPathSet.length).toBe(graphEdgesCount + 1);

    expect(eulerianPathSet[0].getKey()).toBe(vertexC.getKey());
    expect(eulerianPathSet[1].getKey()).toBe(vertexA.getKey());
    expect(eulerianPathSet[2].getKey()).toBe(vertexB.getKey());
    expect(eulerianPathSet[3].getKey()).toBe(vertexD.getKey());
    expect(eulerianPathSet[4].getKey()).toBe(vertexC.getKey());
    expect(eulerianPathSet[5].getKey()).toBe(vertexE.getKey());
    expect(eulerianPathSet[6].getKey()).toBe(vertexF.getKey());
    expect(eulerianPathSet[7].getKey()).toBe(vertexH.getKey());
    expect(eulerianPathSet[8].getKey()).toBe(vertexG.getKey());
    expect(eulerianPathSet[9].getKey()).toBe(vertexF.getKey());
  })",snuts
/src/algorithms/graph/eulerian-path/__test__/eulerianPath.test.js,VerboseStatement,"{'startLine':36,'endLine':87}","it('should find Eulerian Circuit in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeAF = new GraphEdge(vertexA, vertexF);
    const edgeAG = new GraphEdge(vertexA, vertexG);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeEB = new GraphEdge(vertexE, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeED = new GraphEdge(vertexE, vertexD);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAF)
      .addEdge(edgeAG)
      .addEdge(edgeGF)
      .addEdge(edgeBE)
      .addEdge(edgeEB)
      .addEdge(edgeBC)
      .addEdge(edgeED)
      .addEdge(edgeCD);

    const graphEdgesCount = graph.getAllEdges().length;

    const eulerianPathSet = eulerianPath(graph);

    expect(eulerianPathSet.length).toBe(graphEdgesCount + 1);

    expect(eulerianPathSet[0].getKey()).toBe(vertexA.getKey());
    expect(eulerianPathSet[1].getKey()).toBe(vertexB.getKey());
    expect(eulerianPathSet[2].getKey()).toBe(vertexE.getKey());
    expect(eulerianPathSet[3].getKey()).toBe(vertexB.getKey());
    expect(eulerianPathSet[4].getKey()).toBe(vertexC.getKey());
    expect(eulerianPathSet[5].getKey()).toBe(vertexD.getKey());
    expect(eulerianPathSet[6].getKey()).toBe(vertexE.getKey());
    expect(eulerianPathSet[7].getKey()).toBe(vertexA.getKey());
    expect(eulerianPathSet[8].getKey()).toBe(vertexF.getKey());
    expect(eulerianPathSet[9].getKey()).toBe(vertexG.getKey());
    expect(eulerianPathSet[10].getKey()).toBe(vertexA.getKey());
  })",snuts
/src/algorithms/graph/eulerian-path/__test__/eulerianPath.test.js,VerboseStatement,"{'startLine':89,'endLine':138}","it('should find Eulerian Path in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeDC = new GraphEdge(vertexD, vertexC);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);
    const edgeFG = new GraphEdge(vertexF, vertexG);
    const edgeHG = new GraphEdge(vertexH, vertexG);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBD)
      .addEdge(edgeDC)
      .addEdge(edgeCE)
      .addEdge(edgeEF)
      .addEdge(edgeFH)
      .addEdge(edgeFG)
      .addEdge(edgeHG);

    const graphEdgesCount = graph.getAllEdges().length;

    const eulerianPathSet = eulerianPath(graph);

    expect(eulerianPathSet.length).toBe(graphEdgesCount + 1);

    expect(eulerianPathSet[0].getKey()).toBe(vertexC.getKey());
    expect(eulerianPathSet[1].getKey()).toBe(vertexA.getKey());
    expect(eulerianPathSet[2].getKey()).toBe(vertexB.getKey());
    expect(eulerianPathSet[3].getKey()).toBe(vertexD.getKey());
    expect(eulerianPathSet[4].getKey()).toBe(vertexC.getKey());
    expect(eulerianPathSet[5].getKey()).toBe(vertexE.getKey());
    expect(eulerianPathSet[6].getKey()).toBe(vertexF.getKey());
    expect(eulerianPathSet[7].getKey()).toBe(vertexH.getKey());
    expect(eulerianPathSet[8].getKey()).toBe(vertexG.getKey());
    expect(eulerianPathSet[9].getKey()).toBe(vertexF.getKey());
  })",snuts
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,SubOptimalAssert,"{'startLine':85,'endLine':85}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",snuts
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,SubOptimalAssert,"{'startLine':86,'endLine':86}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",snuts
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,SubOptimalAssert,"{'startLine':146,'endLine':146}","it('should find minimum paths to all vertices for directed graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 3);
    const edgeBA = new GraphEdge(vertexB, vertexA, 8);
    const edgeAD = new GraphEdge(vertexA, vertexD, 7);
    const edgeDA = new GraphEdge(vertexD, vertexA, 2);
    const edgeBC = new GraphEdge(vertexB, vertexC, 2);
    const edgeCA = new GraphEdge(vertexC, vertexA, 5);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBA)
      .addEdge(edgeAD)
      .addEdge(edgeDA)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeCD);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);

    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(5);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(6);

    expect(distances).toEqual([
      [0, 3, 5, 6],
      [5, 0, 2, 3],
      [3, 6, 0, 1],
      [2, 5, 7, 0],
    ]);

    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexB);
    expect(nextVertices[vertexBIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
  })",snuts
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,SubOptimalAssert,"{'startLine':211,'endLine':211}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeFE = new GraphEdge(vertexF, vertexE, 8);
    const edgeFA = new GraphEdge(vertexF, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeFE)
      .addEdge(edgeFA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexFIndex = vertices.indexOf(vertexF);

    expect(distances[vertexFIndex][vertexGIndex]).toBe(Infinity);
    expect(distances[vertexFIndex][vertexFIndex]).toBe(0);
    expect(distances[vertexFIndex][vertexAIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexBIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexCIndex]).toBe(7);
    expect(distances[vertexFIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexFIndex][vertexEIndex]).toBe(8);

    expect(nextVertices[vertexFIndex][vertexGIndex]).toBe(null);
    expect(nextVertices[vertexFIndex][vertexFIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexFIndex][vertexBIndex]).toBe(vertexE);
    expect(nextVertices[vertexEIndex][vertexBIndex]).toBe(vertexD);
    expect(nextVertices[vertexDIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
  })",snuts
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,SubOptimalAssert,"{'startLine':212,'endLine':212}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeFE = new GraphEdge(vertexF, vertexE, 8);
    const edgeFA = new GraphEdge(vertexF, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeFE)
      .addEdge(edgeFA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexFIndex = vertices.indexOf(vertexF);

    expect(distances[vertexFIndex][vertexGIndex]).toBe(Infinity);
    expect(distances[vertexFIndex][vertexFIndex]).toBe(0);
    expect(distances[vertexFIndex][vertexAIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexBIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexCIndex]).toBe(7);
    expect(distances[vertexFIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexFIndex][vertexEIndex]).toBe(8);

    expect(nextVertices[vertexFIndex][vertexGIndex]).toBe(null);
    expect(nextVertices[vertexFIndex][vertexFIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexFIndex][vertexBIndex]).toBe(vertexE);
    expect(nextVertices[vertexEIndex][vertexBIndex]).toBe(vertexD);
    expect(nextVertices[vertexDIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
  })",snuts
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,VerboseStatement,"{'startLine':7,'endLine':87}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",snuts
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,VerboseStatement,"{'startLine':89,'endLine':148}","it('should find minimum paths to all vertices for directed graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 3);
    const edgeBA = new GraphEdge(vertexB, vertexA, 8);
    const edgeAD = new GraphEdge(vertexA, vertexD, 7);
    const edgeDA = new GraphEdge(vertexD, vertexA, 2);
    const edgeBC = new GraphEdge(vertexB, vertexC, 2);
    const edgeCA = new GraphEdge(vertexC, vertexA, 5);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBA)
      .addEdge(edgeAD)
      .addEdge(edgeDA)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeCD);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);

    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(5);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(6);

    expect(distances).toEqual([
      [0, 3, 5, 6],
      [5, 0, 2, 3],
      [3, 6, 0, 1],
      [2, 5, 7, 0],
    ]);

    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexB);
    expect(nextVertices[vertexBIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
  })",snuts
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,VerboseStatement,"{'startLine':150,'endLine':219}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeFE = new GraphEdge(vertexF, vertexE, 8);
    const edgeFA = new GraphEdge(vertexF, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeFE)
      .addEdge(edgeFA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexFIndex = vertices.indexOf(vertexF);

    expect(distances[vertexFIndex][vertexGIndex]).toBe(Infinity);
    expect(distances[vertexFIndex][vertexFIndex]).toBe(0);
    expect(distances[vertexFIndex][vertexAIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexBIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexCIndex]).toBe(7);
    expect(distances[vertexFIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexFIndex][vertexEIndex]).toBe(8);

    expect(nextVertices[vertexFIndex][vertexGIndex]).toBe(null);
    expect(nextVertices[vertexFIndex][vertexFIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexFIndex][vertexBIndex]).toBe(vertexE);
    expect(nextVertices[vertexEIndex][vertexBIndex]).toBe(vertexD);
    expect(nextVertices[vertexDIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,SubOptimalAssert,"{'startLine':26,'endLine':26}","it('should find articulation points in simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(2);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexB.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,SubOptimalAssert,"{'startLine':52,'endLine':52}","it('should find articulation points in simple graph with back edge', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(1);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,SubOptimalAssert,"{'startLine':80,'endLine':80}","it('should find articulation points in simple graph with back edge #2', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeCE = new GraphEdge(vertexC, vertexE);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeCE)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(1);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,SubOptimalAssert,"{'startLine':119,'endLine':119}","it('should find articulation points in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeDE)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(4);
    expect(articulationPointsSet[0].getKey()).toBe(vertexF.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexE.getKey());
    expect(articulationPointsSet[2].getKey()).toBe(vertexD.getKey());
    expect(articulationPointsSet[3].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,SubOptimalAssert,"{'startLine':161,'endLine':161}","it('should find articulation points in graph starting with articulation root vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeDE)
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(4);
    expect(articulationPointsSet[0].getKey()).toBe(vertexF.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexE.getKey());
    expect(articulationPointsSet[2].getKey()).toBe(vertexC.getKey());
    expect(articulationPointsSet[3].getKey()).toBe(vertexD.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,SubOptimalAssert,"{'startLine':192,'endLine':192}","it('should find articulation points in yet another graph #1', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeDE);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(2);
    expect(articulationPointsSet[0].getKey()).toBe(vertexD.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,SubOptimalAssert,"{'startLine':229,'endLine':229}","it('should find articulation points in yet another graph #2', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeCF = new GraphEdge(vertexC, vertexF);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeCE)
      .addEdge(edgeCF)
      .addEdge(edgeEG)
      .addEdge(edgeFG);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(1);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,VerboseStatement,"{'startLine':56,'endLine':82}","it('should find articulation points in simple graph with back edge #2', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeCE = new GraphEdge(vertexC, vertexE);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeCE)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(1);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,VerboseStatement,"{'startLine':84,'endLine':124}","it('should find articulation points in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeDE)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(4);
    expect(articulationPointsSet[0].getKey()).toBe(vertexF.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexE.getKey());
    expect(articulationPointsSet[2].getKey()).toBe(vertexD.getKey());
    expect(articulationPointsSet[3].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,VerboseStatement,"{'startLine':126,'endLine':166}","it('should find articulation points in graph starting with articulation root vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeDE)
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(4);
    expect(articulationPointsSet[0].getKey()).toBe(vertexF.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexE.getKey());
    expect(articulationPointsSet[2].getKey()).toBe(vertexC.getKey());
    expect(articulationPointsSet[3].getKey()).toBe(vertexD.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,VerboseStatement,"{'startLine':168,'endLine':195}","it('should find articulation points in yet another graph #1', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeDE);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(2);
    expect(articulationPointsSet[0].getKey()).toBe(vertexD.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,VerboseStatement,"{'startLine':197,'endLine':231}","it('should find articulation points in yet another graph #2', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeCF = new GraphEdge(vertexC, vertexF);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeCE)
      .addEdge(edgeCF)
      .addEdge(edgeEG)
      .addEdge(edgeFG);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(1);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
  })",snuts
/src/algorithms/graph/dijkstra/__test__/dijkstra.test.js,VerboseStatement,"{'startLine':7,'endLine':66}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();
    graph
      .addVertex(vertexH)
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, previousVertices } = dijkstra(graph, vertexA);

    expect(distances).toEqual({
      H: Infinity,
      A: 0,
      B: 4,
      E: 7,
      C: 3,
      D: 9,
      G: 12,
      F: 11,
    });

    expect(previousVertices.F.getKey()).toBe('D');
    expect(previousVertices.D.getKey()).toBe('B');
    expect(previousVertices.B.getKey()).toBe('A');
    expect(previousVertices.G.getKey()).toBe('E');
    expect(previousVertices.C.getKey()).toBe('A');
    expect(previousVertices.A).toBeNull();
    expect(previousVertices.H).toBeNull();
  })",snuts
/src/algorithms/graph/dijkstra/__test__/dijkstra.test.js,VerboseStatement,"{'startLine':68,'endLine':116}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexS = new GraphVertex('S');
    const vertexE = new GraphVertex('E');
    const vertexA = new GraphVertex('A');
    const vertexD = new GraphVertex('D');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexH = new GraphVertex('H');

    const edgeSE = new GraphEdge(vertexS, vertexE, 8);
    const edgeSA = new GraphEdge(vertexS, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);
    graph
      .addVertex(vertexH)
      .addEdge(edgeSE)
      .addEdge(edgeSA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, previousVertices } = dijkstra(graph, vertexS);

    expect(distances).toEqual({
      H: Infinity,
      S: 0,
      A: 5,
      B: 5,
      C: 7,
      D: 9,
      E: 8,
    });

    expect(previousVertices.H).toBeNull();
    expect(previousVertices.S).toBeNull();
    expect(previousVertices.B.getKey()).toBe('C');
    expect(previousVertices.C.getKey()).toBe('A');
    expect(previousVertices.A.getKey()).toBe('D');
    expect(previousVertices.D.getKey()).toBe('E');
  })",snuts
/src/utils/comparator/__test__/Comparator.test.js,Conditional Test Logic,"{'line': 27, 'column': 6, 'index': 1178}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1290}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1290}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1341}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1341}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 1392}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 1447}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 1513}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1578}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1578}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1670}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1670}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1721}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1721}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1772}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1828}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1893}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1959}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/utils/comparator/__test__/Comparator.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1959}","it('should compare with custom comparator function', () => {
    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);

    comparator.reverse();

    expect(comparator.equal('a', 'b')).toBe(true);
    expect(comparator.equal('a', '')).toBe(false);
    expect(comparator.lessThan('b', 'aa')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
  })",steel
/src/playground/__test__/playground.test.js,Magic Number,"{'line': 6, 'column': 30, 'index': 220}","it('should return correct results', () => {
    // Replace the next dummy test with your playground function tests.
    expect(playground()).toBe(120);
  })",steel
/src/data-structures/trie/__test__/TrieNode.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 952}","it('should check if node has children', () => {
    const trieNode = new TrieNode('c');

    expect(trieNode.hasChildren()).toBe(false);

    trieNode.addChild('a');

    expect(trieNode.hasChildren()).toBe(true);
  })",steel
/src/data-structures/trie/__test__/TrieNode.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1030}","it('should check if node has children', () => {
    const trieNode = new TrieNode('c');

    expect(trieNode.hasChildren()).toBe(false);

    trieNode.addChild('a');

    expect(trieNode.hasChildren()).toBe(true);
  })",steel
/src/data-structures/trie/__test__/TrieNode.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1740}","it('should delete child node if the child node has NO children', () => {
    const trieNode = new TrieNode('c');
    trieNode.addChild('a');
    expect(trieNode.hasChild('a')).toBe(true);

    trieNode.removeChild('a');
    expect(trieNode.hasChild('a')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/TrieNode.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1819}","it('should delete child node if the child node has NO children', () => {
    const trieNode = new TrieNode('c');
    trieNode.addChild('a');
    expect(trieNode.hasChild('a')).toBe(true);

    trieNode.removeChild('a');
    expect(trieNode.hasChild('a')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 16, 'column': 4, 'index': 303}","it('should add words to trie', () => {
    const trie = new Trie();

    trie.addWord('cat');

    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');

    trie.addWord('car');
    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');
    expect(trie.head.getChild('c').getChild('a').toString()).toBe('a:t,r');
    expect(trie.head.getChild('c').getChild('a').getChild('t').toString()).toBe('t*');
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 16, 'column': 4, 'index': 303}","it('should add words to trie', () => {
    const trie = new Trie();

    trie.addWord('cat');

    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');

    trie.addWord('car');
    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');
    expect(trie.head.getChild('c').getChild('a').toString()).toBe('a:t,r');
    expect(trie.head.getChild('c').getChild('a').getChild('t').toString()).toBe('t*');
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 349}","it('should add words to trie', () => {
    const trie = new Trie();

    trie.addWord('cat');

    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');

    trie.addWord('car');
    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');
    expect(trie.head.getChild('c').getChild('a').toString()).toBe('a:t,r');
    expect(trie.head.getChild('c').getChild('a').getChild('t').toString()).toBe('t*');
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 349}","it('should add words to trie', () => {
    const trie = new Trie();

    trie.addWord('cat');

    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');

    trie.addWord('car');
    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');
    expect(trie.head.getChild('c').getChild('a').toString()).toBe('a:t,r');
    expect(trie.head.getChild('c').getChild('a').getChild('t').toString()).toBe('t*');
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 20, 'column': 4, 'index': 435}","it('should add words to trie', () => {
    const trie = new Trie();

    trie.addWord('cat');

    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');

    trie.addWord('car');
    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');
    expect(trie.head.getChild('c').getChild('a').toString()).toBe('a:t,r');
    expect(trie.head.getChild('c').getChild('a').getChild('t').toString()).toBe('t*');
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 20, 'column': 4, 'index': 435}","it('should add words to trie', () => {
    const trie = new Trie();

    trie.addWord('cat');

    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');

    trie.addWord('car');
    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');
    expect(trie.head.getChild('c').getChild('a').toString()).toBe('a:t,r');
    expect(trie.head.getChild('c').getChild('a').getChild('t').toString()).toBe('t*');
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 481}","it('should add words to trie', () => {
    const trie = new Trie();

    trie.addWord('cat');

    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');

    trie.addWord('car');
    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');
    expect(trie.head.getChild('c').getChild('a').toString()).toBe('a:t,r');
    expect(trie.head.getChild('c').getChild('a').getChild('t').toString()).toBe('t*');
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 481}","it('should add words to trie', () => {
    const trie = new Trie();

    trie.addWord('cat');

    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');

    trie.addWord('car');
    expect(trie.head.toString()).toBe('*:c');
    expect(trie.head.getChild('c').toString()).toBe('c:a');
    expect(trie.head.getChild('c').getChild('a').toString()).toBe('a:t,r');
    expect(trie.head.getChild('c').getChild('a').getChild('t').toString()).toBe('t*');
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 891}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 891}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 944}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 944}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 994}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 994}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 1045}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 1045}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1174}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1174}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1227}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1227}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1277}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1277}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1328}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1328}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1410}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1467}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1467}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1520}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1520}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1571}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1571}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1650}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1650}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1703}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1703}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1754}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 1834}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 1834}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 1888}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 1888}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1969}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1969}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/trie/__test__/Trie.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 2023}","it('should delete words from trie', () => {
    const trie = new Trie();

    trie.addWord('carpet');
    trie.addWord('car');
    trie.addWord('cat');
    trie.addWord('cart');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    // Try to delete not-existing word first.
    trie.deleteWord('carpool');
    expect(trie.doesWordExist('carpet')).toBe(true);
    expect(trie.doesWordExist('car')).toBe(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('carpet');
    expect(trie.doesWordExist('carpet')).toEqual(false);
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(true);

    trie.deleteWord('cat');
    expect(trie.doesWordExist('car')).toEqual(true);
    expect(trie.doesWordExist('cart')).toBe(true);
    expect(trie.doesWordExist('cat')).toBe(false);

    trie.deleteWord('car');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(true);

    trie.deleteWord('cart');
    expect(trie.doesWordExist('car')).toEqual(false);
    expect(trie.doesWordExist('cart')).toBe(false);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 60, 'column': 46, 'index': 2343}","it('should do min range query on power of two length array', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(-1);
    expect(segmentTree.rangeQuery(0, 2)).toBe(-1);
    expect(segmentTree.rangeQuery(1, 3)).toBe(0);
    expect(segmentTree.rangeQuery(2, 4)).toBe(0);
    expect(segmentTree.rangeQuery(4, 5)).toBe(1);
    expect(segmentTree.rangeQuery(2, 2)).toBe(4);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 61, 'column': 46, 'index': 2393}","it('should do min range query on power of two length array', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(-1);
    expect(segmentTree.rangeQuery(0, 2)).toBe(-1);
    expect(segmentTree.rangeQuery(1, 3)).toBe(0);
    expect(segmentTree.rangeQuery(2, 4)).toBe(0);
    expect(segmentTree.rangeQuery(4, 5)).toBe(1);
    expect(segmentTree.rangeQuery(2, 2)).toBe(4);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 62, 'column': 46, 'index': 2443}","it('should do min range query on power of two length array', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(-1);
    expect(segmentTree.rangeQuery(0, 2)).toBe(-1);
    expect(segmentTree.rangeQuery(1, 3)).toBe(0);
    expect(segmentTree.rangeQuery(2, 4)).toBe(0);
    expect(segmentTree.rangeQuery(4, 5)).toBe(1);
    expect(segmentTree.rangeQuery(2, 2)).toBe(4);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 63, 'column': 46, 'index': 2493}","it('should do min range query on power of two length array', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(-1);
    expect(segmentTree.rangeQuery(0, 2)).toBe(-1);
    expect(segmentTree.rangeQuery(1, 3)).toBe(0);
    expect(segmentTree.rangeQuery(2, 4)).toBe(0);
    expect(segmentTree.rangeQuery(4, 5)).toBe(1);
    expect(segmentTree.rangeQuery(2, 2)).toBe(4);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 72, 'column': 46, 'index': 2829}","it('should do min range query on not power of two length array', () => {
    const array = [-1, 2, 4, 0];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.rangeQuery(0, 4)).toBe(-1);
    expect(segmentTree.rangeQuery(0, 1)).toBe(-1);
    expect(segmentTree.rangeQuery(1, 3)).toBe(0);
    expect(segmentTree.rangeQuery(1, 2)).toBe(2);
    expect(segmentTree.rangeQuery(2, 3)).toBe(0);
    expect(segmentTree.rangeQuery(2, 2)).toBe(4);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 73, 'column': 46, 'index': 2879}","it('should do min range query on not power of two length array', () => {
    const array = [-1, 2, 4, 0];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.rangeQuery(0, 4)).toBe(-1);
    expect(segmentTree.rangeQuery(0, 1)).toBe(-1);
    expect(segmentTree.rangeQuery(1, 3)).toBe(0);
    expect(segmentTree.rangeQuery(1, 2)).toBe(2);
    expect(segmentTree.rangeQuery(2, 3)).toBe(0);
    expect(segmentTree.rangeQuery(2, 2)).toBe(4);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 74, 'column': 46, 'index': 2929}","it('should do min range query on not power of two length array', () => {
    const array = [-1, 2, 4, 0];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.rangeQuery(0, 4)).toBe(-1);
    expect(segmentTree.rangeQuery(0, 1)).toBe(-1);
    expect(segmentTree.rangeQuery(1, 3)).toBe(0);
    expect(segmentTree.rangeQuery(1, 2)).toBe(2);
    expect(segmentTree.rangeQuery(2, 3)).toBe(0);
    expect(segmentTree.rangeQuery(2, 2)).toBe(4);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 75, 'column': 46, 'index': 2979}","it('should do min range query on not power of two length array', () => {
    const array = [-1, 2, 4, 0];
    const segmentTree = new SegmentTree(array, Math.min, Infinity);

    expect(segmentTree.rangeQuery(0, 4)).toBe(-1);
    expect(segmentTree.rangeQuery(0, 1)).toBe(-1);
    expect(segmentTree.rangeQuery(1, 3)).toBe(0);
    expect(segmentTree.rangeQuery(1, 2)).toBe(2);
    expect(segmentTree.rangeQuery(2, 3)).toBe(0);
    expect(segmentTree.rangeQuery(2, 2)).toBe(4);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 82, 'column': 46, 'index': 3187}","it('should do max range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.max, -Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(4);
    expect(segmentTree.rangeQuery(0, 1)).toBe(3);
    expect(segmentTree.rangeQuery(1, 3)).toBe(4);
    expect(segmentTree.rangeQuery(2, 4)).toBe(4);
    expect(segmentTree.rangeQuery(4, 5)).toBe(2);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 83, 'column': 46, 'index': 3237}","it('should do max range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.max, -Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(4);
    expect(segmentTree.rangeQuery(0, 1)).toBe(3);
    expect(segmentTree.rangeQuery(1, 3)).toBe(4);
    expect(segmentTree.rangeQuery(2, 4)).toBe(4);
    expect(segmentTree.rangeQuery(4, 5)).toBe(2);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 84, 'column': 46, 'index': 3287}","it('should do max range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.max, -Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(4);
    expect(segmentTree.rangeQuery(0, 1)).toBe(3);
    expect(segmentTree.rangeQuery(1, 3)).toBe(4);
    expect(segmentTree.rangeQuery(2, 4)).toBe(4);
    expect(segmentTree.rangeQuery(4, 5)).toBe(2);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 85, 'column': 46, 'index': 3337}","it('should do max range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.max, -Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(4);
    expect(segmentTree.rangeQuery(0, 1)).toBe(3);
    expect(segmentTree.rangeQuery(1, 3)).toBe(4);
    expect(segmentTree.rangeQuery(2, 4)).toBe(4);
    expect(segmentTree.rangeQuery(4, 5)).toBe(2);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 86, 'column': 46, 'index': 3387}","it('should do max range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.max, -Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(4);
    expect(segmentTree.rangeQuery(0, 1)).toBe(3);
    expect(segmentTree.rangeQuery(1, 3)).toBe(4);
    expect(segmentTree.rangeQuery(2, 4)).toBe(4);
    expect(segmentTree.rangeQuery(4, 5)).toBe(2);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 87, 'column': 46, 'index': 3437}","it('should do max range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, Math.max, -Infinity);

    expect(segmentTree.rangeQuery(0, 5)).toBe(4);
    expect(segmentTree.rangeQuery(0, 1)).toBe(3);
    expect(segmentTree.rangeQuery(1, 3)).toBe(4);
    expect(segmentTree.rangeQuery(2, 4)).toBe(4);
    expect(segmentTree.rangeQuery(4, 5)).toBe(2);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 94, 'column': 46, 'index': 3646}","it('should do sum range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, (a, b) => (a + b), 0);

    expect(segmentTree.rangeQuery(0, 5)).toBe(9);
    expect(segmentTree.rangeQuery(0, 1)).toBe(2);
    expect(segmentTree.rangeQuery(1, 3)).toBe(7);
    expect(segmentTree.rangeQuery(2, 4)).toBe(6);
    expect(segmentTree.rangeQuery(4, 5)).toBe(3);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 95, 'column': 46, 'index': 3696}","it('should do sum range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, (a, b) => (a + b), 0);

    expect(segmentTree.rangeQuery(0, 5)).toBe(9);
    expect(segmentTree.rangeQuery(0, 1)).toBe(2);
    expect(segmentTree.rangeQuery(1, 3)).toBe(7);
    expect(segmentTree.rangeQuery(2, 4)).toBe(6);
    expect(segmentTree.rangeQuery(4, 5)).toBe(3);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 96, 'column': 46, 'index': 3746}","it('should do sum range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, (a, b) => (a + b), 0);

    expect(segmentTree.rangeQuery(0, 5)).toBe(9);
    expect(segmentTree.rangeQuery(0, 1)).toBe(2);
    expect(segmentTree.rangeQuery(1, 3)).toBe(7);
    expect(segmentTree.rangeQuery(2, 4)).toBe(6);
    expect(segmentTree.rangeQuery(4, 5)).toBe(3);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 97, 'column': 46, 'index': 3796}","it('should do sum range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, (a, b) => (a + b), 0);

    expect(segmentTree.rangeQuery(0, 5)).toBe(9);
    expect(segmentTree.rangeQuery(0, 1)).toBe(2);
    expect(segmentTree.rangeQuery(1, 3)).toBe(7);
    expect(segmentTree.rangeQuery(2, 4)).toBe(6);
    expect(segmentTree.rangeQuery(4, 5)).toBe(3);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 98, 'column': 46, 'index': 3846}","it('should do sum range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, (a, b) => (a + b), 0);

    expect(segmentTree.rangeQuery(0, 5)).toBe(9);
    expect(segmentTree.rangeQuery(0, 1)).toBe(2);
    expect(segmentTree.rangeQuery(1, 3)).toBe(7);
    expect(segmentTree.rangeQuery(2, 4)).toBe(6);
    expect(segmentTree.rangeQuery(4, 5)).toBe(3);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js,Magic Number,"{'line': 99, 'column': 46, 'index': 3896}","it('should do sum range query', () => {
    const array = [-1, 3, 4, 0, 2, 1];
    const segmentTree = new SegmentTree(array, (a, b) => (a + b), 0);

    expect(segmentTree.rangeQuery(0, 5)).toBe(9);
    expect(segmentTree.rangeQuery(0, 1)).toBe(2);
    expect(segmentTree.rangeQuery(1, 3)).toBe(7);
    expect(segmentTree.rangeQuery(2, 4)).toBe(6);
    expect(segmentTree.rangeQuery(4, 5)).toBe(3);
    expect(segmentTree.rangeQuery(3, 3)).toBe(0);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1439}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1439}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1525}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1525}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1573}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1573}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1656}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1656}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1704}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1704}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1834}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1834}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1882}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1882}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 1930}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 1930}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1978}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1978}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 2061}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 2061}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 2109}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 2109}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 75, 'column': 4, 'index': 2157}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 75, 'column': 4, 'index': 2157}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 76, 'column': 4, 'index': 2205}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 76, 'column': 4, 'index': 2205}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 77, 'column': 4, 'index': 2251}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 77, 'column': 4, 'index': 2251}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2333}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2333}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 82, 'column': 4, 'index': 2381}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 82, 'column': 4, 'index': 2381}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2429}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2429}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2477}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2477}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2523}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2523}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2616}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 89, 'column': 4, 'index': 2672}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 2802}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 2860}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 2899}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 2899}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 99, 'column': 4, 'index': 2947}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 99, 'column': 4, 'index': 2947}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 100, 'column': 4, 'index': 2993}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 100, 'column': 4, 'index': 2993}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 101, 'column': 4, 'index': 3041}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 101, 'column': 4, 'index': 3041}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 102, 'column': 4, 'index': 3089}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 102, 'column': 4, 'index': 3089}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 103, 'column': 4, 'index': 3137}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 103, 'column': 4, 'index': 3137}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 121, 'column': 4, 'index': 3693}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 122, 'column': 4, 'index': 3756}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 122, 'column': 4, 'index': 3756}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 125, 'column': 4, 'index': 3843}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 125, 'column': 4, 'index': 3843}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 126, 'column': 4, 'index': 3889}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 126, 'column': 4, 'index': 3889}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 127, 'column': 4, 'index': 3937}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 127, 'column': 4, 'index': 3937}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 128, 'column': 4, 'index': 3985}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 128, 'column': 4, 'index': 3985}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 129, 'column': 4, 'index': 4033}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 129, 'column': 4, 'index': 4033}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 130, 'column': 4, 'index': 4079}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 130, 'column': 4, 'index': 4079}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 136, 'column': 4, 'index': 4254}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 4319}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 4319}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 141, 'column': 4, 'index': 4406}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 141, 'column': 4, 'index': 4406}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 4500}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 4500}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 4593}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 4593}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 146, 'column': 4, 'index': 4639}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 146, 'column': 4, 'index': 4639}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 147, 'column': 4, 'index': 4685}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 147, 'column': 4, 'index': 4685}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 150, 'column': 4, 'index': 4829}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 150, 'column': 4, 'index': 4829}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 162, 'column': 4, 'index': 5143}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 163, 'column': 4, 'index': 5195}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 163, 'column': 4, 'index': 5195}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 165, 'column': 4, 'index': 5234}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 165, 'column': 4, 'index': 5234}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 166, 'column': 4, 'index': 5282}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 166, 'column': 4, 'index': 5282}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 168, 'column': 4, 'index': 5378}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 168, 'column': 4, 'index': 5378}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 173, 'column': 4, 'index': 5507}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 174, 'column': 4, 'index': 5562}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 174, 'column': 4, 'index': 5562}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 176, 'column': 4, 'index': 5601}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 176, 'column': 4, 'index': 5601}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 177, 'column': 4, 'index': 5649}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 177, 'column': 4, 'index': 5649}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 179, 'column': 4, 'index': 5745}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 179, 'column': 4, 'index': 5745}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 193, 'column': 4, 'index': 6150}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 194, 'column': 4, 'index': 6202}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 194, 'column': 4, 'index': 6202}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 196, 'column': 4, 'index': 6241}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 196, 'column': 4, 'index': 6241}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 197, 'column': 4, 'index': 6289}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 197, 'column': 4, 'index': 6289}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 199, 'column': 4, 'index': 6385}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 199, 'column': 4, 'index': 6385}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 200, 'column': 4, 'index': 6431}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 200, 'column': 4, 'index': 6431}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 204, 'column': 4, 'index': 6514}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 205, 'column': 4, 'index': 6569}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 205, 'column': 4, 'index': 6569}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 207, 'column': 4, 'index': 6608}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 207, 'column': 4, 'index': 6608}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 208, 'column': 4, 'index': 6656}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 208, 'column': 4, 'index': 6656}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 210, 'column': 4, 'index': 6752}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 210, 'column': 4, 'index': 6752}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 211, 'column': 4, 'index': 6798}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 211, 'column': 4, 'index': 6798}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 228, 'column': 4, 'index': 7322}","it('should do recoloring, left-left and left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(30);
    const node8 = tree.insert(1);
    const node9 = tree.insert(9);

    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 229, 'column': 4, 'index': 7385}","it('should do recoloring, left-left and left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(30);
    const node8 = tree.insert(1);
    const node9 = tree.insert(9);

    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 229, 'column': 4, 'index': 7385}","it('should do recoloring, left-left and left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(30);
    const node8 = tree.insert(1);
    const node9 = tree.insert(9);

    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 243, 'column': 4, 'index': 7868}","it('should do recoloring, left-left and left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(30);
    const node8 = tree.insert(1);
    const node9 = tree.insert(9);

    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 244, 'column': 4, 'index': 7933}","it('should do recoloring, left-left and left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(30);
    const node8 = tree.insert(1);
    const node9 = tree.insert(9);

    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 244, 'column': 4, 'index': 7933}","it('should do recoloring, left-left and left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(30);
    const node8 = tree.insert(1);
    const node9 = tree.insert(9);

    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 257, 'column': 4, 'index': 8274}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 258, 'column': 4, 'index': 8330}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 258, 'column': 4, 'index': 8330}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 260, 'column': 4, 'index': 8369}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 260, 'column': 4, 'index': 8369}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 261, 'column': 4, 'index': 8417}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 261, 'column': 4, 'index': 8417}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 263, 'column': 4, 'index': 8513}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 263, 'column': 4, 'index': 8513}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 264, 'column': 4, 'index': 8559}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 264, 'column': 4, 'index': 8559}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 265, 'column': 4, 'index': 8605}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 265, 'column': 4, 'index': 8605}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 277, 'column': 4, 'index': 8965}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 278, 'column': 4, 'index': 9024}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 278, 'column': 4, 'index': 9024}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 280, 'column': 4, 'index': 9063}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 280, 'column': 4, 'index': 9063}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 281, 'column': 4, 'index': 9111}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 281, 'column': 4, 'index': 9111}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 283, 'column': 4, 'index': 9207}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 283, 'column': 4, 'index': 9207}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 284, 'column': 4, 'index': 9253}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 284, 'column': 4, 'index': 9253}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 286, 'column': 4, 'index': 9345}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Duplicate Assert,"{'line': 286, 'column': 4, 'index': 9345}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 14, 'column': 34, 'index': 485}","it('should always color first inserted node as black', () => {
    const tree = new RedBlackTree();

    const firstInsertedNode = tree.insert(10);

    expect(tree.isNodeColored(firstInsertedNode)).toBe(true);
    expect(tree.isNodeBlack(firstInsertedNode)).toBe(true);
    expect(tree.isNodeRed(firstInsertedNode)).toBe(false);

    expect(tree.toString()).toBe('10');
    expect(tree.root.height).toBe(0);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 29, 'column': 34, 'index': 990}","it('should always color new leaf node as red', () => {
    const tree = new RedBlackTree();

    const firstInsertedNode = tree.insert(10);
    const secondInsertedNode = tree.insert(15);
    const thirdInsertedNode = tree.insert(5);

    expect(tree.isNodeBlack(firstInsertedNode)).toBe(true);
    expect(tree.isNodeRed(secondInsertedNode)).toBe(true);
    expect(tree.isNodeRed(thirdInsertedNode)).toBe(true);

    expect(tree.toString()).toBe('5,10,15');
    expect(tree.root.height).toBe(1);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 43, 'column': 34, 'index': 1291}","it('should balance itself', () => {
    const tree = new RedBlackTree();

    tree.insert(5);
    tree.insert(10);
    tree.insert(15);
    tree.insert(20);
    tree.insert(25);
    tree.insert(30);

    expect(tree.toString()).toBe('5,10,15,20,25,30');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 89, 'column': 34, 'index': 2702}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 96, 'column': 34, 'index': 2890}","it('should balance itself when parent is black', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);

    expect(tree.isNodeBlack(node1)).toBe(true);

    const node2 = tree.insert(-10);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);

    const node3 = tree.insert(20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);

    const node4 = tree.insert(-20);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);

    const node5 = tree.insert(25);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(6);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
    expect(tree.root.height).toBe(2);

    const node7 = tree.insert(4);

    expect(tree.root.left.value).toEqual(node2.value);

    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 122, 'column': 34, 'index': 3786}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 137, 'column': 34, 'index': 4349}","it('should balance itself when uncle is red', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(25);
    const node8 = tree.insert(2);
    const node9 = tree.insert(8);

    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    const node10 = tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
    expect(tree.root.height).toBe(3);

    expect(tree.root.value).toBe(node5.value);

    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeRed(node10)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node8)).toBe(true);
    expect(tree.isNodeBlack(node9)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 163, 'column': 34, 'index': 5225}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 174, 'column': 34, 'index': 5592}","it('should do left-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(13);

    expect(tree.toString()).toBe('-10,7,10,13,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 194, 'column': 34, 'index': 6232}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 205, 'column': 34, 'index': 6599}","it('should do left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(7);
    const node5 = tree.insert(15);

    expect(tree.toString()).toBe('-10,7,10,15,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);

    const node6 = tree.insert(17);

    expect(tree.toString()).toBe('-10,7,10,15,17,20');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node6)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 229, 'column': 34, 'index': 7415}","it('should do recoloring, left-left and left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(30);
    const node8 = tree.insert(1);
    const node9 = tree.insert(9);

    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 244, 'column': 34, 'index': 7963}","it('should do recoloring, left-left and left-right rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(15);
    const node7 = tree.insert(30);
    const node8 = tree.insert(1);
    const node9 = tree.insert(9);

    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeRed(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeBlack(node4)).toBe(true);
    expect(tree.isNodeBlack(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
    expect(tree.isNodeRed(node7)).toBe(true);
    expect(tree.isNodeRed(node8)).toBe(true);
    expect(tree.isNodeRed(node9)).toBe(true);

    tree.insert(4);

    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 258, 'column': 34, 'index': 8360}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 278, 'column': 34, 'index': 9054}","it('should do right-left rotation', () => {
    const tree = new RedBlackTree();

    const node1 = tree.insert(10);
    const node2 = tree.insert(-10);
    const node3 = tree.insert(20);
    const node4 = tree.insert(-20);
    const node5 = tree.insert(6);
    const node6 = tree.insert(30);

    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node3)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);

    const node7 = tree.insert(25);

    const rightNode = tree.root.right;
    const rightLeftNode = rightNode.left;
    const rightRightNode = rightNode.right;

    expect(rightNode.value).toBe(node7.value);
    expect(rightLeftNode.value).toBe(node3.value);
    expect(rightRightNode.value).toBe(node6.value);

    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
    expect(tree.root.height).toBe(2);

    expect(tree.isNodeBlack(node1)).toBe(true);
    expect(tree.isNodeBlack(node2)).toBe(true);
    expect(tree.isNodeBlack(node7)).toBe(true);
    expect(tree.isNodeRed(node4)).toBe(true);
    expect(tree.isNodeRed(node5)).toBe(true);
    expect(tree.isNodeRed(node3)).toBe(true);
    expect(tree.isNodeRed(node6)).toBe(true);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 299, 'column': 34, 'index': 9690}","it('should do left-left rotation with left grand-parent', () => {
    const tree = new RedBlackTree();

    tree.insert(20);
    tree.insert(15);
    tree.insert(25);
    tree.insert(10);
    tree.insert(5);

    expect(tree.toString()).toBe('5,10,15,20,25');
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js,Magic Number,"{'line': 312, 'column': 34, 'index': 10001}","it('should do right-right rotation with left grand-parent', () => {
    const tree = new RedBlackTree();

    tree.insert(20);
    tree.insert(15);
    tree.insert(25);
    tree.insert(17);
    tree.insert(19);

    expect(tree.toString()).toBe('15,17,19,20,25');
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Conditional Test Logic,"{'line': 8, 'column': 4, 'index': 231}","it('should create empty fenwick tree of correct size', () => {
    const tree1 = new FenwickTree(5);
    expect(tree1.treeArray.length).toBe(5 + 1);

    for (let i = 0; i < 5; i += 1) {
      expect(tree1.treeArray[i]).toBe(0);
    }

    const tree2 = new FenwickTree(50);
    expect(tree2.treeArray.length).toBe(50 + 1);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 811}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 811}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 846}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 846}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 881}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 916}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 32, 'column': 4, 'index': 952}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 988}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1024}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1060}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 1096}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 1132}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 1169}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1207}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1207}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1250}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1250}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1293}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1336}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1336}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1407}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1407}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1442}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1442}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1477}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 50, 'column': 4, 'index': 1512}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1548}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1584}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1620}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1656}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1692}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1728}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 1765}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1803}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1803}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1846}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1846}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1889}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1932}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1932}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 2192}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 77, 'column': 4, 'index': 2297}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2402}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 9, 'column': 38, 'index': 302}","it('should create empty fenwick tree of correct size', () => {
    const tree1 = new FenwickTree(5);
    expect(tree1.treeArray.length).toBe(5 + 1);

    for (let i = 0; i < 5; i += 1) {
      expect(tree1.treeArray[i]).toBe(0);
    }

    const tree2 = new FenwickTree(50);
    expect(tree2.treeArray.length).toBe(50 + 1);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 28, 'column': 31, 'index': 838}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 29, 'column': 31, 'index': 873}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 30, 'column': 31, 'index': 908}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 31, 'column': 31, 'index': 943}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 32, 'column': 31, 'index': 979}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 33, 'column': 31, 'index': 1015}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 34, 'column': 31, 'index': 1051}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 35, 'column': 31, 'index': 1087}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 36, 'column': 31, 'index': 1123}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 37, 'column': 32, 'index': 1160}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 38, 'column': 32, 'index': 1197}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 40, 'column': 39, 'index': 1242}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 41, 'column': 39, 'index': 1285}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 42, 'column': 39, 'index': 1328}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 43, 'column': 39, 'index': 1371}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 47, 'column': 31, 'index': 1434}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 48, 'column': 31, 'index': 1469}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 49, 'column': 31, 'index': 1504}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 50, 'column': 31, 'index': 1539}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 51, 'column': 31, 'index': 1575}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 52, 'column': 31, 'index': 1611}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 53, 'column': 31, 'index': 1647}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 54, 'column': 31, 'index': 1683}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 55, 'column': 31, 'index': 1719}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 56, 'column': 32, 'index': 1756}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 57, 'column': 32, 'index': 1793}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 59, 'column': 39, 'index': 1838}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 60, 'column': 39, 'index': 1881}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 61, 'column': 39, 'index': 1924}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 62, 'column': 39, 'index': 1967}","it('should create correct fenwick tree', () => {
    const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];

    const tree = new FenwickTree(inputArray.length);
    expect(tree.treeArray.length).toBe(inputArray.length + 1);

    inputArray.forEach((value, index) => {
      tree.increase(index + 1, value);
    });

    expect(tree.treeArray).toEqual([0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9, 3]);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(4);
    expect(tree.query(4)).toBe(10);
    expect(tree.query(5)).toBe(15);
    expect(tree.query(6)).toBe(19);
    expect(tree.query(7)).toBe(16);
    expect(tree.query(8)).toBe(19);
    expect(tree.query(9)).toBe(26);
    expect(tree.query(10)).toBe(28);
    expect(tree.query(11)).toBe(31);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(7);
    expect(tree.queryRange(6, 9)).toBe(11);

    tree.increase(3, 1);

    expect(tree.query(1)).toBe(3);
    expect(tree.query(2)).toBe(5);
    expect(tree.query(3)).toBe(5);
    expect(tree.query(4)).toBe(11);
    expect(tree.query(5)).toBe(16);
    expect(tree.query(6)).toBe(20);
    expect(tree.query(7)).toBe(17);
    expect(tree.query(8)).toBe(20);
    expect(tree.query(9)).toBe(27);
    expect(tree.query(10)).toBe(29);
    expect(tree.query(11)).toBe(32);

    expect(tree.queryRange(1, 1)).toBe(3);
    expect(tree.queryRange(1, 2)).toBe(5);
    expect(tree.queryRange(2, 4)).toBe(8);
    expect(tree.queryRange(6, 9)).toBe(11);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 71, 'column': 31, 'index': 2148}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 72, 'column': 31, 'index': 2183}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 73, 'column': 31, 'index': 2219}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 74, 'column': 39, 'index': 2263}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 77, 'column': 31, 'index': 2324}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 80, 'column': 39, 'index': 2394}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 81, 'column': 31, 'index': 2429}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js,Magic Number,"{'line': 82, 'column': 39, 'index': 2473}","it('should correctly execute queries', () => {
    const tree = new FenwickTree(5);

    tree.increase(1, 4);
    tree.increase(3, 7);

    expect(tree.query(1)).toBe(4);
    expect(tree.query(3)).toBe(11);
    expect(tree.query(5)).toBe(11);
    expect(tree.queryRange(2, 3)).toBe(7);

    tree.increase(2, 5);
    expect(tree.query(5)).toBe(16);

    tree.increase(1, 3);
    expect(tree.queryRange(1, 1)).toBe(7);
    expect(tree.query(5)).toBe(19);
    expect(tree.queryRange(1, 5)).toBe(19);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Conditional Test Logic,"{'line': 221, 'column': 6, 'index': 6123}","it('should be possible to use objects as node values', () => {
    const nodeValueComparatorCallback = (a, b) => {
      const normalizedA = a || { value: null };
      const normalizedB = b || { value: null };

      if (normalizedA.value === normalizedB.value) {
        return 0;
      }

      return normalizedA.value < normalizedB.value ? -1 : 1;
    };

    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };

    const bstNode = new BinarySearchTreeNode(obj2, nodeValueComparatorCallback);
    bstNode.insert(obj1);

    expect(bstNode.toString()).toBe('obj1,obj2');
    expect(bstNode.contains(obj1)).toBe(true);
    expect(bstNode.contains(obj3)).toBe(false);

    bstNode.insert(obj3);

    expect(bstNode.toString()).toBe('obj1,obj2,obj3');
    expect(bstNode.contains(obj3)).toBe(true);

    expect(bstNode.findMin().value).toEqual(obj1);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 755}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 843}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 976}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1022}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1066}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1136}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1228}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1228}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1298}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1348}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1392}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1392}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1462}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1558}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1558}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1728}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1728}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1772}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1772}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1816}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1816}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1886}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1886}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1930}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1930}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 1974}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 1974}","it('should not insert duplicates', () => {
    const bstNode = new BinarySearchTreeNode(2);
    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    bstNode.insert(1);

    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 126, 'column': 4, 'index': 3437}","it('should remove leaf nodes', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);

    expect(bstRootNode.toString()).toBe('5,10,20');

    const removed1 = bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('10,20');
    expect(removed1).toBe(true);

    const removed2 = bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('10');
    expect(removed2).toBe(true);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 129, 'column': 4, 'index': 3534}","it('should remove leaf nodes', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);

    expect(bstRootNode.toString()).toBe('5,10,20');

    const removed1 = bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('10,20');
    expect(removed1).toBe(true);

    const removed2 = bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('10');
    expect(removed2).toBe(true);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 133, 'column': 4, 'index': 3663}","it('should remove leaf nodes', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);

    expect(bstRootNode.toString()).toBe('5,10,20');

    const removed1 = bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('10,20');
    expect(removed1).toBe(true);

    const removed2 = bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('10');
    expect(removed2).toBe(true);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 3966}","it('should remove nodes with one child', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);

    expect(bstRootNode.toString()).toBe('5,10,20,30');

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,30');

    bstRootNode.insert(1);
    expect(bstRootNode.toString()).toBe('1,5,10,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('1,10,30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 148, 'column': 4, 'index': 4050}","it('should remove nodes with one child', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);

    expect(bstRootNode.toString()).toBe('5,10,20,30');

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,30');

    bstRootNode.insert(1);
    expect(bstRootNode.toString()).toBe('1,5,10,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('1,10,30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 151, 'column': 4, 'index': 4130}","it('should remove nodes with one child', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);

    expect(bstRootNode.toString()).toBe('5,10,20,30');

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,30');

    bstRootNode.insert(1);
    expect(bstRootNode.toString()).toBe('1,5,10,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('1,10,30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 154, 'column': 4, 'index': 4212}","it('should remove nodes with one child', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);

    expect(bstRootNode.toString()).toBe('5,10,20,30');

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,30');

    bstRootNode.insert(1);
    expect(bstRootNode.toString()).toBe('1,5,10,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('1,10,30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 167, 'column': 4, 'index': 4546}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 172, 'column': 4, 'index': 4745}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 175, 'column': 4, 'index': 4832}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 178, 'column': 4, 'index': 4916}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 182, 'column': 4, 'index': 5037}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 185, 'column': 4, 'index': 5114}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 190, 'column': 4, 'index': 5270}","it('should remove node with no parent', () => {
    const bstRootNode = new BinarySearchTreeNode();
    expect(bstRootNode.toString()).toBe('');

    bstRootNode.insert(1);
    bstRootNode.insert(2);
    expect(bstRootNode.toString()).toBe('1,2');

    bstRootNode.remove(1);
    expect(bstRootNode.toString()).toBe('2');

    bstRootNode.remove(2);
    expect(bstRootNode.toString()).toBe('');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 190, 'column': 4, 'index': 5270}","it('should remove node with no parent', () => {
    const bstRootNode = new BinarySearchTreeNode();
    expect(bstRootNode.toString()).toBe('');

    bstRootNode.insert(1);
    bstRootNode.insert(2);
    expect(bstRootNode.toString()).toBe('1,2');

    bstRootNode.remove(1);
    expect(bstRootNode.toString()).toBe('2');

    bstRootNode.remove(2);
    expect(bstRootNode.toString()).toBe('');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 194, 'column': 4, 'index': 5370}","it('should remove node with no parent', () => {
    const bstRootNode = new BinarySearchTreeNode();
    expect(bstRootNode.toString()).toBe('');

    bstRootNode.insert(1);
    bstRootNode.insert(2);
    expect(bstRootNode.toString()).toBe('1,2');

    bstRootNode.remove(1);
    expect(bstRootNode.toString()).toBe('2');

    bstRootNode.remove(2);
    expect(bstRootNode.toString()).toBe('');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 197, 'column': 4, 'index': 5446}","it('should remove node with no parent', () => {
    const bstRootNode = new BinarySearchTreeNode();
    expect(bstRootNode.toString()).toBe('');

    bstRootNode.insert(1);
    bstRootNode.insert(2);
    expect(bstRootNode.toString()).toBe('1,2');

    bstRootNode.remove(1);
    expect(bstRootNode.toString()).toBe('2');

    bstRootNode.remove(2);
    expect(bstRootNode.toString()).toBe('');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 200, 'column': 4, 'index': 5520}","it('should remove node with no parent', () => {
    const bstRootNode = new BinarySearchTreeNode();
    expect(bstRootNode.toString()).toBe('');

    bstRootNode.insert(1);
    bstRootNode.insert(2);
    expect(bstRootNode.toString()).toBe('1,2');

    bstRootNode.remove(1);
    expect(bstRootNode.toString()).toBe('2');

    bstRootNode.remove(2);
    expect(bstRootNode.toString()).toBe('');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 200, 'column': 4, 'index': 5520}","it('should remove node with no parent', () => {
    const bstRootNode = new BinarySearchTreeNode();
    expect(bstRootNode.toString()).toBe('');

    bstRootNode.insert(1);
    bstRootNode.insert(2);
    expect(bstRootNode.toString()).toBe('1,2');

    bstRootNode.remove(1);
    expect(bstRootNode.toString()).toBe('2');

    bstRootNode.remove(2);
    expect(bstRootNode.toString()).toBe('');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 235, 'column': 4, 'index': 6583}","it('should be possible to use objects as node values', () => {
    const nodeValueComparatorCallback = (a, b) => {
      const normalizedA = a || { value: null };
      const normalizedB = b || { value: null };

      if (normalizedA.value === normalizedB.value) {
        return 0;
      }

      return normalizedA.value < normalizedB.value ? -1 : 1;
    };

    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };

    const bstNode = new BinarySearchTreeNode(obj2, nodeValueComparatorCallback);
    bstNode.insert(obj1);

    expect(bstNode.toString()).toBe('obj1,obj2');
    expect(bstNode.contains(obj1)).toBe(true);
    expect(bstNode.contains(obj3)).toBe(false);

    bstNode.insert(obj3);

    expect(bstNode.toString()).toBe('obj1,obj2,obj3');
    expect(bstNode.contains(obj3)).toBe(true);

    expect(bstNode.findMin().value).toEqual(obj1);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 237, 'column': 4, 'index': 6680}","it('should be possible to use objects as node values', () => {
    const nodeValueComparatorCallback = (a, b) => {
      const normalizedA = a || { value: null };
      const normalizedB = b || { value: null };

      if (normalizedA.value === normalizedB.value) {
        return 0;
      }

      return normalizedA.value < normalizedB.value ? -1 : 1;
    };

    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };

    const bstNode = new BinarySearchTreeNode(obj2, nodeValueComparatorCallback);
    bstNode.insert(obj1);

    expect(bstNode.toString()).toBe('obj1,obj2');
    expect(bstNode.contains(obj1)).toBe(true);
    expect(bstNode.contains(obj3)).toBe(false);

    bstNode.insert(obj3);

    expect(bstNode.toString()).toBe('obj1,obj2,obj3');
    expect(bstNode.contains(obj3)).toBe(true);

    expect(bstNode.findMin().value).toEqual(obj1);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 241, 'column': 4, 'index': 6756}","it('should be possible to use objects as node values', () => {
    const nodeValueComparatorCallback = (a, b) => {
      const normalizedA = a || { value: null };
      const normalizedB = b || { value: null };

      if (normalizedA.value === normalizedB.value) {
        return 0;
      }

      return normalizedA.value < normalizedB.value ? -1 : 1;
    };

    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };

    const bstNode = new BinarySearchTreeNode(obj2, nodeValueComparatorCallback);
    bstNode.insert(obj1);

    expect(bstNode.toString()).toBe('obj1,obj2');
    expect(bstNode.contains(obj1)).toBe(true);
    expect(bstNode.contains(obj3)).toBe(false);

    bstNode.insert(obj3);

    expect(bstNode.toString()).toBe('obj1,obj2,obj3');
    expect(bstNode.contains(obj3)).toBe(true);

    expect(bstNode.findMin().value).toEqual(obj1);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Duplicate Assert,"{'line': 242, 'column': 4, 'index': 6811}","it('should be possible to use objects as node values', () => {
    const nodeValueComparatorCallback = (a, b) => {
      const normalizedA = a || { value: null };
      const normalizedB = b || { value: null };

      if (normalizedA.value === normalizedB.value) {
        return 0;
      }

      return normalizedA.value < normalizedB.value ? -1 : 1;
    };

    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };

    const bstNode = new BinarySearchTreeNode(obj2, nodeValueComparatorCallback);
    bstNode.insert(obj1);

    expect(bstNode.toString()).toBe('obj1,obj2');
    expect(bstNode.contains(obj1)).toBe(true);
    expect(bstNode.contains(obj3)).toBe(false);

    bstNode.insert(obj3);

    expect(bstNode.toString()).toBe('obj1,obj2,obj3');
    expect(bstNode.contains(obj3)).toBe(true);

    expect(bstNode.findMin().value).toEqual(obj1);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 7, 'column': 31, 'index': 232}","it('should create binary search tree', () => {
    const bstNode = new BinarySearchTreeNode(2);

    expect(bstNode.value).toBe(2);
    expect(bstNode.left).toBeNull();
    expect(bstNode.right).toBeNull();
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 16, 'column': 31, 'index': 476}","it('should insert in itself if it is empty', () => {
    const bstNode = new BinarySearchTreeNode();
    bstNode.insert(1);

    expect(bstNode.value).toBe(1);
    expect(bstNode.left).toBeNull();
    expect(bstNode.right).toBeNull();
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 25, 'column': 37, 'index': 747}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 32, 'column': 37, 'index': 968}","it('should insert nodes in correct order', () => {
    const bstNode = new BinarySearchTreeNode(2);
    const insertedNode1 = bstNode.insert(1);

    expect(insertedNode1.value).toBe(1);
    expect(bstNode.toString()).toBe('1,2');
    expect(bstNode.contains(1)).toBe(true);
    expect(bstNode.contains(3)).toBe(false);

    const insertedNode2 = bstNode.insert(3);

    expect(insertedNode2.value).toBe(3);
    expect(bstNode.toString()).toBe('1,2,3');
    expect(bstNode.contains(3)).toBe(true);
    expect(bstNode.contains(4)).toBe(false);

    bstNode.insert(7);

    expect(bstNode.toString()).toBe('1,2,3,7');
    expect(bstNode.contains(7)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(4);

    expect(bstNode.toString()).toBe('1,2,3,4,7');
    expect(bstNode.contains(4)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);

    bstNode.insert(6);

    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
    expect(bstNode.contains(6)).toBe(true);
    expect(bstNode.contains(8)).toBe(false);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 81, 'column': 38, 'index': 2292}","it('should find min node', () => {
    const node = new BinarySearchTreeNode(10);

    node.insert(20);
    node.insert(30);
    node.insert(5);
    node.insert(40);
    node.insert(1);

    expect(node.findMin()).not.toBeNull();
    expect(node.findMin().value).toBe(1);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 100, 'column': 38, 'index': 2815}","it('should be possible to attach meta information to binary search tree nodes', () => {
    const node = new BinarySearchTreeNode(10);

    node.insert(20);
    const node1 = node.insert(30);
    node.insert(5);
    node.insert(40);
    const node2 = node.insert(1);

    node.meta.set('color', 'red');
    node1.meta.set('color', 'black');
    node2.meta.set('color', 'white');

    expect(node.meta.get('color')).toBe('red');

    expect(node.findMin()).not.toBeNull();
    expect(node.findMin().value).toBe(1);
    expect(node.findMin().meta.get('color')).toBe('white');
    expect(node.find(30).meta.get('color')).toBe('black');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 116, 'column': 36, 'index': 3244}","it('should find node', () => {
    const node = new BinarySearchTreeNode(10);

    node.insert(20);
    node.insert(30);
    node.insert(5);
    node.insert(40);
    node.insert(1);

    expect(node.find(6)).toBeNull();
    expect(node.find(5)).not.toBeNull();
    expect(node.find(5).value).toBe(5);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 168, 'column': 49, 'index': 4652}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 169, 'column': 50, 'index': 4707}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js,Magic Number,"{'line': 179, 'column': 35, 'index': 4999}","it('should remove nodes with two children', () => {
    const bstRootNode = new BinarySearchTreeNode();

    bstRootNode.insert(10);
    bstRootNode.insert(20);
    bstRootNode.insert(5);
    bstRootNode.insert(30);
    bstRootNode.insert(15);
    bstRootNode.insert(25);

    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
    expect(bstRootNode.find(20).left.value).toBe(15);
    expect(bstRootNode.find(20).right.value).toBe(30);

    bstRootNode.remove(20);
    expect(bstRootNode.toString()).toBe('5,10,15,25,30');

    bstRootNode.remove(15);
    expect(bstRootNode.toString()).toBe('5,10,25,30');

    bstRootNode.remove(10);
    expect(bstRootNode.toString()).toBe('5,25,30');
    expect(bstRootNode.value).toBe(25);

    bstRootNode.remove(25);
    expect(bstRootNode.toString()).toBe('5,30');

    bstRootNode.remove(5);
    expect(bstRootNode.toString()).toBe('30');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Conditional Test Logic,"{'line': 60, 'column': 6, 'index': 1529}","it('should insert object values', () => {
    const nodeValueCompareFunction = (a, b) => {
      const normalizedA = a || { value: null };
      const normalizedB = b || { value: null };

      if (normalizedA.value === normalizedB.value) {
        return 0;
      }

      return normalizedA.value < normalizedB.value ? -1 : 1;
    };

    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };

    const bst = new BinarySearchTree(nodeValueCompareFunction);

    bst.insert(obj2);
    bst.insert(obj3);
    bst.insert(obj1);

    expect(bst.toString()).toBe('obj1,obj2,obj3');
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1064}","it('should remove nodes', () => {
    const bst = new BinarySearchTree();

    bst.insert(10);
    bst.insert(20);
    bst.insert(5);

    expect(bst.toString()).toBe('5,10,20');

    const removed1 = bst.remove(5);
    expect(bst.toString()).toBe('10,20');
    expect(removed1).toBe(true);

    const removed2 = bst.remove(20);
    expect(bst.toString()).toBe('10');
    expect(removed2).toBe(true);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1145}","it('should remove nodes', () => {
    const bst = new BinarySearchTree();

    bst.insert(10);
    bst.insert(20);
    bst.insert(5);

    expect(bst.toString()).toBe('5,10,20');

    const removed1 = bst.remove(5);
    expect(bst.toString()).toBe('10,20');
    expect(removed1).toBe(true);

    const removed2 = bst.remove(20);
    expect(bst.toString()).toBe('10');
    expect(removed2).toBe(true);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1258}","it('should remove nodes', () => {
    const bst = new BinarySearchTree();

    bst.insert(10);
    bst.insert(20);
    bst.insert(5);

    expect(bst.toString()).toBe('5,10,20');

    const removed1 = bst.remove(5);
    expect(bst.toString()).toBe('10,20');
    expect(removed1).toBe(true);

    const removed2 = bst.remove(20);
    expect(bst.toString()).toBe('10');
    expect(removed2).toBe(true);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2286}","it('should be traversed to sorted array', () => {
    const bst = new BinarySearchTree();

    bst.insert(10);
    bst.insert(-10);
    bst.insert(20);
    bst.insert(-20);
    bst.insert(25);
    bst.insert(6);

    expect(bst.toString()).toBe('-20,-10,6,10,20,25');
    expect(bst.root.height).toBe(2);

    bst.insert(4);

    expect(bst.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(bst.root.height).toBe(3);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Duplicate Assert,"{'line': 91, 'column': 4, 'index': 2341}","it('should be traversed to sorted array', () => {
    const bst = new BinarySearchTree();

    bst.insert(10);
    bst.insert(-10);
    bst.insert(20);
    bst.insert(-20);
    bst.insert(25);
    bst.insert(6);

    expect(bst.toString()).toBe('-20,-10,6,10,20,25');
    expect(bst.root.height).toBe(2);

    bst.insert(4);

    expect(bst.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(bst.root.height).toBe(3);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 2399}","it('should be traversed to sorted array', () => {
    const bst = new BinarySearchTree();

    bst.insert(10);
    bst.insert(-10);
    bst.insert(20);
    bst.insert(-20);
    bst.insert(25);
    bst.insert(6);

    expect(bst.toString()).toBe('-20,-10,6,10,20,25');
    expect(bst.root.height).toBe(2);

    bst.insert(4);

    expect(bst.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(bst.root.height).toBe(3);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 2456}","it('should be traversed to sorted array', () => {
    const bst = new BinarySearchTree();

    bst.insert(10);
    bst.insert(-10);
    bst.insert(20);
    bst.insert(-20);
    bst.insert(25);
    bst.insert(6);

    expect(bst.toString()).toBe('-20,-10,6,10,20,25');
    expect(bst.root.height).toBe(2);

    bst.insert(4);

    expect(bst.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(bst.root.height).toBe(3);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Magic Number,"{'line': 22, 'column': 37, 'index': 633}","it('should insert values', () => {
    const bst = new BinarySearchTree();

    const insertedNode1 = bst.insert(10);
    const insertedNode2 = bst.insert(20);
    bst.insert(5);

    expect(bst.toString()).toBe('5,10,20');
    expect(insertedNode1.value).toBe(10);
    expect(insertedNode2.value).toBe(20);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Magic Number,"{'line': 23, 'column': 37, 'index': 675}","it('should insert values', () => {
    const bst = new BinarySearchTree();

    const insertedNode1 = bst.insert(10);
    const insertedNode2 = bst.insert(20);
    bst.insert(5);

    expect(bst.toString()).toBe('5,10,20');
    expect(insertedNode1.value).toBe(10);
    expect(insertedNode2.value).toBe(20);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Magic Number,"{'line': 91, 'column': 33, 'index': 2370}","it('should be traversed to sorted array', () => {
    const bst = new BinarySearchTree();

    bst.insert(10);
    bst.insert(-10);
    bst.insert(20);
    bst.insert(-20);
    bst.insert(25);
    bst.insert(6);

    expect(bst.toString()).toBe('-20,-10,6,10,20,25');
    expect(bst.root.height).toBe(2);

    bst.insert(4);

    expect(bst.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(bst.root.height).toBe(3);
  })",steel
/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js,Magic Number,"{'line': 96, 'column': 33, 'index': 2485}","it('should be traversed to sorted array', () => {
    const bst = new BinarySearchTree();

    bst.insert(10);
    bst.insert(-10);
    bst.insert(20);
    bst.insert(-20);
    bst.insert(25);
    bst.insert(6);

    expect(bst.toString()).toBe('-20,-10,6,10,20,25');
    expect(bst.root.height).toBe(2);

    bst.insert(4);

    expect(bst.toString()).toBe('-20,-10,4,6,10,20,25');
    expect(bst.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 213}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 12, 'column': 4, 'index': 256}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 12, 'column': 4, 'index': 256}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 293}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 353}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 18, 'column': 4, 'index': 398}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 18, 'column': 4, 'index': 398}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 435}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 435}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 495}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 24, 'column': 4, 'index': 542}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 24, 'column': 4, 'index': 542}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 621}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 621}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 837}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 837}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 875}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 875}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 913}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 984}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 984}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1022}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1022}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1060}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1133}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1171}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1171}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1209}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1418}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1461}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1461}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1498}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 65, 'column': 4, 'index': 1558}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1603}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1603}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1640}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1640}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 1700}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 1747}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 1747}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 1827}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 1827}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2045}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2045}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2083}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2083}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2121}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2192}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2192}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 91, 'column': 4, 'index': 2230}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 91, 'column': 4, 'index': 2230}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 2268}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 2342}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 2380}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 2380}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 97, 'column': 4, 'index': 2418}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 132, 'column': 4, 'index': 3235}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 132, 'column': 4, 'index': 3235}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 133, 'column': 4, 'index': 3272}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 134, 'column': 4, 'index': 3310}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 138, 'column': 4, 'index': 3375}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 138, 'column': 4, 'index': 3375}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 139, 'column': 4, 'index': 3412}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 139, 'column': 4, 'index': 3412}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 140, 'column': 4, 'index': 3450}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 3518}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 3518}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 3555}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 3555}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 146, 'column': 4, 'index': 3593}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 150, 'column': 4, 'index': 3664}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 150, 'column': 4, 'index': 3664}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 151, 'column': 4, 'index': 3701}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 151, 'column': 4, 'index': 3701}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 152, 'column': 4, 'index': 3739}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 156, 'column': 4, 'index': 3813}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 156, 'column': 4, 'index': 3813}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 157, 'column': 4, 'index': 3850}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 157, 'column': 4, 'index': 3850}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 158, 'column': 4, 'index': 3888}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 162, 'column': 4, 'index': 3965}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 162, 'column': 4, 'index': 3965}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 163, 'column': 4, 'index': 4002}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 164, 'column': 4, 'index': 4040}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 178, 'column': 4, 'index': 4371}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 178, 'column': 4, 'index': 4371}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 179, 'column': 4, 'index': 4409}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 179, 'column': 4, 'index': 4409}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 180, 'column': 4, 'index': 4447}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 184, 'column': 4, 'index': 4522}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 184, 'column': 4, 'index': 4522}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 185, 'column': 4, 'index': 4560}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 185, 'column': 4, 'index': 4560}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 186, 'column': 4, 'index': 4598}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 202, 'column': 4, 'index': 4961}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(5);
    tree.insert(12);

    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);

    tree.insert(11);

    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 203, 'column': 4, 'index': 5024}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(5);
    tree.insert(12);

    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);

    tree.insert(11);

    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 203, 'column': 4, 'index': 5024}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(5);
    tree.insert(12);

    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);

    tree.insert(11);

    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 207, 'column': 4, 'index': 5085}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(5);
    tree.insert(12);

    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);

    tree.insert(11);

    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 208, 'column': 4, 'index': 5151}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(5);
    tree.insert(12);

    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);

    tree.insert(11);

    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 208, 'column': 4, 'index': 5151}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(5);
    tree.insert(12);

    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);

    tree.insert(11);

    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 224, 'column': 4, 'index': 5498}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 225, 'column': 4, 'index': 5562}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 225, 'column': 4, 'index': 5562}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 229, 'column': 4, 'index': 5623}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 230, 'column': 4, 'index': 5690}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 230, 'column': 4, 'index': 5690}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 241, 'column': 4, 'index': 5930}","it('should remove values from the tree with right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(40);

    expect(tree.toString()).toBe('10,20,30,40');

    tree.remove(10);

    expect(tree.toString()).toBe('20,30,40');
    expect(tree.root.value).toBe(30);
    expect(tree.root.left.value).toBe(20);
    expect(tree.root.right.value).toBe(40);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 245, 'column': 4, 'index': 6002}","it('should remove values from the tree with right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(40);

    expect(tree.toString()).toBe('10,20,30,40');

    tree.remove(10);

    expect(tree.toString()).toBe('20,30,40');
    expect(tree.root.value).toBe(30);
    expect(tree.root.left.value).toBe(20);
    expect(tree.root.right.value).toBe(40);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 260, 'column': 4, 'index': 6417}","it('should remove values from the tree with left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(5);

    expect(tree.toString()).toBe('5,10,20,30');

    tree.remove(30);

    expect(tree.toString()).toBe('5,10,20');
    expect(tree.root.value).toBe(10);
    expect(tree.root.left.value).toBe(5);
    expect(tree.root.right.value).toBe(20);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 264, 'column': 4, 'index': 6488}","it('should remove values from the tree with left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(5);

    expect(tree.toString()).toBe('5,10,20,30');

    tree.remove(30);

    expect(tree.toString()).toBe('5,10,20');
    expect(tree.root.value).toBe(10);
    expect(tree.root.left.value).toBe(5);
    expect(tree.root.right.value).toBe(20);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 284, 'column': 4, 'index': 6973}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 285, 'column': 4, 'index': 7028}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 285, 'column': 4, 'index': 7028}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 286, 'column': 4, 'index': 7065}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 287, 'column': 4, 'index': 7103}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 287, 'column': 4, 'index': 7103}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 7171}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 7171}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 292, 'column': 4, 'index': 7208}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 292, 'column': 4, 'index': 7208}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 298, 'column': 4, 'index': 7360}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 299, 'column': 4, 'index': 7411}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 299, 'column': 4, 'index': 7411}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 300, 'column': 4, 'index': 7448}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Duplicate Assert,"{'line': 301, 'column': 4, 'index': 7486}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 12, 'column': 33, 'index': 285}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 13, 'column': 34, 'index': 323}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 18, 'column': 33, 'index': 427}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 19, 'column': 34, 'index': 465}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 24, 'column': 33, 'index': 571}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 25, 'column': 38, 'index': 613}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 26, 'column': 34, 'index': 651}","it('should do simple left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(4);
    tree.insert(3);
    tree.insert(2);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(1);

    expect(tree.toString()).toBe('1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(0);

    expect(tree.toString()).toBe('0,1,2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.left.value).toBe(1);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 37, 'column': 33, 'index': 866}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 38, 'column': 34, 'index': 905}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 42, 'column': 33, 'index': 1013}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 43, 'column': 34, 'index': 1052}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 47, 'column': 33, 'index': 1162}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 48, 'column': 34, 'index': 1201}","it('should do complex left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(10);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,30,40');

    tree.insert(25);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('10,20,25,30,40');

    tree.insert(5);
    expect(tree.root.value).toBe(20);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('5,10,20,25,30,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 60, 'column': 33, 'index': 1490}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 61, 'column': 34, 'index': 1528}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 66, 'column': 33, 'index': 1632}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 67, 'column': 34, 'index': 1670}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 72, 'column': 33, 'index': 1776}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 73, 'column': 39, 'index': 1819}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 74, 'column': 34, 'index': 1857}","it('should do simple right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(2);
    tree.insert(3);
    tree.insert(4);

    expect(tree.toString()).toBe('2,3,4');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(1);

    tree.insert(5);

    expect(tree.toString()).toBe('2,3,4,5');
    expect(tree.root.value).toBe(3);
    expect(tree.root.height).toBe(2);

    tree.insert(6);

    expect(tree.toString()).toBe('2,3,4,5,6');
    expect(tree.root.value).toBe(3);
    expect(tree.root.right.value).toBe(5);
    expect(tree.root.height).toBe(2);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 85, 'column': 33, 'index': 2074}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 86, 'column': 34, 'index': 2113}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 90, 'column': 33, 'index': 2221}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 91, 'column': 34, 'index': 2260}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 95, 'column': 33, 'index': 2371}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 96, 'column': 34, 'index': 2410}","it('should do complex right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(40);
    tree.insert(50);

    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,40,50');

    tree.insert(35);
    expect(tree.root.value).toBe(30);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50');

    tree.insert(55);
    expect(tree.root.value).toBe(40);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('20,30,35,40,50,55');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 107, 'column': 34, 'index': 2653}","it('should do left-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(25);

    expect(tree.root.height).toBe(1);
    expect(tree.root.value).toBe(25);
    expect(tree.toString()).toBe('20,25,30');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 108, 'column': 33, 'index': 2690}","it('should do left-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(20);
    tree.insert(25);

    expect(tree.root.height).toBe(1);
    expect(tree.root.value).toBe(25);
    expect(tree.toString()).toBe('20,25,30');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 119, 'column': 34, 'index': 2925}","it('should do right-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(40);
    tree.insert(35);

    expect(tree.root.height).toBe(1);
    expect(tree.root.value).toBe(35);
    expect(tree.toString()).toBe('30,35,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 120, 'column': 33, 'index': 2962}","it('should do right-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(40);
    tree.insert(35);

    expect(tree.root.height).toBe(1);
    expect(tree.root.value).toBe(35);
    expect(tree.toString()).toBe('30,35,40');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 132, 'column': 33, 'index': 3264}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 133, 'column': 34, 'index': 3302}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 138, 'column': 33, 'index': 3404}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 139, 'column': 34, 'index': 3442}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 144, 'column': 33, 'index': 3547}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 145, 'column': 34, 'index': 3585}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 150, 'column': 33, 'index': 3693}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 151, 'column': 34, 'index': 3731}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 156, 'column': 33, 'index': 3842}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 157, 'column': 34, 'index': 3880}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 162, 'column': 33, 'index': 3994}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 163, 'column': 34, 'index': 4032}","it('should create balanced tree: case #1', () => {
    // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(1);
    expect(tree.toString()).toBe('1,2,3');

    tree.insert(6);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6');

    tree.insert(15);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('1,2,3,6,15');

    tree.insert(-2);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-2,1,2,3,6,15');

    tree.insert(-5);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');

    tree.insert(-8);

    expect(tree.root.value).toBe(2);
    expect(tree.root.height).toBe(3);
    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 178, 'column': 33, 'index': 4400}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 179, 'column': 34, 'index': 4439}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 184, 'column': 33, 'index': 4551}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 185, 'column': 34, 'index': 4590}","it('should create balanced tree: case #2', () => {
    // @see https://www.youtube.com/watch?v=7m94k2Qhg68
    const tree = new AvlTree();

    tree.insert(43);
    tree.insert(18);
    tree.insert(22);
    tree.insert(9);
    tree.insert(21);
    tree.insert(6);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,9,18,21,22,43');

    tree.insert(8);

    expect(tree.root.value).toBe(18);
    expect(tree.root.height).toBe(2);
    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 203, 'column': 34, 'index': 5054}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(5);
    tree.insert(12);

    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);

    tree.insert(11);

    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 208, 'column': 34, 'index': 5181}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(5);
    tree.insert(12);

    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);

    tree.insert(11);

    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 225, 'column': 34, 'index': 5592}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 230, 'column': 34, 'index': 5720}","it('should do left right rotation and keeping left right node safe', () => {
    const tree = new AvlTree();

    tree.insert(30);
    tree.insert(15);
    tree.insert(40);
    tree.insert(10);
    tree.insert(18);
    tree.insert(35);
    tree.insert(45);
    tree.insert(42);
    tree.insert(47);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
    expect(tree.root.height).toBe(3);

    tree.insert(43);

    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
    expect(tree.root.height).toBe(3);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 246, 'column': 33, 'index': 6077}","it('should remove values from the tree with right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(40);

    expect(tree.toString()).toBe('10,20,30,40');

    tree.remove(10);

    expect(tree.toString()).toBe('20,30,40');
    expect(tree.root.value).toBe(30);
    expect(tree.root.left.value).toBe(20);
    expect(tree.root.right.value).toBe(40);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 247, 'column': 38, 'index': 6120}","it('should remove values from the tree with right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(40);

    expect(tree.toString()).toBe('10,20,30,40');

    tree.remove(10);

    expect(tree.toString()).toBe('20,30,40');
    expect(tree.root.value).toBe(30);
    expect(tree.root.left.value).toBe(20);
    expect(tree.root.right.value).toBe(40);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 248, 'column': 39, 'index': 6164}","it('should remove values from the tree with right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(40);

    expect(tree.toString()).toBe('10,20,30,40');

    tree.remove(10);

    expect(tree.toString()).toBe('20,30,40');
    expect(tree.root.value).toBe(30);
    expect(tree.root.left.value).toBe(20);
    expect(tree.root.right.value).toBe(40);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 249, 'column': 41, 'index': 6210}","it('should remove values from the tree with right-right rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(40);

    expect(tree.toString()).toBe('10,20,30,40');

    tree.remove(10);

    expect(tree.toString()).toBe('20,30,40');
    expect(tree.root.value).toBe(30);
    expect(tree.root.left.value).toBe(20);
    expect(tree.root.right.value).toBe(40);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 265, 'column': 33, 'index': 6562}","it('should remove values from the tree with left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(5);

    expect(tree.toString()).toBe('5,10,20,30');

    tree.remove(30);

    expect(tree.toString()).toBe('5,10,20');
    expect(tree.root.value).toBe(10);
    expect(tree.root.left.value).toBe(5);
    expect(tree.root.right.value).toBe(20);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 266, 'column': 38, 'index': 6605}","it('should remove values from the tree with left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(5);

    expect(tree.toString()).toBe('5,10,20,30');

    tree.remove(30);

    expect(tree.toString()).toBe('5,10,20');
    expect(tree.root.value).toBe(10);
    expect(tree.root.left.value).toBe(5);
    expect(tree.root.right.value).toBe(20);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 267, 'column': 39, 'index': 6648}","it('should remove values from the tree with left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(5);

    expect(tree.toString()).toBe('5,10,20,30');

    tree.remove(30);

    expect(tree.toString()).toBe('5,10,20');
    expect(tree.root.value).toBe(10);
    expect(tree.root.left.value).toBe(5);
    expect(tree.root.right.value).toBe(20);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 268, 'column': 41, 'index': 6694}","it('should remove values from the tree with left-left rotation', () => {
    const tree = new AvlTree();

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(5);

    expect(tree.toString()).toBe('5,10,20,30');

    tree.remove(30);

    expect(tree.toString()).toBe('5,10,20');
    expect(tree.root.value).toBe(10);
    expect(tree.root.left.value).toBe(5);
    expect(tree.root.right.value).toBe(20);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 285, 'column': 33, 'index': 7057}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 286, 'column': 34, 'index': 7095}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 291, 'column': 33, 'index': 7200}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 299, 'column': 33, 'index': 7440}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 300, 'column': 34, 'index': 7478}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js,Magic Number,"{'line': 301, 'column': 41, 'index': 7523}","it('should keep balance after removal', () => {
    const tree = new AvlTree();

    tree.insert(1);
    tree.insert(2);
    tree.insert(3);
    tree.insert(4);
    tree.insert(5);
    tree.insert(6);
    tree.insert(7);
    tree.insert(8);
    tree.insert(9);

    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(3);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(8);

    expect(tree.root.value).toBe(4);
    expect(tree.root.balanceFactor).toBe(-1);

    tree.remove(9);

    expect(tree.contains(8)).toBeFalsy();
    expect(tree.contains(9)).toBeFalsy();
    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
    expect(tree.root.value).toBe(4);
    expect(tree.root.height).toBe(2);
    expect(tree.root.balanceFactor).toBe(0);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1654}","it('should remove child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    expect(rootNode.removeChild(rootNode.left)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2, 3]);

    expect(rootNode.removeChild(rootNode.right)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2]);

    expect(rootNode.removeChild(rootNode.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([2]);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1774}","it('should remove child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    expect(rootNode.removeChild(rootNode.left)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2, 3]);

    expect(rootNode.removeChild(rootNode.right)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2]);

    expect(rootNode.removeChild(rootNode.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([2]);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1831}","it('should remove child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    expect(rootNode.removeChild(rootNode.left)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2, 3]);

    expect(rootNode.removeChild(rootNode.right)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2]);

    expect(rootNode.removeChild(rootNode.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([2]);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1892}","it('should remove child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    expect(rootNode.removeChild(rootNode.left)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2, 3]);

    expect(rootNode.removeChild(rootNode.right)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2]);

    expect(rootNode.removeChild(rootNode.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([2]);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1892}","it('should remove child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    expect(rootNode.removeChild(rootNode.left)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2, 3]);

    expect(rootNode.removeChild(rootNode.right)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2]);

    expect(rootNode.removeChild(rootNode.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([2]);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 1946}","it('should remove child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    expect(rootNode.removeChild(rootNode.left)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2, 3]);

    expect(rootNode.removeChild(rootNode.right)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2]);

    expect(rootNode.removeChild(rootNode.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([2]);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 2008}","it('should remove child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    expect(rootNode.removeChild(rootNode.left)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2, 3]);

    expect(rootNode.removeChild(rootNode.right)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2]);

    expect(rootNode.removeChild(rootNode.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([2]);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 2008}","it('should remove child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    expect(rootNode.removeChild(rootNode.left)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2, 3]);

    expect(rootNode.removeChild(rootNode.right)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([2]);

    expect(rootNode.removeChild(rootNode.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([2]);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2311}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2464}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 2527}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 2698}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 2698}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 97, 'column': 4, 'index': 2758}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 2843}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 2843}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 101, 'column': 4, 'index': 2982}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 101, 'column': 4, 'index': 2982}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 104, 'column': 4, 'index': 3120}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 117, 'column': 4, 'index': 3586}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 118, 'column': 4, 'index': 3619}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 118, 'column': 4, 'index': 3619}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 124, 'column': 4, 'index': 3715}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 125, 'column': 4, 'index': 3748}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 126, 'column': 4, 'index': 3781}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 126, 'column': 4, 'index': 3781}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 132, 'column': 4, 'index': 3887}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 133, 'column': 4, 'index': 3920}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 134, 'column': 4, 'index': 3953}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 135, 'column': 4, 'index': 3991}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 135, 'column': 4, 'index': 3991}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 136, 'column': 4, 'index': 4030}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 140, 'column': 4, 'index': 4111}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 141, 'column': 4, 'index': 4144}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 142, 'column': 4, 'index': 4177}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 4215}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 4215}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 4297}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 186, 'column': 4, 'index': 5362}","it('should be possible to create node with object as a value', () => {
    const obj1 = { key: 'object_1', toString: () => 'object_1' };
    const obj2 = { key: 'object_2' };

    const node1 = new BinaryTreeNode(obj1);
    const node2 = new BinaryTreeNode(obj2);

    node1.setLeft(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left.value).toEqual(obj2);

    node1.removeChild(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left).toBeNull();

    expect(node1.toString()).toBe('object_1');
    expect(node2.toString()).toBe('[object Object]');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 186, 'column': 4, 'index': 5362}","it('should be possible to create node with object as a value', () => {
    const obj1 = { key: 'object_1', toString: () => 'object_1' };
    const obj2 = { key: 'object_2' };

    const node1 = new BinaryTreeNode(obj1);
    const node2 = new BinaryTreeNode(obj2);

    node1.setLeft(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left.value).toEqual(obj2);

    node1.removeChild(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left).toBeNull();

    expect(node1.toString()).toBe('object_1');
    expect(node2.toString()).toBe('[object Object]');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 187, 'column': 4, 'index': 5401}","it('should be possible to create node with object as a value', () => {
    const obj1 = { key: 'object_1', toString: () => 'object_1' };
    const obj2 = { key: 'object_2' };

    const node1 = new BinaryTreeNode(obj1);
    const node2 = new BinaryTreeNode(obj2);

    node1.setLeft(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left.value).toEqual(obj2);

    node1.removeChild(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left).toBeNull();

    expect(node1.toString()).toBe('object_1');
    expect(node2.toString()).toBe('[object Object]');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 187, 'column': 4, 'index': 5401}","it('should be possible to create node with object as a value', () => {
    const obj1 = { key: 'object_1', toString: () => 'object_1' };
    const obj2 = { key: 'object_2' };

    const node1 = new BinaryTreeNode(obj1);
    const node2 = new BinaryTreeNode(obj2);

    node1.setLeft(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left.value).toEqual(obj2);

    node1.removeChild(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left).toBeNull();

    expect(node1.toString()).toBe('object_1');
    expect(node2.toString()).toBe('[object Object]');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 192, 'column': 4, 'index': 5516}","it('should be possible to create node with object as a value', () => {
    const obj1 = { key: 'object_1', toString: () => 'object_1' };
    const obj2 = { key: 'object_2' };

    const node1 = new BinaryTreeNode(obj1);
    const node2 = new BinaryTreeNode(obj2);

    node1.setLeft(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left.value).toEqual(obj2);

    node1.removeChild(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left).toBeNull();

    expect(node1.toString()).toBe('object_1');
    expect(node2.toString()).toBe('[object Object]');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 192, 'column': 4, 'index': 5516}","it('should be possible to create node with object as a value', () => {
    const obj1 = { key: 'object_1', toString: () => 'object_1' };
    const obj2 = { key: 'object_2' };

    const node1 = new BinaryTreeNode(obj1);
    const node2 = new BinaryTreeNode(obj2);

    node1.setLeft(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left.value).toEqual(obj2);

    node1.removeChild(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left).toBeNull();

    expect(node1.toString()).toBe('object_1');
    expect(node2.toString()).toBe('[object Object]');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 193, 'column': 4, 'index': 5555}","it('should be possible to create node with object as a value', () => {
    const obj1 = { key: 'object_1', toString: () => 'object_1' };
    const obj2 = { key: 'object_2' };

    const node1 = new BinaryTreeNode(obj1);
    const node2 = new BinaryTreeNode(obj2);

    node1.setLeft(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left.value).toEqual(obj2);

    node1.removeChild(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left).toBeNull();

    expect(node1.toString()).toBe('object_1');
    expect(node2.toString()).toBe('[object Object]');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 193, 'column': 4, 'index': 5555}","it('should be possible to create node with object as a value', () => {
    const obj1 = { key: 'object_1', toString: () => 'object_1' };
    const obj2 = { key: 'object_2' };

    const node1 = new BinaryTreeNode(obj1);
    const node2 = new BinaryTreeNode(obj2);

    node1.setLeft(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left.value).toEqual(obj2);

    node1.removeChild(node2);

    expect(node1.value).toEqual(obj1);
    expect(node2.value).toEqual(obj2);
    expect(node1.left).toBeNull();

    expect(node1.toString()).toBe('object_1');
    expect(node2.toString()).toBe('[object Object]');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 218, 'column': 4, 'index': 6390}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 218, 'column': 4, 'index': 6390}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 222, 'column': 4, 'index': 6469}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 222, 'column': 4, 'index': 6469}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 223, 'column': 4, 'index': 6513}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 223, 'column': 4, 'index': 6513}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 227, 'column': 4, 'index': 6585}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 227, 'column': 4, 'index': 6585}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 231, 'column': 4, 'index': 6663}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 231, 'column': 4, 'index': 6663}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 232, 'column': 4, 'index': 6707}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 233, 'column': 4, 'index': 6746}","it('should detect right uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setLeft(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setLeft(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setRight(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 243, 'column': 4, 'index': 7087}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 243, 'column': 4, 'index': 7087}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 247, 'column': 4, 'index': 7167}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 247, 'column': 4, 'index': 7167}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 248, 'column': 4, 'index': 7211}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 248, 'column': 4, 'index': 7211}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 252, 'column': 4, 'index': 7284}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 252, 'column': 4, 'index': 7284}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 256, 'column': 4, 'index': 7361}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 256, 'column': 4, 'index': 7361}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 257, 'column': 4, 'index': 7405}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 258, 'column': 4, 'index': 7444}","it('should detect left uncle', () => {
    const grandParent = new BinaryTreeNode('grand-parent');
    const parent = new BinaryTreeNode('parent');
    const uncle = new BinaryTreeNode('uncle');
    const child = new BinaryTreeNode('child');

    expect(grandParent.uncle).not.toBeDefined();
    expect(parent.uncle).not.toBeDefined();

    grandParent.setRight(parent);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).not.toBeDefined();

    parent.setRight(child);

    expect(child.uncle).not.toBeDefined();

    grandParent.setLeft(uncle);

    expect(parent.uncle).not.toBeDefined();
    expect(child.uncle).toBeDefined();
    expect(child.uncle).toEqual(uncle);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 264, 'column': 4, 'index': 7600}","it('should be possible to set node values', () => {
    const node = new BinaryTreeNode('initial_value');

    expect(node.value).toBe('initial_value');

    node.setValue('new_value');

    expect(node.value).toBe('new_value');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 268, 'column': 4, 'index': 7680}","it('should be possible to set node values', () => {
    const node = new BinaryTreeNode('initial_value');

    expect(node.value).toBe('initial_value');

    node.setValue('new_value');

    expect(node.value).toBe('new_value');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 280, 'column': 4, 'index': 7970}","it('should be possible to copy node', () => {
    const root = new BinaryTreeNode('root');
    const left = new BinaryTreeNode('left');
    const right = new BinaryTreeNode('right');

    root
      .setLeft(left)
      .setRight(right);

    expect(root.toString()).toBe('left,root,right');

    const newRoot = new BinaryTreeNode('new_root');
    const newLeft = new BinaryTreeNode('new_left');
    const newRight = new BinaryTreeNode('new_right');

    newRoot
      .setLeft(newLeft)
      .setRight(newRight);

    expect(newRoot.toString()).toBe('new_left,new_root,new_right');

    BinaryTreeNode.copyNode(root, newRoot);

    expect(root.toString()).toBe('left,root,right');
    expect(newRoot.toString()).toBe('left,root,right');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 280, 'column': 4, 'index': 7970}","it('should be possible to copy node', () => {
    const root = new BinaryTreeNode('root');
    const left = new BinaryTreeNode('left');
    const right = new BinaryTreeNode('right');

    root
      .setLeft(left)
      .setRight(right);

    expect(root.toString()).toBe('left,root,right');

    const newRoot = new BinaryTreeNode('new_root');
    const newLeft = new BinaryTreeNode('new_left');
    const newRight = new BinaryTreeNode('new_right');

    newRoot
      .setLeft(newLeft)
      .setRight(newRight);

    expect(newRoot.toString()).toBe('new_left,new_root,new_right');

    BinaryTreeNode.copyNode(root, newRoot);

    expect(root.toString()).toBe('left,root,right');
    expect(newRoot.toString()).toBe('left,root,right');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 290, 'column': 4, 'index': 8247}","it('should be possible to copy node', () => {
    const root = new BinaryTreeNode('root');
    const left = new BinaryTreeNode('left');
    const right = new BinaryTreeNode('right');

    root
      .setLeft(left)
      .setRight(right);

    expect(root.toString()).toBe('left,root,right');

    const newRoot = new BinaryTreeNode('new_root');
    const newLeft = new BinaryTreeNode('new_left');
    const newRight = new BinaryTreeNode('new_right');

    newRoot
      .setLeft(newLeft)
      .setRight(newRight);

    expect(newRoot.toString()).toBe('new_left,new_root,new_right');

    BinaryTreeNode.copyNode(root, newRoot);

    expect(root.toString()).toBe('left,root,right');
    expect(newRoot.toString()).toBe('left,root,right');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 294, 'column': 4, 'index': 8361}","it('should be possible to copy node', () => {
    const root = new BinaryTreeNode('root');
    const left = new BinaryTreeNode('left');
    const right = new BinaryTreeNode('right');

    root
      .setLeft(left)
      .setRight(right);

    expect(root.toString()).toBe('left,root,right');

    const newRoot = new BinaryTreeNode('new_root');
    const newLeft = new BinaryTreeNode('new_left');
    const newRight = new BinaryTreeNode('new_right');

    newRoot
      .setLeft(newLeft)
      .setRight(newRight);

    expect(newRoot.toString()).toBe('new_left,new_root,new_right');

    BinaryTreeNode.copyNode(root, newRoot);

    expect(root.toString()).toBe('left,root,right');
    expect(newRoot.toString()).toBe('left,root,right');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 294, 'column': 4, 'index': 8361}","it('should be possible to copy node', () => {
    const root = new BinaryTreeNode('root');
    const left = new BinaryTreeNode('left');
    const right = new BinaryTreeNode('right');

    root
      .setLeft(left)
      .setRight(right);

    expect(root.toString()).toBe('left,root,right');

    const newRoot = new BinaryTreeNode('new_root');
    const newLeft = new BinaryTreeNode('new_left');
    const newRight = new BinaryTreeNode('new_right');

    newRoot
      .setLeft(newLeft)
      .setRight(newRight);

    expect(newRoot.toString()).toBe('new_left,new_root,new_right');

    BinaryTreeNode.copyNode(root, newRoot);

    expect(root.toString()).toBe('left,root,right');
    expect(newRoot.toString()).toBe('left,root,right');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Duplicate Assert,"{'line': 295, 'column': 4, 'index': 8414}","it('should be possible to copy node', () => {
    const root = new BinaryTreeNode('root');
    const left = new BinaryTreeNode('left');
    const right = new BinaryTreeNode('right');

    root
      .setLeft(left)
      .setRight(right);

    expect(root.toString()).toBe('left,root,right');

    const newRoot = new BinaryTreeNode('new_root');
    const newLeft = new BinaryTreeNode('new_left');
    const newRight = new BinaryTreeNode('new_right');

    newRoot
      .setLeft(newLeft)
      .setRight(newRight);

    expect(newRoot.toString()).toBe('new_left,new_root,new_right');

    BinaryTreeNode.copyNode(root, newRoot);

    expect(root.toString()).toBe('left,root,right');
    expect(newRoot.toString()).toBe('left,root,right');
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 21, 'column': 32, 'index': 530}","it('should create node', () => {
    const node = new BinaryTreeNode();

    expect(node).toBeDefined();

    expect(node.value).toBeNull();
    expect(node.left).toBeNull();
    expect(node.right).toBeNull();

    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.value).toBe(2);
    expect(rootNode.left.value).toBe(1);
    expect(rootNode.right.value).toBe(3);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 22, 'column': 37, 'index': 571}","it('should create node', () => {
    const node = new BinaryTreeNode();

    expect(node).toBeDefined();

    expect(node.value).toBeNull();
    expect(node.left).toBeNull();
    expect(node.right).toBeNull();

    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.value).toBe(2);
    expect(rootNode.left.value).toBe(1);
    expect(rootNode.right.value).toBe(3);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 23, 'column': 38, 'index': 613}","it('should create node', () => {
    const node = new BinaryTreeNode();

    expect(node).toBeDefined();

    expect(node.value).toBeNull();
    expect(node.left).toBeNull();
    expect(node.right).toBeNull();

    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.value).toBe(2);
    expect(rootNode.left.value).toBe(1);
    expect(rootNode.right.value).toBe(3);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 36, 'column': 44, 'index': 943}","it('should set parent', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.parent).toBeNull();
    expect(rootNode.left.parent.value).toBe(2);
    expect(rootNode.right.parent.value).toBe(2);
    expect(rootNode.right.parent).toEqual(rootNode);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 37, 'column': 45, 'index': 992}","it('should set parent', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.parent).toBeNull();
    expect(rootNode.left.parent.value).toBe(2);
    expect(rootNode.right.parent.value).toBe(2);
    expect(rootNode.right.parent).toEqual(rootNode);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 93, 'column': 38, 'index': 2645}","it('should replace child node', () => {
    const leftNode = new BinaryTreeNode(1);
    const rightNode = new BinaryTreeNode(3);
    const rootNode = new BinaryTreeNode(2);

    rootNode
      .setLeft(leftNode)
      .setRight(rightNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);

    const replacementNode = new BinaryTreeNode(5);
    rightNode.setRight(replacementNode);

    expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
    expect(rootNode.right.value).toBe(5);
    expect(rootNode.right.right).toBeNull();
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);

    expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
    expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);

    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 117, 'column': 29, 'index': 3611}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 118, 'column': 36, 'index': 3651}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 124, 'column': 29, 'index': 3740}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 125, 'column': 29, 'index': 3773}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 126, 'column': 36, 'index': 3813}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 132, 'column': 29, 'index': 3912}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 133, 'column': 29, 'index': 3945}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 134, 'column': 34, 'index': 3983}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 135, 'column': 35, 'index': 4022}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 136, 'column': 36, 'index': 4062}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 140, 'column': 29, 'index': 4136}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 141, 'column': 29, 'index': 4169}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 142, 'column': 34, 'index': 4207}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 143, 'column': 35, 'index': 4246}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 144, 'column': 39, 'index': 4289}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 145, 'column': 36, 'index': 4329}","it('should calculate node height', () => {
    const root = new BinaryTreeNode(1);
    const left = new BinaryTreeNode(3);
    const right = new BinaryTreeNode(2);
    const grandLeft = new BinaryTreeNode(5);
    const grandRight = new BinaryTreeNode(6);
    const grandGrandLeft = new BinaryTreeNode(7);

    expect(root.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    root
      .setLeft(left)
      .setRight(right);

    expect(root.height).toBe(1);
    expect(left.height).toBe(0);
    expect(root.balanceFactor).toBe(0);

    left
      .setLeft(grandLeft)
      .setRight(grandRight);

    expect(root.height).toBe(2);
    expect(left.height).toBe(1);
    expect(grandLeft.height).toBe(0);
    expect(grandRight.height).toBe(0);
    expect(root.balanceFactor).toBe(1);

    grandLeft.setLeft(grandGrandLeft);

    expect(root.height).toBe(3);
    expect(left.height).toBe(2);
    expect(grandLeft.height).toBe(1);
    expect(grandRight.height).toBe(0);
    expect(grandGrandLeft.height).toBe(0);
    expect(root.balanceFactor).toBe(2);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 154, 'column': 29, 'index': 4547}","it('should calculate node height for right nodes as well', () => {
    const root = new BinaryTreeNode(1);
    const right = new BinaryTreeNode(2);

    root.setRight(right);

    expect(root.height).toBe(1);
    expect(right.height).toBe(0);
    expect(root.balanceFactor).toBe(-1);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 155, 'column': 30, 'index': 4581}","it('should calculate node height for right nodes as well', () => {
    const root = new BinaryTreeNode(1);
    const right = new BinaryTreeNode(2);

    root.setRight(right);

    expect(root.height).toBe(1);
    expect(right.height).toBe(0);
    expect(root.balanceFactor).toBe(-1);
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 167, 'column': 33, 'index': 4895}","it('should set null for left and right node', () => {
    const root = new BinaryTreeNode(2);
    const left = new BinaryTreeNode(1);
    const right = new BinaryTreeNode(3);

    root.setLeft(left);
    root.setRight(right);

    expect(root.left.value).toBe(1);
    expect(root.right.value).toBe(3);

    root.setLeft(null);
    root.setRight(null);

    expect(root.left).toBeNull();
    expect(root.right).toBeNull();
  })",steel
/src/data-structures/tree/__test__/BinaryTreeNode.test.js,Magic Number,"{'line': 168, 'column': 34, 'index': 4933}","it('should set null for left and right node', () => {
    const root = new BinaryTreeNode(2);
    const left = new BinaryTreeNode(1);
    const right = new BinaryTreeNode(3);

    root.setLeft(left);
    root.setRight(right);

    expect(root.left.value).toBe(1);
    expect(root.right.value).toBe(3);

    root.setLeft(null);
    root.setRight(null);

    expect(root.left).toBeNull();
    expect(root.right).toBeNull();
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 459}","it('should peek data from stack', () => {
    const stack = new Stack();

    expect(stack.peek()).toBeNull();

    stack.push(1);
    stack.push(2);

    expect(stack.peek()).toBe(2);
    expect(stack.peek()).toBe(2);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 536}","it('should peek data from stack', () => {
    const stack = new Stack();

    expect(stack.peek()).toBeNull();

    stack.push(1);
    stack.push(2);

    expect(stack.peek()).toBe(2);
    expect(stack.peek()).toBe(2);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 536}","it('should peek data from stack', () => {
    const stack = new Stack();

    expect(stack.peek()).toBeNull();

    stack.push(1);
    stack.push(2);

    expect(stack.peek()).toBe(2);
    expect(stack.peek()).toBe(2);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 570}","it('should peek data from stack', () => {
    const stack = new Stack();

    expect(stack.peek()).toBeNull();

    stack.push(1);
    stack.push(2);

    expect(stack.peek()).toBe(2);
    expect(stack.peek()).toBe(2);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 570}","it('should peek data from stack', () => {
    const stack = new Stack();

    expect(stack.peek()).toBeNull();

    stack.push(1);
    stack.push(2);

    expect(stack.peek()).toBe(2);
    expect(stack.peek()).toBe(2);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 690}","it('should check if stack is empty', () => {
    const stack = new Stack();

    expect(stack.isEmpty()).toBe(true);

    stack.push(1);

    expect(stack.isEmpty()).toBe(false);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 751}","it('should check if stack is empty', () => {
    const stack = new Stack();

    expect(stack.isEmpty()).toBe(true);

    stack.push(1);

    expect(stack.isEmpty()).toBe(false);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 913}","it('should pop data from stack', () => {
    const stack = new Stack();

    stack.push(1);
    stack.push(2);

    expect(stack.pop()).toBe(2);
    expect(stack.pop()).toBe(1);
    expect(stack.pop()).toBeNull();
    expect(stack.isEmpty()).toBe(true);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 946}","it('should pop data from stack', () => {
    const stack = new Stack();

    stack.push(1);
    stack.push(2);

    expect(stack.pop()).toBe(2);
    expect(stack.pop()).toBe(1);
    expect(stack.pop()).toBeNull();
    expect(stack.isEmpty()).toBe(true);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 979}","it('should pop data from stack', () => {
    const stack = new Stack();

    stack.push(1);
    stack.push(2);

    expect(stack.pop()).toBe(2);
    expect(stack.pop()).toBe(1);
    expect(stack.pop()).toBeNull();
    expect(stack.isEmpty()).toBe(true);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1386}","it('should be possible to push/pop objects', () => {
    const stack = new Stack();

    stack.push({ value: 'test1', key: 'key1' });
    stack.push({ value: 'test2', key: 'key2' });

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(stack.toString(stringifier)).toBe('key2:test2,key1:test1');
    expect(stack.pop().value).toBe('test2');
    expect(stack.pop().value).toBe('test1');
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Duplicate Assert,"{'line': 63, 'column': 4, 'index': 1431}","it('should be possible to push/pop objects', () => {
    const stack = new Stack();

    stack.push({ value: 'test1', key: 'key1' });
    stack.push({ value: 'test2', key: 'key2' });

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(stack.toString(stringifier)).toBe('key2:test2,key1:test1');
    expect(stack.pop().value).toBe('test2');
    expect(stack.pop().value).toBe('test1');
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Magic Number,"{'line': 27, 'column': 30, 'index': 562}","it('should peek data from stack', () => {
    const stack = new Stack();

    expect(stack.peek()).toBeNull();

    stack.push(1);
    stack.push(2);

    expect(stack.peek()).toBe(2);
    expect(stack.peek()).toBe(2);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Magic Number,"{'line': 28, 'column': 30, 'index': 596}","it('should peek data from stack', () => {
    const stack = new Stack();

    expect(stack.peek()).toBeNull();

    stack.push(1);
    stack.push(2);

    expect(stack.peek()).toBe(2);
    expect(stack.peek()).toBe(2);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Magic Number,"{'line': 47, 'column': 29, 'index': 938}","it('should pop data from stack', () => {
    const stack = new Stack();

    stack.push(1);
    stack.push(2);

    expect(stack.pop()).toBe(2);
    expect(stack.pop()).toBe(1);
    expect(stack.pop()).toBeNull();
    expect(stack.isEmpty()).toBe(true);
  })",steel
/src/data-structures/stack/__test__/Stack.test.js,Magic Number,"{'line': 48, 'column': 29, 'index': 971}","it('should pop data from stack', () => {
    const stack = new Stack();

    stack.push(1);
    stack.push(2);

    expect(stack.pop()).toBe(2);
    expect(stack.pop()).toBe(1);
    expect(stack.pop()).toBeNull();
    expect(stack.isEmpty()).toBe(true);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 728}","it('should be possible to enqueue/dequeue objects', () => {
    const queue = new Queue();

    queue.enqueue({ value: 'test1', key: 'key1' });
    queue.enqueue({ value: 'test2', key: 'key2' });

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(queue.toString(stringifier)).toBe('key1:test1,key2:test2');
    expect(queue.dequeue().value).toBe('test1');
    expect(queue.dequeue().value).toBe('test2');
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 777}","it('should be possible to enqueue/dequeue objects', () => {
    const queue = new Queue();

    queue.enqueue({ value: 'test1', key: 'key1' });
    queue.enqueue({ value: 'test2', key: 'key2' });

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(queue.toString(stringifier)).toBe('key1:test1,key2:test2');
    expect(queue.dequeue().value).toBe('test1');
    expect(queue.dequeue().value).toBe('test2');
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 909}","it('should peek data from queue', () => {
    const queue = new Queue();

    expect(queue.peek()).toBeNull();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.peek()).toBe(1);
    expect(queue.peek()).toBe(1);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 992}","it('should peek data from queue', () => {
    const queue = new Queue();

    expect(queue.peek()).toBeNull();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.peek()).toBe(1);
    expect(queue.peek()).toBe(1);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 992}","it('should peek data from queue', () => {
    const queue = new Queue();

    expect(queue.peek()).toBeNull();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.peek()).toBe(1);
    expect(queue.peek()).toBe(1);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1026}","it('should peek data from queue', () => {
    const queue = new Queue();

    expect(queue.peek()).toBeNull();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.peek()).toBe(1);
    expect(queue.peek()).toBe(1);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1026}","it('should peek data from queue', () => {
    const queue = new Queue();

    expect(queue.peek()).toBeNull();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.peek()).toBe(1);
    expect(queue.peek()).toBe(1);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1146}","it('should check if queue is empty', () => {
    const queue = new Queue();

    expect(queue.isEmpty()).toBe(true);

    queue.enqueue(1);

    expect(queue.isEmpty()).toBe(false);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1210}","it('should check if queue is empty', () => {
    const queue = new Queue();

    expect(queue.isEmpty()).toBe(true);

    queue.enqueue(1);

    expect(queue.isEmpty()).toBe(false);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1391}","it('should dequeue from queue in FIFO order', () => {
    const queue = new Queue();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.dequeue()).toBe(1);
    expect(queue.dequeue()).toBe(2);
    expect(queue.dequeue()).toBeNull();
    expect(queue.isEmpty()).toBe(true);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1428}","it('should dequeue from queue in FIFO order', () => {
    const queue = new Queue();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.dequeue()).toBe(1);
    expect(queue.dequeue()).toBe(2);
    expect(queue.dequeue()).toBeNull();
    expect(queue.isEmpty()).toBe(true);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1465}","it('should dequeue from queue in FIFO order', () => {
    const queue = new Queue();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.dequeue()).toBe(1);
    expect(queue.dequeue()).toBe(2);
    expect(queue.dequeue()).toBeNull();
    expect(queue.isEmpty()).toBe(true);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Magic Number,"{'line': 40, 'column': 30, 'index': 1018}","it('should peek data from queue', () => {
    const queue = new Queue();

    expect(queue.peek()).toBeNull();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.peek()).toBe(1);
    expect(queue.peek()).toBe(1);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Magic Number,"{'line': 41, 'column': 30, 'index': 1052}","it('should peek data from queue', () => {
    const queue = new Queue();

    expect(queue.peek()).toBeNull();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.peek()).toBe(1);
    expect(queue.peek()).toBe(1);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Magic Number,"{'line': 60, 'column': 33, 'index': 1420}","it('should dequeue from queue in FIFO order', () => {
    const queue = new Queue();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.dequeue()).toBe(1);
    expect(queue.dequeue()).toBe(2);
    expect(queue.dequeue()).toBeNull();
    expect(queue.isEmpty()).toBe(true);
  })",steel
/src/data-structures/queue/__test__/Queue.test.js,Magic Number,"{'line': 61, 'column': 33, 'index': 1457}","it('should dequeue from queue in FIFO order', () => {
    const queue = new Queue();

    queue.enqueue(1);
    queue.enqueue(2);

    expect(queue.dequeue()).toBe(1);
    expect(queue.dequeue()).toBe(2);
    expect(queue.dequeue()).toBeNull();
    expect(queue.isEmpty()).toBe(true);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 384}","it('should insert items to the queue and respect priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(5, 2);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(100, 0);
    expect(priorityQueue.peek()).toBe(100);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 384}","it('should insert items to the queue and respect priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(5, 2);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(100, 0);
    expect(priorityQueue.peek()).toBe(100);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 457}","it('should insert items to the queue and respect priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(5, 2);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(100, 0);
    expect(priorityQueue.peek()).toBe(100);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 457}","it('should insert items to the queue and respect priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(5, 2);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(100, 0);
    expect(priorityQueue.peek()).toBe(100);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 20, 'column': 4, 'index': 532}","it('should insert items to the queue and respect priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(5, 2);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(100, 0);
    expect(priorityQueue.peek()).toBe(100);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 841}","it('should be possible to use objects in priority queue', () => {
    const priorityQueue = new PriorityQueue();

    const user1 = { name: 'Mike' };
    const user2 = { name: 'Bill' };
    const user3 = { name: 'Jane' };

    priorityQueue.add(user1, 1);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user2, 2);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user3, 0);
    expect(priorityQueue.peek()).toBe(user3);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 841}","it('should be possible to use objects in priority queue', () => {
    const priorityQueue = new PriorityQueue();

    const user1 = { name: 'Mike' };
    const user2 = { name: 'Bill' };
    const user3 = { name: 'Jane' };

    priorityQueue.add(user1, 1);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user2, 2);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user3, 0);
    expect(priorityQueue.peek()).toBe(user3);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 921}","it('should be possible to use objects in priority queue', () => {
    const priorityQueue = new PriorityQueue();

    const user1 = { name: 'Mike' };
    const user2 = { name: 'Bill' };
    const user3 = { name: 'Jane' };

    priorityQueue.add(user1, 1);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user2, 2);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user3, 0);
    expect(priorityQueue.peek()).toBe(user3);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 921}","it('should be possible to use objects in priority queue', () => {
    const priorityQueue = new PriorityQueue();

    const user1 = { name: 'Mike' };
    const user2 = { name: 'Bill' };
    const user3 = { name: 'Jane' };

    priorityQueue.add(user1, 1);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user2, 2);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user3, 0);
    expect(priorityQueue.peek()).toBe(user3);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 1001}","it('should be possible to use objects in priority queue', () => {
    const priorityQueue = new PriorityQueue();

    const user1 = { name: 'Mike' };
    const user2 = { name: 'Bill' };
    const user3 = { name: 'Jane' };

    priorityQueue.add(user1, 1);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user2, 2);
    expect(priorityQueue.peek()).toBe(user1);

    priorityQueue.add(user3, 0);
    expect(priorityQueue.peek()).toBe(user3);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1290}","it('should poll from queue with respect to priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
    expect(priorityQueue.poll()).toBe(5);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1334}","it('should poll from queue with respect to priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
    expect(priorityQueue.poll()).toBe(5);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 50, 'column': 4, 'index': 1378}","it('should poll from queue with respect to priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
    expect(priorityQueue.poll()).toBe(5);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1421}","it('should poll from queue with respect to priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
    expect(priorityQueue.poll()).toBe(5);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1838}","it('should be possible to change priority of head node', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(100, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 1882}","it('should be possible to change priority of head node', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(100, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1924}","it('should be possible to change priority of head node', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(100, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1968}","it('should be possible to change priority of head node', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(100, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2391}","it('should be possible to change priority of internal nodes', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2435}","it('should be possible to change priority of internal nodes', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2477}","it('should be possible to change priority of internal nodes', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 89, 'column': 4, 'index': 2521}","it('should be possible to change priority of internal nodes', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 105, 'column': 4, 'index': 2938}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 106, 'column': 4, 'index': 2982}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 107, 'column': 4, 'index': 3024}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 108, 'column': 4, 'index': 3068}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Duplicate Assert,"{'line': 109, 'column': 4, 'index': 3111}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 14, 'column': 38, 'index': 418}","it('should insert items to the queue and respect priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(5, 2);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(100, 0);
    expect(priorityQueue.peek()).toBe(100);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 17, 'column': 38, 'index': 491}","it('should insert items to the queue and respect priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(5, 2);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(100, 0);
    expect(priorityQueue.peek()).toBe(100);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 20, 'column': 38, 'index': 566}","it('should insert items to the queue and respect priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(5, 2);
    expect(priorityQueue.peek()).toBe(10);

    priorityQueue.add(100, 0);
    expect(priorityQueue.peek()).toBe(100);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 48, 'column': 38, 'index': 1324}","it('should poll from queue with respect to priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
    expect(priorityQueue.poll()).toBe(5);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 49, 'column': 38, 'index': 1368}","it('should poll from queue with respect to priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
    expect(priorityQueue.poll()).toBe(5);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 50, 'column': 38, 'index': 1412}","it('should poll from queue with respect to priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
    expect(priorityQueue.poll()).toBe(5);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 51, 'column': 38, 'index': 1455}","it('should poll from queue with respect to priorities', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
    expect(priorityQueue.poll()).toBe(5);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 62, 'column': 38, 'index': 1741}","it('should be possible to change priority of head node', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(100, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 67, 'column': 38, 'index': 1872}","it('should be possible to change priority of head node', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(100, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 68, 'column': 38, 'index': 1916}","it('should be possible to change priority of head node', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(100, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 69, 'column': 38, 'index': 1958}","it('should be possible to change priority of head node', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(100, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 70, 'column': 38, 'index': 2002}","it('should be possible to change priority of head node', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(100, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 81, 'column': 38, 'index': 2294}","it('should be possible to change priority of internal nodes', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 86, 'column': 38, 'index': 2425}","it('should be possible to change priority of internal nodes', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 87, 'column': 38, 'index': 2469}","it('should be possible to change priority of internal nodes', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 88, 'column': 38, 'index': 2511}","it('should be possible to change priority of internal nodes', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 89, 'column': 38, 'index': 2555}","it('should be possible to change priority of internal nodes', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    expect(priorityQueue.peek()).toBe(100);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 105, 'column': 38, 'index': 2972}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 106, 'column': 38, 'index': 3016}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 107, 'column': 38, 'index': 3058}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 108, 'column': 38, 'index': 3102}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/priority-queue/__test__/PriorityQueue.test.js,Magic Number,"{'line': 109, 'column': 38, 'index': 3145}","it('should be possible to change priority along with node addition', () => {
    const priorityQueue = new PriorityQueue();

    priorityQueue.add(10, 1);
    priorityQueue.add(5, 2);
    priorityQueue.add(100, 0);
    priorityQueue.add(200, 0);

    priorityQueue.changePriority(200, 10);
    priorityQueue.changePriority(10, 20);

    priorityQueue.add(15, 15);

    expect(priorityQueue.poll()).toBe(100);
    expect(priorityQueue.poll()).toBe(5);
    expect(priorityQueue.poll()).toBe(200);
    expect(priorityQueue.poll()).toBe(15);
    expect(priorityQueue.poll()).toBe(10);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 6, 'column': 4, 'index': 181}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 314}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 314}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 12, 'column': 4, 'index': 355}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 12, 'column': 4, 'index': 355}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 396}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 396}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 437}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 437}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 15, 'column': 4, 'index': 478}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 15, 'column': 4, 'index': 478}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 16, 'column': 4, 'index': 519}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 16, 'column': 4, 'index': 519}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 642}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 682}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 722}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 891}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 891}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 968}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1038}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1038}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1086}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 1156}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1254}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1520}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1520}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1599}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1599}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1671}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1671}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1713}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1785}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1785}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1857}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1857}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 63, 'column': 4, 'index': 1906}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 63, 'column': 4, 'index': 1906}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1948}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1948}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 2020}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 2020}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 2069}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 2118}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 2118}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 79, 'column': 4, 'index': 2413}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 79, 'column': 4, 'index': 2413}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 80, 'column': 4, 'index': 2453}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 80, 'column': 4, 'index': 2453}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2493}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2561}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2561}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2601}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2601}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2641}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2641}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 89, 'column': 4, 'index': 2709}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2757}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2757}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 91, 'column': 4, 'index': 2797}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 91, 'column': 4, 'index': 2797}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 112, 'column': 4, 'index': 3362}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 112, 'column': 4, 'index': 3362}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 115, 'column': 4, 'index': 3430}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 115, 'column': 4, 'index': 3430}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 128, 'column': 4, 'index': 3828}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 129, 'column': 4, 'index': 3868}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 129, 'column': 4, 'index': 3868}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 130, 'column': 4, 'index': 3908}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 130, 'column': 4, 'index': 3908}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 131, 'column': 4, 'index': 3948}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 131, 'column': 4, 'index': 3948}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 134, 'column': 4, 'index': 4016}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 134, 'column': 4, 'index': 4016}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 135, 'column': 4, 'index': 4056}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 135, 'column': 4, 'index': 4056}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 136, 'column': 4, 'index': 4096}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 136, 'column': 4, 'index': 4096}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 4136}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 4136}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 138, 'column': 4, 'index': 4184}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 138, 'column': 4, 'index': 4184}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 141, 'column': 4, 'index': 4252}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 142, 'column': 4, 'index': 4300}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 142, 'column': 4, 'index': 4300}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 4340}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 4340}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 4380}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 4380}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 4428}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 4428}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 11, 'column': 36, 'index': 346}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 12, 'column': 36, 'index': 387}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 13, 'column': 36, 'index': 428}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 14, 'column': 36, 'index': 469}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 15, 'column': 36, 'index': 510}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 16, 'column': 36, 'index': 551}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 21, 'column': 36, 'index': 674}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 22, 'column': 36, 'index': 714}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 23, 'column': 36, 'index': 754}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 31, 'column': 36, 'index': 1000}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 35, 'column': 36, 'index': 1118}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 38, 'column': 36, 'index': 1188}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 44, 'column': 36, 'index': 1382}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 52, 'column': 37, 'index': 1632}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 55, 'column': 37, 'index': 1704}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 56, 'column': 37, 'index': 1746}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 59, 'column': 37, 'index': 1818}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 63, 'column': 37, 'index': 1939}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 64, 'column': 37, 'index': 1981}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 69, 'column': 37, 'index': 2151}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 70, 'column': 37, 'index': 2193}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 79, 'column': 36, 'index': 2445}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 80, 'column': 36, 'index': 2485}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 81, 'column': 36, 'index': 2525}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 84, 'column': 36, 'index': 2593}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 85, 'column': 36, 'index': 2633}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 86, 'column': 36, 'index': 2673}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 90, 'column': 36, 'index': 2789}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 91, 'column': 36, 'index': 2829}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 92, 'column': 36, 'index': 2869}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 103, 'column': 32, 'index': 3151}","it('should promote the node while calling set() method', () => {
    const cache = new LRUCache(2);

    cache.set('2', 1);
    cache.set('1', 1);
    cache.set('2', 3);
    cache.set('4', 1);
    expect(cache.get('1')).toBeUndefined();
    expect(cache.get('2')).toBe(3);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 112, 'column': 36, 'index': 3394}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 115, 'column': 36, 'index': 3462}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 116, 'column': 36, 'index': 3502}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 117, 'column': 36, 'index': 3542}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 128, 'column': 36, 'index': 3860}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 129, 'column': 36, 'index': 3900}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 130, 'column': 36, 'index': 3940}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 131, 'column': 36, 'index': 3980}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 134, 'column': 36, 'index': 4048}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 135, 'column': 36, 'index': 4088}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 136, 'column': 36, 'index': 4128}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 138, 'column': 36, 'index': 4216}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 142, 'column': 36, 'index': 4332}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 143, 'column': 36, 'index': 4372}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 145, 'column': 36, 'index': 4460}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCacheOnMap.test.js,Magic Number,"{'line': 146, 'column': 36, 'index': 4500}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 6, 'column': 4, 'index': 171}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 304}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 304}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 12, 'column': 4, 'index': 345}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 12, 'column': 4, 'index': 345}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 386}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 386}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 427}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 427}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 15, 'column': 4, 'index': 468}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 15, 'column': 4, 'index': 468}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 16, 'column': 4, 'index': 509}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 16, 'column': 4, 'index': 509}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 632}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 672}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 712}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 881}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 881}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 958}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1028}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1028}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1076}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 1146}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1244}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1510}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1510}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1589}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1589}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1661}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1661}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1703}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1775}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1775}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1847}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1847}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 63, 'column': 4, 'index': 1879}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 63, 'column': 4, 'index': 1879}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1928}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1928}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 65, 'column': 4, 'index': 1970}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 65, 'column': 4, 'index': 1970}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 2042}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 2042}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 2074}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 2074}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 2123}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 2172}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 2172}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2467}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2467}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 82, 'column': 4, 'index': 2507}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 82, 'column': 4, 'index': 2507}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2547}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2615}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2615}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2655}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2655}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2695}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2695}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 91, 'column': 4, 'index': 2763}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 2811}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 2811}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 2851}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 2851}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 114, 'column': 4, 'index': 3416}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 114, 'column': 4, 'index': 3416}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 117, 'column': 4, 'index': 3484}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 117, 'column': 4, 'index': 3484}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 130, 'column': 4, 'index': 3882}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 131, 'column': 4, 'index': 3922}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 131, 'column': 4, 'index': 3922}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 132, 'column': 4, 'index': 3962}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 132, 'column': 4, 'index': 3962}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 133, 'column': 4, 'index': 4002}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 133, 'column': 4, 'index': 4002}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 136, 'column': 4, 'index': 4070}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 136, 'column': 4, 'index': 4070}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 4110}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 4110}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 138, 'column': 4, 'index': 4150}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 138, 'column': 4, 'index': 4150}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 139, 'column': 4, 'index': 4190}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 139, 'column': 4, 'index': 4190}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 140, 'column': 4, 'index': 4238}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 140, 'column': 4, 'index': 4238}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 4306}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 4354}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 4354}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 4394}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 4394}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 146, 'column': 4, 'index': 4434}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 146, 'column': 4, 'index': 4434}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 147, 'column': 4, 'index': 4482}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Duplicate Assert,"{'line': 147, 'column': 4, 'index': 4482}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 11, 'column': 36, 'index': 336}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 12, 'column': 36, 'index': 377}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 13, 'column': 36, 'index': 418}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 14, 'column': 36, 'index': 459}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 15, 'column': 36, 'index': 500}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 16, 'column': 36, 'index': 541}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 21, 'column': 36, 'index': 664}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 22, 'column': 36, 'index': 704}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 23, 'column': 36, 'index': 744}","it('should set and get values to and from the cache', () => {
    const cache = new LRUCache(100);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    cache.set('key-2', 16);
    cache.set('key-3', 17);
    expect(cache.get('key-1')).toBe(15);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-3')).toBe(17);
    expect(cache.get('key-2')).toBe(16);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-1', 5);
    cache.set('key-2', 6);
    cache.set('key-3', 7);
    expect(cache.get('key-1')).toBe(5);
    expect(cache.get('key-2')).toBe(6);
    expect(cache.get('key-3')).toBe(7);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 31, 'column': 36, 'index': 990}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 35, 'column': 36, 'index': 1108}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 38, 'column': 36, 'index': 1178}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 44, 'column': 36, 'index': 1372}","it('should evict least recently used items from cache with cache size of 1', () => {
    const cache = new LRUCache(1);
    expect(cache.get('key-1')).toBeUndefined();

    cache.set('key-1', 15);
    expect(cache.get('key-1')).toBe(15);

    cache.set('key-2', 16);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(16);

    cache.set('key-2', 17);
    expect(cache.get('key-2')).toBe(17);

    cache.set('key-3', 18);
    cache.set('key-4', 19);
    expect(cache.get('key-2')).toBeUndefined();
    expect(cache.get('key-3')).toBeUndefined();
    expect(cache.get('key-4')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 52, 'column': 37, 'index': 1622}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 55, 'column': 37, 'index': 1694}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 56, 'column': 37, 'index': 1736}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 59, 'column': 37, 'index': 1808}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 62, 'column': 28, 'index': 1871}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 64, 'column': 37, 'index': 1961}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 65, 'column': 37, 'index': 2003}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 68, 'column': 28, 'index': 2066}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 71, 'column': 37, 'index': 2205}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 72, 'column': 37, 'index': 2247}","it('should evict least recently used items from cache with cache size of 2', () => {
    const cache = new LRUCache(2);
    expect(cache.get('key-21')).toBeUndefined();

    cache.set('key-21', 15);
    expect(cache.get('key-21')).toBe(15);

    cache.set('key-22', 16);
    expect(cache.get('key-21')).toBe(15);
    expect(cache.get('key-22')).toBe(16);

    cache.set('key-22', 17);
    expect(cache.get('key-22')).toBe(17);

    cache.set('key-23', 18);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBe(17);
    expect(cache.get('key-23')).toBe(18);

    cache.set('key-24', 19);
    expect(cache.size).toBe(2);
    expect(cache.get('key-21')).toBeUndefined();
    expect(cache.get('key-22')).toBeUndefined();
    expect(cache.get('key-23')).toBe(18);
    expect(cache.get('key-24')).toBe(19);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 81, 'column': 36, 'index': 2499}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 82, 'column': 36, 'index': 2539}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 83, 'column': 36, 'index': 2579}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 86, 'column': 36, 'index': 2647}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 87, 'column': 36, 'index': 2687}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 88, 'column': 36, 'index': 2727}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 92, 'column': 36, 'index': 2843}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 93, 'column': 36, 'index': 2883}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 94, 'column': 36, 'index': 2923}","it('should evict least recently used items from cache with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);

    cache.set('key-3', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);

    cache.set('key-4', 5);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(4);
    expect(cache.get('key-4')).toBe(5);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 105, 'column': 32, 'index': 3205}","it('should promote the node while calling set() method', () => {
    const cache = new LRUCache(2);

    cache.set('2', 1);
    cache.set('1', 1);
    cache.set('2', 3);
    cache.set('4', 1);
    expect(cache.get('1')).toBeUndefined();
    expect(cache.get('2')).toBe(3);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 114, 'column': 36, 'index': 3448}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 117, 'column': 36, 'index': 3516}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 118, 'column': 36, 'index': 3556}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 119, 'column': 36, 'index': 3596}","it('should promote the recently accessed item with cache size of 3', () => {
    const cache = new LRUCache(3);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-4', 4);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-2')).toBeUndefined();
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 130, 'column': 36, 'index': 3914}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 131, 'column': 36, 'index': 3954}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 132, 'column': 36, 'index': 3994}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 133, 'column': 36, 'index': 4034}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 136, 'column': 36, 'index': 4102}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 137, 'column': 36, 'index': 4142}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 138, 'column': 36, 'index': 4182}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 140, 'column': 36, 'index': 4270}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 144, 'column': 36, 'index': 4386}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 145, 'column': 36, 'index': 4426}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 147, 'column': 36, 'index': 4514}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/lru-cache/__test__/LRUCache.test.js,Magic Number,"{'line': 148, 'column': 36, 'index': 4554}","it('should promote the recently accessed item with cache size of 4', () => {
    const cache = new LRUCache(4);

    cache.set('key-1', 1);
    cache.set('key-2', 2);
    cache.set('key-3', 3);
    cache.set('key-4', 4);
    expect(cache.get('key-4')).toBe(4);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-1')).toBe(1);

    cache.set('key-5', 5);
    expect(cache.get('key-1')).toBe(1);
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);

    cache.set('key-6', 6);
    expect(cache.get('key-1')).toBeUndefined();
    expect(cache.get('key-2')).toBe(2);
    expect(cache.get('key-3')).toBe(3);
    expect(cache.get('key-4')).toBeUndefined();
    expect(cache.get('key-5')).toBe(5);
    expect(cache.get('key-6')).toBe(6);
  })",steel
/src/data-structures/linked-list/__test__/LinkedListNode.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 905}","it('should convert node to string', () => {
    const node = new LinkedListNode(1);

    expect(node.toString()).toBe('1');

    node.value = 'string value';
    expect(node.toString()).toBe('string value');
  })",steel
/src/data-structures/linked-list/__test__/LinkedListNode.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 978}","it('should convert node to string', () => {
    const node = new LinkedListNode(1);

    expect(node.toString()).toBe('1');

    node.value = 'string value';
    expect(node.toString()).toBe('string value');
  })",steel
/src/data-structures/linked-list/__test__/LinkedListNode.test.js,Magic Number,"{'line': 7, 'column': 28, 'index': 204}","it('should create list node with value', () => {
    const node = new LinkedListNode(1);

    expect(node.value).toBe(1);
    expect(node.next).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedListNode.test.js,Magic Number,"{'line': 15, 'column': 34, 'index': 444}","it('should create list node with object as a value', () => {
    const nodeValue = { value: 1, key: 'test' };
    const node = new LinkedListNode(nodeValue);

    expect(node.value.value).toBe(1);
    expect(node.value.key).toBe('test');
    expect(node.next).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedListNode.test.js,Magic Number,"{'line': 26, 'column': 29, 'index': 765}","it('should link nodes together', () => {
    const node2 = new LinkedListNode(2);
    const node1 = new LinkedListNode(1, node2);

    expect(node1.next).toBeDefined();
    expect(node2.next).toBeNull();
    expect(node1.value).toBe(1);
    expect(node1.next.value).toBe(2);
  })",steel
/src/data-structures/linked-list/__test__/LinkedListNode.test.js,Magic Number,"{'line': 27, 'column': 34, 'index': 803}","it('should link nodes together', () => {
    const node2 = new LinkedListNode(2);
    const node1 = new LinkedListNode(1, node2);

    expect(node1.next).toBeDefined();
    expect(node2.next).toBeNull();
    expect(node1.value).toBe(1);
    expect(node1.next.value).toBe(2);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Conditional Test Logic,"{'line': 212, 'column': 6, 'index': 5984}","it('should find node by means of custom compare function', () => {
    const comparatorFunction = (a, b) => {
      if (a.customValue === b.customValue) {
        return 0;
      }

      return a.customValue < b.customValue ? -1 : 1;
    };

    const linkedList = new LinkedList(comparatorFunction);

    linkedList
      .append({ value: 1, customValue: 'test1' })
      .append({ value: 2, customValue: 'test2' })
      .append({ value: 3, customValue: 'test3' });

    const node = linkedList.find({
      value: { value: 2, customValue: 'test2' },
    });

    expect(node).toBeDefined();
    expect(node.value.value).toBe(2);
    expect(node.value.customValue).toBe('test2');
    expect(linkedList.find({ value: { value: 2, customValue: 'test5' } })).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1632}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 65, 'column': 4, 'index': 1682}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 65, 'column': 4, 'index': 1682}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1818}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1818}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 1898}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 1898}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 75, 'column': 4, 'index': 1978}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 77, 'column': 4, 'index': 2028}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 77, 'column': 4, 'index': 2028}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 78, 'column': 4, 'index': 2078}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 78, 'column': 4, 'index': 2078}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2155}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2203}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2203}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2253}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2330}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 89, 'column': 4, 'index': 2376}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 89, 'column': 4, 'index': 2376}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2426}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 2503}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 103, 'column': 4, 'index': 2722}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 103, 'column': 4, 'index': 2722}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 104, 'column': 4, 'index': 2772}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 109, 'column': 4, 'index': 2914}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 110, 'column': 4, 'index': 2961}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 110, 'column': 4, 'index': 2961}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 111, 'column': 4, 'index': 3011}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 116, 'column': 4, 'index': 3153}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 117, 'column': 4, 'index': 3198}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 117, 'column': 4, 'index': 3198}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 118, 'column': 4, 'index': 3248}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 123, 'column': 4, 'index': 3390}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 136, 'column': 4, 'index': 3712}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 3762}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 3762}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 142, 'column': 4, 'index': 3904}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 3949}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 3999}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 144, 'column': 4, 'index': 3999}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 149, 'column': 4, 'index': 4141}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 172, 'column': 4, 'index': 4805}","it('should find node by value', () => {
    const linkedList = new LinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 172, 'column': 4, 'index': 4805}","it('should find node by value', () => {
    const linkedList = new LinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 184, 'column': 4, 'index': 5076}","it('should find node by value', () => {
    const linkedList = new LinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 184, 'column': 4, 'index': 5076}","it('should find node by value', () => {
    const linkedList = new LinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 243, 'column': 4, 'index': 6937}","it('should find preferring callback over compare function', () => {
    const greaterThan = (value, compareTo) => (value > compareTo ? 0 : 1);

    const linkedList = new LinkedList(greaterThan);
    linkedList.fromArray([1, 2, 3, 4, 5]);

    let node = linkedList.find({ value: 3 });
    expect(node.value).toBe(4);

    node = linkedList.find({ callback: (value) => value < 3 });
    expect(node.value).toBe(1);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 246, 'column': 4, 'index': 7034}","it('should find preferring callback over compare function', () => {
    const greaterThan = (value, compareTo) => (value > compareTo ? 0 : 1);

    const linkedList = new LinkedList(greaterThan);
    linkedList.fromArray([1, 2, 3, 4, 5]);

    let node = linkedList.find({ value: 3 });
    expect(node.value).toBe(4);

    node = linkedList.find({ callback: (value) => value < 3 });
    expect(node.value).toBe(1);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 266, 'column': 4, 'index': 7489}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 266, 'column': 4, 'index': 7489}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 267, 'column': 4, 'index': 7538}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 267, 'column': 4, 'index': 7538}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 268, 'column': 4, 'index': 7581}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 268, 'column': 4, 'index': 7581}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 272, 'column': 4, 'index': 7679}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 273, 'column': 4, 'index': 7728}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 274, 'column': 4, 'index': 7771}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 278, 'column': 4, 'index': 7891}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 278, 'column': 4, 'index': 7891}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 279, 'column': 4, 'index': 7940}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 279, 'column': 4, 'index': 7940}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 280, 'column': 4, 'index': 7983}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Duplicate Assert,"{'line': 280, 'column': 4, 'index': 7983}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 68, 'column': 35, 'index': 1810}","it('should delete node by value from linked list', () => {
    const linkedList = new LinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 108, 'column': 36, 'index': 2906}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 115, 'column': 36, 'index': 3145}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 122, 'column': 36, 'index': 3382}","it('should delete linked list tail', () => {
    const linkedList = new LinkedList();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 141, 'column': 36, 'index': 3896}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 148, 'column': 36, 'index': 4133}","it('should delete linked list head', () => {
    const linkedList = new LinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 183, 'column': 28, 'index': 5068}","it('should find node by value', () => {
    const linkedList = new LinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 198, 'column': 34, 'index': 5512}","it('should find node by callback', () => {
    const linkedList = new LinkedList();

    linkedList
      .append({ value: 1, key: 'test1' })
      .append({ value: 2, key: 'test2' })
      .append({ value: 3, key: 'test3' });

    const node = linkedList.find({ callback: (value) => value.key === 'test2' });

    expect(node).toBeDefined();
    expect(node.value.value).toBe(2);
    expect(node.value.key).toBe('test2');
    expect(linkedList.find({ callback: (value) => value.key === 'test5' })).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 231, 'column': 34, 'index': 6497}","it('should find node by means of custom compare function', () => {
    const comparatorFunction = (a, b) => {
      if (a.customValue === b.customValue) {
        return 0;
      }

      return a.customValue < b.customValue ? -1 : 1;
    };

    const linkedList = new LinkedList(comparatorFunction);

    linkedList
      .append({ value: 1, customValue: 'test1' })
      .append({ value: 2, customValue: 'test2' })
      .append({ value: 3, customValue: 'test3' });

    const node = linkedList.find({
      value: { value: 2, customValue: 'test2' },
    });

    expect(node).toBeDefined();
    expect(node.value.value).toBe(2);
    expect(node.value.customValue).toBe('test2');
    expect(linkedList.find({ value: { value: 2, customValue: 'test5' } })).toBeNull();
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 243, 'column': 28, 'index': 6961}","it('should find preferring callback over compare function', () => {
    const greaterThan = (value, compareTo) => (value > compareTo ? 0 : 1);

    const linkedList = new LinkedList(greaterThan);
    linkedList.fromArray([1, 2, 3, 4, 5]);

    let node = linkedList.find({ value: 3 });
    expect(node.value).toBe(4);

    node = linkedList.find({ callback: (value) => value < 3 });
    expect(node.value).toBe(1);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 246, 'column': 28, 'index': 7058}","it('should find preferring callback over compare function', () => {
    const greaterThan = (value, compareTo) => (value > compareTo ? 0 : 1);

    const linkedList = new LinkedList(greaterThan);
    linkedList.fromArray([1, 2, 3, 4, 5]);

    let node = linkedList.find({ value: 3 });
    expect(node.value).toBe(4);

    node = linkedList.find({ callback: (value) => value < 3 });
    expect(node.value).toBe(1);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 267, 'column': 39, 'index': 7573}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 268, 'column': 39, 'index': 7616}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 273, 'column': 39, 'index': 7763}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 274, 'column': 39, 'index': 7806}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 279, 'column': 39, 'index': 7975}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/linked-list/__test__/LinkedList.test.js,Magic Number,"{'line': 280, 'column': 39, 'index': 8018}","it('should reverse linked list', () => {
    const linkedList = new LinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3);

    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);

    // Reverse linked list.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('3,2,1');
    expect(linkedList.head.value).toBe(3);
    expect(linkedList.tail.value).toBe(1);

    // Reverse linked list back to initial state.
    linkedList.reverse();
    expect(linkedList.toString()).toBe('1,2,3');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(3);
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 466}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 18, 'column': 4, 'index': 502}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 565}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 565}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 601}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 667}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 667}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 703}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 703}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 771}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 771}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 807}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 807}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 877}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 877}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 913}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 965}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 965}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 1001}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 1001}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1051}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1051}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1087}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1087}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1135}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1171}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1435}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 1488}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 1524}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1575}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1611}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 63, 'column': 4, 'index': 1660}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1696}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1743}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1780}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1824}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1861}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1861}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 1903}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 1947}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 1947}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2168}","it('should heapify down through the right branch as well', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);

    expect(minHeap.toString()).toBe('3,12,10');

    minHeap.add(11);
    expect(minHeap.toString()).toBe('3,11,10,12');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('10,11,12');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2238}","it('should heapify down through the right branch as well', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);

    expect(minHeap.toString()).toBe('3,12,10');

    minHeap.add(11);
    expect(minHeap.toString()).toBe('3,11,10,12');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('10,11,12');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Duplicate Assert,"{'line': 89, 'column': 4, 'index': 2326}","it('should heapify down through the right branch as well', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);

    expect(minHeap.toString()).toBe('3,12,10');

    minHeap.add(11);
    expect(minHeap.toString()).toBe('3,11,10,12');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('10,11,12');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 17, 'column': 32, 'index': 494}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 21, 'column': 32, 'index': 593}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 25, 'column': 32, 'index': 695}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 29, 'column': 32, 'index': 799}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 33, 'column': 32, 'index': 905}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 36, 'column': 32, 'index': 993}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 39, 'column': 32, 'index': 1079}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 42, 'column': 32, 'index': 1163}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 57, 'column': 32, 'index': 1516}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 60, 'column': 32, 'index': 1603}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 63, 'column': 32, 'index': 1688}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 66, 'column': 32, 'index': 1771}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 69, 'column': 32, 'index': 1852}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBe(undefined);
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeapAdhoc.test.js,Magic Number,"{'line': 88, 'column': 32, 'index': 2318}","it('should heapify down through the right branch as well', () => {
    const minHeap = new MinHeapAdhoc();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);

    expect(minHeap.toString()).toBe('3,12,10');

    minHeap.add(11);
    expect(minHeap.toString()).toBe('3,11,10,12');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('10,11,12');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Conditional Test Logic,"{'line': 162, 'column': 6, 'index': 4579}","it('should be possible to remove items from heap with custom finding comparator', () => {
    const minHeap = new MinHeap();
    minHeap.add('dddd');
    minHeap.add('ccc');
    minHeap.add('bb');
    minHeap.add('a');

    expect(minHeap.toString()).toBe('a,bb,ccc,dddd');

    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    minHeap.remove('hey', comparator);
    expect(minHeap.toString()).toBe('a,bb,dddd');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 18, 'column': 4, 'index': 499}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 535}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 598}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 598}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 634}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 700}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 700}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 736}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 736}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 804}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 804}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 840}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 840}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 910}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 910}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 946}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 998}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 998}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 1034}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 1034}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1084}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1084}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1120}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1120}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1168}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1204}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1463}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 1516}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1552}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1603}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1639}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1688}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 65, 'column': 4, 'index': 1724}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1771}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 1808}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1852}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 1889}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 1889}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 1931}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 1970}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 1970}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2186}","it('should heapify down through the right branch as well', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);

    expect(minHeap.toString()).toBe('3,12,10');

    minHeap.add(11);
    expect(minHeap.toString()).toBe('3,11,10,12');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('10,11,12');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2256}","it('should heapify down through the right branch as well', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);

    expect(minHeap.toString()).toBe('3,12,10');

    minHeap.add(11);
    expect(minHeap.toString()).toBe('3,11,10,12');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('10,11,12');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2344}","it('should heapify down through the right branch as well', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);

    expect(minHeap.toString()).toBe('3,12,10');

    minHeap.add(11);
    expect(minHeap.toString()).toBe('3,11,10,12');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('10,11,12');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 121, 'column': 4, 'index': 3136}","it('should be possible to remove items from heap with heapify down', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(11);

    expect(minHeap.toString()).toBe('3,11,10,12,11');

    expect(minHeap.remove(3).toString()).toEqual('10,11,11,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
    expect(minHeap.remove(11).toString()).toEqual('10,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 121, 'column': 4, 'index': 3136}","it('should be possible to remove items from heap with heapify down', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(11);

    expect(minHeap.toString()).toBe('3,11,10,12,11');

    expect(minHeap.remove(3).toString()).toEqual('10,11,11,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
    expect(minHeap.remove(11).toString()).toEqual('10,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 123, 'column': 4, 'index': 3246}","it('should be possible to remove items from heap with heapify down', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(11);

    expect(minHeap.toString()).toBe('3,11,10,12,11');

    expect(minHeap.remove(3).toString()).toEqual('10,11,11,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
    expect(minHeap.remove(11).toString()).toEqual('10,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 123, 'column': 4, 'index': 3246}","it('should be possible to remove items from heap with heapify down', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(11);

    expect(minHeap.toString()).toBe('3,11,10,12,11');

    expect(minHeap.remove(3).toString()).toEqual('10,11,11,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
    expect(minHeap.remove(11).toString()).toEqual('10,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 159, 'column': 4, 'index': 4472}","it('should be possible to remove items from heap with custom finding comparator', () => {
    const minHeap = new MinHeap();
    minHeap.add('dddd');
    minHeap.add('ccc');
    minHeap.add('bb');
    minHeap.add('a');

    expect(minHeap.toString()).toBe('a,bb,ccc,dddd');

    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    minHeap.remove('hey', comparator);
    expect(minHeap.toString()).toBe('a,bb,dddd');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 170, 'column': 4, 'index': 4730}","it('should be possible to remove items from heap with custom finding comparator', () => {
    const minHeap = new MinHeap();
    minHeap.add('dddd');
    minHeap.add('ccc');
    minHeap.add('bb');
    minHeap.add('a');

    expect(minHeap.toString()).toBe('a,bb,ccc,dddd');

    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    minHeap.remove('hey', comparator);
    expect(minHeap.toString()).toBe('a,bb,dddd');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 186, 'column': 4, 'index': 5083}","it('should remove values from heap and correctly re-order the tree', () => {
    const minHeap = new MinHeap();

    minHeap.add(1);
    minHeap.add(2);
    minHeap.add(3);
    minHeap.add(4);
    minHeap.add(5);
    minHeap.add(6);
    minHeap.add(7);
    minHeap.add(8);
    minHeap.add(9);

    expect(minHeap.toString()).toBe('1,2,3,4,5,6,7,8,9');

    minHeap.remove(2);
    expect(minHeap.toString()).toBe('1,4,3,8,5,6,7,9');

    minHeap.remove(4);
    expect(minHeap.toString()).toBe('1,5,3,8,9,6,7');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 189, 'column': 4, 'index': 5165}","it('should remove values from heap and correctly re-order the tree', () => {
    const minHeap = new MinHeap();

    minHeap.add(1);
    minHeap.add(2);
    minHeap.add(3);
    minHeap.add(4);
    minHeap.add(5);
    minHeap.add(6);
    minHeap.add(7);
    minHeap.add(8);
    minHeap.add(9);

    expect(minHeap.toString()).toBe('1,2,3,4,5,6,7,8,9');

    minHeap.remove(2);
    expect(minHeap.toString()).toBe('1,4,3,8,5,6,7,9');

    minHeap.remove(4);
    expect(minHeap.toString()).toBe('1,5,3,8,9,6,7');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Duplicate Assert,"{'line': 192, 'column': 4, 'index': 5245}","it('should remove values from heap and correctly re-order the tree', () => {
    const minHeap = new MinHeap();

    minHeap.add(1);
    minHeap.add(2);
    minHeap.add(3);
    minHeap.add(4);
    minHeap.add(5);
    minHeap.add(6);
    minHeap.add(7);
    minHeap.add(8);
    minHeap.add(9);

    expect(minHeap.toString()).toBe('1,2,3,4,5,6,7,8,9');

    minHeap.remove(2);
    expect(minHeap.toString()).toBe('1,4,3,8,5,6,7,9');

    minHeap.remove(4);
    expect(minHeap.toString()).toBe('1,5,3,8,9,6,7');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 18, 'column': 32, 'index': 527}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 22, 'column': 32, 'index': 626}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 26, 'column': 32, 'index': 728}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 30, 'column': 32, 'index': 832}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 34, 'column': 32, 'index': 938}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 37, 'column': 32, 'index': 1026}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 40, 'column': 32, 'index': 1112}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 43, 'column': 32, 'index': 1196}","it('should add items to the heap and heapify it up', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    expect(minHeap.isEmpty()).toBe(false);
    expect(minHeap.peek()).toBe(5);
    expect(minHeap.toString()).toBe('5');

    minHeap.add(3);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5');

    minHeap.add(10);
    expect(minHeap.peek()).toBe(3);
    expect(minHeap.toString()).toBe('3,5,10');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    minHeap.add(1);
    expect(minHeap.peek()).toBe(1);
    expect(minHeap.toString()).toBe('1,1,10,5,3');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('1,3,10,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,10');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 58, 'column': 32, 'index': 1544}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 61, 'column': 32, 'index': 1631}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 64, 'column': 32, 'index': 1716}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 67, 'column': 32, 'index': 1799}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 70, 'column': 32, 'index': 1880}","it('should poll items from the heap and heapify it down', () => {
    const minHeap = new MinHeap();

    minHeap.add(5);
    minHeap.add(3);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(1);

    expect(minHeap.toString()).toBe('1,3,10,11,5');

    expect(minHeap.poll()).toBe(1);
    expect(minHeap.toString()).toBe('3,5,10,11');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('5,11,10');

    expect(minHeap.poll()).toBe(5);
    expect(minHeap.toString()).toBe('10,11');

    expect(minHeap.poll()).toBe(10);
    expect(minHeap.toString()).toBe('11');

    expect(minHeap.poll()).toBe(11);
    expect(minHeap.toString()).toBe('');

    expect(minHeap.poll()).toBeNull();
    expect(minHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 89, 'column': 32, 'index': 2336}","it('should heapify down through the right branch as well', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);

    expect(minHeap.toString()).toBe('3,12,10');

    minHeap.add(11);
    expect(minHeap.toString()).toBe('3,11,10,12');

    expect(minHeap.poll()).toBe(3);
    expect(minHeap.toString()).toBe('10,11,12');
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 121, 'column': 45, 'index': 3177}","it('should be possible to remove items from heap with heapify down', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(11);

    expect(minHeap.toString()).toBe('3,11,10,12,11');

    expect(minHeap.remove(3).toString()).toEqual('10,11,11,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
    expect(minHeap.remove(11).toString()).toEqual('10,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
  })",steel
/src/data-structures/heap/__test__/MinHeap.test.js,Magic Number,"{'line': 123, 'column': 45, 'index': 3287}","it('should be possible to remove items from heap with heapify down', () => {
    const minHeap = new MinHeap();

    minHeap.add(3);
    minHeap.add(12);
    minHeap.add(10);
    minHeap.add(11);
    minHeap.add(11);

    expect(minHeap.toString()).toBe('3,11,10,12,11');

    expect(minHeap.remove(3).toString()).toEqual('10,11,11,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
    expect(minHeap.remove(11).toString()).toEqual('10,12');
    expect(minHeap.remove(3).peek()).toEqual(10);
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 451}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 451}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 18, 'column': 4, 'index': 487}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 550}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 550}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 586}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 652}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 652}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 689}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 757}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 757}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 794}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 864}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 864}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 901}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 953}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 990}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1039}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1075}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1122}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1158}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1416}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 1469}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 1506}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1556}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1593}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 63, 'column': 4, 'index': 1640}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1676}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1721}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1757}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1800}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1836}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1836}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 1878}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 1922}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 1922}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2138}","it('should heapify down through the right branch as well', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);

    expect(maxHeap.toString()).toBe('12,3,10');

    maxHeap.add(11);
    expect(maxHeap.toString()).toBe('12,11,10,3');

    expect(maxHeap.poll()).toBe(12);
    expect(maxHeap.toString()).toBe('11,3,10');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2208}","it('should heapify down through the right branch as well', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);

    expect(maxHeap.toString()).toBe('12,3,10');

    maxHeap.add(11);
    expect(maxHeap.toString()).toBe('12,11,10,3');

    expect(maxHeap.poll()).toBe(12);
    expect(maxHeap.toString()).toBe('11,3,10');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Duplicate Assert,"{'line': 89, 'column': 4, 'index': 2297}","it('should heapify down through the right branch as well', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);

    expect(maxHeap.toString()).toBe('12,3,10');

    maxHeap.add(11);
    expect(maxHeap.toString()).toBe('12,11,10,3');

    expect(maxHeap.poll()).toBe(12);
    expect(maxHeap.toString()).toBe('11,3,10');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 17, 'column': 32, 'index': 479}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 21, 'column': 32, 'index': 578}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 25, 'column': 32, 'index': 680}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 29, 'column': 32, 'index': 785}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 33, 'column': 32, 'index': 892}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 36, 'column': 32, 'index': 981}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 39, 'column': 32, 'index': 1067}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 42, 'column': 32, 'index': 1150}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 57, 'column': 32, 'index': 1497}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 60, 'column': 32, 'index': 1584}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 63, 'column': 32, 'index': 1668}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 66, 'column': 32, 'index': 1749}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 69, 'column': 32, 'index': 1828}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBe(undefined);
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeapAdhoc.test.js,Magic Number,"{'line': 88, 'column': 32, 'index': 2288}","it('should heapify down through the right branch as well', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);

    expect(maxHeap.toString()).toBe('12,3,10');

    maxHeap.add(11);
    expect(maxHeap.toString()).toBe('12,11,10,3');

    expect(maxHeap.poll()).toBe(12);
    expect(maxHeap.toString()).toBe('11,3,10');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Conditional Test Logic,"{'line': 162, 'column': 6, 'index': 4573}","it('should be possible to remove items from heap with custom finding comparator', () => {
    const maxHeap = new MaxHeap();
    maxHeap.add('a');
    maxHeap.add('bb');
    maxHeap.add('ccc');
    maxHeap.add('dddd');

    expect(maxHeap.toString()).toBe('dddd,ccc,bb,a');

    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    maxHeap.remove('hey', comparator);
    expect(maxHeap.toString()).toBe('dddd,a,bb');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 18, 'column': 4, 'index': 499}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 18, 'column': 4, 'index': 499}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 535}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 598}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 598}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 634}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 700}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 700}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 737}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 805}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 805}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 842}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 912}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 912}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 949}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 1001}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 1038}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1087}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1123}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1170}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1206}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1464}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 1517}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1554}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1604}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1641}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1688}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 65, 'column': 4, 'index': 1724}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1769}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 1805}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1848}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 1884}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 1884}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 1926}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 1965}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 1965}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2181}","it('should heapify down through the right branch as well', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);

    expect(maxHeap.toString()).toBe('12,3,10');

    maxHeap.add(11);
    expect(maxHeap.toString()).toBe('12,11,10,3');

    expect(maxHeap.poll()).toBe(12);
    expect(maxHeap.toString()).toBe('11,3,10');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2251}","it('should heapify down through the right branch as well', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);

    expect(maxHeap.toString()).toBe('12,3,10');

    maxHeap.add(11);
    expect(maxHeap.toString()).toBe('12,11,10,3');

    expect(maxHeap.poll()).toBe(12);
    expect(maxHeap.toString()).toBe('11,3,10');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2340}","it('should heapify down through the right branch as well', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);

    expect(maxHeap.toString()).toBe('12,3,10');

    maxHeap.add(11);
    expect(maxHeap.toString()).toBe('12,11,10,3');

    expect(maxHeap.poll()).toBe(12);
    expect(maxHeap.toString()).toBe('11,3,10');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 159, 'column': 4, 'index': 4466}","it('should be possible to remove items from heap with custom finding comparator', () => {
    const maxHeap = new MaxHeap();
    maxHeap.add('a');
    maxHeap.add('bb');
    maxHeap.add('ccc');
    maxHeap.add('dddd');

    expect(maxHeap.toString()).toBe('dddd,ccc,bb,a');

    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    maxHeap.remove('hey', comparator);
    expect(maxHeap.toString()).toBe('dddd,a,bb');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Duplicate Assert,"{'line': 170, 'column': 4, 'index': 4724}","it('should be possible to remove items from heap with custom finding comparator', () => {
    const maxHeap = new MaxHeap();
    maxHeap.add('a');
    maxHeap.add('bb');
    maxHeap.add('ccc');
    maxHeap.add('dddd');

    expect(maxHeap.toString()).toBe('dddd,ccc,bb,a');

    const comparator = new Comparator((a, b) => {
      if (a.length === b.length) {
        return 0;
      }

      return a.length < b.length ? -1 : 1;
    });

    maxHeap.remove('hey', comparator);
    expect(maxHeap.toString()).toBe('dddd,a,bb');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 18, 'column': 32, 'index': 527}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 22, 'column': 32, 'index': 626}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 26, 'column': 32, 'index': 728}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 30, 'column': 32, 'index': 833}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 34, 'column': 32, 'index': 940}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 37, 'column': 32, 'index': 1029}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 40, 'column': 32, 'index': 1115}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 43, 'column': 32, 'index': 1198}","it('should add items to the heap and heapify it up', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    expect(maxHeap.isEmpty()).toBe(false);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5');

    maxHeap.add(3);
    expect(maxHeap.peek()).toBe(5);
    expect(maxHeap.toString()).toBe('5,3');

    maxHeap.add(10);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    maxHeap.add(1);
    expect(maxHeap.peek()).toBe(10);
    expect(maxHeap.toString()).toBe('10,3,5,1,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1,1');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 58, 'column': 32, 'index': 1545}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 61, 'column': 32, 'index': 1632}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 64, 'column': 32, 'index': 1716}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 67, 'column': 32, 'index': 1797}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 70, 'column': 32, 'index': 1876}","it('should poll items from the heap and heapify it down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(5);
    maxHeap.add(3);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(1);

    expect(maxHeap.toString()).toBe('11,10,5,3,1');

    expect(maxHeap.poll()).toBe(11);
    expect(maxHeap.toString()).toBe('10,3,5,1');

    expect(maxHeap.poll()).toBe(10);
    expect(maxHeap.toString()).toBe('5,3,1');

    expect(maxHeap.poll()).toBe(5);
    expect(maxHeap.toString()).toBe('3,1');

    expect(maxHeap.poll()).toBe(3);
    expect(maxHeap.toString()).toBe('1');

    expect(maxHeap.poll()).toBe(1);
    expect(maxHeap.toString()).toBe('');

    expect(maxHeap.poll()).toBeNull();
    expect(maxHeap.toString()).toBe('');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 89, 'column': 32, 'index': 2331}","it('should heapify down through the right branch as well', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);

    expect(maxHeap.toString()).toBe('12,3,10');

    maxHeap.add(11);
    expect(maxHeap.toString()).toBe('12,11,10,3');

    expect(maxHeap.poll()).toBe(12);
    expect(maxHeap.toString()).toBe('11,3,10');
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 121, 'column': 46, 'index': 3174}","it('should be possible to remove items from heap with heapify down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(11);

    expect(maxHeap.toString()).toBe('12,11,10,3,11');

    expect(maxHeap.remove(12).toString()).toEqual('11,11,10,3');
    expect(maxHeap.remove(12).peek()).toEqual(11);
    expect(maxHeap.remove(11).toString()).toEqual('10,3');
    expect(maxHeap.remove(10).peek()).toEqual(3);
  })",steel
/src/data-structures/heap/__test__/MaxHeap.test.js,Magic Number,"{'line': 123, 'column': 46, 'index': 3284}","it('should be possible to remove items from heap with heapify down', () => {
    const maxHeap = new MaxHeap();

    maxHeap.add(3);
    maxHeap.add(12);
    maxHeap.add(10);
    maxHeap.add(11);
    maxHeap.add(11);

    expect(maxHeap.toString()).toBe('12,11,10,3,11');

    expect(maxHeap.remove(12).toString()).toEqual('11,11,10,3');
    expect(maxHeap.remove(12).peek()).toEqual(11);
    expect(maxHeap.remove(11).toString()).toEqual('10,3');
    expect(maxHeap.remove(10).peek()).toEqual(3);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1427}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1471}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1471}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1654}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1704}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1704}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1788}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 80, 'column': 4, 'index': 2479}","it('should track actual keys', () => {
    const hashTable = new HashTable(3);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.getKeys()).toEqual(['a', 'b', 'c', 'd']);
    expect(hashTable.has('a')).toBe(true);
    expect(hashTable.has('x')).toBe(false);

    hashTable.delete('a');

    expect(hashTable.has('a')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('x')).toBe(false);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2522}","it('should track actual keys', () => {
    const hashTable = new HashTable(3);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.getKeys()).toEqual(['a', 'b', 'c', 'd']);
    expect(hashTable.has('a')).toBe(true);
    expect(hashTable.has('x')).toBe(false);

    hashTable.delete('a');

    expect(hashTable.has('a')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('x')).toBe(false);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2522}","it('should track actual keys', () => {
    const hashTable = new HashTable(3);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.getKeys()).toEqual(['a', 'b', 'c', 'd']);
    expect(hashTable.has('a')).toBe(true);
    expect(hashTable.has('x')).toBe(false);

    hashTable.delete('a');

    expect(hashTable.has('a')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('x')).toBe(false);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2595}","it('should track actual keys', () => {
    const hashTable = new HashTable(3);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.getKeys()).toEqual(['a', 'b', 'c', 'd']);
    expect(hashTable.has('a')).toBe(true);
    expect(hashTable.has('x')).toBe(false);

    hashTable.delete('a');

    expect(hashTable.has('a')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('x')).toBe(false);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2682}","it('should track actual keys', () => {
    const hashTable = new HashTable(3);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.getKeys()).toEqual(['a', 'b', 'c', 'd']);
    expect(hashTable.has('a')).toBe(true);
    expect(hashTable.has('x')).toBe(false);

    hashTable.delete('a');

    expect(hashTable.has('a')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('x')).toBe(false);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2682}","it('should track actual keys', () => {
    const hashTable = new HashTable(3);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.getKeys()).toEqual(['a', 'b', 'c', 'd']);
    expect(hashTable.has('a')).toBe(true);
    expect(hashTable.has('x')).toBe(false);

    hashTable.delete('a');

    expect(hashTable.has('a')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('x')).toBe(false);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Magic Number,"{'line': 6, 'column': 49, 'index': 221}","it('should create hash table of certain size', () => {
    const defaultHashTable = new HashTable();
    expect(defaultHashTable.buckets.length).toBe(32);

    const biggerHashTable = new HashTable(64);
    expect(biggerHashTable.buckets.length).toBe(64);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Magic Number,"{'line': 9, 'column': 48, 'index': 322}","it('should create hash table of certain size', () => {
    const defaultHashTable = new HashTable();
    expect(defaultHashTable.buckets.length).toBe(32);

    const biggerHashTable = new HashTable(64);
    expect(biggerHashTable.buckets.length).toBe(64);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Magic Number,"{'line': 15, 'column': 37, 'index': 474}","it('should generate proper hash for specified keys', () => {
    const hashTable = new HashTable();

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('abc')).toBe(6);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Magic Number,"{'line': 16, 'column': 37, 'index': 515}","it('should generate proper hash for specified keys', () => {
    const hashTable = new HashTable();

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('abc')).toBe(6);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Magic Number,"{'line': 17, 'column': 39, 'index': 558}","it('should generate proper hash for specified keys', () => {
    const hashTable = new HashTable();

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('abc')).toBe(6);
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Magic Number,"{'line': 23, 'column': 37, 'index': 712}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Magic Number,"{'line': 24, 'column': 37, 'index': 753}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Magic Number,"{'line': 25, 'column': 37, 'index': 794}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/hash-table/__test__/HashTable.test.js,Magic Number,"{'line': 26, 'column': 37, 'index': 835}","it('should set, read and delete data with collisions', () => {
    const hashTable = new HashTable(3);

    expect(hashTable.hash('a')).toBe(1);
    expect(hashTable.hash('b')).toBe(2);
    expect(hashTable.hash('c')).toBe(0);
    expect(hashTable.hash('d')).toBe(1);

    hashTable.set('a', 'sky-old');
    hashTable.set('a', 'sky');
    hashTable.set('b', 'sea');
    hashTable.set('c', 'earth');
    hashTable.set('d', 'ocean');

    expect(hashTable.has('x')).toBe(false);
    expect(hashTable.has('b')).toBe(true);
    expect(hashTable.has('c')).toBe(true);

    const stringifier = (value) => `${value.key}:${value.value}`;

    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');

    expect(hashTable.get('a')).toBe('sky');
    expect(hashTable.get('d')).toBe('ocean');
    expect(hashTable.get('x')).not.toBeDefined();

    hashTable.delete('a');

    expect(hashTable.delete('not-existing')).toBeNull();

    expect(hashTable.get('a')).not.toBeDefined();
    expect(hashTable.get('d')).toBe('ocean');

    hashTable.set('d', 'ocean-new');
    expect(hashTable.get('d')).toBe('ocean-new');
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1489}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1587}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1587}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 1685}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1733}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 63, 'column': 4, 'index': 1882}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 63, 'column': 4, 'index': 1882}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1931}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 64, 'column': 4, 'index': 1931}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 65, 'column': 4, 'index': 1979}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 2070}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 2070}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 2119}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 2168}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2565}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2613}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 85, 'column': 4, 'index': 2613}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2663}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2711}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2711}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 90, 'column': 4, 'index': 2761}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 94, 'column': 4, 'index': 2840}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 2889}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 2889}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 97, 'column': 4, 'index': 2939}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 2988}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 2988}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 100, 'column': 4, 'index': 3038}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 171, 'column': 4, 'index': 5169}","it('should calculate vertex degree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    expect(vertexA.getDegree()).toBe(0);

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.getDegree()).toBe(1);

    const edgeBA = new GraphEdge(vertexB, vertexA);
    vertexA.addEdge(edgeBA);

    expect(vertexA.getDegree()).toBe(2);

    vertexA.addEdge(edgeAB);
    expect(vertexA.getDegree()).toBe(3);

    expect(vertexA.getEdges().length).toEqual(3);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 176, 'column': 4, 'index': 5293}","it('should calculate vertex degree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    expect(vertexA.getDegree()).toBe(0);

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.getDegree()).toBe(1);

    const edgeBA = new GraphEdge(vertexB, vertexA);
    vertexA.addEdge(edgeBA);

    expect(vertexA.getDegree()).toBe(2);

    vertexA.addEdge(edgeAB);
    expect(vertexA.getDegree()).toBe(3);

    expect(vertexA.getEdges().length).toEqual(3);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 181, 'column': 4, 'index': 5417}","it('should calculate vertex degree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    expect(vertexA.getDegree()).toBe(0);

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.getDegree()).toBe(1);

    const edgeBA = new GraphEdge(vertexB, vertexA);
    vertexA.addEdge(edgeBA);

    expect(vertexA.getDegree()).toBe(2);

    vertexA.addEdge(edgeAB);
    expect(vertexA.getDegree()).toBe(3);

    expect(vertexA.getEdges().length).toEqual(3);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Duplicate Assert,"{'line': 184, 'column': 4, 'index': 5488}","it('should calculate vertex degree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    expect(vertexA.getDegree()).toBe(0);

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.getDegree()).toBe(1);

    const edgeBA = new GraphEdge(vertexB, vertexA);
    vertexA.addEdge(edgeBA);

    expect(vertexA.getDegree()).toBe(2);

    vertexA.addEdge(edgeAB);
    expect(vertexA.getDegree()).toBe(3);

    expect(vertexA.getEdges().length).toEqual(3);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 36, 'column': 43, 'index': 1077}","it('should add edges to vertex and check if it exists', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.getEdges().length).toBe(1);
    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 57, 'column': 43, 'index': 1724}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 70, 'column': 43, 'index': 2207}","it('should delete edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
    expect(vertexA.getEdges()[1].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAB);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexA.getEdges()[0].toString()).toBe('A_C');

    vertexA.deleteEdge(edgeAC);
    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 90, 'column': 43, 'index': 2800}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 100, 'column': 43, 'index': 3077}","it('should delete all edges from vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexA.hasEdge(edgeAB)).toBe(true);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(true);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(2);

    vertexA.deleteAllEdges();

    expect(vertexA.hasEdge(edgeAB)).toBe(false);
    expect(vertexB.hasEdge(edgeAB)).toBe(false);

    expect(vertexA.hasEdge(edgeAC)).toBe(false);
    expect(vertexC.hasEdge(edgeAC)).toBe(false);

    expect(vertexA.getEdges().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 118, 'column': 34, 'index': 3593}","it('should return vertex neighbors in case if current node is start one', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    vertexA
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    expect(vertexB.getNeighbors()).toEqual([]);

    const neighbors = vertexA.getNeighbors();

    expect(neighbors.length).toBe(2);
    expect(neighbors[0]).toEqual(vertexB);
    expect(neighbors[1]).toEqual(vertexC);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 138, 'column': 34, 'index': 4193}","it('should return vertex neighbors in case if current node is end one', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeBA = new GraphEdge(vertexB, vertexA);
    const edgeCA = new GraphEdge(vertexC, vertexA);
    vertexA
      .addEdge(edgeBA)
      .addEdge(edgeCA);

    expect(vertexB.getNeighbors()).toEqual([]);

    const neighbors = vertexA.getNeighbors();

    expect(neighbors.length).toBe(2);
    expect(neighbors[0]).toEqual(vertexB);
    expect(neighbors[1]).toEqual(vertexC);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 171, 'column': 37, 'index': 5202}","it('should calculate vertex degree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    expect(vertexA.getDegree()).toBe(0);

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.getDegree()).toBe(1);

    const edgeBA = new GraphEdge(vertexB, vertexA);
    vertexA.addEdge(edgeBA);

    expect(vertexA.getDegree()).toBe(2);

    vertexA.addEdge(edgeAB);
    expect(vertexA.getDegree()).toBe(3);

    expect(vertexA.getEdges().length).toEqual(3);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 176, 'column': 37, 'index': 5326}","it('should calculate vertex degree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    expect(vertexA.getDegree()).toBe(0);

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.getDegree()).toBe(1);

    const edgeBA = new GraphEdge(vertexB, vertexA);
    vertexA.addEdge(edgeBA);

    expect(vertexA.getDegree()).toBe(2);

    vertexA.addEdge(edgeAB);
    expect(vertexA.getDegree()).toBe(3);

    expect(vertexA.getEdges().length).toEqual(3);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 181, 'column': 37, 'index': 5450}","it('should calculate vertex degree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    expect(vertexA.getDegree()).toBe(0);

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.getDegree()).toBe(1);

    const edgeBA = new GraphEdge(vertexB, vertexA);
    vertexA.addEdge(edgeBA);

    expect(vertexA.getDegree()).toBe(2);

    vertexA.addEdge(edgeAB);
    expect(vertexA.getDegree()).toBe(3);

    expect(vertexA.getEdges().length).toEqual(3);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 184, 'column': 37, 'index': 5521}","it('should calculate vertex degree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    expect(vertexA.getDegree()).toBe(0);

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.getDegree()).toBe(1);

    const edgeBA = new GraphEdge(vertexB, vertexA);
    vertexA.addEdge(edgeBA);

    expect(vertexA.getDegree()).toBe(2);

    vertexA.addEdge(edgeAB);
    expect(vertexA.getDegree()).toBe(3);

    expect(vertexA.getEdges().length).toEqual(3);
  })",steel
/src/data-structures/graph/__test__/GraphVertex.test.js,Magic Number,"{'line': 186, 'column': 46, 'index': 5572}","it('should calculate vertex degree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    expect(vertexA.getDegree()).toBe(0);

    const edgeAB = new GraphEdge(vertexA, vertexB);
    vertexA.addEdge(edgeAB);

    expect(vertexA.getDegree()).toBe(1);

    const edgeBA = new GraphEdge(vertexB, vertexA);
    vertexA.addEdge(edgeBA);

    expect(vertexA.getDegree()).toBe(2);

    vertexA.addEdge(edgeAB);
    expect(vertexA.getDegree()).toBe(3);

    expect(vertexA.getEdges().length).toEqual(3);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Duplicate Assert,"{'line': 32, 'column': 4, 'index': 1094}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 1141}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1186}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1186}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Duplicate Assert,"{'line': 38, 'column': 4, 'index': 1245}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1292}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1337}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1337}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Magic Number,"{'line': 14, 'column': 32, 'index': 529}","it('should create graph edge with default weight', () => {
    const startVertex = new GraphVertex('A');
    const endVertex = new GraphVertex('B');
    const edge = new GraphEdge(startVertex, endVertex);

    expect(edge.getKey()).toBe('A_B');
    expect(edge.toString()).toBe('A_B');
    expect(edge.startVertex).toEqual(startVertex);
    expect(edge.endVertex).toEqual(endVertex);
    expect(edge.weight).toEqual(0);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Magic Number,"{'line': 24, 'column': 32, 'index': 885}","it('should create graph edge with predefined weight', () => {
    const startVertex = new GraphVertex('A');
    const endVertex = new GraphVertex('B');
    const edge = new GraphEdge(startVertex, endVertex, 10);

    expect(edge.startVertex).toEqual(startVertex);
    expect(edge.endVertex).toEqual(endVertex);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Magic Number,"{'line': 34, 'column': 32, 'index': 1214}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/GraphEdge.test.js,Magic Number,"{'line': 40, 'column': 32, 'index': 1365}","it('should be possible to do edge reverse', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const edge = new GraphEdge(vertexA, vertexB, 10);

    expect(edge.startVertex).toEqual(vertexA);
    expect(edge.endVertex).toEqual(vertexB);
    expect(edge.weight).toEqual(10);

    edge.reverse();

    expect(edge.startVertex).toEqual(vertexB);
    expect(edge.endVertex).toEqual(vertexA);
    expect(edge.weight).toEqual(10);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1346}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1407}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1530}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 50, 'column': 4, 'index': 1591}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 2227}","it('should add edges to directed graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 2288}","it('should add edges to directed graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 242, 'column': 4, 'index': 7134}","it('should be possible to delete edges from graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC);

    expect(graph.getAllEdges().length).toBe(3);

    graph.deleteEdge(edgeAB);

    expect(graph.getAllEdges().length).toBe(2);
    expect(graph.getAllEdges()[0].getKey()).toBe(edgeBC.getKey());
    expect(graph.getAllEdges()[1].getKey()).toBe(edgeAC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 246, 'column': 4, 'index': 7214}","it('should be possible to delete edges from graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC);

    expect(graph.getAllEdges().length).toBe(3);

    graph.deleteEdge(edgeAB);

    expect(graph.getAllEdges().length).toBe(2);
    expect(graph.getAllEdges()[0].getKey()).toBe(edgeBC.getKey());
    expect(graph.getAllEdges()[1].getKey()).toBe(edgeAC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 285, 'column': 4, 'index': 8422}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 285, 'column': 4, 'index': 8422}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 286, 'column': 4, 'index': 8468}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 286, 'column': 4, 'index': 8468}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 287, 'column': 4, 'index': 8516}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 290, 'column': 4, 'index': 8724}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 8780}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 8780}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 292, 'column': 4, 'index': 8836}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 293, 'column': 4, 'index': 8912}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 297, 'column': 4, 'index': 8991}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 297, 'column': 4, 'index': 8991}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 298, 'column': 4, 'index': 9037}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 298, 'column': 4, 'index': 9037}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 299, 'column': 4, 'index': 9085}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 300, 'column': 4, 'index': 9141}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 302, 'column': 4, 'index': 9273}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 302, 'column': 4, 'index': 9273}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 303, 'column': 4, 'index': 9329}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Duplicate Assert,"{'line': 304, 'column': 4, 'index': 9405}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 31, 'column': 47, 'index': 848}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 44, 'column': 52, 'index': 1338}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 48, 'column': 52, 'index': 1522}","it('should add edges to undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    expect(graph.getAllVertices().length).toBe(2);
    expect(graph.getAllVertices()[0]).toEqual(vertexA);
    expect(graph.getAllVertices()[1]).toEqual(vertexB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graph.getVertexByKey('not existing')).toBeUndefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(1);
    expect(graphVertexB.getNeighbors()[0]).toEqual(vertexA);
    expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 70, 'column': 52, 'index': 2219}","it('should add edges to directed graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 74, 'column': 52, 'index': 2403}","it('should add edges to directed graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');

    const edgeAB = new GraphEdge(vertexA, vertexB);

    graph.addEdge(edgeAB);

    const graphVertexA = graph.getVertexByKey(vertexA.getKey());
    const graphVertexB = graph.getVertexByKey(vertexB.getKey());

    expect(graph.toString()).toBe('A,B');
    expect(graphVertexA).toBeDefined();
    expect(graphVertexB).toBeDefined();

    expect(graphVertexA.getNeighbors().length).toBe(1);
    expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
    expect(graphVertexA.getNeighbors()[0]).toEqual(graphVertexB);

    expect(graphVertexB.getNeighbors().length).toBe(0);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 97, 'column': 36, 'index': 3146}","it('should find edge by vertices in undirected graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB, 10);

    graph.addEdge(edgeAB);

    const graphEdgeAB = graph.findEdge(vertexA, vertexB);
    const graphEdgeBA = graph.findEdge(vertexB, vertexA);
    const graphEdgeAC = graph.findEdge(vertexA, vertexC);
    const graphEdgeCA = graph.findEdge(vertexC, vertexA);

    expect(graphEdgeAC).toBeNull();
    expect(graphEdgeCA).toBeNull();
    expect(graphEdgeAB).toEqual(edgeAB);
    expect(graphEdgeBA).toEqual(edgeAB);
    expect(graphEdgeAB.weight).toBe(10);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 120, 'column': 36, 'index': 3887}","it('should find edge by vertices in directed graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB, 10);

    graph.addEdge(edgeAB);

    const graphEdgeAB = graph.findEdge(vertexA, vertexB);
    const graphEdgeBA = graph.findEdge(vertexB, vertexA);
    const graphEdgeAC = graph.findEdge(vertexA, vertexC);
    const graphEdgeCA = graph.findEdge(vertexC, vertexA);

    expect(graphEdgeAC).toBeNull();
    expect(graphEdgeCA).toBeNull();
    expect(graphEdgeBA).toBeNull();
    expect(graphEdgeAB).toEqual(edgeAB);
    expect(graphEdgeAB.weight).toBe(10);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 139, 'column': 34, 'index': 4358}","it('should return vertex neighbors', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC);

    const neighbors = graph.getNeighbors(vertexA);

    expect(neighbors.length).toBe(2);
    expect(neighbors[0]).toEqual(vertexB);
    expect(neighbors[1]).toEqual(vertexC);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 177, 'column': 30, 'index': 5310}","it('should return the list of all added edges', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC);

    const edges = graph.getAllEdges();

    expect(edges.length).toBe(2);
    expect(edges[0]).toEqual(edgeAB);
    expect(edges[1]).toEqual(edgeBC);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 201, 'column': 35, 'index': 6016}","it('should calculate total graph weight for default graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeAD = new GraphEdge(vertexA, vertexD);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeAD);

    expect(graph.getWeight()).toBe(0);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 223, 'column': 35, 'index': 6659}","it('should calculate total graph weight for weighted graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeBC = new GraphEdge(vertexB, vertexC, 2);
    const edgeCD = new GraphEdge(vertexC, vertexD, 3);
    const edgeAD = new GraphEdge(vertexA, vertexD, 4);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeAD);

    expect(graph.getWeight()).toBe(10);
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 242, 'column': 44, 'index': 7174}","it('should be possible to delete edges from graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC);

    expect(graph.getAllEdges().length).toBe(3);

    graph.deleteEdge(edgeAB);

    expect(graph.getAllEdges().length).toBe(2);
    expect(graph.getAllEdges()[0].getKey()).toBe(edgeBC.getKey());
    expect(graph.getAllEdges()[1].getKey()).toBe(edgeAC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 246, 'column': 44, 'index': 7254}","it('should be possible to delete edges from graph', () => {
    const graph = new Graph();

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC);

    expect(graph.getAllEdges().length).toBe(3);

    graph.deleteEdge(edgeAB);

    expect(graph.getAllEdges().length).toBe(2);
    expect(graph.getAllEdges()[0].getKey()).toBe(edgeBC.getKey());
    expect(graph.getAllEdges()[1].getKey()).toBe(edgeAC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 286, 'column': 44, 'index': 8508}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 287, 'column': 52, 'index': 8564}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 290, 'column': 52, 'index': 8772}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 291, 'column': 52, 'index': 8828}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 293, 'column': 52, 'index': 8960}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 298, 'column': 44, 'index': 9077}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 299, 'column': 52, 'index': 9133}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 300, 'column': 52, 'index': 9189}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 302, 'column': 52, 'index': 9321}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/graph/__test__/Graph.test.js,Magic Number,"{'line': 304, 'column': 52, 'index': 9453}","it('should be possible to reverse graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeCD);

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(2);
    expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
    expect(graph.getNeighbors(vertexA)[1].getKey()).toBe(vertexC.getKey());
    expect(graph.getNeighbors(vertexB).length).toBe(0);
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexD.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(0);

    graph.reverse();

    expect(graph.toString()).toBe('A,B,C,D');
    expect(graph.getAllEdges().length).toBe(3);
    expect(graph.getNeighbors(vertexA).length).toBe(0);
    expect(graph.getNeighbors(vertexB).length).toBe(1);
    expect(graph.getNeighbors(vertexB)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexC).length).toBe(1);
    expect(graph.getNeighbors(vertexC)[0].getKey()).toBe(vertexA.getKey());
    expect(graph.getNeighbors(vertexD).length).toBe(1);
    expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1329}","it('should convert node to string', () => {
    const node = new DoublyLinkedListNode(1);

    expect(node.toString()).toBe('1');

    node.value = 'string value';
    expect(node.toString()).toBe('string value');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1402}","it('should convert node to string', () => {
    const node = new DoublyLinkedListNode(1);

    expect(node.toString()).toBe('1');

    node.value = 'string value';
    expect(node.toString()).toBe('string value');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js,Magic Number,"{'line': 7, 'column': 28, 'index': 228}","it('should create list node with value', () => {
    const node = new DoublyLinkedListNode(1);

    expect(node.value).toBe(1);
    expect(node.next).toBeNull();
    expect(node.previous).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js,Magic Number,"{'line': 16, 'column': 34, 'index': 512}","it('should create list node with object as a value', () => {
    const nodeValue = { value: 1, key: 'test' };
    const node = new DoublyLinkedListNode(nodeValue);

    expect(node.value.value).toBe(1);
    expect(node.value.key).toBe('test');
    expect(node.next).toBeNull();
    expect(node.previous).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js,Magic Number,"{'line': 33, 'column': 29, 'index': 1103}","it('should link nodes together', () => {
    const node2 = new DoublyLinkedListNode(2);
    const node1 = new DoublyLinkedListNode(1, node2);
    const node3 = new DoublyLinkedListNode(10, node1, node2);

    expect(node1.next).toBeDefined();
    expect(node1.previous).toBeNull();
    expect(node2.next).toBeNull();
    expect(node2.previous).toBeNull();
    expect(node3.next).toBeDefined();
    expect(node3.previous).toBeDefined();
    expect(node1.value).toBe(1);
    expect(node1.next.value).toBe(2);
    expect(node3.next.value).toBe(1);
    expect(node3.previous.value).toBe(2);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js,Magic Number,"{'line': 34, 'column': 34, 'index': 1141}","it('should link nodes together', () => {
    const node2 = new DoublyLinkedListNode(2);
    const node1 = new DoublyLinkedListNode(1, node2);
    const node3 = new DoublyLinkedListNode(10, node1, node2);

    expect(node1.next).toBeDefined();
    expect(node1.previous).toBeNull();
    expect(node2.next).toBeNull();
    expect(node2.previous).toBeNull();
    expect(node3.next).toBeDefined();
    expect(node3.previous).toBeDefined();
    expect(node1.value).toBe(1);
    expect(node1.next.value).toBe(2);
    expect(node3.next.value).toBe(1);
    expect(node3.previous.value).toBe(2);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js,Magic Number,"{'line': 35, 'column': 34, 'index': 1179}","it('should link nodes together', () => {
    const node2 = new DoublyLinkedListNode(2);
    const node1 = new DoublyLinkedListNode(1, node2);
    const node3 = new DoublyLinkedListNode(10, node1, node2);

    expect(node1.next).toBeDefined();
    expect(node1.previous).toBeNull();
    expect(node2.next).toBeNull();
    expect(node2.previous).toBeNull();
    expect(node3.next).toBeDefined();
    expect(node3.previous).toBeDefined();
    expect(node1.value).toBe(1);
    expect(node1.next.value).toBe(2);
    expect(node3.next.value).toBe(1);
    expect(node3.previous.value).toBe(2);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js,Magic Number,"{'line': 36, 'column': 38, 'index': 1221}","it('should link nodes together', () => {
    const node2 = new DoublyLinkedListNode(2);
    const node1 = new DoublyLinkedListNode(1, node2);
    const node3 = new DoublyLinkedListNode(10, node1, node2);

    expect(node1.next).toBeDefined();
    expect(node1.previous).toBeNull();
    expect(node2.next).toBeNull();
    expect(node2.previous).toBeNull();
    expect(node3.next).toBeDefined();
    expect(node3.previous).toBeDefined();
    expect(node1.value).toBe(1);
    expect(node1.next.value).toBe(2);
    expect(node3.next.value).toBe(1);
    expect(node3.previous.value).toBe(2);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Conditional Test Logic,"{'line': 208, 'column': 6, 'index': 6247}","it('should find node by means of custom compare function', () => {
    const comparatorFunction = (a, b) => {
      if (a.customValue === b.customValue) {
        return 0;
      }

      return a.customValue < b.customValue ? -1 : 1;
    };

    const linkedList = new DoublyLinkedList(comparatorFunction);

    linkedList
      .append({ value: 1, customValue: 'test1' })
      .append({ value: 2, customValue: 'test2' })
      .append({ value: 3, customValue: 'test3' });

    const node = linkedList.find({
      value: { value: 2, customValue: 'test2' },
    });

    expect(node).toBeDefined();
    expect(node.value.value).toBe(2);
    expect(node.value.customValue).toBe('test2');
    expect(linkedList.find({ value: 2, customValue: 'test5' })).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1738}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1788}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1788}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1985}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1985}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 2065}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 2065}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 2145}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 2195}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 2195}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 77, 'column': 4, 'index': 2375}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 77, 'column': 4, 'index': 2375}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 80, 'column': 4, 'index': 2452}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 82, 'column': 4, 'index': 2500}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 82, 'column': 4, 'index': 2500}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2550}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2627}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2673}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2673}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 89, 'column': 4, 'index': 2723}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 2851}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 105, 'column': 4, 'index': 3125}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 105, 'column': 4, 'index': 3125}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 106, 'column': 4, 'index': 3175}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 111, 'column': 4, 'index': 3317}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 112, 'column': 4, 'index': 3364}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 112, 'column': 4, 'index': 3364}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 113, 'column': 4, 'index': 3414}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 118, 'column': 4, 'index': 3556}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 119, 'column': 4, 'index': 3601}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 119, 'column': 4, 'index': 3601}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 120, 'column': 4, 'index': 3651}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 125, 'column': 4, 'index': 3793}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 138, 'column': 4, 'index': 4121}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 139, 'column': 4, 'index': 4171}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 139, 'column': 4, 'index': 4171}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 145, 'column': 4, 'index': 4362}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 146, 'column': 4, 'index': 4407}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 147, 'column': 4, 'index': 4457}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 147, 'column': 4, 'index': 4457}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 152, 'column': 4, 'index': 4599}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 175, 'column': 4, 'index': 5275}","it('should find node by value', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 175, 'column': 4, 'index': 5275}","it('should find node by value', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 187, 'column': 4, 'index': 5546}","it('should find node by value', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 187, 'column': 4, 'index': 5546}","it('should find node by value', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 242, 'column': 4, 'index': 7122}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 242, 'column': 4, 'index': 7122}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 243, 'column': 4, 'index': 7173}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 243, 'column': 4, 'index': 7173}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 244, 'column': 4, 'index': 7216}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 244, 'column': 4, 'index': 7216}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 249, 'column': 4, 'index': 7315}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 251, 'column': 4, 'index': 7367}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 251, 'column': 4, 'index': 7367}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 252, 'column': 4, 'index': 7416}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 253, 'column': 4, 'index': 7459}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 254, 'column': 4, 'index': 7507}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 255, 'column': 4, 'index': 7560}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 257, 'column': 4, 'index': 7619}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 257, 'column': 4, 'index': 7619}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 258, 'column': 4, 'index': 7664}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 259, 'column': 4, 'index': 7707}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 260, 'column': 4, 'index': 7759}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 261, 'column': 4, 'index': 7820}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 266, 'column': 4, 'index': 7968}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 266, 'column': 4, 'index': 7968}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 268, 'column': 4, 'index': 8020}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 268, 'column': 4, 'index': 8020}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 269, 'column': 4, 'index': 8069}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 269, 'column': 4, 'index': 8069}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 270, 'column': 4, 'index': 8112}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 271, 'column': 4, 'index': 8160}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 272, 'column': 4, 'index': 8213}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 274, 'column': 4, 'index': 8272}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 274, 'column': 4, 'index': 8272}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 275, 'column': 4, 'index': 8317}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 275, 'column': 4, 'index': 8317}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 276, 'column': 4, 'index': 8360}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 277, 'column': 4, 'index': 8412}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Duplicate Assert,"{'line': 278, 'column': 4, 'index': 8473}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 18, 'column': 44, 'index': 512}","it('should append node to linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.tail.previous.value).toBe(1);
    expect(linkedList.toString()).toBe('1,2');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 19, 'column': 48, 'index': 564}","it('should append node to linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.tail.previous.value).toBe(1);
    expect(linkedList.toString()).toBe('1,2');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 35, 'column': 48, 'index': 1091}","it('should prepend node to linked list', () => {
    const linkedList = new DoublyLinkedList();

    linkedList.prepend(2);
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    linkedList.append(1);
    linkedList.prepend(3);

    expect(linkedList.head.next.next.previous).toBe(linkedList.head.next);
    expect(linkedList.tail.previous.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('3,2,1');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 64, 'column': 35, 'index': 1916}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 65, 'column': 57, 'index': 1977}","it('should delete node by value from linked list', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.delete(5)).toBeNull();

    linkedList.append(1);
    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(3);
    linkedList.append(4);
    linkedList.append(5);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('5');

    const deletedNode = linkedList.delete(3);
    expect(deletedNode.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(3);
    expect(linkedList.toString()).toBe('1,1,2,4,5');

    linkedList.delete(1);
    expect(linkedList.toString()).toBe('2,4,5');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.head.next.next).toBe(linkedList.tail);
    expect(linkedList.tail.previous.previous).toBe(linkedList.head);
    expect(linkedList.tail.toString()).toBe('5');

    linkedList.delete(5);
    expect(linkedList.toString()).toBe('2,4');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('4');

    linkedList.delete(4);
    expect(linkedList.toString()).toBe('2');

    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');
    expect(linkedList.head).toBe(linkedList.tail);

    linkedList.delete(2);
    expect(linkedList.toString()).toBe('');
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 110, 'column': 36, 'index': 3309}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 117, 'column': 36, 'index': 3548}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 124, 'column': 36, 'index': 3785}","it('should delete linked list tail', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteTail()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);
    linkedList.append(3);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('3');

    const deletedNode1 = linkedList.deleteTail();

    expect(deletedNode1.value).toBe(3);
    expect(linkedList.toString()).toBe('1,2');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteTail();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('1');
    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('1');

    const deletedNode3 = linkedList.deleteTail();

    expect(deletedNode3.value).toBe(1);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 143, 'column': 36, 'index': 4305}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 151, 'column': 36, 'index': 4591}","it('should delete linked list head', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.deleteHead()).toBeNull();

    linkedList.append(1);
    linkedList.append(2);

    expect(linkedList.head.toString()).toBe('1');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode1 = linkedList.deleteHead();

    expect(deletedNode1.value).toBe(1);
    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.toString()).toBe('2');
    expect(linkedList.head.toString()).toBe('2');
    expect(linkedList.tail.toString()).toBe('2');

    const deletedNode2 = linkedList.deleteHead();

    expect(deletedNode2.value).toBe(2);
    expect(linkedList.toString()).toBe('');
    expect(linkedList.head).toBeNull();
    expect(linkedList.tail).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 186, 'column': 28, 'index': 5538}","it('should find node by value', () => {
    const linkedList = new DoublyLinkedList();

    expect(linkedList.find({ value: 5 })).toBeNull();

    linkedList.append(1);
    expect(linkedList.find({ value: 1 })).toBeDefined();

    linkedList
      .append(2)
      .append(3);

    const node = linkedList.find({ value: 2 });

    expect(node.value).toBe(2);
    expect(linkedList.find({ value: 5 })).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 201, 'column': 34, 'index': 5988}","it('should find node by callback', () => {
    const linkedList = new DoublyLinkedList();

    linkedList
      .append({ value: 1, key: 'test1' })
      .append({ value: 2, key: 'test2' })
      .append({ value: 3, key: 'test3' });

    const node = linkedList.find({ callback: (value) => value.key === 'test2' });

    expect(node).toBeDefined();
    expect(node.value.value).toBe(2);
    expect(node.value.key).toBe('test2');
    expect(linkedList.find({ callback: (value) => value.key === 'test5' })).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 227, 'column': 34, 'index': 6766}","it('should find node by means of custom compare function', () => {
    const comparatorFunction = (a, b) => {
      if (a.customValue === b.customValue) {
        return 0;
      }

      return a.customValue < b.customValue ? -1 : 1;
    };

    const linkedList = new DoublyLinkedList(comparatorFunction);

    linkedList
      .append({ value: 1, customValue: 'test1' })
      .append({ value: 2, customValue: 'test2' })
      .append({ value: 3, customValue: 'test3' });

    const node = linkedList.find({
      value: { value: 2, customValue: 'test2' },
    });

    expect(node).toBeDefined();
    expect(node.value.value).toBe(2);
    expect(node.value.customValue).toBe('test2');
    expect(linkedList.find({ value: 2, customValue: 'test5' })).toBeNull();
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 243, 'column': 39, 'index': 7208}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 244, 'column': 39, 'index': 7251}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 252, 'column': 39, 'index': 7451}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 253, 'column': 44, 'index': 7499}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 254, 'column': 49, 'index': 7552}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 255, 'column': 54, 'index': 7610}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 258, 'column': 39, 'index': 7699}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 259, 'column': 48, 'index': 7751}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 260, 'column': 57, 'index': 7812}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 261, 'column': 66, 'index': 7882}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 269, 'column': 39, 'index': 8104}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 270, 'column': 44, 'index': 8152}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 271, 'column': 49, 'index': 8205}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 272, 'column': 54, 'index': 8263}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 275, 'column': 39, 'index': 8352}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 276, 'column': 48, 'index': 8404}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 277, 'column': 57, 'index': 8465}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js,Magic Number,"{'line': 278, 'column': 66, 'index': 8535}","it('should reverse linked list', () => {
    const linkedList = new DoublyLinkedList();

    // Add test values to linked list.
    linkedList
      .append(1)
      .append(2)
      .append(3)
      .append(4);

    expect(linkedList.toString()).toBe('1,2,3,4');
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.tail.value).toBe(4);

    // Reverse linked list.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('4,3,2,1');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(4);
    expect(linkedList.head.next.value).toBe(3);
    expect(linkedList.head.next.next.value).toBe(2);
    expect(linkedList.head.next.next.next.value).toBe(1);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(1);
    expect(linkedList.tail.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.previous.value).toBe(4);

    // Reverse linked list back to initial state.
    linkedList.reverse();

    expect(linkedList.toString()).toBe('1,2,3,4');

    expect(linkedList.head.previous).toBeNull();
    expect(linkedList.head.value).toBe(1);
    expect(linkedList.head.next.value).toBe(2);
    expect(linkedList.head.next.next.value).toBe(3);
    expect(linkedList.head.next.next.next.value).toBe(4);

    expect(linkedList.tail.next).toBeNull();
    expect(linkedList.tail.value).toBe(4);
    expect(linkedList.tail.previous.value).toBe(3);
    expect(linkedList.tail.previous.previous.value).toBe(2);
    expect(linkedList.tail.previous.previous.previous.value).toBe(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 10, 'column': 4, 'index': 336}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 456}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 456}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 500}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 500}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 15, 'column': 4, 'index': 539}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 20, 'column': 4, 'index': 635}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 672}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 710}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1082}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1082}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1260}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1260}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1299}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1299}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1339}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1378}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1378}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1447}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1447}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1486}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1486}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 50, 'column': 4, 'index': 1526}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1566}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 51, 'column': 4, 'index': 1566}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1607}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1647}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1687}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 2207}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 2327}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 2327}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 2371}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 72, 'column': 4, 'index': 2371}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 2410}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 78, 'column': 4, 'index': 2506}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 79, 'column': 4, 'index': 2543}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 81, 'column': 4, 'index': 2581}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 2953}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 2953}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 99, 'column': 4, 'index': 3131}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 99, 'column': 4, 'index': 3131}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 100, 'column': 4, 'index': 3170}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 100, 'column': 4, 'index': 3170}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 101, 'column': 4, 'index': 3210}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 102, 'column': 4, 'index': 3249}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 102, 'column': 4, 'index': 3249}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 106, 'column': 4, 'index': 3318}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 106, 'column': 4, 'index': 3318}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 107, 'column': 4, 'index': 3357}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 107, 'column': 4, 'index': 3357}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 108, 'column': 4, 'index': 3397}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 109, 'column': 4, 'index': 3437}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 109, 'column': 4, 'index': 3437}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 111, 'column': 4, 'index': 3478}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 112, 'column': 4, 'index': 3518}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Duplicate Assert,"{'line': 113, 'column': 4, 'index': 3558}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 10, 'column': 33, 'index': 365}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 20, 'column': 33, 'index': 664}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 21, 'column': 33, 'index': 701}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 23, 'column': 33, 'index': 739}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 24, 'column': 33, 'index': 776}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 26, 'column': 44, 'index': 825}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 27, 'column': 44, 'index': 873}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 32, 'column': 44, 'index': 1025}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 33, 'column': 44, 'index': 1073}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 53, 'column': 36, 'index': 1639}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 54, 'column': 36, 'index': 1679}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 55, 'column': 36, 'index': 1719}","it('should do basic manipulation with disjoint set item', () => {
    const itemA = new DisjointSetItem('A');
    const itemB = new DisjointSetItem('B');
    const itemC = new DisjointSetItem('C');
    const itemD = new DisjointSetItem('D');

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 68, 'column': 33, 'index': 2236}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 78, 'column': 33, 'index': 2535}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 79, 'column': 33, 'index': 2572}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 81, 'column': 33, 'index': 2610}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 82, 'column': 33, 'index': 2647}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 84, 'column': 44, 'index': 2696}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 85, 'column': 44, 'index': 2744}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 90, 'column': 44, 'index': 2896}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 91, 'column': 44, 'index': 2944}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 111, 'column': 36, 'index': 3510}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 112, 'column': 36, 'index': 3550}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js,Magic Number,"{'line': 113, 'column': 36, 'index': 3590}","it('should do basic manipulation with disjoint set item with custom key extractor', () => {
    const keyExtractor = (value) => {
      return value.key;
    };

    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);

    expect(itemA.getRank()).toBe(0);
    expect(itemA.getChildren()).toEqual([]);
    expect(itemA.getKey()).toBe('A');
    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(true);

    itemA.addChild(itemB);
    itemD.setParent(itemC);

    expect(itemA.getRank()).toBe(1);
    expect(itemC.getRank()).toBe(1);

    expect(itemB.getRank()).toBe(0);
    expect(itemD.getRank()).toBe(0);

    expect(itemA.getChildren().length).toBe(1);
    expect(itemC.getChildren().length).toBe(1);

    expect(itemA.getChildren()[0]).toEqual(itemB);
    expect(itemC.getChildren()[0]).toEqual(itemD);

    expect(itemB.getChildren().length).toBe(0);
    expect(itemD.getChildren().length).toBe(0);

    expect(itemA.getRoot()).toEqual(itemA);
    expect(itemB.getRoot()).toEqual(itemA);

    expect(itemC.getRoot()).toEqual(itemC);
    expect(itemD.getRoot()).toEqual(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(true);
    expect(itemD.isRoot()).toBe(false);

    itemA.addChild(itemC);

    expect(itemA.isRoot()).toBe(true);
    expect(itemB.isRoot()).toBe(false);
    expect(itemC.isRoot()).toBe(false);
    expect(itemD.isRoot()).toBe(false);

    expect(itemA.getRank()).toEqual(3);
    expect(itemB.getRank()).toEqual(0);
    expect(itemC.getRank()).toEqual(1);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetAdhoc.test.js,Duplicate Assert,"{'line': 20, 'column': 4, 'index': 488}","it('should create unions and find connected elements', () => {
    const set = new DisjointSetAdhoc(10);

    // 1-2-5-6-7 3-8-9 4
    set.union(1, 2);
    set.union(2, 5);
    set.union(5, 6);
    set.union(6, 7);

    set.union(3, 8);
    set.union(8, 9);

    expect(set.connected(1, 5)).toBe(true);
    expect(set.connected(5, 7)).toBe(true);
    expect(set.connected(3, 8)).toBe(true);

    expect(set.connected(4, 9)).toBe(false);
    expect(set.connected(4, 7)).toBe(false);

    // 1-2-5-6-7 3-8-9-4
    set.union(9, 4);

    expect(set.connected(4, 9)).toBe(true);
    expect(set.connected(4, 3)).toBe(true);
    expect(set.connected(8, 4)).toBe(true);

    expect(set.connected(8, 7)).toBe(false);
    expect(set.connected(2, 3)).toBe(false);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetAdhoc.test.js,Duplicate Assert,"{'line': 26, 'column': 4, 'index': 626}","it('should create unions and find connected elements', () => {
    const set = new DisjointSetAdhoc(10);

    // 1-2-5-6-7 3-8-9 4
    set.union(1, 2);
    set.union(2, 5);
    set.union(5, 6);
    set.union(6, 7);

    set.union(3, 8);
    set.union(8, 9);

    expect(set.connected(1, 5)).toBe(true);
    expect(set.connected(5, 7)).toBe(true);
    expect(set.connected(3, 8)).toBe(true);

    expect(set.connected(4, 9)).toBe(false);
    expect(set.connected(4, 7)).toBe(false);

    // 1-2-5-6-7 3-8-9-4
    set.union(9, 4);

    expect(set.connected(4, 9)).toBe(true);
    expect(set.connected(4, 3)).toBe(true);
    expect(set.connected(8, 4)).toBe(true);

    expect(set.connected(8, 7)).toBe(false);
    expect(set.connected(2, 3)).toBe(false);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSetAdhoc.test.js,Magic Number,"{'line': 48, 'column': 42, 'index': 1259}","it('should keep the height of the tree small', () => {
    const set = new DisjointSetAdhoc(10);

    // 1-2-6-7-9 1 3 4 5
    set.union(7, 6);
    set.union(1, 2);
    set.union(2, 6);
    set.union(1, 7);
    set.union(9, 1);

    expect(set.connected(1, 7)).toBe(true);
    expect(set.connected(6, 9)).toBe(true);
    expect(set.connected(4, 9)).toBe(false);

    expect(Math.max(...set.heights)).toBe(3);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 24, 'column': 4, 'index': 620}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 666}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 666}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 744}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 744}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 789}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 789}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 867}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 867}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 912}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 989}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1081}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1081}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1126}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1126}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1171}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1171}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1283}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1409}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1409}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1454}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1454}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 1545}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 1545}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1657}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 74, 'column': 4, 'index': 1942}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 80, 'column': 4, 'index': 2135}","it('should do basic manipulations on disjoint set', () => {
    const disjointSet = new DisjointSet();

    expect(disjointSet.find('A')).toBeNull();
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('A');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBeNull();

    disjointSet.makeSet('B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('B');

    disjointSet.makeSet('C');

    expect(disjointSet.inSameSet('A', 'B')).toBe(false);

    disjointSet.union('A', 'B');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(false);

    disjointSet.union('A', 'A');

    disjointSet.union('B', 'C');

    expect(disjointSet.find('A')).toBe('A');
    expect(disjointSet.find('B')).toBe('A');
    expect(disjointSet.find('C')).toBe('A');

    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
    expect(disjointSet.inSameSet('A', 'C')).toBe(true);

    disjointSet
      .makeSet('E')
      .makeSet('F')
      .makeSet('G')
      .makeSet('H')
      .makeSet('I');

    disjointSet
      .union('E', 'F')
      .union('F', 'G')
      .union('G', 'H')
      .union('H', 'I');

    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
    expect(disjointSet.inSameSet('E', 'I')).toBe(true);

    disjointSet.union('I', 'C');

    expect(disjointSet.find('I')).toBe('E');
    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 105, 'column': 4, 'index': 2827}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 106, 'column': 4, 'index': 2875}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 106, 'column': 4, 'index': 2875}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 110, 'column': 4, 'index': 2957}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 110, 'column': 4, 'index': 2957}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 111, 'column': 4, 'index': 3004}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 111, 'column': 4, 'index': 3004}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 115, 'column': 4, 'index': 3086}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 115, 'column': 4, 'index': 3086}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 116, 'column': 4, 'index': 3133}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 120, 'column': 4, 'index': 3214}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 124, 'column': 4, 'index': 3314}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 124, 'column': 4, 'index': 3314}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 125, 'column': 4, 'index': 3361}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 125, 'column': 4, 'index': 3361}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 126, 'column': 4, 'index': 3408}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 126, 'column': 4, 'index': 3408}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 128, 'column': 4, 'index': 3528}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 132, 'column': 4, 'index': 3628}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 132, 'column': 4, 'index': 3628}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 133, 'column': 4, 'index': 3675}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 133, 'column': 4, 'index': 3675}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 136, 'column': 4, 'index': 3770}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 136, 'column': 4, 'index': 3770}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/disjoint-set/__test__/DisjointSet.test.js,Duplicate Assert,"{'line': 138, 'column': 4, 'index': 3890}","it('should do basic manipulations on disjoint set with custom key extractor', () => {
    const keyExtractor = (value) => value.key;

    const disjointSet = new DisjointSet(keyExtractor);

    const itemA = { key: 'A', value: 1 };
    const itemB = { key: 'B', value: 2 };
    const itemC = { key: 'C', value: 3 };

    expect(disjointSet.find(itemA)).toBeNull();
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemA);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBeNull();

    disjointSet.makeSet(itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('B');

    disjointSet.makeSet(itemC);

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(false);

    disjointSet.union(itemA, itemB);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);

    disjointSet.union(itemA, itemC);

    expect(disjointSet.find(itemA)).toBe('A');
    expect(disjointSet.find(itemB)).toBe('A');
    expect(disjointSet.find(itemC)).toBe('A');

    expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
    expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
    expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 770}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 840}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 910}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 981}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1027}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1073}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1148}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1218}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1288}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1359}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1404}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1450}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Magic Number,"{'line': 33, 'column': 41, 'index': 1018}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Magic Number,"{'line': 34, 'column': 41, 'index': 1064}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Magic Number,"{'line': 35, 'column': 41, 'index': 1110}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Magic Number,"{'line': 43, 'column': 41, 'index': 1396}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Magic Number,"{'line': 44, 'column': 41, 'index': 1441}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Magic Number,"{'line': 45, 'column': 41, 'index': 1487}","it('should hash deterministically with all 3 hash functions', () => {
    const str1 = 'apple';

    expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
    expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
    expect(bloomFilter.hash3(str1)).toEqual(bloomFilter.hash3(str1));

    expect(bloomFilter.hash1(str1)).toBe(14);
    expect(bloomFilter.hash2(str1)).toBe(43);
    expect(bloomFilter.hash3(str1)).toBe(10);

    const str2 = 'orange';

    expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
    expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
    expect(bloomFilter.hash3(str2)).toEqual(bloomFilter.hash3(str2));

    expect(bloomFilter.hash1(str2)).toBe(0);
    expect(bloomFilter.hash2(str2)).toBe(61);
    expect(bloomFilter.hash3(str2)).toBe(10);
  })",steel
/src/data-structures/bloom-filter/__test__/BloomFilter.test.js,Magic Number,"{'line': 49, 'column': 57, 'index': 1614}","it('should create an array with 3 hash values', () => {
    expect(bloomFilter.getHashValues('abc').length).toBe(3);
    expect(bloomFilter.getHashValues('abc')).toEqual([66, 63, 54]);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js,Magic Number,"{'line': 5, 'column': 35, 'index': 174}","it('should find the number of unique paths on board', () => {
    expect(uniquePaths(3, 2)).toBe(3);
    expect(uniquePaths(7, 3)).toBe(28);
    expect(uniquePaths(3, 7)).toBe(28);
    expect(uniquePaths(10, 10)).toBe(48620);
    expect(uniquePaths(100, 1)).toBe(1);
    expect(uniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js,Magic Number,"{'line': 6, 'column': 35, 'index': 213}","it('should find the number of unique paths on board', () => {
    expect(uniquePaths(3, 2)).toBe(3);
    expect(uniquePaths(7, 3)).toBe(28);
    expect(uniquePaths(3, 7)).toBe(28);
    expect(uniquePaths(10, 10)).toBe(48620);
    expect(uniquePaths(100, 1)).toBe(1);
    expect(uniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js,Magic Number,"{'line': 7, 'column': 35, 'index': 253}","it('should find the number of unique paths on board', () => {
    expect(uniquePaths(3, 2)).toBe(3);
    expect(uniquePaths(7, 3)).toBe(28);
    expect(uniquePaths(3, 7)).toBe(28);
    expect(uniquePaths(10, 10)).toBe(48620);
    expect(uniquePaths(100, 1)).toBe(1);
    expect(uniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js,Magic Number,"{'line': 8, 'column': 37, 'index': 295}","it('should find the number of unique paths on board', () => {
    expect(uniquePaths(3, 2)).toBe(3);
    expect(uniquePaths(7, 3)).toBe(28);
    expect(uniquePaths(3, 7)).toBe(28);
    expect(uniquePaths(10, 10)).toBe(48620);
    expect(uniquePaths(100, 1)).toBe(1);
    expect(uniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js,Magic Number,"{'line': 9, 'column': 37, 'index': 340}","it('should find the number of unique paths on board', () => {
    expect(uniquePaths(3, 2)).toBe(3);
    expect(uniquePaths(7, 3)).toBe(28);
    expect(uniquePaths(3, 7)).toBe(28);
    expect(uniquePaths(10, 10)).toBe(48620);
    expect(uniquePaths(100, 1)).toBe(1);
    expect(uniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js,Magic Number,"{'line': 10, 'column': 37, 'index': 381}","it('should find the number of unique paths on board', () => {
    expect(uniquePaths(3, 2)).toBe(3);
    expect(uniquePaths(7, 3)).toBe(28);
    expect(uniquePaths(3, 7)).toBe(28);
    expect(uniquePaths(10, 10)).toBe(48620);
    expect(uniquePaths(100, 1)).toBe(1);
    expect(uniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js,Magic Number,"{'line': 5, 'column': 37, 'index': 182}","it('should find the number of unique paths on board', () => {
    expect(dpUniquePaths(3, 2)).toBe(3);
    expect(dpUniquePaths(7, 3)).toBe(28);
    expect(dpUniquePaths(3, 7)).toBe(28);
    expect(dpUniquePaths(10, 10)).toBe(48620);
    expect(dpUniquePaths(100, 1)).toBe(1);
    expect(dpUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js,Magic Number,"{'line': 6, 'column': 37, 'index': 223}","it('should find the number of unique paths on board', () => {
    expect(dpUniquePaths(3, 2)).toBe(3);
    expect(dpUniquePaths(7, 3)).toBe(28);
    expect(dpUniquePaths(3, 7)).toBe(28);
    expect(dpUniquePaths(10, 10)).toBe(48620);
    expect(dpUniquePaths(100, 1)).toBe(1);
    expect(dpUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js,Magic Number,"{'line': 7, 'column': 37, 'index': 265}","it('should find the number of unique paths on board', () => {
    expect(dpUniquePaths(3, 2)).toBe(3);
    expect(dpUniquePaths(7, 3)).toBe(28);
    expect(dpUniquePaths(3, 7)).toBe(28);
    expect(dpUniquePaths(10, 10)).toBe(48620);
    expect(dpUniquePaths(100, 1)).toBe(1);
    expect(dpUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js,Magic Number,"{'line': 8, 'column': 39, 'index': 309}","it('should find the number of unique paths on board', () => {
    expect(dpUniquePaths(3, 2)).toBe(3);
    expect(dpUniquePaths(7, 3)).toBe(28);
    expect(dpUniquePaths(3, 7)).toBe(28);
    expect(dpUniquePaths(10, 10)).toBe(48620);
    expect(dpUniquePaths(100, 1)).toBe(1);
    expect(dpUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js,Magic Number,"{'line': 9, 'column': 39, 'index': 356}","it('should find the number of unique paths on board', () => {
    expect(dpUniquePaths(3, 2)).toBe(3);
    expect(dpUniquePaths(7, 3)).toBe(28);
    expect(dpUniquePaths(3, 7)).toBe(28);
    expect(dpUniquePaths(10, 10)).toBe(48620);
    expect(dpUniquePaths(100, 1)).toBe(1);
    expect(dpUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js,Magic Number,"{'line': 10, 'column': 39, 'index': 399}","it('should find the number of unique paths on board', () => {
    expect(dpUniquePaths(3, 2)).toBe(3);
    expect(dpUniquePaths(7, 3)).toBe(28);
    expect(dpUniquePaths(3, 7)).toBe(28);
    expect(dpUniquePaths(10, 10)).toBe(48620);
    expect(dpUniquePaths(100, 1)).toBe(1);
    expect(dpUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js,Magic Number,"{'line': 5, 'column': 37, 'index': 182}","it('should find the number of unique paths on board', () => {
    expect(btUniquePaths(3, 2)).toBe(3);
    expect(btUniquePaths(7, 3)).toBe(28);
    expect(btUniquePaths(3, 7)).toBe(28);
    expect(btUniquePaths(10, 10)).toBe(48620);
    expect(btUniquePaths(100, 1)).toBe(1);
    expect(btUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js,Magic Number,"{'line': 6, 'column': 37, 'index': 223}","it('should find the number of unique paths on board', () => {
    expect(btUniquePaths(3, 2)).toBe(3);
    expect(btUniquePaths(7, 3)).toBe(28);
    expect(btUniquePaths(3, 7)).toBe(28);
    expect(btUniquePaths(10, 10)).toBe(48620);
    expect(btUniquePaths(100, 1)).toBe(1);
    expect(btUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js,Magic Number,"{'line': 7, 'column': 37, 'index': 265}","it('should find the number of unique paths on board', () => {
    expect(btUniquePaths(3, 2)).toBe(3);
    expect(btUniquePaths(7, 3)).toBe(28);
    expect(btUniquePaths(3, 7)).toBe(28);
    expect(btUniquePaths(10, 10)).toBe(48620);
    expect(btUniquePaths(100, 1)).toBe(1);
    expect(btUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js,Magic Number,"{'line': 8, 'column': 39, 'index': 309}","it('should find the number of unique paths on board', () => {
    expect(btUniquePaths(3, 2)).toBe(3);
    expect(btUniquePaths(7, 3)).toBe(28);
    expect(btUniquePaths(3, 7)).toBe(28);
    expect(btUniquePaths(10, 10)).toBe(48620);
    expect(btUniquePaths(100, 1)).toBe(1);
    expect(btUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js,Magic Number,"{'line': 9, 'column': 39, 'index': 356}","it('should find the number of unique paths on board', () => {
    expect(btUniquePaths(3, 2)).toBe(3);
    expect(btUniquePaths(7, 3)).toBe(28);
    expect(btUniquePaths(3, 7)).toBe(28);
    expect(btUniquePaths(10, 10)).toBe(48620);
    expect(btUniquePaths(100, 1)).toBe(1);
    expect(btUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js,Magic Number,"{'line': 10, 'column': 39, 'index': 399}","it('should find the number of unique paths on board', () => {
    expect(btUniquePaths(3, 2)).toBe(3);
    expect(btUniquePaths(7, 3)).toBe(28);
    expect(btUniquePaths(3, 7)).toBe(28);
    expect(btUniquePaths(10, 10)).toBe(48620);
    expect(btUniquePaths(100, 1)).toBe(1);
    expect(btUniquePaths(1, 100)).toBe(1);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 5, 'column': 43, 'index': 235}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 6, 'column': 42, 'index': 281}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 7, 'column': 42, 'index': 327}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 8, 'column': 42, 'index': 373}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 9, 'column': 42, 'index': 419}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 10, 'column': 42, 'index': 465}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 11, 'column': 42, 'index': 511}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 12, 'column': 42, 'index': 557}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 13, 'column': 42, 'index': 604}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 14, 'column': 42, 'index': 651}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 15, 'column': 42, 'index': 698}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js,Magic Number,"{'line': 16, 'column': 43, 'index': 746}","it('should calculate number of variants using Brute Force with Memoization', () => {
    expect(recursiveStaircaseMEM(-1)).toBe(0);
    expect(recursiveStaircaseMEM(0)).toBe(0);
    expect(recursiveStaircaseMEM(1)).toBe(1);
    expect(recursiveStaircaseMEM(2)).toBe(2);
    expect(recursiveStaircaseMEM(3)).toBe(3);
    expect(recursiveStaircaseMEM(4)).toBe(5);
    expect(recursiveStaircaseMEM(5)).toBe(8);
    expect(recursiveStaircaseMEM(6)).toBe(13);
    expect(recursiveStaircaseMEM(7)).toBe(21);
    expect(recursiveStaircaseMEM(8)).toBe(34);
    expect(recursiveStaircaseMEM(9)).toBe(55);
    expect(recursiveStaircaseMEM(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 5, 'column': 42, 'index': 221}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 6, 'column': 41, 'index': 266}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 7, 'column': 41, 'index': 311}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 8, 'column': 41, 'index': 356}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 9, 'column': 41, 'index': 401}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 10, 'column': 41, 'index': 446}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 11, 'column': 41, 'index': 491}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 12, 'column': 41, 'index': 536}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 13, 'column': 41, 'index': 582}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 14, 'column': 41, 'index': 628}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 15, 'column': 41, 'index': 674}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js,Magic Number,"{'line': 16, 'column': 42, 'index': 721}","it('should calculate number of variants using Iterative solution', () => {
    expect(recursiveStaircaseIT(-1)).toBe(0);
    expect(recursiveStaircaseIT(0)).toBe(0);
    expect(recursiveStaircaseIT(1)).toBe(1);
    expect(recursiveStaircaseIT(2)).toBe(2);
    expect(recursiveStaircaseIT(3)).toBe(3);
    expect(recursiveStaircaseIT(4)).toBe(5);
    expect(recursiveStaircaseIT(5)).toBe(8);
    expect(recursiveStaircaseIT(6)).toBe(13);
    expect(recursiveStaircaseIT(7)).toBe(21);
    expect(recursiveStaircaseIT(8)).toBe(34);
    expect(recursiveStaircaseIT(9)).toBe(55);
    expect(recursiveStaircaseIT(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 5, 'column': 42, 'index': 231}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 6, 'column': 41, 'index': 276}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 7, 'column': 41, 'index': 321}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 8, 'column': 41, 'index': 366}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 9, 'column': 41, 'index': 411}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 10, 'column': 41, 'index': 456}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 11, 'column': 41, 'index': 501}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 12, 'column': 41, 'index': 546}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 13, 'column': 41, 'index': 592}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 14, 'column': 41, 'index': 638}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 15, 'column': 41, 'index': 684}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js,Magic Number,"{'line': 16, 'column': 42, 'index': 731}","it('should calculate number of variants using Dynamic Programming solution', () => {
    expect(recursiveStaircaseDP(-1)).toBe(0);
    expect(recursiveStaircaseDP(0)).toBe(0);
    expect(recursiveStaircaseDP(1)).toBe(1);
    expect(recursiveStaircaseDP(2)).toBe(2);
    expect(recursiveStaircaseDP(3)).toBe(3);
    expect(recursiveStaircaseDP(4)).toBe(5);
    expect(recursiveStaircaseDP(5)).toBe(8);
    expect(recursiveStaircaseDP(6)).toBe(13);
    expect(recursiveStaircaseDP(7)).toBe(21);
    expect(recursiveStaircaseDP(8)).toBe(34);
    expect(recursiveStaircaseDP(9)).toBe(55);
    expect(recursiveStaircaseDP(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 5, 'column': 42, 'index': 223}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 6, 'column': 41, 'index': 268}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 7, 'column': 41, 'index': 313}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 8, 'column': 41, 'index': 358}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 9, 'column': 41, 'index': 403}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 10, 'column': 41, 'index': 448}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 11, 'column': 41, 'index': 493}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 12, 'column': 41, 'index': 538}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 13, 'column': 41, 'index': 584}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 14, 'column': 41, 'index': 630}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 15, 'column': 41, 'index': 676}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js,Magic Number,"{'line': 16, 'column': 42, 'index': 723}","it('should calculate number of variants using Brute Force solution', () => {
    expect(recursiveStaircaseBF(-1)).toBe(0);
    expect(recursiveStaircaseBF(0)).toBe(0);
    expect(recursiveStaircaseBF(1)).toBe(1);
    expect(recursiveStaircaseBF(2)).toBe(2);
    expect(recursiveStaircaseBF(3)).toBe(3);
    expect(recursiveStaircaseBF(4)).toBe(5);
    expect(recursiveStaircaseBF(5)).toBe(8);
    expect(recursiveStaircaseBF(6)).toBe(13);
    expect(recursiveStaircaseBF(7)).toBe(21);
    expect(recursiveStaircaseBF(8)).toBe(34);
    expect(recursiveStaircaseBF(9)).toBe(55);
    expect(recursiveStaircaseBF(10)).toBe(89);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 5, 'column': 37, 'index': 193}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 6, 'column': 40, 'index': 237}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 7, 'column': 40, 'index': 281}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 8, 'column': 43, 'index': 328}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 9, 'column': 46, 'index': 378}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 10, 'column': 52, 'index': 434}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 11, 'column': 52, 'index': 490}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 12, 'column': 43, 'index': 537}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 13, 'column': 43, 'index': 584}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 14, 'column': 52, 'index': 640}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 15, 'column': 70, 'index': 715}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 16, 'column': 49, 'index': 768}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 17, 'column': 49, 'index': 821}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 18, 'column': 58, 'index': 883}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js,Magic Number,"{'line': 19, 'column': 67, 'index': 954}","it('should find the amount of water collected after raining', () => {
    expect(dpRainTerraces([1])).toBe(0);
    expect(dpRainTerraces([1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1])).toBe(0);
    expect(dpRainTerraces([0, 1, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(dpRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(dpRainTerraces([2, 0, 2])).toBe(2);
    expect(dpRainTerraces([2, 0, 5])).toBe(2);
    expect(dpRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(dpRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(dpRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(dpRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(dpRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 5, 'column': 37, 'index': 193}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 6, 'column': 40, 'index': 237}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 7, 'column': 40, 'index': 281}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 8, 'column': 43, 'index': 328}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 9, 'column': 46, 'index': 378}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 10, 'column': 52, 'index': 434}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 11, 'column': 52, 'index': 490}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 12, 'column': 43, 'index': 537}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 13, 'column': 43, 'index': 584}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 14, 'column': 52, 'index': 640}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 15, 'column': 70, 'index': 715}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 16, 'column': 49, 'index': 768}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 17, 'column': 49, 'index': 821}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 18, 'column': 58, 'index': 883}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js,Magic Number,"{'line': 19, 'column': 67, 'index': 954}","it('should find the amount of water collected after raining', () => {
    expect(bfRainTerraces([1])).toBe(0);
    expect(bfRainTerraces([1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1])).toBe(0);
    expect(bfRainTerraces([0, 1, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0])).toBe(0);
    expect(bfRainTerraces([0, 1, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([0, 2, 0, 0, 1, 0])).toBe(2);
    expect(bfRainTerraces([2, 0, 2])).toBe(2);
    expect(bfRainTerraces([2, 0, 5])).toBe(2);
    expect(bfRainTerraces([3, 0, 0, 2, 0, 4])).toBe(10);
    expect(bfRainTerraces([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6);
    expect(bfRainTerraces([1, 1, 1, 1, 1])).toBe(0);
    expect(bfRainTerraces([1, 2, 3, 4, 5])).toBe(0);
    expect(bfRainTerraces([4, 1, 3, 1, 2, 1, 2, 1])).toBe(4);
    expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js,Magic Number,"{'line': 5, 'column': 35, 'index': 175}","it('should have solutions for 4 to N queens', () => {
    expect(nQueensBitwise(4)).toBe(2);
    expect(nQueensBitwise(5)).toBe(10);
    expect(nQueensBitwise(6)).toBe(4);
    expect(nQueensBitwise(7)).toBe(40);
    expect(nQueensBitwise(8)).toBe(92);
    expect(nQueensBitwise(9)).toBe(352);
    expect(nQueensBitwise(10)).toBe(724);
    expect(nQueensBitwise(11)).toBe(2680);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js,Magic Number,"{'line': 6, 'column': 35, 'index': 214}","it('should have solutions for 4 to N queens', () => {
    expect(nQueensBitwise(4)).toBe(2);
    expect(nQueensBitwise(5)).toBe(10);
    expect(nQueensBitwise(6)).toBe(4);
    expect(nQueensBitwise(7)).toBe(40);
    expect(nQueensBitwise(8)).toBe(92);
    expect(nQueensBitwise(9)).toBe(352);
    expect(nQueensBitwise(10)).toBe(724);
    expect(nQueensBitwise(11)).toBe(2680);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js,Magic Number,"{'line': 7, 'column': 35, 'index': 254}","it('should have solutions for 4 to N queens', () => {
    expect(nQueensBitwise(4)).toBe(2);
    expect(nQueensBitwise(5)).toBe(10);
    expect(nQueensBitwise(6)).toBe(4);
    expect(nQueensBitwise(7)).toBe(40);
    expect(nQueensBitwise(8)).toBe(92);
    expect(nQueensBitwise(9)).toBe(352);
    expect(nQueensBitwise(10)).toBe(724);
    expect(nQueensBitwise(11)).toBe(2680);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js,Magic Number,"{'line': 8, 'column': 35, 'index': 293}","it('should have solutions for 4 to N queens', () => {
    expect(nQueensBitwise(4)).toBe(2);
    expect(nQueensBitwise(5)).toBe(10);
    expect(nQueensBitwise(6)).toBe(4);
    expect(nQueensBitwise(7)).toBe(40);
    expect(nQueensBitwise(8)).toBe(92);
    expect(nQueensBitwise(9)).toBe(352);
    expect(nQueensBitwise(10)).toBe(724);
    expect(nQueensBitwise(11)).toBe(2680);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js,Magic Number,"{'line': 9, 'column': 35, 'index': 333}","it('should have solutions for 4 to N queens', () => {
    expect(nQueensBitwise(4)).toBe(2);
    expect(nQueensBitwise(5)).toBe(10);
    expect(nQueensBitwise(6)).toBe(4);
    expect(nQueensBitwise(7)).toBe(40);
    expect(nQueensBitwise(8)).toBe(92);
    expect(nQueensBitwise(9)).toBe(352);
    expect(nQueensBitwise(10)).toBe(724);
    expect(nQueensBitwise(11)).toBe(2680);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js,Magic Number,"{'line': 10, 'column': 35, 'index': 373}","it('should have solutions for 4 to N queens', () => {
    expect(nQueensBitwise(4)).toBe(2);
    expect(nQueensBitwise(5)).toBe(10);
    expect(nQueensBitwise(6)).toBe(4);
    expect(nQueensBitwise(7)).toBe(40);
    expect(nQueensBitwise(8)).toBe(92);
    expect(nQueensBitwise(9)).toBe(352);
    expect(nQueensBitwise(10)).toBe(724);
    expect(nQueensBitwise(11)).toBe(2680);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js,Magic Number,"{'line': 11, 'column': 36, 'index': 415}","it('should have solutions for 4 to N queens', () => {
    expect(nQueensBitwise(4)).toBe(2);
    expect(nQueensBitwise(5)).toBe(10);
    expect(nQueensBitwise(6)).toBe(4);
    expect(nQueensBitwise(7)).toBe(40);
    expect(nQueensBitwise(8)).toBe(92);
    expect(nQueensBitwise(9)).toBe(352);
    expect(nQueensBitwise(10)).toBe(724);
    expect(nQueensBitwise(11)).toBe(2680);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js,Magic Number,"{'line': 12, 'column': 36, 'index': 457}","it('should have solutions for 4 to N queens', () => {
    expect(nQueensBitwise(4)).toBe(2);
    expect(nQueensBitwise(5)).toBe(10);
    expect(nQueensBitwise(6)).toBe(4);
    expect(nQueensBitwise(7)).toBe(40);
    expect(nQueensBitwise(8)).toBe(92);
    expect(nQueensBitwise(9)).toBe(352);
    expect(nQueensBitwise(10)).toBe(724);
    expect(nQueensBitwise(11)).toBe(2680);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js,Magic Number,"{'line': 6, 'column': 34, 'index': 184}","it('should not hae solution for 3 queens', () => {
    const solutions = nQueens(3);
    expect(solutions.length).toBe(0);
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js,Magic Number,"{'line': 11, 'column': 34, 'index': 322}","it('should solve n-queens problem for 4 queens', () => {
    const solutions = nQueens(4);
    expect(solutions.length).toBe(2);

    // First solution.
    expect(solutions[0][0].toString()).toBe('0,1');
    expect(solutions[0][1].toString()).toBe('1,3');
    expect(solutions[0][2].toString()).toBe('2,0');
    expect(solutions[0][3].toString()).toBe('3,2');

    // Second solution (mirrored).
    expect(solutions[1][0].toString()).toBe('0,2');
    expect(solutions[1][1].toString()).toBe('1,0');
    expect(solutions[1][2].toString()).toBe('2,3');
    expect(solutions[1][3].toString()).toBe('3,1');
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js,Magic Number,"{'line': 28, 'column': 34, 'index': 936}","it('should solve n-queens problem for 6 queens', () => {
    const solutions = nQueens(6);
    expect(solutions.length).toBe(4);

    // First solution.
    expect(solutions[0][0].toString()).toBe('0,1');
    expect(solutions[0][1].toString()).toBe('1,3');
    expect(solutions[0][2].toString()).toBe('2,5');
    expect(solutions[0][3].toString()).toBe('3,0');
    expect(solutions[0][4].toString()).toBe('4,2');
    expect(solutions[0][5].toString()).toBe('5,4');
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js,Magic Number,"{'line': 8, 'column': 39, 'index': 273}","it('should store queen position on chessboard', () => {
    const position1 = new QueenPosition(0, 0);
    const position2 = new QueenPosition(2, 1);

    expect(position2.columnIndex).toBe(1);
    expect(position2.rowIndex).toBe(2);
    expect(position1.leftDiagonal).toBe(0);
    expect(position1.rightDiagonal).toBe(0);
    expect(position2.leftDiagonal).toBe(1);
    expect(position2.rightDiagonal).toBe(3);
    expect(position2.toString()).toBe('2,1');
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js,Magic Number,"{'line': 9, 'column': 36, 'index': 313}","it('should store queen position on chessboard', () => {
    const position1 = new QueenPosition(0, 0);
    const position2 = new QueenPosition(2, 1);

    expect(position2.columnIndex).toBe(1);
    expect(position2.rowIndex).toBe(2);
    expect(position1.leftDiagonal).toBe(0);
    expect(position1.rightDiagonal).toBe(0);
    expect(position2.leftDiagonal).toBe(1);
    expect(position2.rightDiagonal).toBe(3);
    expect(position2.toString()).toBe('2,1');
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js,Magic Number,"{'line': 10, 'column': 40, 'index': 357}","it('should store queen position on chessboard', () => {
    const position1 = new QueenPosition(0, 0);
    const position2 = new QueenPosition(2, 1);

    expect(position2.columnIndex).toBe(1);
    expect(position2.rowIndex).toBe(2);
    expect(position1.leftDiagonal).toBe(0);
    expect(position1.rightDiagonal).toBe(0);
    expect(position2.leftDiagonal).toBe(1);
    expect(position2.rightDiagonal).toBe(3);
    expect(position2.toString()).toBe('2,1');
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js,Magic Number,"{'line': 11, 'column': 41, 'index': 402}","it('should store queen position on chessboard', () => {
    const position1 = new QueenPosition(0, 0);
    const position2 = new QueenPosition(2, 1);

    expect(position2.columnIndex).toBe(1);
    expect(position2.rowIndex).toBe(2);
    expect(position1.leftDiagonal).toBe(0);
    expect(position1.rightDiagonal).toBe(0);
    expect(position2.leftDiagonal).toBe(1);
    expect(position2.rightDiagonal).toBe(3);
    expect(position2.toString()).toBe('2,1');
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js,Magic Number,"{'line': 12, 'column': 40, 'index': 446}","it('should store queen position on chessboard', () => {
    const position1 = new QueenPosition(0, 0);
    const position2 = new QueenPosition(2, 1);

    expect(position2.columnIndex).toBe(1);
    expect(position2.rowIndex).toBe(2);
    expect(position1.leftDiagonal).toBe(0);
    expect(position1.rightDiagonal).toBe(0);
    expect(position2.leftDiagonal).toBe(1);
    expect(position2.rightDiagonal).toBe(3);
    expect(position2.toString()).toBe('2,1');
  })",steel
/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js,Magic Number,"{'line': 13, 'column': 41, 'index': 491}","it('should store queen position on chessboard', () => {
    const position1 = new QueenPosition(0, 0);
    const position2 = new QueenPosition(2, 1);

    expect(position2.columnIndex).toBe(1);
    expect(position2.rowIndex).toBe(2);
    expect(position1.leftDiagonal).toBe(0);
    expect(position1.rightDiagonal).toBe(0);
    expect(position2.leftDiagonal).toBe(1);
    expect(position2.rightDiagonal).toBe(3);
    expect(position2.toString()).toBe('2,1');
  })",steel
/src/algorithms/uncategorized/knight-tour/__test__/knightTour.test.js,Magic Number,"{'line': 7, 'column': 30, 'index': 190}","it('should not find solution on 3x3 board', () => {
    const moves = knightTour(3);

    expect(moves.length).toBe(0);
  })",steel
/src/algorithms/uncategorized/knight-tour/__test__/knightTour.test.js,Magic Number,"{'line': 13, 'column': 30, 'index': 337}","it('should find one solution to do knight tour on 5x5 board', () => {
    const moves = knightTour(5);

    expect(moves.length).toBe(25);

    expect(moves).toEqual([
      [0, 0],
      [1, 2],
      [2, 0],
      [0, 1],
      [1, 3],
      [3, 4],
      [2, 2],
      [4, 1],
      [3, 3],
      [1, 4],
      [0, 2],
      [1, 0],
      [3, 1],
      [4, 3],
      [2, 4],
      [0, 3],
      [1, 1],
      [3, 0],
      [4, 2],
      [2, 1],
      [4, 0],
      [3, 2],
      [4, 4],
      [2, 3],
      [0, 4],
    ]);
  })",steel
/src/algorithms/uncategorized/hanoi-tower/__test__/hanoiTower.test.js,Magic Number,"{'line': 26, 'column': 47, 'index': 690}","it('should solve tower of hanoi puzzle with 2 discs', () => {
    const moveCallback = jest.fn();
    const numberOfDiscs = 2;

    const fromPole = new Stack();
    const withPole = new Stack();
    const toPole = new Stack();

    hanoiTower({
      numberOfDiscs,
      moveCallback,
      fromPole,
      withPole,
      toPole,
    });

    expect(moveCallback).toHaveBeenCalledTimes((2 ** numberOfDiscs) - 1);

    expect(fromPole.toArray()).toEqual([]);
    expect(toPole.toArray()).toEqual([1, 2]);

    expect(moveCallback.mock.calls[0][0]).toBe(1);
    expect(moveCallback.mock.calls[0][1]).toEqual([1, 2]);
    expect(moveCallback.mock.calls[0][2]).toEqual([]);

    expect(moveCallback.mock.calls[1][0]).toBe(2);
    expect(moveCallback.mock.calls[1][1]).toEqual([2]);
    expect(moveCallback.mock.calls[1][2]).toEqual([]);

    expect(moveCallback.mock.calls[2][0]).toBe(1);
    expect(moveCallback.mock.calls[2][1]).toEqual([1]);
    expect(moveCallback.mock.calls[2][2]).toEqual([2]);
  })",steel
/src/algorithms/uncategorized/hanoi-tower/__test__/hanoiTower.test.js,Magic Number,"{'line': 30, 'column': 47, 'index': 856}","it('should solve tower of hanoi puzzle with 2 discs', () => {
    const moveCallback = jest.fn();
    const numberOfDiscs = 2;

    const fromPole = new Stack();
    const withPole = new Stack();
    const toPole = new Stack();

    hanoiTower({
      numberOfDiscs,
      moveCallback,
      fromPole,
      withPole,
      toPole,
    });

    expect(moveCallback).toHaveBeenCalledTimes((2 ** numberOfDiscs) - 1);

    expect(fromPole.toArray()).toEqual([]);
    expect(toPole.toArray()).toEqual([1, 2]);

    expect(moveCallback.mock.calls[0][0]).toBe(1);
    expect(moveCallback.mock.calls[0][1]).toEqual([1, 2]);
    expect(moveCallback.mock.calls[0][2]).toEqual([]);

    expect(moveCallback.mock.calls[1][0]).toBe(2);
    expect(moveCallback.mock.calls[1][1]).toEqual([2]);
    expect(moveCallback.mock.calls[1][2]).toEqual([]);

    expect(moveCallback.mock.calls[2][0]).toBe(1);
    expect(moveCallback.mock.calls[2][1]).toEqual([1]);
    expect(moveCallback.mock.calls[2][2]).toEqual([2]);
  })",steel
/src/algorithms/uncategorized/hanoi-tower/__test__/hanoiTower.test.js,Magic Number,"{'line': 34, 'column': 47, 'index': 1019}","it('should solve tower of hanoi puzzle with 2 discs', () => {
    const moveCallback = jest.fn();
    const numberOfDiscs = 2;

    const fromPole = new Stack();
    const withPole = new Stack();
    const toPole = new Stack();

    hanoiTower({
      numberOfDiscs,
      moveCallback,
      fromPole,
      withPole,
      toPole,
    });

    expect(moveCallback).toHaveBeenCalledTimes((2 ** numberOfDiscs) - 1);

    expect(fromPole.toArray()).toEqual([]);
    expect(toPole.toArray()).toEqual([1, 2]);

    expect(moveCallback.mock.calls[0][0]).toBe(1);
    expect(moveCallback.mock.calls[0][1]).toEqual([1, 2]);
    expect(moveCallback.mock.calls[0][2]).toEqual([]);

    expect(moveCallback.mock.calls[1][0]).toBe(2);
    expect(moveCallback.mock.calls[1][1]).toEqual([2]);
    expect(moveCallback.mock.calls[1][2]).toEqual([]);

    expect(moveCallback.mock.calls[2][0]).toBe(1);
    expect(moveCallback.mock.calls[2][1]).toEqual([1]);
    expect(moveCallback.mock.calls[2][2]).toEqual([2]);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 386}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 15, 'column': 4, 'index': 527}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 668}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 813}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 971}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 1124}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1274}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1424}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1650}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 7, 'column': 62, 'index': 284}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 10, 'column': 66, 'index': 378}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 14, 'column': 69, 'index': 519}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 18, 'column': 69, 'index': 660}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 22, 'column': 73, 'index': 805}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 26, 'column': 85, 'index': 962}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 30, 'column': 81, 'index': 1116}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 34, 'column': 78, 'index': 1266}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 38, 'column': 78, 'index': 1416}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 45, 'column': 15, 'index': 1641}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(peakvalleyBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 346}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 15, 'column': 4, 'index': 479}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 612}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 749}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 900}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 1047}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1191}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1334}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1553}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 7, 'column': 54, 'index': 252}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 10, 'column': 58, 'index': 338}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 14, 'column': 61, 'index': 471}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 18, 'column': 61, 'index': 604}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 22, 'column': 65, 'index': 741}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 26, 'column': 77, 'index': 891}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 30, 'column': 73, 'index': 1039}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 34, 'column': 70, 'index': 1183}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 38, 'column': 70, 'index': 1326}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 45, 'column': 15, 'index': 1544}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(7);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(15);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(127);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(63);

    visit = jest.fn();
    expect(dqBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(2097151);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 346}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 15, 'column': 4, 'index': 479}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 612}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 749}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 899}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 1044}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1186}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1328}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1546}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 7, 'column': 54, 'index': 252}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 10, 'column': 58, 'index': 338}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 14, 'column': 61, 'index': 471}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 18, 'column': 61, 'index': 604}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 22, 'column': 65, 'index': 741}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 26, 'column': 77, 'index': 890}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 30, 'column': 73, 'index': 1036}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 34, 'column': 70, 'index': 1178}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 38, 'column': 70, 'index': 1320}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 45, 'column': 15, 'index': 1537}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(dpBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 391}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 15, 'column': 4, 'index': 533}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 675}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 821}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 980}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 1134}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1285}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1436}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1663}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 7, 'column': 63, 'index': 288}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 10, 'column': 67, 'index': 383}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 14, 'column': 70, 'index': 525}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 18, 'column': 70, 'index': 667}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 22, 'column': 74, 'index': 813}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 26, 'column': 86, 'index': 971}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 30, 'column': 82, 'index': 1126}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 34, 'column': 79, 'index': 1277}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 38, 'column': 79, 'index': 1428}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js,Magic Number,"{'line': 45, 'column': 15, 'index': 1654}","it('should find the best time to buy and sell stocks', () => {
    let visit;

    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(1);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(2);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);
    expect(visit).toHaveBeenCalledTimes(3);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
    expect(visit).toHaveBeenCalledTimes(6);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
    expect(visit).toHaveBeenCalledTimes(5);

    visit = jest.fn();
    expect(accumulatorBestTimeToBuySellStocks(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      visit,
    )).toEqual(19);
    expect(visit).toHaveBeenCalledTimes(20);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 5, 'column': 35, 'index': 154}","it('should find substring in a string', () => {
    expect(rabinKarp('', '')).toBe(0);
    expect(rabinKarp('a', '')).toBe(0);
    expect(rabinKarp('a', 'a')).toBe(0);
    expect(rabinKarp('ab', 'b')).toBe(1);
    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 6, 'column': 36, 'index': 194}","it('should find substring in a string', () => {
    expect(rabinKarp('', '')).toBe(0);
    expect(rabinKarp('a', '')).toBe(0);
    expect(rabinKarp('a', 'a')).toBe(0);
    expect(rabinKarp('ab', 'b')).toBe(1);
    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 7, 'column': 37, 'index': 235}","it('should find substring in a string', () => {
    expect(rabinKarp('', '')).toBe(0);
    expect(rabinKarp('a', '')).toBe(0);
    expect(rabinKarp('a', 'a')).toBe(0);
    expect(rabinKarp('ab', 'b')).toBe(1);
    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 8, 'column': 38, 'index': 277}","it('should find substring in a string', () => {
    expect(rabinKarp('', '')).toBe(0);
    expect(rabinKarp('a', '')).toBe(0);
    expect(rabinKarp('a', 'a')).toBe(0);
    expect(rabinKarp('ab', 'b')).toBe(1);
    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 10, 'column': 47, 'index': 380}","it('should find substring in a string', () => {
    expect(rabinKarp('', '')).toBe(0);
    expect(rabinKarp('a', '')).toBe(0);
    expect(rabinKarp('a', 'a')).toBe(0);
    expect(rabinKarp('ab', 'b')).toBe(1);
    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 11, 'column': 66, 'index': 450}","it('should find substring in a string', () => {
    expect(rabinKarp('', '')).toBe(0);
    expect(rabinKarp('a', '')).toBe(0);
    expect(rabinKarp('a', 'a')).toBe(0);
    expect(rabinKarp('ab', 'b')).toBe(1);
    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 13, 'column': 74, 'index': 600}","it('should find substring in a string', () => {
    expect(rabinKarp('', '')).toBe(0);
    expect(rabinKarp('a', '')).toBe(0);
    expect(rabinKarp('a', 'a')).toBe(0);
    expect(rabinKarp('ab', 'b')).toBe(1);
    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 14, 'column': 76, 'index': 681}","it('should find substring in a string', () => {
    expect(rabinKarp('', '')).toBe(0);
    expect(rabinKarp('a', '')).toBe(0);
    expect(rabinKarp('a', 'a')).toBe(0);
    expect(rabinKarp('ab', 'b')).toBe(1);
    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 15, 'column': 56, 'index': 742}","it('should find substring in a string', () => {
    expect(rabinKarp('', '')).toBe(0);
    expect(rabinKarp('a', '')).toBe(0);
    expect(rabinKarp('a', 'a')).toBe(0);
    expect(rabinKarp('ab', 'b')).toBe(1);
    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 30, 'column': 42, 'index': 1518}","it('should work with bigger texts', () => {
    const text = 'Lorem Ipsum is simply dummy text of the printing and '
    + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
    + 'dummy text ever since the 1500s, when an unknown printer took a '
    + 'galley of type and scrambled it to make a type specimen book. It '
    + 'has survived not only five centuries, but also the leap into '
    + 'electronic typesetting, remaining essentially unchanged. It was '
    + 'popularised in the 1960s with the release of Letraset sheets '
    + 'containing Lorem Ipsum passages, and more recently with desktop'
    + 'publishing software like Aldus PageMaker including versions of Lorem '
    + 'Ipsum.';

    expect(rabinKarp(text, 'Lorem')).toBe(0);
    expect(rabinKarp(text, 'versions')).toBe(549);
    expect(rabinKarp(text, 'versions of Lorem Ipsum.')).toBe(549);
    expect(rabinKarp(text, 'versions of Lorem Ipsum:')).toBe(-1);
    expect(rabinKarp(text, 'Lorem Ipsum passages, and more recently with')).toBe(446);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 31, 'column': 45, 'index': 1567}","it('should work with bigger texts', () => {
    const text = 'Lorem Ipsum is simply dummy text of the printing and '
    + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
    + 'dummy text ever since the 1500s, when an unknown printer took a '
    + 'galley of type and scrambled it to make a type specimen book. It '
    + 'has survived not only five centuries, but also the leap into '
    + 'electronic typesetting, remaining essentially unchanged. It was '
    + 'popularised in the 1960s with the release of Letraset sheets '
    + 'containing Lorem Ipsum passages, and more recently with desktop'
    + 'publishing software like Aldus PageMaker including versions of Lorem '
    + 'Ipsum.';

    expect(rabinKarp(text, 'Lorem')).toBe(0);
    expect(rabinKarp(text, 'versions')).toBe(549);
    expect(rabinKarp(text, 'versions of Lorem Ipsum.')).toBe(549);
    expect(rabinKarp(text, 'versions of Lorem Ipsum:')).toBe(-1);
    expect(rabinKarp(text, 'Lorem Ipsum passages, and more recently with')).toBe(446);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 32, 'column': 61, 'index': 1634}","it('should work with bigger texts', () => {
    const text = 'Lorem Ipsum is simply dummy text of the printing and '
    + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
    + 'dummy text ever since the 1500s, when an unknown printer took a '
    + 'galley of type and scrambled it to make a type specimen book. It '
    + 'has survived not only five centuries, but also the leap into '
    + 'electronic typesetting, remaining essentially unchanged. It was '
    + 'popularised in the 1960s with the release of Letraset sheets '
    + 'containing Lorem Ipsum passages, and more recently with desktop'
    + 'publishing software like Aldus PageMaker including versions of Lorem '
    + 'Ipsum.';

    expect(rabinKarp(text, 'Lorem')).toBe(0);
    expect(rabinKarp(text, 'versions')).toBe(549);
    expect(rabinKarp(text, 'versions of Lorem Ipsum.')).toBe(549);
    expect(rabinKarp(text, 'versions of Lorem Ipsum:')).toBe(-1);
    expect(rabinKarp(text, 'Lorem Ipsum passages, and more recently with')).toBe(446);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 34, 'column': 81, 'index': 1787}","it('should work with bigger texts', () => {
    const text = 'Lorem Ipsum is simply dummy text of the printing and '
    + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
    + 'dummy text ever since the 1500s, when an unknown printer took a '
    + 'galley of type and scrambled it to make a type specimen book. It '
    + 'has survived not only five centuries, but also the leap into '
    + 'electronic typesetting, remaining essentially unchanged. It was '
    + 'popularised in the 1960s with the release of Letraset sheets '
    + 'containing Lorem Ipsum passages, and more recently with desktop'
    + 'publishing software like Aldus PageMaker including versions of Lorem '
    + 'Ipsum.';

    expect(rabinKarp(text, 'Lorem')).toBe(0);
    expect(rabinKarp(text, 'versions')).toBe(549);
    expect(rabinKarp(text, 'versions of Lorem Ipsum.')).toBe(549);
    expect(rabinKarp(text, 'versions of Lorem Ipsum:')).toBe(-1);
    expect(rabinKarp(text, 'Lorem Ipsum passages, and more recently with')).toBe(446);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 38, 'column': 52, 'index': 1897}","it('should work with UTF symbols', () => {
    expect(rabinKarp('a\u{ffff}', '\u{ffff}')).toBe(1);
    expect(rabinKarp('\u0000\u0000', '\u0000')).toBe(1);
    // @TODO: Provide Unicode support.
    // expect(rabinKarp('a\u{20000}', '\u{20000}')).toBe(1);
  })",steel
/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js,Magic Number,"{'line': 39, 'column': 55, 'index': 1956}","it('should work with UTF symbols', () => {
    expect(rabinKarp('a\u{ffff}', '\u{ffff}')).toBe(1);
    expect(rabinKarp('\u0000\u0000', '\u0000')).toBe(1);
    // @TODO: Provide Unicode support.
    // expect(rabinKarp('a\u{20000}', '\u{20000}')).toBe(1);
  })",steel
/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js,Magic Number,"{'line': 5, 'column': 42, 'index': 188}","it('should find word position in given text', () => {
    expect(knuthMorrisPratt('', '')).toBe(0);
    expect(knuthMorrisPratt('a', '')).toBe(0);
    expect(knuthMorrisPratt('a', 'a')).toBe(0);
    expect(knuthMorrisPratt('abcbcglx', 'abca')).toBe(-1);
    expect(knuthMorrisPratt('abcbcglx', 'bcgl')).toBe(3);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(knuthMorrisPratt('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(knuthMorrisPratt('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
  })",steel
/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js,Magic Number,"{'line': 6, 'column': 43, 'index': 235}","it('should find word position in given text', () => {
    expect(knuthMorrisPratt('', '')).toBe(0);
    expect(knuthMorrisPratt('a', '')).toBe(0);
    expect(knuthMorrisPratt('a', 'a')).toBe(0);
    expect(knuthMorrisPratt('abcbcglx', 'abca')).toBe(-1);
    expect(knuthMorrisPratt('abcbcglx', 'bcgl')).toBe(3);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(knuthMorrisPratt('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(knuthMorrisPratt('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
  })",steel
/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js,Magic Number,"{'line': 7, 'column': 44, 'index': 283}","it('should find word position in given text', () => {
    expect(knuthMorrisPratt('', '')).toBe(0);
    expect(knuthMorrisPratt('a', '')).toBe(0);
    expect(knuthMorrisPratt('a', 'a')).toBe(0);
    expect(knuthMorrisPratt('abcbcglx', 'abca')).toBe(-1);
    expect(knuthMorrisPratt('abcbcglx', 'bcgl')).toBe(3);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(knuthMorrisPratt('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(knuthMorrisPratt('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
  })",steel
/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js,Magic Number,"{'line': 9, 'column': 54, 'index': 400}","it('should find word position in given text', () => {
    expect(knuthMorrisPratt('', '')).toBe(0);
    expect(knuthMorrisPratt('a', '')).toBe(0);
    expect(knuthMorrisPratt('a', 'a')).toBe(0);
    expect(knuthMorrisPratt('abcbcglx', 'abca')).toBe(-1);
    expect(knuthMorrisPratt('abcbcglx', 'bcgl')).toBe(3);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(knuthMorrisPratt('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(knuthMorrisPratt('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
  })",steel
/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js,Magic Number,"{'line': 10, 'column': 73, 'index': 477}","it('should find word position in given text', () => {
    expect(knuthMorrisPratt('', '')).toBe(0);
    expect(knuthMorrisPratt('a', '')).toBe(0);
    expect(knuthMorrisPratt('a', 'a')).toBe(0);
    expect(knuthMorrisPratt('abcbcglx', 'abca')).toBe(-1);
    expect(knuthMorrisPratt('abcbcglx', 'bcgl')).toBe(3);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(knuthMorrisPratt('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(knuthMorrisPratt('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
  })",steel
/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js,Magic Number,"{'line': 12, 'column': 81, 'index': 641}","it('should find word position in given text', () => {
    expect(knuthMorrisPratt('', '')).toBe(0);
    expect(knuthMorrisPratt('a', '')).toBe(0);
    expect(knuthMorrisPratt('a', 'a')).toBe(0);
    expect(knuthMorrisPratt('abcbcglx', 'abca')).toBe(-1);
    expect(knuthMorrisPratt('abcbcglx', 'bcgl')).toBe(3);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(knuthMorrisPratt('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(knuthMorrisPratt('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
  })",steel
/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js,Magic Number,"{'line': 13, 'column': 83, 'index': 729}","it('should find word position in given text', () => {
    expect(knuthMorrisPratt('', '')).toBe(0);
    expect(knuthMorrisPratt('a', '')).toBe(0);
    expect(knuthMorrisPratt('a', 'a')).toBe(0);
    expect(knuthMorrisPratt('abcbcglx', 'abca')).toBe(-1);
    expect(knuthMorrisPratt('abcbcglx', 'bcgl')).toBe(3);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
    expect(knuthMorrisPratt('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
    expect(knuthMorrisPratt('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
  })",steel
/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js,Conditional Test Logic,"{'line': 40, 'column': 4, 'index': 1970}","it('should correctly do random selection based on wights', () => {
    // Number of times we're going to select the random items based on their weights.
    const ATTEMPTS_NUM = 1000;
    // The +/- delta in the number of times each item has been actually selected.
    // I.e. if we want the item 'a' to be selected 300 times out of 1000 cases (30%)
    // then 267 times is acceptable since it is bigger that 250 (which is 300 - 50)
    // ans smaller than 350 (which is 300 + 50)
    const THRESHOLD = 50;

    const items = ['a', 'b', 'c']; // The actual items values don't matter.
    const weights = [0.1, 0.3, 0.6];

    const counter = [];
    for (let i = 0; i < ATTEMPTS_NUM; i += 1) {
      const randomItem = weightedRandom(items, weights);
      if (!counter[randomItem.index]) {
        counter[randomItem.index] = 1;
      } else {
        counter[randomItem.index] += 1;
      }
    }

    for (let itemIndex = 0; itemIndex < items.length; itemIndex += 1) {
      /*
        i.e. item with the index of 0 must be selected 100 times (ideally)
        or with the threshold of [100 - 50, 100 + 50] times.

        i.e. item with the index of 1 must be selected 300 times (ideally)
        or with the threshold of [300 - 50, 300 + 50] times.

        i.e. item with the index of 2 must be selected 600 times (ideally)
        or with the threshold of [600 - 50, 600 + 50] times.
       */
      expect(counter[itemIndex]).toBeGreaterThan(ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD);
      expect(counter[itemIndex]).toBeLessThan(ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD);
    }
  })",steel
/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js,Conditional Test Logic,"{'line': 42, 'column': 6, 'index': 2077}","it('should correctly do random selection based on wights', () => {
    // Number of times we're going to select the random items based on their weights.
    const ATTEMPTS_NUM = 1000;
    // The +/- delta in the number of times each item has been actually selected.
    // I.e. if we want the item 'a' to be selected 300 times out of 1000 cases (30%)
    // then 267 times is acceptable since it is bigger that 250 (which is 300 - 50)
    // ans smaller than 350 (which is 300 + 50)
    const THRESHOLD = 50;

    const items = ['a', 'b', 'c']; // The actual items values don't matter.
    const weights = [0.1, 0.3, 0.6];

    const counter = [];
    for (let i = 0; i < ATTEMPTS_NUM; i += 1) {
      const randomItem = weightedRandom(items, weights);
      if (!counter[randomItem.index]) {
        counter[randomItem.index] = 1;
      } else {
        counter[randomItem.index] += 1;
      }
    }

    for (let itemIndex = 0; itemIndex < items.length; itemIndex += 1) {
      /*
        i.e. item with the index of 0 must be selected 100 times (ideally)
        or with the threshold of [100 - 50, 100 + 50] times.

        i.e. item with the index of 1 must be selected 300 times (ideally)
        or with the threshold of [300 - 50, 300 + 50] times.

        i.e. item with the index of 2 must be selected 600 times (ideally)
        or with the threshold of [600 - 50, 600 + 50] times.
       */
      expect(counter[itemIndex]).toBeGreaterThan(ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD);
      expect(counter[itemIndex]).toBeLessThan(ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD);
    }
  })",steel
/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js,Conditional Test Logic,"{'line': 49, 'column': 4, 'index': 2224}","it('should correctly do random selection based on wights', () => {
    // Number of times we're going to select the random items based on their weights.
    const ATTEMPTS_NUM = 1000;
    // The +/- delta in the number of times each item has been actually selected.
    // I.e. if we want the item 'a' to be selected 300 times out of 1000 cases (30%)
    // then 267 times is acceptable since it is bigger that 250 (which is 300 - 50)
    // ans smaller than 350 (which is 300 + 50)
    const THRESHOLD = 50;

    const items = ['a', 'b', 'c']; // The actual items values don't matter.
    const weights = [0.1, 0.3, 0.6];

    const counter = [];
    for (let i = 0; i < ATTEMPTS_NUM; i += 1) {
      const randomItem = weightedRandom(items, weights);
      if (!counter[randomItem.index]) {
        counter[randomItem.index] = 1;
      } else {
        counter[randomItem.index] += 1;
      }
    }

    for (let itemIndex = 0; itemIndex < items.length; itemIndex += 1) {
      /*
        i.e. item with the index of 0 must be selected 100 times (ideally)
        or with the threshold of [100 - 50, 100 + 50] times.

        i.e. item with the index of 1 must be selected 300 times (ideally)
        or with the threshold of [300 - 50, 300 + 50] times.

        i.e. item with the index of 2 must be selected 600 times (ideally)
        or with the threshold of [600 - 50, 600 + 50] times.
       */
      expect(counter[itemIndex]).toBeGreaterThan(ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD);
      expect(counter[itemIndex]).toBeLessThan(ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD);
    }
  })",steel
/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js,Duplicate Assert,"{'line': 60, 'column': 6, 'index': 2727}","it('should correctly do random selection based on wights', () => {
    // Number of times we're going to select the random items based on their weights.
    const ATTEMPTS_NUM = 1000;
    // The +/- delta in the number of times each item has been actually selected.
    // I.e. if we want the item 'a' to be selected 300 times out of 1000 cases (30%)
    // then 267 times is acceptable since it is bigger that 250 (which is 300 - 50)
    // ans smaller than 350 (which is 300 + 50)
    const THRESHOLD = 50;

    const items = ['a', 'b', 'c']; // The actual items values don't matter.
    const weights = [0.1, 0.3, 0.6];

    const counter = [];
    for (let i = 0; i < ATTEMPTS_NUM; i += 1) {
      const randomItem = weightedRandom(items, weights);
      if (!counter[randomItem.index]) {
        counter[randomItem.index] = 1;
      } else {
        counter[randomItem.index] += 1;
      }
    }

    for (let itemIndex = 0; itemIndex < items.length; itemIndex += 1) {
      /*
        i.e. item with the index of 0 must be selected 100 times (ideally)
        or with the threshold of [100 - 50, 100 + 50] times.

        i.e. item with the index of 1 must be selected 300 times (ideally)
        or with the threshold of [300 - 50, 300 + 50] times.

        i.e. item with the index of 2 must be selected 600 times (ideally)
        or with the threshold of [600 - 50, 600 + 50] times.
       */
      expect(counter[itemIndex]).toBeGreaterThan(ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD);
      expect(counter[itemIndex]).toBeLessThan(ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD);
    }
  })",steel
/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js,Duplicate Assert,"{'line': 61, 'column': 6, 'index': 2824}","it('should correctly do random selection based on wights', () => {
    // Number of times we're going to select the random items based on their weights.
    const ATTEMPTS_NUM = 1000;
    // The +/- delta in the number of times each item has been actually selected.
    // I.e. if we want the item 'a' to be selected 300 times out of 1000 cases (30%)
    // then 267 times is acceptable since it is bigger that 250 (which is 300 - 50)
    // ans smaller than 350 (which is 300 + 50)
    const THRESHOLD = 50;

    const items = ['a', 'b', 'c']; // The actual items values don't matter.
    const weights = [0.1, 0.3, 0.6];

    const counter = [];
    for (let i = 0; i < ATTEMPTS_NUM; i += 1) {
      const randomItem = weightedRandom(items, weights);
      if (!counter[randomItem.index]) {
        counter[randomItem.index] = 1;
      } else {
        counter[randomItem.index] += 1;
      }
    }

    for (let itemIndex = 0; itemIndex < items.length; itemIndex += 1) {
      /*
        i.e. item with the index of 0 must be selected 100 times (ideally)
        or with the threshold of [100 - 50, 100 + 50] times.

        i.e. item with the index of 1 must be selected 300 times (ideally)
        or with the threshold of [300 - 50, 300 + 50] times.

        i.e. item with the index of 2 must be selected 600 times (ideally)
        or with the threshold of [600 - 50, 600 + 50] times.
       */
      expect(counter[itemIndex]).toBeGreaterThan(ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD);
      expect(counter[itemIndex]).toBeLessThan(ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD);
    }
  })",steel
/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js,Unknown Test,"{'column': 2, 'line': 17}","it('should sort array', () => {
    SortTester.testSort(ShellSort);
  })",steel
/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js,Unknown Test,"{'column': 2, 'line': 21}","it('should sort array with custom comparator', () => {
    SortTester.testSortWithCustomComparator(ShellSort);
  })",steel
/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js,Unknown Test,"{'column': 2, 'line': 25}","it('should sort negative numbers', () => {
    SortTester.testNegativeNumbersSort(ShellSort);
  })",steel
/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js,Unknown Test,"{'column': 2, 'line': 29}","it('should visit EQUAL array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      ShellSort,
      equalArr,
      EQUAL_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js,Unknown Test,"{'column': 2, 'line': 37}","it('should visit SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      ShellSort,
      sortedArr,
      SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js,Unknown Test,"{'column': 2, 'line': 45}","it('should visit NOT SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      ShellSort,
      notSortedArr,
      NOT_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js,Unknown Test,"{'column': 2, 'line': 53}","it('should visit REVERSE SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      ShellSort,
      reverseArr,
      REVERSE_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js,Unknown Test,"{'column': 2, 'line': 17}","it('should sort array', () => {
    SortTester.testSort(SelectionSort);
  })",steel
/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js,Unknown Test,"{'column': 2, 'line': 21}","it('should sort array with custom comparator', () => {
    SortTester.testSortWithCustomComparator(SelectionSort);
  })",steel
/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js,Unknown Test,"{'column': 2, 'line': 25}","it('should sort negative numbers', () => {
    SortTester.testNegativeNumbersSort(SelectionSort);
  })",steel
/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js,Unknown Test,"{'column': 2, 'line': 29}","it('should visit EQUAL array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      SelectionSort,
      equalArr,
      EQUAL_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js,Unknown Test,"{'column': 2, 'line': 37}","it('should visit SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      SelectionSort,
      sortedArr,
      SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js,Unknown Test,"{'column': 2, 'line': 45}","it('should visit NOT SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      SelectionSort,
      notSortedArr,
      NOT_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js,Unknown Test,"{'column': 2, 'line': 53}","it('should visit REVERSE SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      SelectionSort,
      reverseArr,
      REVERSE_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/radix-sort/__test__/RadixSort.test.js,Unknown Test,"{'column': 2, 'line': 8}","it('should sort array', () => {
    SortTester.testSort(RadixSort);
  })",steel
/src/algorithms/sorting/radix-sort/__test__/RadixSort.test.js,Unknown Test,"{'column': 2, 'line': 12}","it('should visit array of strings n (number of strings) x m (length of longest element) times', () => {
    SortTester.testAlgorithmTimeComplexity(
      RadixSort,
      ['zzz', 'bb', 'a', 'rr', 'rrb', 'rrba'],
      ARRAY_OF_STRINGS_VISIT_COUNT,
    );
  })",steel
/src/algorithms/sorting/radix-sort/__test__/RadixSort.test.js,Unknown Test,"{'column': 2, 'line': 20}","it('should visit array of integers n (number of elements) x m (length of longest integer) times', () => {
    SortTester.testAlgorithmTimeComplexity(
      RadixSort,
      [3, 1, 75, 32, 884, 523, 4343456, 232, 123, 656, 343],
      ARRAY_OF_INTEGERS_VISIT_COUNT,
    );
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js,Unknown Test,"{'column': 2, 'line': 17}","it('should sort array', () => {
    SortTester.testSort(QuickSortInPlace);
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js,Unknown Test,"{'column': 2, 'line': 21}","it('should sort array with custom comparator', () => {
    SortTester.testSortWithCustomComparator(QuickSortInPlace);
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js,Unknown Test,"{'column': 2, 'line': 25}","it('should sort negative numbers', () => {
    SortTester.testNegativeNumbersSort(QuickSortInPlace);
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js,Unknown Test,"{'column': 2, 'line': 29}","it('should visit EQUAL array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      QuickSortInPlace,
      equalArr,
      EQUAL_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js,Unknown Test,"{'column': 2, 'line': 37}","it('should visit SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      QuickSortInPlace,
      sortedArr,
      SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js,Unknown Test,"{'column': 2, 'line': 45}","it('should visit NOT SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      QuickSortInPlace,
      notSortedArr,
      NOT_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js,Unknown Test,"{'column': 2, 'line': 53}","it('should visit REVERSE SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      QuickSortInPlace,
      reverseArr,
      REVERSE_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js,Unknown Test,"{'column': 2, 'line': 17}","it('should sort array', () => {
    SortTester.testSort(QuickSort);
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js,Unknown Test,"{'column': 2, 'line': 21}","it('should sort array with custom comparator', () => {
    SortTester.testSortWithCustomComparator(QuickSort);
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js,Unknown Test,"{'column': 2, 'line': 25}","it('should do stable sorting', () => {
    SortTester.testSortStability(QuickSort);
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js,Unknown Test,"{'column': 2, 'line': 29}","it('should sort negative numbers', () => {
    SortTester.testNegativeNumbersSort(QuickSort);
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js,Unknown Test,"{'column': 2, 'line': 33}","it('should visit EQUAL array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      QuickSort,
      equalArr,
      EQUAL_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js,Unknown Test,"{'column': 2, 'line': 41}","it('should visit SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      QuickSort,
      sortedArr,
      SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js,Unknown Test,"{'column': 2, 'line': 49}","it('should visit NOT SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      QuickSort,
      notSortedArr,
      NOT_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js,Unknown Test,"{'column': 2, 'line': 57}","it('should visit REVERSE SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      QuickSort,
      reverseArr,
      REVERSE_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js,Unknown Test,"{'column': 2, 'line': 17}","it('should sort array', () => {
    SortTester.testSort(MergeSort);
  })",steel
/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js,Unknown Test,"{'column': 2, 'line': 21}","it('should sort array with custom comparator', () => {
    SortTester.testSortWithCustomComparator(MergeSort);
  })",steel
/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js,Unknown Test,"{'column': 2, 'line': 25}","it('should do stable sorting', () => {
    SortTester.testSortStability(MergeSort);
  })",steel
/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js,Unknown Test,"{'column': 2, 'line': 29}","it('should sort negative numbers', () => {
    SortTester.testNegativeNumbersSort(MergeSort);
  })",steel
/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js,Unknown Test,"{'column': 2, 'line': 33}","it('should visit EQUAL array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      MergeSort,
      equalArr,
      EQUAL_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js,Unknown Test,"{'column': 2, 'line': 41}","it('should visit SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      MergeSort,
      sortedArr,
      SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js,Unknown Test,"{'column': 2, 'line': 49}","it('should visit NOT SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      MergeSort,
      notSortedArr,
      NOT_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js,Unknown Test,"{'column': 2, 'line': 57}","it('should visit REVERSE SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      MergeSort,
      reverseArr,
      REVERSE_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js,Unknown Test,"{'column': 2, 'line': 17}","it('should sort array', () => {
    SortTester.testSort(InsertionSort);
  })",steel
/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js,Unknown Test,"{'column': 2, 'line': 21}","it('should sort array with custom comparator', () => {
    SortTester.testSortWithCustomComparator(InsertionSort);
  })",steel
/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js,Unknown Test,"{'column': 2, 'line': 25}","it('should do stable sorting', () => {
    SortTester.testSortStability(InsertionSort);
  })",steel
/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js,Unknown Test,"{'column': 2, 'line': 29}","it('should sort negative numbers', () => {
    SortTester.testNegativeNumbersSort(InsertionSort);
  })",steel
/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js,Unknown Test,"{'column': 2, 'line': 33}","it('should visit EQUAL array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      InsertionSort,
      equalArr,
      EQUAL_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js,Unknown Test,"{'column': 2, 'line': 41}","it('should visit SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      InsertionSort,
      sortedArr,
      SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js,Unknown Test,"{'column': 2, 'line': 49}","it('should visit NOT SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      InsertionSort,
      notSortedArr,
      NOT_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js,Unknown Test,"{'column': 2, 'line': 57}","it('should visit REVERSE SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      InsertionSort,
      reverseArr,
      REVERSE_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js,Unknown Test,"{'column': 2, 'line': 19}","it('should sort array', () => {
    SortTester.testSort(HeapSort);
  })",steel
/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js,Unknown Test,"{'column': 2, 'line': 23}","it('should sort array with custom comparator', () => {
    SortTester.testSortWithCustomComparator(HeapSort);
  })",steel
/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js,Unknown Test,"{'column': 2, 'line': 27}","it('should sort negative numbers', () => {
    SortTester.testNegativeNumbersSort(HeapSort);
  })",steel
/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js,Unknown Test,"{'column': 2, 'line': 31}","it('should visit EQUAL array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      HeapSort,
      equalArr,
      EQUAL_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js,Unknown Test,"{'column': 2, 'line': 39}","it('should visit SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      HeapSort,
      sortedArr,
      SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js,Unknown Test,"{'column': 2, 'line': 47}","it('should visit NOT SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      HeapSort,
      notSortedArr,
      NOT_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js,Unknown Test,"{'column': 2, 'line': 55}","it('should visit REVERSE SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      HeapSort,
      reverseArr,
      REVERSE_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js,Unknown Test,"{'column': 2, 'line': 17}","it('should sort array', () => {
    SortTester.testSort(CountingSort);
  })",steel
/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js,Unknown Test,"{'column': 2, 'line': 21}","it('should sort negative numbers', () => {
    SortTester.testNegativeNumbersSort(CountingSort);
  })",steel
/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js,Unknown Test,"{'column': 2, 'line': 43}","it('should visit EQUAL array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      CountingSort,
      equalArr,
      EQUAL_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js,Unknown Test,"{'column': 2, 'line': 51}","it('should visit SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      CountingSort,
      sortedArr,
      SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js,Unknown Test,"{'column': 2, 'line': 59}","it('should visit NOT SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      CountingSort,
      notSortedArr,
      NOT_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js,Unknown Test,"{'column': 2, 'line': 67}","it('should visit REVERSE SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      CountingSort,
      reverseArr,
      REVERSE_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js,Unknown Test,"{'column': 2, 'line': 17}","it('should sort array', () => {
    SortTester.testSort(BubbleSort);
  })",steel
/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js,Unknown Test,"{'column': 2, 'line': 21}","it('should sort array with custom comparator', () => {
    SortTester.testSortWithCustomComparator(BubbleSort);
  })",steel
/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js,Unknown Test,"{'column': 2, 'line': 25}","it('should do stable sorting', () => {
    SortTester.testSortStability(BubbleSort);
  })",steel
/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js,Unknown Test,"{'column': 2, 'line': 29}","it('should sort negative numbers', () => {
    SortTester.testNegativeNumbersSort(BubbleSort);
  })",steel
/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js,Unknown Test,"{'column': 2, 'line': 33}","it('should visit EQUAL array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      BubbleSort,
      equalArr,
      EQUAL_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js,Unknown Test,"{'column': 2, 'line': 41}","it('should visit SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      BubbleSort,
      sortedArr,
      SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js,Unknown Test,"{'column': 2, 'line': 49}","it('should visit NOT SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      BubbleSort,
      notSortedArr,
      NOT_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js,Unknown Test,"{'column': 2, 'line': 57}","it('should visit REVERSE SORTED array element specified number of times', () => {
    SortTester.testAlgorithmTimeComplexity(
      BubbleSort,
      reverseArr,
      REVERSE_SORTED_ARRAY_VISITING_COUNT,
    );
  })",steel
/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js,Magic Number,"{'line': 12, 'column': 38, 'index': 447}","it('should permutate string', () => {
    const permutations1 = permutateWithoutRepetitions(['A']);
    expect(permutations1).toEqual([
      ['A'],
    ]);

    const permutations2 = permutateWithoutRepetitions(['A', 'B']);
    expect(permutations2.length).toBe(2);
    expect(permutations2).toEqual([
      ['A', 'B'],
      ['B', 'A'],
    ]);

    const permutations6 = permutateWithoutRepetitions(['A', 'A']);
    expect(permutations6.length).toBe(2);
    expect(permutations6).toEqual([
      ['A', 'A'],
      ['A', 'A'],
    ]);

    const permutations3 = permutateWithoutRepetitions(['A', 'B', 'C']);
    expect(permutations3.length).toBe(factorial(3));
    expect(permutations3).toEqual([
      ['A', 'B', 'C'],
      ['B', 'A', 'C'],
      ['B', 'C', 'A'],
      ['A', 'C', 'B'],
      ['C', 'A', 'B'],
      ['C', 'B', 'A'],
    ]);

    const permutations4 = permutateWithoutRepetitions(['A', 'B', 'C', 'D']);
    expect(permutations4.length).toBe(factorial(4));
    expect(permutations4).toEqual([
      ['A', 'B', 'C', 'D'],
      ['B', 'A', 'C', 'D'],
      ['B', 'C', 'A', 'D'],
      ['B', 'C', 'D', 'A'],
      ['A', 'C', 'B', 'D'],
      ['C', 'A', 'B', 'D'],
      ['C', 'B', 'A', 'D'],
      ['C', 'B', 'D', 'A'],
      ['A', 'C', 'D', 'B'],
      ['C', 'A', 'D', 'B'],
      ['C', 'D', 'A', 'B'],
      ['C', 'D', 'B', 'A'],
      ['A', 'B', 'D', 'C'],
      ['B', 'A', 'D', 'C'],
      ['B', 'D', 'A', 'C'],
      ['B', 'D', 'C', 'A'],
      ['A', 'D', 'B', 'C'],
      ['D', 'A', 'B', 'C'],
      ['D', 'B', 'A', 'C'],
      ['D', 'B', 'C', 'A'],
      ['A', 'D', 'C', 'B'],
      ['D', 'A', 'C', 'B'],
      ['D', 'C', 'A', 'B'],
      ['D', 'C', 'B', 'A'],
    ]);

    const permutations5 = permutateWithoutRepetitions(['A', 'B', 'C', 'D', 'E', 'F']);
    expect(permutations5.length).toBe(factorial(6));
  })",steel
/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js,Magic Number,"{'line': 19, 'column': 38, 'index': 637}","it('should permutate string', () => {
    const permutations1 = permutateWithoutRepetitions(['A']);
    expect(permutations1).toEqual([
      ['A'],
    ]);

    const permutations2 = permutateWithoutRepetitions(['A', 'B']);
    expect(permutations2.length).toBe(2);
    expect(permutations2).toEqual([
      ['A', 'B'],
      ['B', 'A'],
    ]);

    const permutations6 = permutateWithoutRepetitions(['A', 'A']);
    expect(permutations6.length).toBe(2);
    expect(permutations6).toEqual([
      ['A', 'A'],
      ['A', 'A'],
    ]);

    const permutations3 = permutateWithoutRepetitions(['A', 'B', 'C']);
    expect(permutations3.length).toBe(factorial(3));
    expect(permutations3).toEqual([
      ['A', 'B', 'C'],
      ['B', 'A', 'C'],
      ['B', 'C', 'A'],
      ['A', 'C', 'B'],
      ['C', 'A', 'B'],
      ['C', 'B', 'A'],
    ]);

    const permutations4 = permutateWithoutRepetitions(['A', 'B', 'C', 'D']);
    expect(permutations4.length).toBe(factorial(4));
    expect(permutations4).toEqual([
      ['A', 'B', 'C', 'D'],
      ['B', 'A', 'C', 'D'],
      ['B', 'C', 'A', 'D'],
      ['B', 'C', 'D', 'A'],
      ['A', 'C', 'B', 'D'],
      ['C', 'A', 'B', 'D'],
      ['C', 'B', 'A', 'D'],
      ['C', 'B', 'D', 'A'],
      ['A', 'C', 'D', 'B'],
      ['C', 'A', 'D', 'B'],
      ['C', 'D', 'A', 'B'],
      ['C', 'D', 'B', 'A'],
      ['A', 'B', 'D', 'C'],
      ['B', 'A', 'D', 'C'],
      ['B', 'D', 'A', 'C'],
      ['B', 'D', 'C', 'A'],
      ['A', 'D', 'B', 'C'],
      ['D', 'A', 'B', 'C'],
      ['D', 'B', 'A', 'C'],
      ['D', 'B', 'C', 'A'],
      ['A', 'D', 'C', 'B'],
      ['D', 'A', 'C', 'B'],
      ['D', 'C', 'A', 'B'],
      ['D', 'C', 'B', 'A'],
    ]);

    const permutations5 = permutateWithoutRepetitions(['A', 'B', 'C', 'D', 'E', 'F']);
    expect(permutations5.length).toBe(factorial(6));
  })",steel
/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js,Magic Number,"{'line': 6, 'column': 46, 'index': 287}","it('should find maximum subarray sum using the divide and conquer algorithm', () => {
    expect(dcMaximumSubarray([])).toEqual(-Infinity);
    expect(dcMaximumSubarray([0, 0])).toEqual(0);
    expect(dcMaximumSubarray([0, 0, 1])).toEqual(1);
    expect(dcMaximumSubarray([0, 0, 1, 2])).toEqual(3);
    expect(dcMaximumSubarray([0, 0, -1, 2])).toEqual(2);
    expect(dcMaximumSubarray([-1, -2, -3, -4, -5])).toEqual(-1);
    expect(dcMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual(20);
    expect(dcMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual(6);
    expect(dcMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual(7);
    expect(dcMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual(27);
  })",steel
/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js,Magic Number,"{'line': 7, 'column': 49, 'index': 340}","it('should find maximum subarray sum using the divide and conquer algorithm', () => {
    expect(dcMaximumSubarray([])).toEqual(-Infinity);
    expect(dcMaximumSubarray([0, 0])).toEqual(0);
    expect(dcMaximumSubarray([0, 0, 1])).toEqual(1);
    expect(dcMaximumSubarray([0, 0, 1, 2])).toEqual(3);
    expect(dcMaximumSubarray([0, 0, -1, 2])).toEqual(2);
    expect(dcMaximumSubarray([-1, -2, -3, -4, -5])).toEqual(-1);
    expect(dcMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual(20);
    expect(dcMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual(6);
    expect(dcMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual(7);
    expect(dcMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual(27);
  })",steel
/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js,Magic Number,"{'line': 8, 'column': 52, 'index': 396}","it('should find maximum subarray sum using the divide and conquer algorithm', () => {
    expect(dcMaximumSubarray([])).toEqual(-Infinity);
    expect(dcMaximumSubarray([0, 0])).toEqual(0);
    expect(dcMaximumSubarray([0, 0, 1])).toEqual(1);
    expect(dcMaximumSubarray([0, 0, 1, 2])).toEqual(3);
    expect(dcMaximumSubarray([0, 0, -1, 2])).toEqual(2);
    expect(dcMaximumSubarray([-1, -2, -3, -4, -5])).toEqual(-1);
    expect(dcMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual(20);
    expect(dcMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual(6);
    expect(dcMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual(7);
    expect(dcMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual(27);
  })",steel
/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js,Magic Number,"{'line': 9, 'column': 53, 'index': 453}","it('should find maximum subarray sum using the divide and conquer algorithm', () => {
    expect(dcMaximumSubarray([])).toEqual(-Infinity);
    expect(dcMaximumSubarray([0, 0])).toEqual(0);
    expect(dcMaximumSubarray([0, 0, 1])).toEqual(1);
    expect(dcMaximumSubarray([0, 0, 1, 2])).toEqual(3);
    expect(dcMaximumSubarray([0, 0, -1, 2])).toEqual(2);
    expect(dcMaximumSubarray([-1, -2, -3, -4, -5])).toEqual(-1);
    expect(dcMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual(20);
    expect(dcMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual(6);
    expect(dcMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual(7);
    expect(dcMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual(27);
  })",steel
/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js,Magic Number,"{'line': 11, 'column': 61, 'index': 583}","it('should find maximum subarray sum using the divide and conquer algorithm', () => {
    expect(dcMaximumSubarray([])).toEqual(-Infinity);
    expect(dcMaximumSubarray([0, 0])).toEqual(0);
    expect(dcMaximumSubarray([0, 0, 1])).toEqual(1);
    expect(dcMaximumSubarray([0, 0, 1, 2])).toEqual(3);
    expect(dcMaximumSubarray([0, 0, -1, 2])).toEqual(2);
    expect(dcMaximumSubarray([-1, -2, -3, -4, -5])).toEqual(-1);
    expect(dcMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual(20);
    expect(dcMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual(6);
    expect(dcMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual(7);
    expect(dcMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual(27);
  })",steel
/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js,Magic Number,"{'line': 12, 'column': 71, 'index': 659}","it('should find maximum subarray sum using the divide and conquer algorithm', () => {
    expect(dcMaximumSubarray([])).toEqual(-Infinity);
    expect(dcMaximumSubarray([0, 0])).toEqual(0);
    expect(dcMaximumSubarray([0, 0, 1])).toEqual(1);
    expect(dcMaximumSubarray([0, 0, 1, 2])).toEqual(3);
    expect(dcMaximumSubarray([0, 0, -1, 2])).toEqual(2);
    expect(dcMaximumSubarray([-1, -2, -3, -4, -5])).toEqual(-1);
    expect(dcMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual(20);
    expect(dcMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual(6);
    expect(dcMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual(7);
    expect(dcMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual(27);
  })",steel
/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js,Magic Number,"{'line': 13, 'column': 69, 'index': 732}","it('should find maximum subarray sum using the divide and conquer algorithm', () => {
    expect(dcMaximumSubarray([])).toEqual(-Infinity);
    expect(dcMaximumSubarray([0, 0])).toEqual(0);
    expect(dcMaximumSubarray([0, 0, 1])).toEqual(1);
    expect(dcMaximumSubarray([0, 0, 1, 2])).toEqual(3);
    expect(dcMaximumSubarray([0, 0, -1, 2])).toEqual(2);
    expect(dcMaximumSubarray([-1, -2, -3, -4, -5])).toEqual(-1);
    expect(dcMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual(20);
    expect(dcMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual(6);
    expect(dcMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual(7);
    expect(dcMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual(27);
  })",steel
/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js,Magic Number,"{'line': 14, 'column': 76, 'index': 812}","it('should find maximum subarray sum using the divide and conquer algorithm', () => {
    expect(dcMaximumSubarray([])).toEqual(-Infinity);
    expect(dcMaximumSubarray([0, 0])).toEqual(0);
    expect(dcMaximumSubarray([0, 0, 1])).toEqual(1);
    expect(dcMaximumSubarray([0, 0, 1, 2])).toEqual(3);
    expect(dcMaximumSubarray([0, 0, -1, 2])).toEqual(2);
    expect(dcMaximumSubarray([-1, -2, -3, -4, -5])).toEqual(-1);
    expect(dcMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual(20);
    expect(dcMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual(6);
    expect(dcMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual(7);
    expect(dcMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual(27);
  })",steel
/src/algorithms/sets/longest-increasing-subsequence/__test__/dpLongestIncreasingSubsequence.test.js,Magic Number,"{'line': 13, 'column': 13, 'index': 368}","it('should find longest increasing subsequence length', () => {
    // Should be:
    // 9 or
    // 8 or
    // 7 or
    // 6 or
    // ...
    expect(dpLongestIncreasingSubsequence([
      9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
    ])).toBe(1);

    // Should be:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
    expect(dpLongestIncreasingSubsequence([
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    ])).toBe(10);

    // Should be:
    // -1, 0, 2, 3
    expect(dpLongestIncreasingSubsequence([
      3, 4, -1, 0, 6, 2, 3,
    ])).toBe(4);

    // Should be:
    // 0, 2, 6, 9, 11, 15 or
    // 0, 4, 6, 9, 11, 15 or
    // 0, 2, 6, 9, 13, 15 or
    // 0, 4, 6, 9, 13, 15
    expect(dpLongestIncreasingSubsequence([
      0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15,
    ])).toBe(6);
  })",steel
/src/algorithms/sets/longest-increasing-subsequence/__test__/dpLongestIncreasingSubsequence.test.js,Magic Number,"{'line': 19, 'column': 13, 'index': 520}","it('should find longest increasing subsequence length', () => {
    // Should be:
    // 9 or
    // 8 or
    // 7 or
    // 6 or
    // ...
    expect(dpLongestIncreasingSubsequence([
      9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
    ])).toBe(1);

    // Should be:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
    expect(dpLongestIncreasingSubsequence([
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    ])).toBe(10);

    // Should be:
    // -1, 0, 2, 3
    expect(dpLongestIncreasingSubsequence([
      3, 4, -1, 0, 6, 2, 3,
    ])).toBe(4);

    // Should be:
    // 0, 2, 6, 9, 11, 15 or
    // 0, 4, 6, 9, 11, 15 or
    // 0, 2, 6, 9, 13, 15 or
    // 0, 4, 6, 9, 13, 15
    expect(dpLongestIncreasingSubsequence([
      0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15,
    ])).toBe(6);
  })",steel
/src/algorithms/sets/longest-increasing-subsequence/__test__/dpLongestIncreasingSubsequence.test.js,Magic Number,"{'line': 25, 'column': 13, 'index': 648}","it('should find longest increasing subsequence length', () => {
    // Should be:
    // 9 or
    // 8 or
    // 7 or
    // 6 or
    // ...
    expect(dpLongestIncreasingSubsequence([
      9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
    ])).toBe(1);

    // Should be:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
    expect(dpLongestIncreasingSubsequence([
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    ])).toBe(10);

    // Should be:
    // -1, 0, 2, 3
    expect(dpLongestIncreasingSubsequence([
      3, 4, -1, 0, 6, 2, 3,
    ])).toBe(4);

    // Should be:
    // 0, 2, 6, 9, 11, 15 or
    // 0, 4, 6, 9, 11, 15 or
    // 0, 2, 6, 9, 13, 15 or
    // 0, 4, 6, 9, 13, 15
    expect(dpLongestIncreasingSubsequence([
      0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15,
    ])).toBe(6);
  })",steel
/src/algorithms/sets/longest-increasing-subsequence/__test__/dpLongestIncreasingSubsequence.test.js,Magic Number,"{'line': 34, 'column': 13, 'index': 901}","it('should find longest increasing subsequence length', () => {
    // Should be:
    // 9 or
    // 8 or
    // 7 or
    // 6 or
    // ...
    expect(dpLongestIncreasingSubsequence([
      9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
    ])).toBe(1);

    // Should be:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
    expect(dpLongestIncreasingSubsequence([
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    ])).toBe(10);

    // Should be:
    // -1, 0, 2, 3
    expect(dpLongestIncreasingSubsequence([
      3, 4, -1, 0, 6, 2, 3,
    ])).toBe(4);

    // Should be:
    // 0, 2, 6, 9, 11, 15 or
    // 0, 4, 6, 9, 11, 15 or
    // 0, 2, 6, 9, 13, 15 or
    // 0, 4, 6, 9, 13, 15
    expect(dpLongestIncreasingSubsequence([
      0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15,
    ])).toBe(6);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 7, 'column': 4, 'index': 232}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 7, 'column': 4, 'index': 232}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 8, 'column': 4, 'index': 272}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 8, 'column': 4, 'index': 272}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 9, 'column': 4, 'index': 313}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 10, 'column': 4, 'index': 356}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 10, 'column': 4, 'index': 356}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 11, 'column': 4, 'index': 412}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 12, 'column': 4, 'index': 467}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 512}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 591}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 591}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 18, 'column': 4, 'index': 631}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 18, 'column': 4, 'index': 631}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 672}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 20, 'column': 4, 'index': 715}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 20, 'column': 4, 'index': 715}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 771}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 826}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 871}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 950}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 950}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 990}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 990}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 1031}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 1074}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 1074}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 1130}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 32, 'column': 4, 'index': 1185}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 1230}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 7, 'column': 36, 'index': 264}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 8, 'column': 37, 'index': 305}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 9, 'column': 39, 'index': 348}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 10, 'column': 50, 'index': 402}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 12, 'column': 41, 'index': 504}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 13, 'column': 42, 'index': 550}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 17, 'column': 36, 'index': 623}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 18, 'column': 37, 'index': 664}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 19, 'column': 39, 'index': 707}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 20, 'column': 50, 'index': 761}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 22, 'column': 41, 'index': 863}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 23, 'column': 42, 'index': 909}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 27, 'column': 36, 'index': 982}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 28, 'column': 37, 'index': 1023}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 29, 'column': 39, 'index': 1066}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 30, 'column': 50, 'index': 1120}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 32, 'column': 41, 'index': 1222}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js,Magic Number,"{'line': 33, 'column': 42, 'index': 1268}","it('should create knapsack item and count its total weight and value', () => {
    const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(1);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
    expect(knapsackItem.totalValue).toBe(3);
    expect(knapsackItem.totalWeight).toBe(2);

    knapsackItem.quantity = 0;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(0);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
    expect(knapsackItem.totalValue).toBe(0);
    expect(knapsackItem.totalWeight).toBe(0);

    knapsackItem.quantity = 2;

    expect(knapsackItem.value).toBe(3);
    expect(knapsackItem.weight).toBe(2);
    expect(knapsackItem.quantity).toBe(2);
    expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
    expect(knapsackItem.totalValue).toBe(6);
    expect(knapsackItem.totalWeight).toBe(4);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 19, 'column': 37, 'index': 594}","it('should solve 0/1 knapsack problem', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 3 }),
      new KnapsackItem({ value: 5, weight: 4 }),
      new KnapsackItem({ value: 7, weight: 5 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(9);
    expect(knapsack.totalWeight).toBe(7);
    expect(knapsack.selectedItems.length).toBe(2);
    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 20, 'column': 38, 'index': 636}","it('should solve 0/1 knapsack problem', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 3 }),
      new KnapsackItem({ value: 5, weight: 4 }),
      new KnapsackItem({ value: 7, weight: 5 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(9);
    expect(knapsack.totalWeight).toBe(7);
    expect(knapsack.selectedItems.length).toBe(2);
    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 21, 'column': 47, 'index': 687}","it('should solve 0/1 knapsack problem', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 3 }),
      new KnapsackItem({ value: 5, weight: 4 }),
      new KnapsackItem({ value: 7, weight: 5 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(9);
    expect(knapsack.totalWeight).toBe(7);
    expect(knapsack.selectedItems.length).toBe(2);
    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 40, 'column': 37, 'index': 1344}","it('should solve 0/1 knapsack problem regardless of items order', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 4 }),
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 7, weight: 5 }),
      new KnapsackItem({ value: 4, weight: 3 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(9);
    expect(knapsack.totalWeight).toBe(7);
    expect(knapsack.selectedItems.length).toBe(2);
    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 41, 'column': 38, 'index': 1386}","it('should solve 0/1 knapsack problem regardless of items order', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 4 }),
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 7, weight: 5 }),
      new KnapsackItem({ value: 4, weight: 3 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(9);
    expect(knapsack.totalWeight).toBe(7);
    expect(knapsack.selectedItems.length).toBe(2);
    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 42, 'column': 47, 'index': 1437}","it('should solve 0/1 knapsack problem regardless of items order', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 4 }),
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 7, weight: 5 }),
      new KnapsackItem({ value: 4, weight: 3 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(9);
    expect(knapsack.totalWeight).toBe(7);
    expect(knapsack.selectedItems.length).toBe(2);
    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 61, 'column': 37, 'index': 2098}","it('should solve 0/1 knapsack problem with impossible items set', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 40 }),
      new KnapsackItem({ value: 1, weight: 10 }),
      new KnapsackItem({ value: 7, weight: 50 }),
      new KnapsackItem({ value: 4, weight: 30 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(0);
    expect(knapsack.totalWeight).toBe(0);
    expect(knapsack.selectedItems.length).toBe(0);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 62, 'column': 38, 'index': 2140}","it('should solve 0/1 knapsack problem with impossible items set', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 40 }),
      new KnapsackItem({ value: 1, weight: 10 }),
      new KnapsackItem({ value: 7, weight: 50 }),
      new KnapsackItem({ value: 4, weight: 30 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(0);
    expect(knapsack.totalWeight).toBe(0);
    expect(knapsack.selectedItems.length).toBe(0);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 63, 'column': 47, 'index': 2191}","it('should solve 0/1 knapsack problem with impossible items set', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 40 }),
      new KnapsackItem({ value: 1, weight: 10 }),
      new KnapsackItem({ value: 7, weight: 50 }),
      new KnapsackItem({ value: 4, weight: 30 }),
    ];

    const maxKnapsackWeight = 7;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(0);
    expect(knapsack.totalWeight).toBe(0);
    expect(knapsack.selectedItems.length).toBe(0);
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 82, 'column': 37, 'index': 2807}","it('should solve 0/1 knapsack problem with all equal weights', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 1 }),
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 7, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
    ];

    const maxKnapsackWeight = 3;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(16);
    expect(knapsack.totalWeight).toBe(3);
    expect(knapsack.selectedItems.length).toBe(3);
    expect(knapsack.selectedItems[0].toString()).toBe('v4 w1 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v5 w1 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v7 w1 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 83, 'column': 38, 'index': 2850}","it('should solve 0/1 knapsack problem with all equal weights', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 1 }),
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 7, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
    ];

    const maxKnapsackWeight = 3;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(16);
    expect(knapsack.totalWeight).toBe(3);
    expect(knapsack.selectedItems.length).toBe(3);
    expect(knapsack.selectedItems[0].toString()).toBe('v4 w1 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v5 w1 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v7 w1 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 84, 'column': 47, 'index': 2901}","it('should solve 0/1 knapsack problem with all equal weights', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 5, weight: 1 }),
      new KnapsackItem({ value: 1, weight: 1 }),
      new KnapsackItem({ value: 7, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
      new KnapsackItem({ value: 4, weight: 1 }),
    ];

    const maxKnapsackWeight = 3;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveZeroOneKnapsackProblem();

    expect(knapsack.totalValue).toBe(16);
    expect(knapsack.totalWeight).toBe(3);
    expect(knapsack.selectedItems.length).toBe(3);
    expect(knapsack.selectedItems[0].toString()).toBe('v4 w1 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v5 w1 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v7 w1 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 106, 'column': 38, 'index': 3817}","it('should solve unbound knapsack problem', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 84, weight: 7 }), // v/w ratio is 12
      new KnapsackItem({ value: 5, weight: 2 }), // v/w ratio is 2.5
      new KnapsackItem({ value: 12, weight: 3 }), // v/w ratio is 4
      new KnapsackItem({ value: 10, weight: 1 }), // v/w ratio is 10
      new KnapsackItem({ value: 20, weight: 2 }), // v/w ratio is 10
    ];

    const maxKnapsackWeight = 15;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveUnboundedKnapsackProblem();

    expect(knapsack.totalValue).toBe(84 + 20 + 12 + 10 + 5);
    expect(knapsack.totalWeight).toBe(15);
    expect(knapsack.selectedItems.length).toBe(5);
    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 1');
    expect(knapsack.selectedItems[3].toString()).toBe('v12 w3 x 1');
    expect(knapsack.selectedItems[4].toString()).toBe('v5 w2 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 107, 'column': 47, 'index': 3869}","it('should solve unbound knapsack problem', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 84, weight: 7 }), // v/w ratio is 12
      new KnapsackItem({ value: 5, weight: 2 }), // v/w ratio is 2.5
      new KnapsackItem({ value: 12, weight: 3 }), // v/w ratio is 4
      new KnapsackItem({ value: 10, weight: 1 }), // v/w ratio is 10
      new KnapsackItem({ value: 20, weight: 2 }), // v/w ratio is 10
    ];

    const maxKnapsackWeight = 15;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveUnboundedKnapsackProblem();

    expect(knapsack.totalValue).toBe(84 + 20 + 12 + 10 + 5);
    expect(knapsack.totalWeight).toBe(15);
    expect(knapsack.selectedItems.length).toBe(5);
    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 1');
    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 1');
    expect(knapsack.selectedItems[3].toString()).toBe('v12 w3 x 1');
    expect(knapsack.selectedItems[4].toString()).toBe('v5 w2 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 131, 'column': 38, 'index': 5026}","it('should solve unbound knapsack problem with items in stock', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 84, weight: 7, itemsInStock: 3 }), // v/w ratio is 12
      new KnapsackItem({ value: 5, weight: 2, itemsInStock: 2 }), // v/w ratio is 2.5
      new KnapsackItem({ value: 12, weight: 3, itemsInStock: 1 }), // v/w ratio is 4
      new KnapsackItem({ value: 10, weight: 1, itemsInStock: 6 }), // v/w ratio is 10
      new KnapsackItem({ value: 20, weight: 2, itemsInStock: 8 }), // v/w ratio is 10
    ];

    const maxKnapsackWeight = 17;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveUnboundedKnapsackProblem();

    expect(knapsack.totalValue).toBe(84 + 84 + 20 + 10);
    expect(knapsack.totalWeight).toBe(17);
    expect(knapsack.selectedItems.length).toBe(3);
    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 2');
    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 132, 'column': 47, 'index': 5078}","it('should solve unbound knapsack problem with items in stock', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 84, weight: 7, itemsInStock: 3 }), // v/w ratio is 12
      new KnapsackItem({ value: 5, weight: 2, itemsInStock: 2 }), // v/w ratio is 2.5
      new KnapsackItem({ value: 12, weight: 3, itemsInStock: 1 }), // v/w ratio is 4
      new KnapsackItem({ value: 10, weight: 1, itemsInStock: 6 }), // v/w ratio is 10
      new KnapsackItem({ value: 20, weight: 2, itemsInStock: 8 }), // v/w ratio is 10
    ];

    const maxKnapsackWeight = 17;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveUnboundedKnapsackProblem();

    expect(knapsack.totalValue).toBe(84 + 84 + 20 + 10);
    expect(knapsack.totalWeight).toBe(17);
    expect(knapsack.selectedItems.length).toBe(3);
    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 2');
    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 1');
    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 1');
  })",steel
/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js,Magic Number,"{'line': 155, 'column': 47, 'index': 6271}","it('should solve unbound knapsack problem with items in stock and max weight more than sum of all items', () => {
    const possibleKnapsackItems = [
      new KnapsackItem({ value: 84, weight: 7, itemsInStock: 3 }), // v/w ratio is 12
      new KnapsackItem({ value: 5, weight: 2, itemsInStock: 2 }), // v/w ratio is 2.5
      new KnapsackItem({ value: 12, weight: 3, itemsInStock: 1 }), // v/w ratio is 4
      new KnapsackItem({ value: 10, weight: 1, itemsInStock: 6 }), // v/w ratio is 10
      new KnapsackItem({ value: 20, weight: 2, itemsInStock: 8 }), // v/w ratio is 10
    ];

    const maxKnapsackWeight = 60;

    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);

    knapsack.solveUnboundedKnapsackProblem();

    expect(knapsack.totalValue).toBe((3 * 84) + (2 * 5) + (1 * 12) + (6 * 10) + (8 * 20));
    expect(knapsack.totalWeight).toBe((3 * 7) + (2 * 2) + (1 * 3) + (6 * 1) + (8 * 2));
    expect(knapsack.selectedItems.length).toBe(5);
    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 3');
    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 8');
    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 6');
    expect(knapsack.selectedItems[3].toString()).toBe('v12 w3 x 1');
    expect(knapsack.selectedItems[4].toString()).toBe('v5 w2 x 2');
  })",steel
/src/algorithms/sets/combinations/__test__/combineWithoutRepetitions.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1748}","it('should combine string without repetitions', () => {
    expect(combineWithoutRepetitions(['A', 'B'], 3)).toEqual([]);

    expect(combineWithoutRepetitions(['A', 'B'], 1)).toEqual([
      ['A'],
      ['B'],
    ]);

    expect(combineWithoutRepetitions(['A'], 1)).toEqual([
      ['A'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B'], 2)).toEqual([
      ['A', 'B'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 2)).toEqual([
      ['A', 'B'],
      ['A', 'C'],
      ['B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 3)).toEqual([
      ['A', 'B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'C', 'D'],
      ['B', 'C', 'D'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D', 'E'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'B', 'E'],
      ['A', 'C', 'D'],
      ['A', 'C', 'E'],
      ['A', 'D', 'E'],
      ['B', 'C', 'D'],
      ['B', 'C', 'E'],
      ['B', 'D', 'E'],
      ['C', 'D', 'E'],
    ]);

    const combinationOptions = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
    const combinationSlotsNumber = 4;
    const combinations = combineWithoutRepetitions(combinationOptions, combinationSlotsNumber);
    const n = combinationOptions.length;
    const r = combinationSlotsNumber;
    const expectedNumberOfCombinations = factorial(n) / (factorial(r) * factorial(n - r));

    expect(combinations.length).toBe(expectedNumberOfCombinations);

    // This one is just to see one of the way of Pascal's triangle application.
    expect(combinations.length).toBe(pascalTriangle(n)[r]);
  })",steel
/src/algorithms/sets/combinations/__test__/combineWithoutRepetitions.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1897}","it('should combine string without repetitions', () => {
    expect(combineWithoutRepetitions(['A', 'B'], 3)).toEqual([]);

    expect(combineWithoutRepetitions(['A', 'B'], 1)).toEqual([
      ['A'],
      ['B'],
    ]);

    expect(combineWithoutRepetitions(['A'], 1)).toEqual([
      ['A'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B'], 2)).toEqual([
      ['A', 'B'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 2)).toEqual([
      ['A', 'B'],
      ['A', 'C'],
      ['B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C'], 3)).toEqual([
      ['A', 'B', 'C'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'C', 'D'],
      ['B', 'C', 'D'],
    ]);

    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D', 'E'], 3)).toEqual([
      ['A', 'B', 'C'],
      ['A', 'B', 'D'],
      ['A', 'B', 'E'],
      ['A', 'C', 'D'],
      ['A', 'C', 'E'],
      ['A', 'D', 'E'],
      ['B', 'C', 'D'],
      ['B', 'C', 'E'],
      ['B', 'D', 'E'],
      ['C', 'D', 'E'],
    ]);

    const combinationOptions = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
    const combinationSlotsNumber = 4;
    const combinations = combineWithoutRepetitions(combinationOptions, combinationSlotsNumber);
    const n = combinationOptions.length;
    const r = combinationSlotsNumber;
    const expectedNumberOfCombinations = factorial(n) / (factorial(r) * factorial(n - r));

    expect(combinations.length).toBe(expectedNumberOfCombinations);

    // This one is just to see one of the way of Pascal's triangle application.
    expect(combinations.length).toBe(pascalTriangle(n)[r]);
  })",steel
/src/algorithms/search/linear-search/__test__/linearSearch.test.js,Conditional Test Logic,"{'line': 22, 'column': 6, 'index': 674}","it('should search through objects as well', () => {
    const comparatorCallback = (a, b) => {
      if (a.key === b.key) {
        return 0;
      }

      return a.key <= b.key ? -1 : 1;
    };

    const array = [
      { key: 5 },
      { key: 6 },
      { key: 7 },
      { key: 6 },
    ];

    expect(linearSearch(array, { key: 10 }, comparatorCallback)).toEqual([]);
    expect(linearSearch(array, { key: 5 }, comparatorCallback)).toEqual([0]);
    expect(linearSearch(array, { key: 6 }, comparatorCallback)).toEqual([1, 3]);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Conditional Test Logic,"{'line': 29, 'column': 6, 'index': 1201}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(jumpSearch([], { key: 1 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(jumpSearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Duplicate Assert,"{'line': 8, 'column': 4, 'index': 258}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Duplicate Assert,"{'line': 8, 'column': 4, 'index': 258}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Duplicate Assert,"{'line': 9, 'column': 4, 'index': 301}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Duplicate Assert,"{'line': 9, 'column': 4, 'index': 301}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Duplicate Assert,"{'line': 12, 'column': 4, 'index': 460}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Duplicate Assert,"{'line': 12, 'column': 4, 'index': 460}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 531}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 531}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 7, 'column': 36, 'index': 250}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 8, 'column': 39, 'index': 293}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 9, 'column': 39, 'index': 336}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 10, 'column': 42, 'index': 382}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 11, 'column': 66, 'index': 452}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 15, 'column': 66, 'index': 735}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 16, 'column': 67, 'index': 806}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 17, 'column': 67, 'index': 877}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 18, 'column': 67, 'index': 948}","it('should search for an element in sorted array', () => {
    expect(jumpSearch([], 1)).toBe(-1);
    expect(jumpSearch([1], 2)).toBe(-1);
    expect(jumpSearch([1], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 2], 1)).toBe(0);
    expect(jumpSearch([1, 1, 1], 1)).toBe(0);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 2)).toBe(1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 0)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 7)).toBe(-1);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 5)).toBe(2);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 20)).toBe(4);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 30)).toBe(7);
    expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 35, 'column': 74, 'index': 1491}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(jumpSearch([], { key: 1 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(jumpSearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 36, 'column': 74, 'index': 1569}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(jumpSearch([], { key: 1 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(jumpSearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",steel
/src/algorithms/search/jump-search/__test__/jumpSearch.test.js,Magic Number,"{'line': 37, 'column': 74, 'index': 1647}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(jumpSearch([], { key: 1 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(jumpSearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(jumpSearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 6, 'column': 45, 'index': 259}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 8, 'column': 48, 'index': 361}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 9, 'column': 48, 'index': 413}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 10, 'column': 48, 'index': 465}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 11, 'column': 63, 'index': 532}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 12, 'column': 94, 'index': 630}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 13, 'column': 96, 'index': 731}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 15, 'column': 85, 'index': 913}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 16, 'column': 85, 'index': 1002}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 17, 'column': 85, 'index': 1091}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 18, 'column': 87, 'index': 1182}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 19, 'column': 87, 'index': 1273}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 20, 'column': 88, 'index': 1365}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 21, 'column': 88, 'index': 1457}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js,Magic Number,"{'line': 22, 'column': 70, 'index': 1531}","it('should search elements in sorted array of numbers', () => {
    expect(interpolationSearch([], 1)).toBe(-1);
    expect(interpolationSearch([1], 1)).toBe(0);
    expect(interpolationSearch([1], 0)).toBe(-1);
    expect(interpolationSearch([1, 1], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 1)).toBe(0);
    expect(interpolationSearch([1, 2], 2)).toBe(1);
    expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
    expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Conditional Test Logic,"{'line': 24, 'column': 6, 'index': 891}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(binarySearch([], { key: 1 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(binarySearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(binarySearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 6, 'column': 38, 'index': 211}","it('should search number in sorted array', () => {
    expect(binarySearch([], 1)).toBe(-1);
    expect(binarySearch([1], 1)).toBe(0);
    expect(binarySearch([1, 2], 1)).toBe(0);
    expect(binarySearch([1, 2], 2)).toBe(1);
    expect(binarySearch([1, 5, 10, 12], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 17)).toBe(5);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 100)).toBe(7);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 0)).toBe(-1);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 7, 'column': 41, 'index': 256}","it('should search number in sorted array', () => {
    expect(binarySearch([], 1)).toBe(-1);
    expect(binarySearch([1], 1)).toBe(0);
    expect(binarySearch([1, 2], 1)).toBe(0);
    expect(binarySearch([1, 2], 2)).toBe(1);
    expect(binarySearch([1, 5, 10, 12], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 17)).toBe(5);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 100)).toBe(7);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 0)).toBe(-1);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 8, 'column': 41, 'index': 301}","it('should search number in sorted array', () => {
    expect(binarySearch([], 1)).toBe(-1);
    expect(binarySearch([1], 1)).toBe(0);
    expect(binarySearch([1, 2], 1)).toBe(0);
    expect(binarySearch([1, 2], 2)).toBe(1);
    expect(binarySearch([1, 5, 10, 12], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 17)).toBe(5);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 100)).toBe(7);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 0)).toBe(-1);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 9, 'column': 49, 'index': 354}","it('should search number in sorted array', () => {
    expect(binarySearch([], 1)).toBe(-1);
    expect(binarySearch([1], 1)).toBe(0);
    expect(binarySearch([1, 2], 1)).toBe(0);
    expect(binarySearch([1, 2], 2)).toBe(1);
    expect(binarySearch([1, 5, 10, 12], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 17)).toBe(5);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 100)).toBe(7);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 0)).toBe(-1);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 10, 'column': 67, 'index': 425}","it('should search number in sorted array', () => {
    expect(binarySearch([], 1)).toBe(-1);
    expect(binarySearch([1], 1)).toBe(0);
    expect(binarySearch([1, 2], 1)).toBe(0);
    expect(binarySearch([1, 2], 2)).toBe(1);
    expect(binarySearch([1, 5, 10, 12], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 17)).toBe(5);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 100)).toBe(7);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 0)).toBe(-1);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 11, 'column': 66, 'index': 495}","it('should search number in sorted array', () => {
    expect(binarySearch([], 1)).toBe(-1);
    expect(binarySearch([1], 1)).toBe(0);
    expect(binarySearch([1, 2], 1)).toBe(0);
    expect(binarySearch([1, 2], 2)).toBe(1);
    expect(binarySearch([1, 5, 10, 12], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 17)).toBe(5);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 100)).toBe(7);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 0)).toBe(-1);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 12, 'column': 68, 'index': 567}","it('should search number in sorted array', () => {
    expect(binarySearch([], 1)).toBe(-1);
    expect(binarySearch([1], 1)).toBe(0);
    expect(binarySearch([1, 2], 1)).toBe(0);
    expect(binarySearch([1, 2], 2)).toBe(1);
    expect(binarySearch([1, 5, 10, 12], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 17)).toBe(5);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 1)).toBe(0);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 100)).toBe(7);
    expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 0)).toBe(-1);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 30, 'column': 76, 'index': 1187}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(binarySearch([], { key: 1 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(binarySearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(binarySearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 31, 'column': 76, 'index': 1267}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(binarySearch([], { key: 1 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(binarySearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(binarySearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",steel
/src/algorithms/search/binary-search/__test__/binarySearch.test.js,Magic Number,"{'line': 32, 'column': 76, 'index': 1347}","it('should search object in sorted array', () => {
    const sortedArrayOfObjects = [
      { key: 1, value: 'value1' },
      { key: 2, value: 'value2' },
      { key: 3, value: 'value3' },
    ];

    const comparator = (a, b) => {
      if (a.key === b.key) return 0;
      return a.key < b.key ? -1 : 1;
    };

    expect(binarySearch([], { key: 1 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 4 }, comparator)).toBe(-1);
    expect(binarySearch(sortedArrayOfObjects, { key: 1 }, comparator)).toBe(0);
    expect(binarySearch(sortedArrayOfObjects, { key: 2 }, comparator)).toBe(1);
    expect(binarySearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
  })",steel
/src/algorithms/ml/knn/__test__/knn.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1136}","it('should find the nearest neighbour', () => {
    let dataSet;
    let labels;
    let toClassify;
    let expectedClass;

    dataSet = [[1, 1], [2, 2]];
    labels = [1, 2];
    toClassify = [1, 1];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 2;
    expect(kNN(dataSet, labels, toClassify, 5)).toBe(expectedClass);
  })",steel
/src/algorithms/ml/knn/__test__/knn.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1136}","it('should find the nearest neighbour', () => {
    let dataSet;
    let labels;
    let toClassify;
    let expectedClass;

    dataSet = [[1, 1], [2, 2]];
    labels = [1, 2];
    toClassify = [1, 1];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 2;
    expect(kNN(dataSet, labels, toClassify, 5)).toBe(expectedClass);
  })",steel
/src/algorithms/ml/knn/__test__/knn.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1365}","it('should find the nearest neighbour', () => {
    let dataSet;
    let labels;
    let toClassify;
    let expectedClass;

    dataSet = [[1, 1], [2, 2]];
    labels = [1, 2];
    toClassify = [1, 1];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 2;
    expect(kNN(dataSet, labels, toClassify, 5)).toBe(expectedClass);
  })",steel
/src/algorithms/ml/knn/__test__/knn.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1365}","it('should find the nearest neighbour', () => {
    let dataSet;
    let labels;
    let toClassify;
    let expectedClass;

    dataSet = [[1, 1], [2, 2]];
    labels = [1, 2];
    toClassify = [1, 1];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 1;
    expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);

    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
    labels = [1, 2, 1, 2, 1, 2, 1];
    toClassify = [1.25, 1.25];
    expectedClass = 2;
    expect(kNN(dataSet, labels, toClassify, 5)).toBe(expectedClass);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 800}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 800}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 846}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 846}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 892}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 940}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 988}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 988}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 32, 'column': 4, 'index': 1034}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 1083}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 1083}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1130}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1130}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1179}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 1230}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1305}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1305}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1351}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1351}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1397}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 43, 'column': 4, 'index': 1447}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1497}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 44, 'column': 4, 'index': 1497}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1543}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1594}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1594}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1641}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1641}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1690}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 49, 'column': 4, 'index': 1743}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1821}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1821}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1867}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1867}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1913}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1970}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 2027}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 2027}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 2073}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 2131}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 2131}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 2178}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 2178}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 2227}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 2287}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 12, 'column': 31, 'index': 342}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 13, 'column': 31, 'index': 377}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 14, 'column': 31, 'index': 412}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 15, 'column': 31, 'index': 447}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 16, 'column': 31, 'index': 482}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 17, 'column': 32, 'index': 518}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 18, 'column': 32, 'index': 554}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 19, 'column': 33, 'index': 591}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 20, 'column': 33, 'index': 629}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 21, 'column': 35, 'index': 669}","it('should correctly calculate square root with default tolerance', () => {
    expect(squareRoot(0)).toBe(0);
    expect(squareRoot(1)).toBe(1);
    expect(squareRoot(2)).toBe(1);
    expect(squareRoot(3)).toBe(2);
    expect(squareRoot(4)).toBe(2);
    expect(squareRoot(15)).toBe(4);
    expect(squareRoot(16)).toBe(4);
    expect(squareRoot(256)).toBe(16);
    expect(squareRoot(473)).toBe(22);
    expect(squareRoot(14723)).toBe(121);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 27, 'column': 42, 'index': 838}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 28, 'column': 42, 'index': 884}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 29, 'column': 42, 'index': 930}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 30, 'column': 42, 'index': 978}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 31, 'column': 42, 'index': 1026}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 32, 'column': 43, 'index': 1073}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 33, 'column': 43, 'index': 1122}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 34, 'column': 44, 'index': 1170}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 35, 'column': 44, 'index': 1219}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 36, 'column': 46, 'index': 1272}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 40, 'column': 42, 'index': 1343}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 41, 'column': 42, 'index': 1389}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 42, 'column': 42, 'index': 1435}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 43, 'column': 42, 'index': 1485}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 44, 'column': 42, 'index': 1535}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 45, 'column': 43, 'index': 1582}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 46, 'column': 43, 'index': 1633}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 47, 'column': 44, 'index': 1681}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 48, 'column': 44, 'index': 1730}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 49, 'column': 46, 'index': 1785}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 53, 'column': 42, 'index': 1859}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 54, 'column': 42, 'index': 1905}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 55, 'column': 42, 'index': 1951}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 56, 'column': 42, 'index': 2008}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 57, 'column': 42, 'index': 2065}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 58, 'column': 43, 'index': 2112}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 59, 'column': 43, 'index': 2170}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 60, 'column': 44, 'index': 2218}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 61, 'column': 44, 'index': 2267}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 62, 'column': 46, 'index': 2329}","it('should correctly calculate square root for integers with custom tolerance', () => {
    let tolerance = 1;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4);
    expect(squareRoot(3, tolerance)).toBe(1.8);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.9);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7);
    expect(squareRoot(14723, tolerance)).toBe(121.3);

    tolerance = 3;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.414);
    expect(squareRoot(3, tolerance)).toBe(1.732);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.873);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.749);
    expect(squareRoot(14723, tolerance)).toBe(121.338);

    tolerance = 10;

    expect(squareRoot(0, tolerance)).toBe(0);
    expect(squareRoot(1, tolerance)).toBe(1);
    expect(squareRoot(2, tolerance)).toBe(1.4142135624);
    expect(squareRoot(3, tolerance)).toBe(1.7320508076);
    expect(squareRoot(4, tolerance)).toBe(2);
    expect(squareRoot(15, tolerance)).toBe(3.8729833462);
    expect(squareRoot(16, tolerance)).toBe(4);
    expect(squareRoot(256, tolerance)).toBe(16);
    expect(squareRoot(473, tolerance)).toBe(21.7485631709);
    expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 66, 'column': 37, 'index': 2480}","it('should correctly calculate square root for integers with custom tolerance', () => {
    expect(squareRoot(4.5, 10)).toBe(2.1213203436);
    expect(squareRoot(217.534, 10)).toBe(14.7490338667);
  })",steel
/src/algorithms/math/square-root/__test__/squareRoot.test.js,Magic Number,"{'line': 67, 'column': 41, 'index': 2536}","it('should correctly calculate square root for integers with custom tolerance', () => {
    expect(squareRoot(4.5, 10)).toBe(2.1213203436);
    expect(squareRoot(217.534, 10)).toBe(14.7490338667);
  })",steel
/src/algorithms/math/radian/__test__/radianToDegree.test.js,Magic Number,"{'line': 5, 'column': 35, 'index': 167}","it('should convert radian to degree', () => {
    expect(radianToDegree(0)).toBe(0);
    expect(radianToDegree(Math.PI / 4)).toBe(45);
    expect(radianToDegree(Math.PI / 2)).toBe(90);
    expect(radianToDegree(Math.PI)).toBe(180);
    expect(radianToDegree((3 * Math.PI) / 2)).toBe(270);
    expect(radianToDegree(2 * Math.PI)).toBe(360);
  })",steel
/src/algorithms/math/radian/__test__/radianToDegree.test.js,Magic Number,"{'line': 6, 'column': 45, 'index': 216}","it('should convert radian to degree', () => {
    expect(radianToDegree(0)).toBe(0);
    expect(radianToDegree(Math.PI / 4)).toBe(45);
    expect(radianToDegree(Math.PI / 2)).toBe(90);
    expect(radianToDegree(Math.PI)).toBe(180);
    expect(radianToDegree((3 * Math.PI) / 2)).toBe(270);
    expect(radianToDegree(2 * Math.PI)).toBe(360);
  })",steel
/src/algorithms/math/radian/__test__/radianToDegree.test.js,Magic Number,"{'line': 7, 'column': 45, 'index': 266}","it('should convert radian to degree', () => {
    expect(radianToDegree(0)).toBe(0);
    expect(radianToDegree(Math.PI / 4)).toBe(45);
    expect(radianToDegree(Math.PI / 2)).toBe(90);
    expect(radianToDegree(Math.PI)).toBe(180);
    expect(radianToDegree((3 * Math.PI) / 2)).toBe(270);
    expect(radianToDegree(2 * Math.PI)).toBe(360);
  })",steel
/src/algorithms/math/radian/__test__/radianToDegree.test.js,Magic Number,"{'line': 8, 'column': 41, 'index': 312}","it('should convert radian to degree', () => {
    expect(radianToDegree(0)).toBe(0);
    expect(radianToDegree(Math.PI / 4)).toBe(45);
    expect(radianToDegree(Math.PI / 2)).toBe(90);
    expect(radianToDegree(Math.PI)).toBe(180);
    expect(radianToDegree((3 * Math.PI) / 2)).toBe(270);
    expect(radianToDegree(2 * Math.PI)).toBe(360);
  })",steel
/src/algorithms/math/radian/__test__/radianToDegree.test.js,Magic Number,"{'line': 9, 'column': 51, 'index': 369}","it('should convert radian to degree', () => {
    expect(radianToDegree(0)).toBe(0);
    expect(radianToDegree(Math.PI / 4)).toBe(45);
    expect(radianToDegree(Math.PI / 2)).toBe(90);
    expect(radianToDegree(Math.PI)).toBe(180);
    expect(radianToDegree((3 * Math.PI) / 2)).toBe(270);
    expect(radianToDegree(2 * Math.PI)).toBe(360);
  })",steel
/src/algorithms/math/radian/__test__/radianToDegree.test.js,Magic Number,"{'line': 10, 'column': 45, 'index': 420}","it('should convert radian to degree', () => {
    expect(radianToDegree(0)).toBe(0);
    expect(radianToDegree(Math.PI / 4)).toBe(45);
    expect(radianToDegree(Math.PI / 2)).toBe(90);
    expect(radianToDegree(Math.PI)).toBe(180);
    expect(radianToDegree((3 * Math.PI) / 2)).toBe(270);
    expect(radianToDegree(2 * Math.PI)).toBe(360);
  })",steel
/src/algorithms/math/radian/__test__/degreeToRadian.test.js,Magic Number,"{'line': 5, 'column': 35, 'index': 167}","it('should convert degree to radian', () => {
    expect(degreeToRadian(0)).toBe(0);
    expect(degreeToRadian(45)).toBe(Math.PI / 4);
    expect(degreeToRadian(90)).toBe(Math.PI / 2);
    expect(degreeToRadian(180)).toBe(Math.PI);
    expect(degreeToRadian(270)).toBe((3 * Math.PI) / 2);
    expect(degreeToRadian(360)).toBe(2 * Math.PI);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 18, 'column': 11, 'index': 498}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 19, 'column': 11, 'index': 539}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 20, 'column': 11, 'index': 581}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 21, 'column': 11, 'index': 623}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 22, 'column': 11, 'index': 668}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 23, 'column': 11, 'index': 714}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 24, 'column': 11, 'index': 766}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 25, 'column': 11, 'index': 818}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 26, 'column': 11, 'index': 871}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 27, 'column': 11, 'index': 925}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 28, 'column': 11, 'index': 976}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 29, 'column': 11, 'index': 1032}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 30, 'column': 11, 'index': 1088}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 31, 'column': 11, 'index': 1148}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 32, 'column': 11, 'index': 1209}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 33, 'column': 11, 'index': 1274}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 34, 'column': 11, 'index': 1331}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 35, 'column': 11, 'index': 1399}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 36, 'column': 11, 'index': 1461}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 40, 'column': 11, 'index': 1622}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 41, 'column': 11, 'index': 1676}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 42, 'column': 11, 'index': 1729}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 43, 'column': 11, 'index': 1783}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 44, 'column': 11, 'index': 1839}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 45, 'column': 11, 'index': 1894}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 46, 'column': 11, 'index': 1951}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 47, 'column': 11, 'index': 2009}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 48, 'column': 11, 'index': 2067}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 49, 'column': 11, 'index': 2125}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 50, 'column': 11, 'index': 2184}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 54, 'column': 30, 'index': 2349}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 54, 'column': 54, 'index': 2373}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 57, 'column': 30, 'index': 2456}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 57, 'column': 54, 'index': 2480}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 60, 'column': 30, 'index': 2563}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 60, 'column': 55, 'index': 2588}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 63, 'column': 30, 'index': 2671}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 63, 'column': 56, 'index': 2697}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 66, 'column': 30, 'index': 2780}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 66, 'column': 56, 'index': 2806}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 69, 'column': 30, 'index': 2889}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 69, 'column': 58, 'index': 2917}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 72, 'column': 30, 'index': 3003}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 72, 'column': 59, 'index': 3032}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 75, 'column': 30, 'index': 3119}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 75, 'column': 59, 'index': 3148}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 78, 'column': 30, 'index': 3235}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 78, 'column': 59, 'index': 3264}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 81, 'column': 30, 'index': 3351}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 81, 'column': 60, 'index': 3381}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 84, 'column': 30, 'index': 3469}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Eager Test,"{'line': 84, 'column': 62, 'index': 3501}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Lazy Test,"{'line': 18, 'column': 11, 'index': 498}","it('should find prime factors', () => {
    expect(primeFactors(1)).toEqual([]);
    expect(primeFactors(2)).toEqual([2]);
    expect(primeFactors(3)).toEqual([3]);
    expect(primeFactors(4)).toEqual([2, 2]);
    expect(primeFactors(14)).toEqual([2, 7]);
    expect(primeFactors(40)).toEqual([2, 2, 2, 5]);
    expect(primeFactors(54)).toEqual([2, 3, 3, 3]);
    expect(primeFactors(100)).toEqual([2, 2, 5, 5]);
    expect(primeFactors(156)).toEqual([2, 2, 3, 13]);
    expect(primeFactors(273)).toEqual([3, 7, 13]);
    expect(primeFactors(300)).toEqual([2, 2, 3, 5, 5]);
    expect(primeFactors(980)).toEqual([2, 2, 5, 7, 7]);
    expect(primeFactors(1000)).toEqual([2, 2, 2, 5, 5, 5]);
    expect(primeFactors(52734)).toEqual([2, 3, 11, 17, 47]);
    expect(primeFactors(343434)).toEqual([2, 3, 7, 13, 17, 37]);
    expect(primeFactors(456745)).toEqual([5, 167, 547]);
    expect(primeFactors(510510)).toEqual([2, 3, 5, 7, 11, 13, 17]);
    expect(primeFactors(8735463)).toEqual([3, 3, 11, 88237]);
    expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Lazy Test,"{'line': 40, 'column': 11, 'index': 1622}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Lazy Test,"{'line': 54, 'column': 30, 'index': 2349}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Lazy Test,"{'line': 54, 'column': 54, 'index': 2373}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 40, 'column': 50, 'index': 1661}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 41, 'column': 42, 'index': 1707}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 41, 'column': 49, 'index': 1714}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 42, 'column': 43, 'index': 1761}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 42, 'column': 50, 'index': 1768}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 43, 'column': 44, 'index': 1816}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 43, 'column': 52, 'index': 1824}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 44, 'column': 44, 'index': 1872}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 44, 'column': 51, 'index': 1879}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 45, 'column': 46, 'index': 1929}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 45, 'column': 53, 'index': 1936}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 46, 'column': 47, 'index': 1987}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 46, 'column': 54, 'index': 1994}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 47, 'column': 47, 'index': 2045}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 47, 'column': 54, 'index': 2052}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 48, 'column': 47, 'index': 2103}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 48, 'column': 54, 'index': 2110}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 49, 'column': 48, 'index': 2162}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 49, 'column': 55, 'index': 2169}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 50, 'column': 50, 'index': 2223}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 50, 'column': 57, 'index': 2230}","it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
    expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
    expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
    expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
    expect(hardyRamanujan(156)).toBeCloseTo(1.6193, 2);
    expect(hardyRamanujan(980)).toBeCloseTo(1.929, 2);
    expect(hardyRamanujan(52734)).toBeCloseTo(2.386, 2);
    expect(hardyRamanujan(343434)).toBeCloseTo(2.545, 2);
    expect(hardyRamanujan(456745)).toBeCloseTo(2.567, 2);
    expect(hardyRamanujan(510510)).toBeCloseTo(2.575, 2);
    expect(hardyRamanujan(8735463)).toBeCloseTo(2.771, 2);
    expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 55, 'column': 19, 'index': 2412}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 55, 'column': 28, 'index': 2421}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 58, 'column': 19, 'index': 2519}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 58, 'column': 28, 'index': 2528}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 61, 'column': 19, 'index': 2627}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 61, 'column': 28, 'index': 2636}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 64, 'column': 19, 'index': 2736}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 64, 'column': 28, 'index': 2745}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 67, 'column': 19, 'index': 2845}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 67, 'column': 28, 'index': 2854}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 70, 'column': 19, 'index': 2960}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 70, 'column': 27, 'index': 2968}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 73, 'column': 19, 'index': 3076}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 73, 'column': 27, 'index': 3084}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 76, 'column': 19, 'index': 3192}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 76, 'column': 27, 'index': 3200}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 79, 'column': 19, 'index': 3308}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 79, 'column': 27, 'index': 3316}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 82, 'column': 19, 'index': 3426}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 82, 'column': 27, 'index': 3434}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 85, 'column': 19, 'index': 3548}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/prime-factors/__test__/primeFactors.test.js,Magic Number,"{'line': 85, 'column': 26, 'index': 3555}","it('should give correct deviation between exact and approx counts', () => {
    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
      .toBeCloseTo(136.651, 2);

    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
      .toBeCloseTo(118.325, 2);

    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
      .toBeCloseTo(109.162, 2);

    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
      .toBeCloseTo(107.330, 2);

    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
      .toBeCloseTo(52.274, 2);

    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
      .toBeCloseTo(57.578, 2);

    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
      .toBeCloseTo(14.420, 2);

    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
      .toBeCloseTo(63.201, 2);

    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
      .toBeCloseTo(30.712, 2);

    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
      .toBeCloseTo(0.823, 2);
  })",steel
/src/algorithms/math/primality-test/__test__/trialDivision.test.js,Unknown Test,"{'column': 2, 'line': 34}","it('should detect prime numbers', () => {
    primalityTest(trialDivision);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 162, 'column': 4, 'index': 3713}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 162, 'column': 4, 'index': 3713}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 163, 'column': 4, 'index': 3756}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 178, 'column': 4, 'index': 3938}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 179, 'column': 4, 'index': 3981}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 195, 'column': 4, 'index': 4186}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 195, 'column': 4, 'index': 4186}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 196, 'column': 4, 'index': 4229}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 211, 'column': 4, 'index': 4441}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/matrix/__tests__/Matrix.test.js,Duplicate Assert,"{'line': 212, 'column': 4, 'index': 4484}","it('should multiply two matrices', () => {
    let c;
    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5, 6],
        [7, 8],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [19, 22],
      [43, 50],
    ]);

    c = mtrx.dot(
      [
        [1, 2],
        [3, 4],
      ],
      [
        [5],
        [6],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 1]);
    expect(c).toEqual([
      [17],
      [39],
    ]);

    c = mtrx.dot(
      [
        [1, 2, 3],
        [4, 5, 6],
      ],
      [
        [7, 8],
        [9, 10],
        [11, 12],
      ],
    );
    expect(mtrx.shape(c)).toEqual([2, 2]);
    expect(c).toEqual([
      [58, 64],
      [139, 154],
    ]);

    c = mtrx.dot(
      [
        [3, 4, 2],
      ],
      [
        [13, 9, 7, 5],
        [8, 7, 4, 6],
        [6, 4, 0, 3],
      ],
    );
    expect(mtrx.shape(c)).toEqual([1, 4]);
    expect(c).toEqual([
      [83, 63, 37, 45],
    ]);
  })",steel
/src/algorithms/math/liu-hui/__test__/liuHui.test.js,Magic Number,"{'line': 5, 'column': 27, 'index': 138}","it('should calculate  based on 12-gon', () => {
    expect(liuHui(1)).toBe(3);
  })",steel
/src/algorithms/math/liu-hui/__test__/liuHui.test.js,Magic Number,"{'line': 9, 'column': 27, 'index': 227}","it('should calculate  based on 24-gon', () => {
    expect(liuHui(2)).toBe(3.105828541230249);
  })",steel
/src/algorithms/math/liu-hui/__test__/liuHui.test.js,Magic Number,"{'line': 13, 'column': 28, 'index': 335}","it('should calculate  based on 6144-gon', () => {
    expect(liuHui(10)).toBe(3.1415921059992717);
  })",steel
/src/algorithms/math/liu-hui/__test__/liuHui.test.js,Magic Number,"{'line': 17, 'column': 28, 'index': 449}","it('should calculate  based on 201326592-gon', () => {
    expect(liuHui(25)).toBe(3.141592653589793);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 5, 'column': 43, 'index': 192}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 6, 'column': 43, 'index': 239}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 7, 'column': 43, 'index': 286}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 8, 'column': 43, 'index': 333}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 9, 'column': 44, 'index': 382}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 10, 'column': 43, 'index': 430}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 11, 'column': 43, 'index': 478}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 12, 'column': 43, 'index': 526}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 13, 'column': 49, 'index': 580}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 14, 'column': 46, 'index': 636}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 15, 'column': 45, 'index': 686}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js,Magic Number,"{'line': 16, 'column': 44, 'index': 735}","it('should find least common multiple', () => {
    expect(leastCommonMultiple(0, 0)).toBe(0);
    expect(leastCommonMultiple(1, 0)).toBe(0);
    expect(leastCommonMultiple(0, 1)).toBe(0);
    expect(leastCommonMultiple(4, 6)).toBe(12);
    expect(leastCommonMultiple(6, 21)).toBe(42);
    expect(leastCommonMultiple(7, 2)).toBe(14);
    expect(leastCommonMultiple(3, 5)).toBe(15);
    expect(leastCommonMultiple(7, 3)).toBe(21);
    expect(leastCommonMultiple(1000000, 2)).toBe(1000000);
    expect(leastCommonMultiple(-9, -18)).toBe(18);
    expect(leastCommonMultiple(-7, -9)).toBe(63);
    expect(leastCommonMultiple(-7, 9)).toBe(63);
  })",steel
/src/algorithms/math/integer-partition/__test__/integerPartition.test.js,Magic Number,"{'line': 5, 'column': 37, 'index': 171}","it('should partition the number', () => {
    expect(integerPartition(1)).toBe(1);
    expect(integerPartition(2)).toBe(2);
    expect(integerPartition(3)).toBe(3);
    expect(integerPartition(4)).toBe(5);
    expect(integerPartition(5)).toBe(7);
    expect(integerPartition(6)).toBe(11);
    expect(integerPartition(7)).toBe(15);
    expect(integerPartition(8)).toBe(22);
  })",steel
/src/algorithms/math/integer-partition/__test__/integerPartition.test.js,Magic Number,"{'line': 6, 'column': 37, 'index': 212}","it('should partition the number', () => {
    expect(integerPartition(1)).toBe(1);
    expect(integerPartition(2)).toBe(2);
    expect(integerPartition(3)).toBe(3);
    expect(integerPartition(4)).toBe(5);
    expect(integerPartition(5)).toBe(7);
    expect(integerPartition(6)).toBe(11);
    expect(integerPartition(7)).toBe(15);
    expect(integerPartition(8)).toBe(22);
  })",steel
/src/algorithms/math/integer-partition/__test__/integerPartition.test.js,Magic Number,"{'line': 7, 'column': 37, 'index': 253}","it('should partition the number', () => {
    expect(integerPartition(1)).toBe(1);
    expect(integerPartition(2)).toBe(2);
    expect(integerPartition(3)).toBe(3);
    expect(integerPartition(4)).toBe(5);
    expect(integerPartition(5)).toBe(7);
    expect(integerPartition(6)).toBe(11);
    expect(integerPartition(7)).toBe(15);
    expect(integerPartition(8)).toBe(22);
  })",steel
/src/algorithms/math/integer-partition/__test__/integerPartition.test.js,Magic Number,"{'line': 8, 'column': 37, 'index': 294}","it('should partition the number', () => {
    expect(integerPartition(1)).toBe(1);
    expect(integerPartition(2)).toBe(2);
    expect(integerPartition(3)).toBe(3);
    expect(integerPartition(4)).toBe(5);
    expect(integerPartition(5)).toBe(7);
    expect(integerPartition(6)).toBe(11);
    expect(integerPartition(7)).toBe(15);
    expect(integerPartition(8)).toBe(22);
  })",steel
/src/algorithms/math/integer-partition/__test__/integerPartition.test.js,Magic Number,"{'line': 9, 'column': 37, 'index': 335}","it('should partition the number', () => {
    expect(integerPartition(1)).toBe(1);
    expect(integerPartition(2)).toBe(2);
    expect(integerPartition(3)).toBe(3);
    expect(integerPartition(4)).toBe(5);
    expect(integerPartition(5)).toBe(7);
    expect(integerPartition(6)).toBe(11);
    expect(integerPartition(7)).toBe(15);
    expect(integerPartition(8)).toBe(22);
  })",steel
/src/algorithms/math/integer-partition/__test__/integerPartition.test.js,Magic Number,"{'line': 10, 'column': 37, 'index': 376}","it('should partition the number', () => {
    expect(integerPartition(1)).toBe(1);
    expect(integerPartition(2)).toBe(2);
    expect(integerPartition(3)).toBe(3);
    expect(integerPartition(4)).toBe(5);
    expect(integerPartition(5)).toBe(7);
    expect(integerPartition(6)).toBe(11);
    expect(integerPartition(7)).toBe(15);
    expect(integerPartition(8)).toBe(22);
  })",steel
/src/algorithms/math/integer-partition/__test__/integerPartition.test.js,Magic Number,"{'line': 11, 'column': 37, 'index': 418}","it('should partition the number', () => {
    expect(integerPartition(1)).toBe(1);
    expect(integerPartition(2)).toBe(2);
    expect(integerPartition(3)).toBe(3);
    expect(integerPartition(4)).toBe(5);
    expect(integerPartition(5)).toBe(7);
    expect(integerPartition(6)).toBe(11);
    expect(integerPartition(7)).toBe(15);
    expect(integerPartition(8)).toBe(22);
  })",steel
/src/algorithms/math/integer-partition/__test__/integerPartition.test.js,Magic Number,"{'line': 12, 'column': 37, 'index': 460}","it('should partition the number', () => {
    expect(integerPartition(1)).toBe(1);
    expect(integerPartition(2)).toBe(2);
    expect(integerPartition(3)).toBe(3);
    expect(integerPartition(4)).toBe(5);
    expect(integerPartition(5)).toBe(7);
    expect(integerPartition(6)).toBe(11);
    expect(integerPartition(7)).toBe(15);
    expect(integerPartition(8)).toBe(22);
  })",steel
/src/algorithms/math/horner-method/__test__/hornerMethod.test.js,Magic Number,"{'line': 6, 'column': 40, 'index': 254}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(hornerMethod([8], 0.1)).toBe(8);
    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(hornerMethod([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.136730065140625);
    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/hornerMethod.test.js,Magic Number,"{'line': 7, 'column': 51, 'index': 309}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(hornerMethod([8], 0.1)).toBe(8);
    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(hornerMethod([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.136730065140625);
    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/hornerMethod.test.js,Magic Number,"{'line': 8, 'column': 50, 'index': 372}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(hornerMethod([8], 0.1)).toBe(8);
    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(hornerMethod([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.136730065140625);
    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/hornerMethod.test.js,Magic Number,"{'line': 9, 'column': 53, 'index': 435}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(hornerMethod([8], 0.1)).toBe(8);
    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(hornerMethod([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.136730065140625);
    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/hornerMethod.test.js,Magic Number,"{'line': 10, 'column': 66, 'index': 515}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(hornerMethod([8], 0.1)).toBe(8);
    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(hornerMethod([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.136730065140625);
    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/hornerMethod.test.js,Magic Number,"{'line': 11, 'column': 62, 'index': 597}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(hornerMethod([8], 0.1)).toBe(8);
    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(hornerMethod([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.136730065140625);
    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/hornerMethod.test.js,Magic Number,"{'line': 12, 'column': 64, 'index': 681}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(hornerMethod([8], 0.1)).toBe(8);
    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(hornerMethod([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.136730065140625);
    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/hornerMethod.test.js,Magic Number,"{'line': 13, 'column': 73, 'index': 774}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(hornerMethod([8], 0.1)).toBe(8);
    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(hornerMethod([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.136730065140625);
    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/classicPolynome.test.js,Magic Number,"{'line': 5, 'column': 43, 'index': 216}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(classicPolynome([8], 0.1)).toBe(8);
    expect(classicPolynome([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(classicPolynome([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(classicPolynome([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.1367300651406251);
    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/classicPolynome.test.js,Magic Number,"{'line': 6, 'column': 54, 'index': 274}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(classicPolynome([8], 0.1)).toBe(8);
    expect(classicPolynome([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(classicPolynome([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(classicPolynome([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.1367300651406251);
    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/classicPolynome.test.js,Magic Number,"{'line': 7, 'column': 53, 'index': 340}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(classicPolynome([8], 0.1)).toBe(8);
    expect(classicPolynome([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(classicPolynome([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(classicPolynome([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.1367300651406251);
    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/classicPolynome.test.js,Magic Number,"{'line': 8, 'column': 56, 'index': 406}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(classicPolynome([8], 0.1)).toBe(8);
    expect(classicPolynome([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(classicPolynome([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(classicPolynome([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.1367300651406251);
    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/classicPolynome.test.js,Magic Number,"{'line': 9, 'column': 69, 'index': 489}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(classicPolynome([8], 0.1)).toBe(8);
    expect(classicPolynome([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(classicPolynome([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(classicPolynome([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.1367300651406251);
    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/classicPolynome.test.js,Magic Number,"{'line': 10, 'column': 65, 'index': 575}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(classicPolynome([8], 0.1)).toBe(8);
    expect(classicPolynome([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(classicPolynome([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(classicPolynome([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.1367300651406251);
    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/classicPolynome.test.js,Magic Number,"{'line': 11, 'column': 67, 'index': 662}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(classicPolynome([8], 0.1)).toBe(8);
    expect(classicPolynome([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(classicPolynome([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(classicPolynome([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.1367300651406251);
    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/horner-method/__test__/classicPolynome.test.js,Magic Number,"{'line': 12, 'column': 76, 'index': 758}","it('should evaluate the polynomial for the specified value of x correctly', () => {
    expect(classicPolynome([8], 0.1)).toBe(8);
    expect(classicPolynome([2, 4, 2, 5], 0.555)).toBe(7.68400775);
    expect(classicPolynome([2, 4, 2, 5], 0.75)).toBe(9.59375);
    expect(classicPolynome([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.1367300651406251);
    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
  })",steel
/src/algorithms/math/fourier-transform/__test__/inverseDiscreteFourierTransform.test.js,Unknown Test,"{'column': 2, 'line': 5}","it('should calculate output signal out of input frequencies', () => {
    FourierTester.testInverseFourierTransform(inverseDiscreteFourierTransform);
  })",steel
/src/algorithms/math/fourier-transform/__test__/fastFourierTransform.test.js,Conditional Test Logic,"{'line': 11, 'column': 2, 'index': 325}",Unknown,steel
/src/algorithms/math/fourier-transform/__test__/fastFourierTransform.test.js,Conditional Test Logic,"{'line': 15, 'column': 2, 'index': 395}",Unknown,steel
/src/algorithms/math/fourier-transform/__test__/fastFourierTransform.test.js,Conditional Test Logic,"{'line': 16, 'column': 4, 'index': 477}",Unknown,steel
/src/algorithms/math/fourier-transform/__test__/fastFourierTransform.test.js,Conditional Test Logic,"{'line': 20, 'column': 4, 'index': 587}",Unknown,steel
/src/algorithms/math/fourier-transform/__test__/discreteFourierTransform.test.js,Unknown Test,"{'column': 2, 'line': 5}","it('should split signal into frequencies', () => {
    FourierTester.testDirectFourierTransform(discreteFourierTransform);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 13, 'column': 43, 'index': 472}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 14, 'column': 43, 'index': 519}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 15, 'column': 43, 'index': 566}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 16, 'column': 43, 'index': 613}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 17, 'column': 43, 'index': 660}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 18, 'column': 43, 'index': 707}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 19, 'column': 43, 'index': 754}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 20, 'column': 43, 'index': 802}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 21, 'column': 44, 'index': 851}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 22, 'column': 44, 'index': 902}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 23, 'column': 44, 'index': 955}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js,Magic Number,"{'line': 24, 'column': 44, 'index': 1013}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNthClosedForm(1)).toBe(1);
    expect(fibonacciNthClosedForm(2)).toBe(1);
    expect(fibonacciNthClosedForm(3)).toBe(2);
    expect(fibonacciNthClosedForm(4)).toBe(3);
    expect(fibonacciNthClosedForm(5)).toBe(5);
    expect(fibonacciNthClosedForm(6)).toBe(8);
    expect(fibonacciNthClosedForm(7)).toBe(13);
    expect(fibonacciNthClosedForm(8)).toBe(21);
    expect(fibonacciNthClosedForm(20)).toBe(6765);
    expect(fibonacciNthClosedForm(30)).toBe(832040);
    expect(fibonacciNthClosedForm(50)).toBe(12586269025);
    expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 5, 'column': 33, 'index': 164}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 6, 'column': 33, 'index': 201}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 7, 'column': 33, 'index': 238}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 8, 'column': 33, 'index': 275}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 9, 'column': 33, 'index': 312}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 10, 'column': 33, 'index': 349}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 11, 'column': 33, 'index': 386}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 12, 'column': 33, 'index': 424}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 13, 'column': 34, 'index': 463}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 14, 'column': 34, 'index': 504}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 15, 'column': 34, 'index': 547}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 16, 'column': 34, 'index': 595}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 17, 'column': 34, 'index': 647}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 18, 'column': 34, 'index': 699}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 19, 'column': 34, 'index': 751}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 20, 'column': 34, 'index': 803}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js,Magic Number,"{'line': 21, 'column': 34, 'index': 856}","it('should calculate fibonacci correctly', () => {
    expect(fibonacciNth(1)).toBe(1);
    expect(fibonacciNth(2)).toBe(1);
    expect(fibonacciNth(3)).toBe(2);
    expect(fibonacciNth(4)).toBe(3);
    expect(fibonacciNth(5)).toBe(5);
    expect(fibonacciNth(6)).toBe(8);
    expect(fibonacciNth(7)).toBe(13);
    expect(fibonacciNth(8)).toBe(21);
    expect(fibonacciNth(20)).toBe(6765);
    expect(fibonacciNth(30)).toBe(832040);
    expect(fibonacciNth(50)).toBe(12586269025);
    expect(fibonacciNth(70)).toBe(190392490709135);
    expect(fibonacciNth(71)).toBe(308061521170129);
    expect(fibonacciNth(72)).toBe(498454011879264);
    expect(fibonacciNth(73)).toBe(806515533049393);
    expect(fibonacciNth(74)).toBe(1304969544928657);
    expect(fibonacciNth(75)).toBe(2111485077978050);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 5, 'column': 36, 'index': 166}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 6, 'column': 36, 'index': 206}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 7, 'column': 36, 'index': 246}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 8, 'column': 36, 'index': 286}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 9, 'column': 36, 'index': 326}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 10, 'column': 36, 'index': 367}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 11, 'column': 36, 'index': 408}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 12, 'column': 36, 'index': 449}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 13, 'column': 36, 'index': 491}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 14, 'column': 36, 'index': 533}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 15, 'column': 38, 'index': 576}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 16, 'column': 37, 'index': 621}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 17, 'column': 38, 'index': 668}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 18, 'column': 37, 'index': 721}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 19, 'column': 38, 'index': 778}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 20, 'column': 37, 'index': 838}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/fast-powering/__test__/fastPowering.test.js,Magic Number,"{'line': 21, 'column': 38, 'index': 897}","it('should compute power in log(n) time', () => {
    expect(fastPowering(1, 1)).toBe(1);
    expect(fastPowering(2, 0)).toBe(1);
    expect(fastPowering(2, 2)).toBe(4);
    expect(fastPowering(2, 3)).toBe(8);
    expect(fastPowering(2, 4)).toBe(16);
    expect(fastPowering(2, 5)).toBe(32);
    expect(fastPowering(2, 6)).toBe(64);
    expect(fastPowering(2, 7)).toBe(128);
    expect(fastPowering(2, 8)).toBe(256);
    expect(fastPowering(3, 4)).toBe(81);
    expect(fastPowering(190, 2)).toBe(36100);
    expect(fastPowering(11, 5)).toBe(161051);
    expect(fastPowering(13, 11)).toBe(1792160394037);
    expect(fastPowering(9, 16)).toBe(1853020188851841);
    expect(fastPowering(16, 16)).toBe(18446744073709552000);
    expect(fastPowering(7, 21)).toBe(558545864083284000);
    expect(fastPowering(100, 9)).toBe(1000000000000000000);
  })",steel
/src/algorithms/math/factorial/__test__/factorialRecursive.test.js,Magic Number,"{'line': 5, 'column': 39, 'index': 178}","it('should calculate factorial', () => {
    expect(factorialRecursive(0)).toBe(1);
    expect(factorialRecursive(1)).toBe(1);
    expect(factorialRecursive(5)).toBe(120);
    expect(factorialRecursive(8)).toBe(40320);
    expect(factorialRecursive(10)).toBe(3628800);
  })",steel
/src/algorithms/math/factorial/__test__/factorialRecursive.test.js,Magic Number,"{'line': 6, 'column': 39, 'index': 221}","it('should calculate factorial', () => {
    expect(factorialRecursive(0)).toBe(1);
    expect(factorialRecursive(1)).toBe(1);
    expect(factorialRecursive(5)).toBe(120);
    expect(factorialRecursive(8)).toBe(40320);
    expect(factorialRecursive(10)).toBe(3628800);
  })",steel
/src/algorithms/math/factorial/__test__/factorialRecursive.test.js,Magic Number,"{'line': 7, 'column': 39, 'index': 264}","it('should calculate factorial', () => {
    expect(factorialRecursive(0)).toBe(1);
    expect(factorialRecursive(1)).toBe(1);
    expect(factorialRecursive(5)).toBe(120);
    expect(factorialRecursive(8)).toBe(40320);
    expect(factorialRecursive(10)).toBe(3628800);
  })",steel
/src/algorithms/math/factorial/__test__/factorialRecursive.test.js,Magic Number,"{'line': 8, 'column': 39, 'index': 309}","it('should calculate factorial', () => {
    expect(factorialRecursive(0)).toBe(1);
    expect(factorialRecursive(1)).toBe(1);
    expect(factorialRecursive(5)).toBe(120);
    expect(factorialRecursive(8)).toBe(40320);
    expect(factorialRecursive(10)).toBe(3628800);
  })",steel
/src/algorithms/math/factorial/__test__/factorialRecursive.test.js,Magic Number,"{'line': 9, 'column': 40, 'index': 357}","it('should calculate factorial', () => {
    expect(factorialRecursive(0)).toBe(1);
    expect(factorialRecursive(1)).toBe(1);
    expect(factorialRecursive(5)).toBe(120);
    expect(factorialRecursive(8)).toBe(40320);
    expect(factorialRecursive(10)).toBe(3628800);
  })",steel
/src/algorithms/math/factorial/__test__/factorial.test.js,Magic Number,"{'line': 5, 'column': 30, 'index': 142}","it('should calculate factorial', () => {
    expect(factorial(0)).toBe(1);
    expect(factorial(1)).toBe(1);
    expect(factorial(5)).toBe(120);
    expect(factorial(8)).toBe(40320);
    expect(factorial(10)).toBe(3628800);
  })",steel
/src/algorithms/math/factorial/__test__/factorial.test.js,Magic Number,"{'line': 6, 'column': 30, 'index': 176}","it('should calculate factorial', () => {
    expect(factorial(0)).toBe(1);
    expect(factorial(1)).toBe(1);
    expect(factorial(5)).toBe(120);
    expect(factorial(8)).toBe(40320);
    expect(factorial(10)).toBe(3628800);
  })",steel
/src/algorithms/math/factorial/__test__/factorial.test.js,Magic Number,"{'line': 7, 'column': 30, 'index': 210}","it('should calculate factorial', () => {
    expect(factorial(0)).toBe(1);
    expect(factorial(1)).toBe(1);
    expect(factorial(5)).toBe(120);
    expect(factorial(8)).toBe(40320);
    expect(factorial(10)).toBe(3628800);
  })",steel
/src/algorithms/math/factorial/__test__/factorial.test.js,Magic Number,"{'line': 8, 'column': 30, 'index': 246}","it('should calculate factorial', () => {
    expect(factorial(0)).toBe(1);
    expect(factorial(1)).toBe(1);
    expect(factorial(5)).toBe(120);
    expect(factorial(8)).toBe(40320);
    expect(factorial(10)).toBe(3628800);
  })",steel
/src/algorithms/math/factorial/__test__/factorial.test.js,Magic Number,"{'line': 9, 'column': 31, 'index': 285}","it('should calculate factorial', () => {
    expect(factorial(0)).toBe(1);
    expect(factorial(1)).toBe(1);
    expect(factorial(5)).toBe(120);
    expect(factorial(8)).toBe(40320);
    expect(factorial(10)).toBe(3628800);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 5, 'column': 51, 'index': 223}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 6, 'column': 51, 'index': 278}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 7, 'column': 51, 'index': 333}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 8, 'column': 51, 'index': 388}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 9, 'column': 51, 'index': 443}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 10, 'column': 51, 'index': 498}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 11, 'column': 51, 'index': 553}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 12, 'column': 51, 'index': 608}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 13, 'column': 52, 'index': 664}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 14, 'column': 52, 'index': 720}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 15, 'column': 52, 'index': 776}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 16, 'column': 53, 'index': 833}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 17, 'column': 53, 'index': 890}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 18, 'column': 53, 'index': 948}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 19, 'column': 55, 'index': 1008}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 20, 'column': 55, 'index': 1068}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 21, 'column': 56, 'index': 1129}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 22, 'column': 56, 'index': 1190}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 23, 'column': 57, 'index': 1252}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js,Magic Number,"{'line': 24, 'column': 58, 'index': 1315}","it('should calculate GCD iteratively', () => {
    expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
    expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
    expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(1, 2)).toBe(1);
    expect(euclideanAlgorithmIterative(2, 1)).toBe(1);
    expect(euclideanAlgorithmIterative(6, 6)).toBe(6);
    expect(euclideanAlgorithmIterative(2, 4)).toBe(2);
    expect(euclideanAlgorithmIterative(4, 2)).toBe(2);
    expect(euclideanAlgorithmIterative(12, 4)).toBe(4);
    expect(euclideanAlgorithmIterative(4, 12)).toBe(4);
    expect(euclideanAlgorithmIterative(5, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(27, 13)).toBe(1);
    expect(euclideanAlgorithmIterative(24, 60)).toBe(12);
    expect(euclideanAlgorithmIterative(60, 24)).toBe(12);
    expect(euclideanAlgorithmIterative(252, 105)).toBe(21);
    expect(euclideanAlgorithmIterative(105, 252)).toBe(21);
    expect(euclideanAlgorithmIterative(1071, 462)).toBe(21);
    expect(euclideanAlgorithmIterative(462, 1071)).toBe(21);
    expect(euclideanAlgorithmIterative(462, -1071)).toBe(21);
    expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 5, 'column': 42, 'index': 187}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 6, 'column': 42, 'index': 233}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 7, 'column': 42, 'index': 279}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 8, 'column': 42, 'index': 325}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 9, 'column': 42, 'index': 371}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 10, 'column': 42, 'index': 417}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 11, 'column': 42, 'index': 463}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 12, 'column': 42, 'index': 509}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 13, 'column': 43, 'index': 556}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 14, 'column': 43, 'index': 603}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 15, 'column': 43, 'index': 650}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 16, 'column': 44, 'index': 698}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 17, 'column': 44, 'index': 746}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 18, 'column': 44, 'index': 795}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 19, 'column': 46, 'index': 846}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 20, 'column': 46, 'index': 897}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 21, 'column': 47, 'index': 949}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 22, 'column': 47, 'index': 1001}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 23, 'column': 48, 'index': 1054}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js,Magic Number,"{'line': 24, 'column': 49, 'index': 1108}","it('should calculate GCD recursively', () => {
    expect(euclideanAlgorithm(0, 0)).toBe(0);
    expect(euclideanAlgorithm(2, 0)).toBe(2);
    expect(euclideanAlgorithm(0, 2)).toBe(2);
    expect(euclideanAlgorithm(1, 2)).toBe(1);
    expect(euclideanAlgorithm(2, 1)).toBe(1);
    expect(euclideanAlgorithm(6, 6)).toBe(6);
    expect(euclideanAlgorithm(2, 4)).toBe(2);
    expect(euclideanAlgorithm(4, 2)).toBe(2);
    expect(euclideanAlgorithm(12, 4)).toBe(4);
    expect(euclideanAlgorithm(4, 12)).toBe(4);
    expect(euclideanAlgorithm(5, 13)).toBe(1);
    expect(euclideanAlgorithm(27, 13)).toBe(1);
    expect(euclideanAlgorithm(24, 60)).toBe(12);
    expect(euclideanAlgorithm(60, 24)).toBe(12);
    expect(euclideanAlgorithm(252, 105)).toBe(21);
    expect(euclideanAlgorithm(105, 252)).toBe(21);
    expect(euclideanAlgorithm(1071, 462)).toBe(21);
    expect(euclideanAlgorithm(462, 1071)).toBe(21);
    expect(euclideanAlgorithm(462, -1071)).toBe(21);
    expect(euclideanAlgorithm(-462, -1071)).toBe(21);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 8, 'column': 34, 'index': 266}","it('should create complex numbers', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 2 });

    expect(complexNumber).toBeDefined();
    expect(complexNumber.re).toBe(1);
    expect(complexNumber.im).toBe(2);

    const defaultComplexNumber = new ComplexNumber();
    expect(defaultComplexNumber.re).toBe(0);
    expect(defaultComplexNumber.im).toBe(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 9, 'column': 34, 'index': 304}","it('should create complex numbers', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 2 });

    expect(complexNumber).toBeDefined();
    expect(complexNumber.re).toBe(1);
    expect(complexNumber.im).toBe(2);

    const defaultComplexNumber = new ComplexNumber();
    expect(defaultComplexNumber.re).toBe(0);
    expect(defaultComplexNumber.im).toBe(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 12, 'column': 41, 'index': 404}","it('should create complex numbers', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 2 });

    expect(complexNumber).toBeDefined();
    expect(complexNumber.re).toBe(1);
    expect(complexNumber.im).toBe(2);

    const defaultComplexNumber = new ComplexNumber();
    expect(defaultComplexNumber.re).toBe(0);
    expect(defaultComplexNumber.im).toBe(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 13, 'column': 41, 'index': 449}","it('should create complex numbers', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 2 });

    expect(complexNumber).toBeDefined();
    expect(complexNumber.re).toBe(1);
    expect(complexNumber.im).toBe(2);

    const defaultComplexNumber = new ComplexNumber();
    expect(defaultComplexNumber.re).toBe(0);
    expect(defaultComplexNumber.im).toBe(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 39, 'column': 35, 'index': 1355}","it('should add complex and natural numbers', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 2 });
    const realNumber = new ComplexNumber({ re: 3 });

    const complexNumber3 = complexNumber.add(realNumber);
    const complexNumber4 = realNumber.add(complexNumber);
    const complexNumber5 = complexNumber.add(3);

    expect(complexNumber3.re).toBe(1 + 3);
    expect(complexNumber3.im).toBe(2);

    expect(complexNumber4.re).toBe(1 + 3);
    expect(complexNumber4.im).toBe(2);

    expect(complexNumber5.re).toBe(1 + 3);
    expect(complexNumber5.im).toBe(2);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 42, 'column': 35, 'index': 1438}","it('should add complex and natural numbers', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 2 });
    const realNumber = new ComplexNumber({ re: 3 });

    const complexNumber3 = complexNumber.add(realNumber);
    const complexNumber4 = realNumber.add(complexNumber);
    const complexNumber5 = complexNumber.add(3);

    expect(complexNumber3.re).toBe(1 + 3);
    expect(complexNumber3.im).toBe(2);

    expect(complexNumber4.re).toBe(1 + 3);
    expect(complexNumber4.im).toBe(2);

    expect(complexNumber5.re).toBe(1 + 3);
    expect(complexNumber5.im).toBe(2);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 45, 'column': 35, 'index': 1521}","it('should add complex and natural numbers', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 2 });
    const realNumber = new ComplexNumber({ re: 3 });

    const complexNumber3 = complexNumber.add(realNumber);
    const complexNumber4 = realNumber.add(complexNumber);
    const complexNumber5 = complexNumber.add(3);

    expect(complexNumber3.re).toBe(1 + 3);
    expect(complexNumber3.im).toBe(2);

    expect(complexNumber4.re).toBe(1 + 3);
    expect(complexNumber4.im).toBe(2);

    expect(complexNumber5.re).toBe(1 + 3);
    expect(complexNumber5.im).toBe(2);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 71, 'column': 35, 'index': 2462}","it('should subtract complex and natural numbers', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 2 });
    const realNumber = new ComplexNumber({ re: 3 });

    const complexNumber3 = complexNumber.subtract(realNumber);
    const complexNumber4 = realNumber.subtract(complexNumber);
    const complexNumber5 = complexNumber.subtract(3);

    expect(complexNumber3.re).toBe(1 - 3);
    expect(complexNumber3.im).toBe(2);

    expect(complexNumber4.re).toBe(3 - 1);
    expect(complexNumber4.im).toBe(-2);

    expect(complexNumber5.re).toBe(1 - 3);
    expect(complexNumber5.im).toBe(2);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 77, 'column': 35, 'index': 2629}","it('should subtract complex and natural numbers', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 2 });
    const realNumber = new ComplexNumber({ re: 3 });

    const complexNumber3 = complexNumber.subtract(realNumber);
    const complexNumber4 = realNumber.subtract(complexNumber);
    const complexNumber5 = complexNumber.subtract(3);

    expect(complexNumber3.re).toBe(1 - 3);
    expect(complexNumber3.im).toBe(2);

    expect(complexNumber4.re).toBe(3 - 1);
    expect(complexNumber4.im).toBe(-2);

    expect(complexNumber5.re).toBe(1 - 3);
    expect(complexNumber5.im).toBe(2);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 89, 'column': 35, 'index': 3085}","it('should multiply complex numbers', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 2 });
    const complexNumber2 = new ComplexNumber({ re: 1, im: 7 });

    const complexNumber3 = complexNumber1.multiply(complexNumber2);
    const complexNumber4 = complexNumber2.multiply(complexNumber1);
    const complexNumber5 = complexNumber1.multiply(5);

    expect(complexNumber3.re).toBe(-11);
    expect(complexNumber3.im).toBe(23);

    expect(complexNumber4.re).toBe(-11);
    expect(complexNumber4.im).toBe(23);

    expect(complexNumber5.re).toBe(15);
    expect(complexNumber5.im).toBe(10);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 92, 'column': 35, 'index': 3167}","it('should multiply complex numbers', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 2 });
    const complexNumber2 = new ComplexNumber({ re: 1, im: 7 });

    const complexNumber3 = complexNumber1.multiply(complexNumber2);
    const complexNumber4 = complexNumber2.multiply(complexNumber1);
    const complexNumber5 = complexNumber1.multiply(5);

    expect(complexNumber3.re).toBe(-11);
    expect(complexNumber3.im).toBe(23);

    expect(complexNumber4.re).toBe(-11);
    expect(complexNumber4.im).toBe(23);

    expect(complexNumber5.re).toBe(15);
    expect(complexNumber5.im).toBe(10);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 94, 'column': 35, 'index': 3208}","it('should multiply complex numbers', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 2 });
    const complexNumber2 = new ComplexNumber({ re: 1, im: 7 });

    const complexNumber3 = complexNumber1.multiply(complexNumber2);
    const complexNumber4 = complexNumber2.multiply(complexNumber1);
    const complexNumber5 = complexNumber1.multiply(5);

    expect(complexNumber3.re).toBe(-11);
    expect(complexNumber3.im).toBe(23);

    expect(complexNumber4.re).toBe(-11);
    expect(complexNumber4.im).toBe(23);

    expect(complexNumber5.re).toBe(15);
    expect(complexNumber5.im).toBe(10);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 95, 'column': 35, 'index': 3248}","it('should multiply complex numbers', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 2 });
    const complexNumber2 = new ComplexNumber({ re: 1, im: 7 });

    const complexNumber3 = complexNumber1.multiply(complexNumber2);
    const complexNumber4 = complexNumber2.multiply(complexNumber1);
    const complexNumber5 = complexNumber1.multiply(5);

    expect(complexNumber3.re).toBe(-11);
    expect(complexNumber3.im).toBe(23);

    expect(complexNumber4.re).toBe(-11);
    expect(complexNumber4.im).toBe(23);

    expect(complexNumber5.re).toBe(15);
    expect(complexNumber5.im).toBe(10);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 103, 'column': 27, 'index': 3472}","it('should multiply complex numbers by themselves', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 1 });

    const result = complexNumber.multiply(complexNumber);

    expect(result.re).toBe(0);
    expect(result.im).toBe(2);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 104, 'column': 27, 'index': 3503}","it('should multiply complex numbers by themselves', () => {
    const complexNumber = new ComplexNumber({ re: 1, im: 1 });

    const result = complexNumber.multiply(complexNumber);

    expect(result.re).toBe(0);
    expect(result.im).toBe(2);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 113, 'column': 27, 'index': 3747}","it('should calculate i in power of two', () => {
    const complexNumber = new ComplexNumber({ re: 0, im: 1 });

    const result = complexNumber.multiply(complexNumber);

    expect(result.re).toBe(-1);
    expect(result.im).toBe(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 126, 'column': 35, 'index': 4180}","it('should divide complex numbers', () => {
    const complexNumber1 = new ComplexNumber({ re: 2, im: 3 });
    const complexNumber2 = new ComplexNumber({ re: 4, im: -5 });

    const complexNumber3 = complexNumber1.divide(complexNumber2);
    const complexNumber4 = complexNumber1.divide(2);

    expect(complexNumber3.re).toBe(-7 / 41);
    expect(complexNumber3.im).toBe(22 / 41);

    expect(complexNumber4.re).toBe(1);
    expect(complexNumber4.im).toBe(1.5);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 127, 'column': 35, 'index': 4219}","it('should divide complex numbers', () => {
    const complexNumber1 = new ComplexNumber({ re: 2, im: 3 });
    const complexNumber2 = new ComplexNumber({ re: 4, im: -5 });

    const complexNumber3 = complexNumber1.divide(complexNumber2);
    const complexNumber4 = complexNumber1.divide(2);

    expect(complexNumber3.re).toBe(-7 / 41);
    expect(complexNumber3.im).toBe(22 / 41);

    expect(complexNumber4.re).toBe(1);
    expect(complexNumber4.im).toBe(1.5);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 134, 'column': 58, 'index': 4567}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 139, 'column': 58, 'index': 4856}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 152, 'column': 61, 'index': 5572}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 153, 'column': 60, 'index': 5639}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 154, 'column': 65, 'index': 5711}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 157, 'column': 61, 'index': 5848}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 158, 'column': 60, 'index': 5915}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 159, 'column': 65, 'index': 5987}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 162, 'column': 61, 'index': 6122}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 167, 'column': 61, 'index': 6378}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 168, 'column': 60, 'index': 6442}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 169, 'column': 65, 'index': 6511}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 172, 'column': 61, 'index': 6645}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 174, 'column': 65, 'index': 6787}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 177, 'column': 62, 'index': 6924}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 178, 'column': 61, 'index': 6992}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js,Magic Number,"{'line': 179, 'column': 66, 'index': 7062}","it('should return complex number in polar form', () => {
    const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
    expect(complexNumber1.getPolarForm(false).phase).toBe(45);

    const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
    expect(complexNumber2.getPolarForm(false).phase).toBe(135);

    const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
    expect(complexNumber3.getPolarForm(false).phase).toBe(-135);

    const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
    expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
    expect(complexNumber4.getPolarForm(false).phase).toBe(-45);

    const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
    expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
    expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);

    const complexNumber6 = new ComplexNumber({ re: 0, im: 0.25 });
    expect(complexNumber6.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber6.getPolarForm().phase).toBeCloseTo(1.57);
    expect(complexNumber6.getPolarForm(false).phase).toBeCloseTo(90);

    const complexNumber7 = new ComplexNumber({ re: 0, im: -0.25 });
    expect(complexNumber7.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber7.getPolarForm().phase).toBeCloseTo(-1.57);
    expect(complexNumber7.getPolarForm(false).phase).toBeCloseTo(-90);

    const complexNumber8 = new ComplexNumber();
    expect(complexNumber8.getPolarForm().radius).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber8.getPolarForm(false).phase).toBeCloseTo(0);

    const complexNumber9 = new ComplexNumber({ re: -0.25, im: 0 });
    expect(complexNumber9.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber9.getPolarForm().phase).toBeCloseTo(Math.PI);
    expect(complexNumber9.getPolarForm(false).phase).toBeCloseTo(180);

    const complexNumber10 = new ComplexNumber({ re: 0.25, im: 0 });
    expect(complexNumber10.getPolarForm().radius).toBeCloseTo(0.25);
    expect(complexNumber10.getPolarForm().phase).toBeCloseTo(0);
    expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 6, 'column': 36, 'index': 178}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 7, 'column': 36, 'index': 218}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 8, 'column': 36, 'index': 258}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 9, 'column': 36, 'index': 298}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 12, 'column': 37, 'index': 359}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 13, 'column': 37, 'index': 401}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 14, 'column': 37, 'index': 443}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 15, 'column': 37, 'index': 485}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 16, 'column': 37, 'index': 526}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/updateBit.test.js,Magic Number,"{'line': 17, 'column': 37, 'index': 568}","it('should update bit at specific position', () => {
    // 1 = 0b0001
    expect(updateBit(1, 0, 1)).toBe(1);
    expect(updateBit(1, 0, 0)).toBe(0);
    expect(updateBit(1, 1, 1)).toBe(3);
    expect(updateBit(1, 2, 1)).toBe(5);

    // 10 = 0b1010
    expect(updateBit(10, 0, 1)).toBe(11);
    expect(updateBit(10, 0, 0)).toBe(10);
    expect(updateBit(10, 1, 1)).toBe(10);
    expect(updateBit(10, 1, 0)).toBe(8);
    expect(updateBit(10, 2, 1)).toBe(14);
    expect(updateBit(10, 2, 0)).toBe(10);
  })",steel
/src/algorithms/math/bits/__test__/switchSign.test.js,Magic Number,"{'line': 5, 'column': 31, 'index': 187}","it('should switch the sign of the number using twos complement approach', () => {
    expect(switchSign(0)).toBe(0);
    expect(switchSign(1)).toBe(-1);
    expect(switchSign(-1)).toBe(1);
    expect(switchSign(32)).toBe(-32);
    expect(switchSign(-32)).toBe(32);
    expect(switchSign(23)).toBe(-23);
    expect(switchSign(-23)).toBe(23);
  })",steel
/src/algorithms/math/bits/__test__/switchSign.test.js,Magic Number,"{'line': 7, 'column': 32, 'index': 259}","it('should switch the sign of the number using twos complement approach', () => {
    expect(switchSign(0)).toBe(0);
    expect(switchSign(1)).toBe(-1);
    expect(switchSign(-1)).toBe(1);
    expect(switchSign(32)).toBe(-32);
    expect(switchSign(-32)).toBe(32);
    expect(switchSign(23)).toBe(-23);
    expect(switchSign(-23)).toBe(23);
  })",steel
/src/algorithms/math/bits/__test__/switchSign.test.js,Magic Number,"{'line': 9, 'column': 33, 'index': 334}","it('should switch the sign of the number using twos complement approach', () => {
    expect(switchSign(0)).toBe(0);
    expect(switchSign(1)).toBe(-1);
    expect(switchSign(-1)).toBe(1);
    expect(switchSign(32)).toBe(-32);
    expect(switchSign(-32)).toBe(32);
    expect(switchSign(23)).toBe(-23);
    expect(switchSign(-23)).toBe(23);
  })",steel
/src/algorithms/math/bits/__test__/switchSign.test.js,Magic Number,"{'line': 11, 'column': 33, 'index': 410}","it('should switch the sign of the number using twos complement approach', () => {
    expect(switchSign(0)).toBe(0);
    expect(switchSign(1)).toBe(-1);
    expect(switchSign(-1)).toBe(1);
    expect(switchSign(32)).toBe(-32);
    expect(switchSign(-32)).toBe(32);
    expect(switchSign(23)).toBe(-23);
    expect(switchSign(-23)).toBe(23);
  })",steel
/src/algorithms/math/bits/__test__/setBit.test.js,Magic Number,"{'line': 6, 'column': 30, 'index': 160}","it('should set bit at specific position', () => {
    // 1 = 0b0001
    expect(setBit(1, 0)).toBe(1);
    expect(setBit(1, 1)).toBe(3);
    expect(setBit(1, 2)).toBe(5);

    // 10 = 0b1010
    expect(setBit(10, 0)).toBe(11);
    expect(setBit(10, 1)).toBe(10);
    expect(setBit(10, 2)).toBe(14);
  })",steel
/src/algorithms/math/bits/__test__/setBit.test.js,Magic Number,"{'line': 7, 'column': 30, 'index': 194}","it('should set bit at specific position', () => {
    // 1 = 0b0001
    expect(setBit(1, 0)).toBe(1);
    expect(setBit(1, 1)).toBe(3);
    expect(setBit(1, 2)).toBe(5);

    // 10 = 0b1010
    expect(setBit(10, 0)).toBe(11);
    expect(setBit(10, 1)).toBe(10);
    expect(setBit(10, 2)).toBe(14);
  })",steel
/src/algorithms/math/bits/__test__/setBit.test.js,Magic Number,"{'line': 8, 'column': 30, 'index': 228}","it('should set bit at specific position', () => {
    // 1 = 0b0001
    expect(setBit(1, 0)).toBe(1);
    expect(setBit(1, 1)).toBe(3);
    expect(setBit(1, 2)).toBe(5);

    // 10 = 0b1010
    expect(setBit(10, 0)).toBe(11);
    expect(setBit(10, 1)).toBe(10);
    expect(setBit(10, 2)).toBe(14);
  })",steel
/src/algorithms/math/bits/__test__/setBit.test.js,Magic Number,"{'line': 11, 'column': 31, 'index': 283}","it('should set bit at specific position', () => {
    // 1 = 0b0001
    expect(setBit(1, 0)).toBe(1);
    expect(setBit(1, 1)).toBe(3);
    expect(setBit(1, 2)).toBe(5);

    // 10 = 0b1010
    expect(setBit(10, 0)).toBe(11);
    expect(setBit(10, 1)).toBe(10);
    expect(setBit(10, 2)).toBe(14);
  })",steel
/src/algorithms/math/bits/__test__/setBit.test.js,Magic Number,"{'line': 12, 'column': 31, 'index': 319}","it('should set bit at specific position', () => {
    // 1 = 0b0001
    expect(setBit(1, 0)).toBe(1);
    expect(setBit(1, 1)).toBe(3);
    expect(setBit(1, 2)).toBe(5);

    // 10 = 0b1010
    expect(setBit(10, 0)).toBe(11);
    expect(setBit(10, 1)).toBe(10);
    expect(setBit(10, 2)).toBe(14);
  })",steel
/src/algorithms/math/bits/__test__/setBit.test.js,Magic Number,"{'line': 13, 'column': 31, 'index': 355}","it('should set bit at specific position', () => {
    // 1 = 0b0001
    expect(setBit(1, 0)).toBe(1);
    expect(setBit(1, 1)).toBe(3);
    expect(setBit(1, 2)).toBe(5);

    // 10 = 0b1010
    expect(setBit(10, 0)).toBe(11);
    expect(setBit(10, 1)).toBe(10);
    expect(setBit(10, 2)).toBe(14);
  })",steel
/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js,Magic Number,"{'line': 5, 'column': 40, 'index': 183}","it('should multiply two unsigned numbers', () => {
    expect(multiplyUnsigned(0, 2)).toBe(0);
    expect(multiplyUnsigned(2, 0)).toBe(0);
    expect(multiplyUnsigned(1, 1)).toBe(1);
    expect(multiplyUnsigned(1, 2)).toBe(2);
    expect(multiplyUnsigned(2, 7)).toBe(14);
    expect(multiplyUnsigned(7, 2)).toBe(14);
    expect(multiplyUnsigned(30, 2)).toBe(60);
    expect(multiplyUnsigned(17, 34)).toBe(578);
    expect(multiplyUnsigned(170, 2340)).toBe(397800);
  })",steel
/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js,Magic Number,"{'line': 6, 'column': 40, 'index': 227}","it('should multiply two unsigned numbers', () => {
    expect(multiplyUnsigned(0, 2)).toBe(0);
    expect(multiplyUnsigned(2, 0)).toBe(0);
    expect(multiplyUnsigned(1, 1)).toBe(1);
    expect(multiplyUnsigned(1, 2)).toBe(2);
    expect(multiplyUnsigned(2, 7)).toBe(14);
    expect(multiplyUnsigned(7, 2)).toBe(14);
    expect(multiplyUnsigned(30, 2)).toBe(60);
    expect(multiplyUnsigned(17, 34)).toBe(578);
    expect(multiplyUnsigned(170, 2340)).toBe(397800);
  })",steel
/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js,Magic Number,"{'line': 7, 'column': 40, 'index': 271}","it('should multiply two unsigned numbers', () => {
    expect(multiplyUnsigned(0, 2)).toBe(0);
    expect(multiplyUnsigned(2, 0)).toBe(0);
    expect(multiplyUnsigned(1, 1)).toBe(1);
    expect(multiplyUnsigned(1, 2)).toBe(2);
    expect(multiplyUnsigned(2, 7)).toBe(14);
    expect(multiplyUnsigned(7, 2)).toBe(14);
    expect(multiplyUnsigned(30, 2)).toBe(60);
    expect(multiplyUnsigned(17, 34)).toBe(578);
    expect(multiplyUnsigned(170, 2340)).toBe(397800);
  })",steel
/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js,Magic Number,"{'line': 8, 'column': 40, 'index': 315}","it('should multiply two unsigned numbers', () => {
    expect(multiplyUnsigned(0, 2)).toBe(0);
    expect(multiplyUnsigned(2, 0)).toBe(0);
    expect(multiplyUnsigned(1, 1)).toBe(1);
    expect(multiplyUnsigned(1, 2)).toBe(2);
    expect(multiplyUnsigned(2, 7)).toBe(14);
    expect(multiplyUnsigned(7, 2)).toBe(14);
    expect(multiplyUnsigned(30, 2)).toBe(60);
    expect(multiplyUnsigned(17, 34)).toBe(578);
    expect(multiplyUnsigned(170, 2340)).toBe(397800);
  })",steel
/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js,Magic Number,"{'line': 9, 'column': 40, 'index': 359}","it('should multiply two unsigned numbers', () => {
    expect(multiplyUnsigned(0, 2)).toBe(0);
    expect(multiplyUnsigned(2, 0)).toBe(0);
    expect(multiplyUnsigned(1, 1)).toBe(1);
    expect(multiplyUnsigned(1, 2)).toBe(2);
    expect(multiplyUnsigned(2, 7)).toBe(14);
    expect(multiplyUnsigned(7, 2)).toBe(14);
    expect(multiplyUnsigned(30, 2)).toBe(60);
    expect(multiplyUnsigned(17, 34)).toBe(578);
    expect(multiplyUnsigned(170, 2340)).toBe(397800);
  })",steel
/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js,Magic Number,"{'line': 10, 'column': 40, 'index': 404}","it('should multiply two unsigned numbers', () => {
    expect(multiplyUnsigned(0, 2)).toBe(0);
    expect(multiplyUnsigned(2, 0)).toBe(0);
    expect(multiplyUnsigned(1, 1)).toBe(1);
    expect(multiplyUnsigned(1, 2)).toBe(2);
    expect(multiplyUnsigned(2, 7)).toBe(14);
    expect(multiplyUnsigned(7, 2)).toBe(14);
    expect(multiplyUnsigned(30, 2)).toBe(60);
    expect(multiplyUnsigned(17, 34)).toBe(578);
    expect(multiplyUnsigned(170, 2340)).toBe(397800);
  })",steel
/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js,Magic Number,"{'line': 11, 'column': 41, 'index': 450}","it('should multiply two unsigned numbers', () => {
    expect(multiplyUnsigned(0, 2)).toBe(0);
    expect(multiplyUnsigned(2, 0)).toBe(0);
    expect(multiplyUnsigned(1, 1)).toBe(1);
    expect(multiplyUnsigned(1, 2)).toBe(2);
    expect(multiplyUnsigned(2, 7)).toBe(14);
    expect(multiplyUnsigned(7, 2)).toBe(14);
    expect(multiplyUnsigned(30, 2)).toBe(60);
    expect(multiplyUnsigned(17, 34)).toBe(578);
    expect(multiplyUnsigned(170, 2340)).toBe(397800);
  })",steel
/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js,Magic Number,"{'line': 12, 'column': 42, 'index': 497}","it('should multiply two unsigned numbers', () => {
    expect(multiplyUnsigned(0, 2)).toBe(0);
    expect(multiplyUnsigned(2, 0)).toBe(0);
    expect(multiplyUnsigned(1, 1)).toBe(1);
    expect(multiplyUnsigned(1, 2)).toBe(2);
    expect(multiplyUnsigned(2, 7)).toBe(14);
    expect(multiplyUnsigned(7, 2)).toBe(14);
    expect(multiplyUnsigned(30, 2)).toBe(60);
    expect(multiplyUnsigned(17, 34)).toBe(578);
    expect(multiplyUnsigned(170, 2340)).toBe(397800);
  })",steel
/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js,Magic Number,"{'line': 13, 'column': 45, 'index': 548}","it('should multiply two unsigned numbers', () => {
    expect(multiplyUnsigned(0, 2)).toBe(0);
    expect(multiplyUnsigned(2, 0)).toBe(0);
    expect(multiplyUnsigned(1, 1)).toBe(1);
    expect(multiplyUnsigned(1, 2)).toBe(2);
    expect(multiplyUnsigned(2, 7)).toBe(14);
    expect(multiplyUnsigned(7, 2)).toBe(14);
    expect(multiplyUnsigned(30, 2)).toBe(60);
    expect(multiplyUnsigned(17, 34)).toBe(578);
    expect(multiplyUnsigned(170, 2340)).toBe(397800);
  })",steel
/src/algorithms/math/bits/__test__/multiplyByTwo.test.js,Magic Number,"{'line': 5, 'column': 34, 'index': 187}","it('should multiply numbers by two using bitwise operations', () => {
    expect(multiplyByTwo(0)).toBe(0);
    expect(multiplyByTwo(1)).toBe(2);
    expect(multiplyByTwo(3)).toBe(6);
    expect(multiplyByTwo(10)).toBe(20);
    expect(multiplyByTwo(17)).toBe(34);
    expect(multiplyByTwo(125)).toBe(250);
  })",steel
/src/algorithms/math/bits/__test__/multiplyByTwo.test.js,Magic Number,"{'line': 6, 'column': 34, 'index': 225}","it('should multiply numbers by two using bitwise operations', () => {
    expect(multiplyByTwo(0)).toBe(0);
    expect(multiplyByTwo(1)).toBe(2);
    expect(multiplyByTwo(3)).toBe(6);
    expect(multiplyByTwo(10)).toBe(20);
    expect(multiplyByTwo(17)).toBe(34);
    expect(multiplyByTwo(125)).toBe(250);
  })",steel
/src/algorithms/math/bits/__test__/multiplyByTwo.test.js,Magic Number,"{'line': 7, 'column': 34, 'index': 263}","it('should multiply numbers by two using bitwise operations', () => {
    expect(multiplyByTwo(0)).toBe(0);
    expect(multiplyByTwo(1)).toBe(2);
    expect(multiplyByTwo(3)).toBe(6);
    expect(multiplyByTwo(10)).toBe(20);
    expect(multiplyByTwo(17)).toBe(34);
    expect(multiplyByTwo(125)).toBe(250);
  })",steel
/src/algorithms/math/bits/__test__/multiplyByTwo.test.js,Magic Number,"{'line': 8, 'column': 35, 'index': 302}","it('should multiply numbers by two using bitwise operations', () => {
    expect(multiplyByTwo(0)).toBe(0);
    expect(multiplyByTwo(1)).toBe(2);
    expect(multiplyByTwo(3)).toBe(6);
    expect(multiplyByTwo(10)).toBe(20);
    expect(multiplyByTwo(17)).toBe(34);
    expect(multiplyByTwo(125)).toBe(250);
  })",steel
/src/algorithms/math/bits/__test__/multiplyByTwo.test.js,Magic Number,"{'line': 9, 'column': 35, 'index': 342}","it('should multiply numbers by two using bitwise operations', () => {
    expect(multiplyByTwo(0)).toBe(0);
    expect(multiplyByTwo(1)).toBe(2);
    expect(multiplyByTwo(3)).toBe(6);
    expect(multiplyByTwo(10)).toBe(20);
    expect(multiplyByTwo(17)).toBe(34);
    expect(multiplyByTwo(125)).toBe(250);
  })",steel
/src/algorithms/math/bits/__test__/multiplyByTwo.test.js,Magic Number,"{'line': 10, 'column': 36, 'index': 383}","it('should multiply numbers by two using bitwise operations', () => {
    expect(multiplyByTwo(0)).toBe(0);
    expect(multiplyByTwo(1)).toBe(2);
    expect(multiplyByTwo(3)).toBe(6);
    expect(multiplyByTwo(10)).toBe(20);
    expect(multiplyByTwo(17)).toBe(34);
    expect(multiplyByTwo(125)).toBe(250);
  })",steel
/src/algorithms/math/bits/__test__/multiply.test.js,Magic Number,"{'line': 5, 'column': 32, 'index': 142}","it('should multiply two numbers', () => {
    expect(multiply(0, 0)).toBe(0);
    expect(multiply(2, 0)).toBe(0);
    expect(multiply(0, 2)).toBe(0);
    expect(multiply(1, 2)).toBe(2);
    expect(multiply(2, 1)).toBe(2);
    expect(multiply(6, 6)).toBe(36);
    expect(multiply(-2, 4)).toBe(-8);
    expect(multiply(4, -2)).toBe(-8);
    expect(multiply(-4, -4)).toBe(16);
    expect(multiply(4, -5)).toBe(-20);
    expect(multiply(2, 121)).toBe(242);
    expect(multiply(121, 2)).toBe(242);
  })",steel
/src/algorithms/math/bits/__test__/multiply.test.js,Magic Number,"{'line': 6, 'column': 32, 'index': 178}","it('should multiply two numbers', () => {
    expect(multiply(0, 0)).toBe(0);
    expect(multiply(2, 0)).toBe(0);
    expect(multiply(0, 2)).toBe(0);
    expect(multiply(1, 2)).toBe(2);
    expect(multiply(2, 1)).toBe(2);
    expect(multiply(6, 6)).toBe(36);
    expect(multiply(-2, 4)).toBe(-8);
    expect(multiply(4, -2)).toBe(-8);
    expect(multiply(-4, -4)).toBe(16);
    expect(multiply(4, -5)).toBe(-20);
    expect(multiply(2, 121)).toBe(242);
    expect(multiply(121, 2)).toBe(242);
  })",steel
/src/algorithms/math/bits/__test__/multiply.test.js,Magic Number,"{'line': 7, 'column': 32, 'index': 214}","it('should multiply two numbers', () => {
    expect(multiply(0, 0)).toBe(0);
    expect(multiply(2, 0)).toBe(0);
    expect(multiply(0, 2)).toBe(0);
    expect(multiply(1, 2)).toBe(2);
    expect(multiply(2, 1)).toBe(2);
    expect(multiply(6, 6)).toBe(36);
    expect(multiply(-2, 4)).toBe(-8);
    expect(multiply(4, -2)).toBe(-8);
    expect(multiply(-4, -4)).toBe(16);
    expect(multiply(4, -5)).toBe(-20);
    expect(multiply(2, 121)).toBe(242);
    expect(multiply(121, 2)).toBe(242);
  })",steel
/src/algorithms/math/bits/__test__/multiply.test.js,Magic Number,"{'line': 8, 'column': 32, 'index': 250}","it('should multiply two numbers', () => {
    expect(multiply(0, 0)).toBe(0);
    expect(multiply(2, 0)).toBe(0);
    expect(multiply(0, 2)).toBe(0);
    expect(multiply(1, 2)).toBe(2);
    expect(multiply(2, 1)).toBe(2);
    expect(multiply(6, 6)).toBe(36);
    expect(multiply(-2, 4)).toBe(-8);
    expect(multiply(4, -2)).toBe(-8);
    expect(multiply(-4, -4)).toBe(16);
    expect(multiply(4, -5)).toBe(-20);
    expect(multiply(2, 121)).toBe(242);
    expect(multiply(121, 2)).toBe(242);
  })",steel
/src/algorithms/math/bits/__test__/multiply.test.js,Magic Number,"{'line': 9, 'column': 32, 'index': 286}","it('should multiply two numbers', () => {
    expect(multiply(0, 0)).toBe(0);
    expect(multiply(2, 0)).toBe(0);
    expect(multiply(0, 2)).toBe(0);
    expect(multiply(1, 2)).toBe(2);
    expect(multiply(2, 1)).toBe(2);
    expect(multiply(6, 6)).toBe(36);
    expect(multiply(-2, 4)).toBe(-8);
    expect(multiply(4, -2)).toBe(-8);
    expect(multiply(-4, -4)).toBe(16);
    expect(multiply(4, -5)).toBe(-20);
    expect(multiply(2, 121)).toBe(242);
    expect(multiply(121, 2)).toBe(242);
  })",steel
/src/algorithms/math/bits/__test__/multiply.test.js,Magic Number,"{'line': 10, 'column': 32, 'index': 322}","it('should multiply two numbers', () => {
    expect(multiply(0, 0)).toBe(0);
    expect(multiply(2, 0)).toBe(0);
    expect(multiply(0, 2)).toBe(0);
    expect(multiply(1, 2)).toBe(2);
    expect(multiply(2, 1)).toBe(2);
    expect(multiply(6, 6)).toBe(36);
    expect(multiply(-2, 4)).toBe(-8);
    expect(multiply(4, -2)).toBe(-8);
    expect(multiply(-4, -4)).toBe(16);
    expect(multiply(4, -5)).toBe(-20);
    expect(multiply(2, 121)).toBe(242);
    expect(multiply(121, 2)).toBe(242);
  })",steel
/src/algorithms/math/bits/__test__/multiply.test.js,Magic Number,"{'line': 13, 'column': 34, 'index': 437}","it('should multiply two numbers', () => {
    expect(multiply(0, 0)).toBe(0);
    expect(multiply(2, 0)).toBe(0);
    expect(multiply(0, 2)).toBe(0);
    expect(multiply(1, 2)).toBe(2);
    expect(multiply(2, 1)).toBe(2);
    expect(multiply(6, 6)).toBe(36);
    expect(multiply(-2, 4)).toBe(-8);
    expect(multiply(4, -2)).toBe(-8);
    expect(multiply(-4, -4)).toBe(16);
    expect(multiply(4, -5)).toBe(-20);
    expect(multiply(2, 121)).toBe(242);
    expect(multiply(121, 2)).toBe(242);
  })",steel
/src/algorithms/math/bits/__test__/multiply.test.js,Magic Number,"{'line': 15, 'column': 34, 'index': 515}","it('should multiply two numbers', () => {
    expect(multiply(0, 0)).toBe(0);
    expect(multiply(2, 0)).toBe(0);
    expect(multiply(0, 2)).toBe(0);
    expect(multiply(1, 2)).toBe(2);
    expect(multiply(2, 1)).toBe(2);
    expect(multiply(6, 6)).toBe(36);
    expect(multiply(-2, 4)).toBe(-8);
    expect(multiply(4, -2)).toBe(-8);
    expect(multiply(-4, -4)).toBe(16);
    expect(multiply(4, -5)).toBe(-20);
    expect(multiply(2, 121)).toBe(242);
    expect(multiply(121, 2)).toBe(242);
  })",steel
/src/algorithms/math/bits/__test__/multiply.test.js,Magic Number,"{'line': 16, 'column': 34, 'index': 555}","it('should multiply two numbers', () => {
    expect(multiply(0, 0)).toBe(0);
    expect(multiply(2, 0)).toBe(0);
    expect(multiply(0, 2)).toBe(0);
    expect(multiply(1, 2)).toBe(2);
    expect(multiply(2, 1)).toBe(2);
    expect(multiply(6, 6)).toBe(36);
    expect(multiply(-2, 4)).toBe(-8);
    expect(multiply(4, -2)).toBe(-8);
    expect(multiply(-4, -4)).toBe(16);
    expect(multiply(4, -5)).toBe(-20);
    expect(multiply(2, 121)).toBe(242);
    expect(multiply(121, 2)).toBe(242);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 6, 'column': 30, 'index': 160}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 7, 'column': 30, 'index': 194}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 10, 'column': 30, 'index': 247}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 11, 'column': 30, 'index': 281}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 14, 'column': 30, 'index': 334}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 15, 'column': 30, 'index': 368}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 18, 'column': 31, 'index': 423}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 19, 'column': 31, 'index': 458}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 20, 'column': 31, 'index': 493}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/getBit.test.js,Magic Number,"{'line': 21, 'column': 31, 'index': 528}","it('should get bit at specific position', () => {
    // 1 = 0b0001
    expect(getBit(1, 0)).toBe(1);
    expect(getBit(1, 1)).toBe(0);

    // 2 = 0b0010
    expect(getBit(2, 0)).toBe(0);
    expect(getBit(2, 1)).toBe(1);

    // 3 = 0b0011
    expect(getBit(3, 0)).toBe(1);
    expect(getBit(3, 1)).toBe(1);

    // 10 = 0b1010
    expect(getBit(10, 0)).toBe(0);
    expect(getBit(10, 1)).toBe(1);
    expect(getBit(10, 2)).toBe(0);
    expect(getBit(10, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 5, 'column': 33, 'index': 144}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 6, 'column': 33, 'index': 181}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 7, 'column': 33, 'index': 218}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 8, 'column': 33, 'index': 255}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 9, 'column': 33, 'index': 292}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 10, 'column': 33, 'index': 329}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 11, 'column': 34, 'index': 368}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 12, 'column': 34, 'index': 406}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 15, 'column': 35, 'index': 524}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/fullAdder.test.js,Magic Number,"{'line': 16, 'column': 35, 'index': 565}","it('should add up two numbers', () => {
    expect(fullAdder(0, 0)).toBe(0);
    expect(fullAdder(2, 0)).toBe(2);
    expect(fullAdder(0, 2)).toBe(2);
    expect(fullAdder(1, 2)).toBe(3);
    expect(fullAdder(2, 1)).toBe(3);
    expect(fullAdder(6, 6)).toBe(12);
    expect(fullAdder(-2, 4)).toBe(2);
    expect(fullAdder(4, -2)).toBe(2);
    expect(fullAdder(-4, -4)).toBe(-8);
    expect(fullAdder(4, -5)).toBe(-1);
    expect(fullAdder(2, 121)).toBe(123);
    expect(fullAdder(121, 2)).toBe(123);
  })",steel
/src/algorithms/math/bits/__test__/divideByTwo.test.js,Magic Number,"{'line': 5, 'column': 32, 'index': 177}","it('should divide numbers by two using bitwise operations', () => {
    expect(divideByTwo(0)).toBe(0);
    expect(divideByTwo(1)).toBe(0);
    expect(divideByTwo(3)).toBe(1);
    expect(divideByTwo(10)).toBe(5);
    expect(divideByTwo(17)).toBe(8);
    expect(divideByTwo(125)).toBe(62);
  })",steel
/src/algorithms/math/bits/__test__/divideByTwo.test.js,Magic Number,"{'line': 6, 'column': 32, 'index': 213}","it('should divide numbers by two using bitwise operations', () => {
    expect(divideByTwo(0)).toBe(0);
    expect(divideByTwo(1)).toBe(0);
    expect(divideByTwo(3)).toBe(1);
    expect(divideByTwo(10)).toBe(5);
    expect(divideByTwo(17)).toBe(8);
    expect(divideByTwo(125)).toBe(62);
  })",steel
/src/algorithms/math/bits/__test__/divideByTwo.test.js,Magic Number,"{'line': 7, 'column': 32, 'index': 249}","it('should divide numbers by two using bitwise operations', () => {
    expect(divideByTwo(0)).toBe(0);
    expect(divideByTwo(1)).toBe(0);
    expect(divideByTwo(3)).toBe(1);
    expect(divideByTwo(10)).toBe(5);
    expect(divideByTwo(17)).toBe(8);
    expect(divideByTwo(125)).toBe(62);
  })",steel
/src/algorithms/math/bits/__test__/divideByTwo.test.js,Magic Number,"{'line': 8, 'column': 33, 'index': 286}","it('should divide numbers by two using bitwise operations', () => {
    expect(divideByTwo(0)).toBe(0);
    expect(divideByTwo(1)).toBe(0);
    expect(divideByTwo(3)).toBe(1);
    expect(divideByTwo(10)).toBe(5);
    expect(divideByTwo(17)).toBe(8);
    expect(divideByTwo(125)).toBe(62);
  })",steel
/src/algorithms/math/bits/__test__/divideByTwo.test.js,Magic Number,"{'line': 9, 'column': 33, 'index': 323}","it('should divide numbers by two using bitwise operations', () => {
    expect(divideByTwo(0)).toBe(0);
    expect(divideByTwo(1)).toBe(0);
    expect(divideByTwo(3)).toBe(1);
    expect(divideByTwo(10)).toBe(5);
    expect(divideByTwo(17)).toBe(8);
    expect(divideByTwo(125)).toBe(62);
  })",steel
/src/algorithms/math/bits/__test__/divideByTwo.test.js,Magic Number,"{'line': 10, 'column': 34, 'index': 361}","it('should divide numbers by two using bitwise operations', () => {
    expect(divideByTwo(0)).toBe(0);
    expect(divideByTwo(1)).toBe(0);
    expect(divideByTwo(3)).toBe(1);
    expect(divideByTwo(10)).toBe(5);
    expect(divideByTwo(17)).toBe(8);
    expect(divideByTwo(125)).toBe(62);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 5, 'column': 33, 'index': 160}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 6, 'column': 33, 'index': 197}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 7, 'column': 33, 'index': 234}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 8, 'column': 33, 'index': 271}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 9, 'column': 33, 'index': 308}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 10, 'column': 33, 'index': 345}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 11, 'column': 34, 'index': 383}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 12, 'column': 35, 'index': 422}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 13, 'column': 36, 'index': 462}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 14, 'column': 34, 'index': 501}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 15, 'column': 35, 'index': 541}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 16, 'column': 36, 'index': 582}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 17, 'column': 37, 'index': 624}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/countSetBits.test.js,Magic Number,"{'line': 18, 'column': 43, 'index': 672}","it('should return number of set bits', () => {
    expect(countSetBits(0)).toBe(0);
    expect(countSetBits(1)).toBe(1);
    expect(countSetBits(2)).toBe(1);
    expect(countSetBits(3)).toBe(2);
    expect(countSetBits(4)).toBe(1);
    expect(countSetBits(5)).toBe(2);
    expect(countSetBits(21)).toBe(3);
    expect(countSetBits(255)).toBe(8);
    expect(countSetBits(1023)).toBe(10);
    expect(countSetBits(-1)).toBe(32);
    expect(countSetBits(-21)).toBe(30);
    expect(countSetBits(-255)).toBe(25);
    expect(countSetBits(-1023)).toBe(23);
    expect(countSetBits(-4294967296)).toBe(0);
  })",steel
/src/algorithms/math/bits/__test__/clearBit.test.js,Magic Number,"{'line': 6, 'column': 32, 'index': 170}","it('should clear bit at specific position', () => {
    // 1 = 0b0001
    expect(clearBit(1, 0)).toBe(0);
    expect(clearBit(1, 1)).toBe(1);
    expect(clearBit(1, 2)).toBe(1);

    // 10 = 0b1010
    expect(clearBit(10, 0)).toBe(10);
    expect(clearBit(10, 1)).toBe(8);
    expect(clearBit(10, 3)).toBe(2);
  })",steel
/src/algorithms/math/bits/__test__/clearBit.test.js,Magic Number,"{'line': 7, 'column': 32, 'index': 206}","it('should clear bit at specific position', () => {
    // 1 = 0b0001
    expect(clearBit(1, 0)).toBe(0);
    expect(clearBit(1, 1)).toBe(1);
    expect(clearBit(1, 2)).toBe(1);

    // 10 = 0b1010
    expect(clearBit(10, 0)).toBe(10);
    expect(clearBit(10, 1)).toBe(8);
    expect(clearBit(10, 3)).toBe(2);
  })",steel
/src/algorithms/math/bits/__test__/clearBit.test.js,Magic Number,"{'line': 8, 'column': 32, 'index': 242}","it('should clear bit at specific position', () => {
    // 1 = 0b0001
    expect(clearBit(1, 0)).toBe(0);
    expect(clearBit(1, 1)).toBe(1);
    expect(clearBit(1, 2)).toBe(1);

    // 10 = 0b1010
    expect(clearBit(10, 0)).toBe(10);
    expect(clearBit(10, 1)).toBe(8);
    expect(clearBit(10, 3)).toBe(2);
  })",steel
/src/algorithms/math/bits/__test__/clearBit.test.js,Magic Number,"{'line': 11, 'column': 33, 'index': 299}","it('should clear bit at specific position', () => {
    // 1 = 0b0001
    expect(clearBit(1, 0)).toBe(0);
    expect(clearBit(1, 1)).toBe(1);
    expect(clearBit(1, 2)).toBe(1);

    // 10 = 0b1010
    expect(clearBit(10, 0)).toBe(10);
    expect(clearBit(10, 1)).toBe(8);
    expect(clearBit(10, 3)).toBe(2);
  })",steel
/src/algorithms/math/bits/__test__/clearBit.test.js,Magic Number,"{'line': 12, 'column': 33, 'index': 337}","it('should clear bit at specific position', () => {
    // 1 = 0b0001
    expect(clearBit(1, 0)).toBe(0);
    expect(clearBit(1, 1)).toBe(1);
    expect(clearBit(1, 2)).toBe(1);

    // 10 = 0b1010
    expect(clearBit(10, 0)).toBe(10);
    expect(clearBit(10, 1)).toBe(8);
    expect(clearBit(10, 3)).toBe(2);
  })",steel
/src/algorithms/math/bits/__test__/clearBit.test.js,Magic Number,"{'line': 13, 'column': 33, 'index': 374}","it('should clear bit at specific position', () => {
    // 1 = 0b0001
    expect(clearBit(1, 0)).toBe(0);
    expect(clearBit(1, 1)).toBe(1);
    expect(clearBit(1, 2)).toBe(1);

    // 10 = 0b1010
    expect(clearBit(10, 0)).toBe(10);
    expect(clearBit(10, 1)).toBe(8);
    expect(clearBit(10, 3)).toBe(2);
  })",steel
/src/algorithms/math/bits/__test__/bitsDiff.test.js,Magic Number,"{'line': 5, 'column': 32, 'index': 167}","it('should calculate bits difference between two numbers', () => {
    expect(bitsDiff(0, 0)).toBe(0);
    expect(bitsDiff(1, 1)).toBe(0);
    expect(bitsDiff(124, 124)).toBe(0);
    expect(bitsDiff(0, 1)).toBe(1);
    expect(bitsDiff(1, 0)).toBe(1);
    expect(bitsDiff(1, 2)).toBe(2);
    expect(bitsDiff(1, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/bitsDiff.test.js,Magic Number,"{'line': 6, 'column': 32, 'index': 203}","it('should calculate bits difference between two numbers', () => {
    expect(bitsDiff(0, 0)).toBe(0);
    expect(bitsDiff(1, 1)).toBe(0);
    expect(bitsDiff(124, 124)).toBe(0);
    expect(bitsDiff(0, 1)).toBe(1);
    expect(bitsDiff(1, 0)).toBe(1);
    expect(bitsDiff(1, 2)).toBe(2);
    expect(bitsDiff(1, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/bitsDiff.test.js,Magic Number,"{'line': 7, 'column': 36, 'index': 243}","it('should calculate bits difference between two numbers', () => {
    expect(bitsDiff(0, 0)).toBe(0);
    expect(bitsDiff(1, 1)).toBe(0);
    expect(bitsDiff(124, 124)).toBe(0);
    expect(bitsDiff(0, 1)).toBe(1);
    expect(bitsDiff(1, 0)).toBe(1);
    expect(bitsDiff(1, 2)).toBe(2);
    expect(bitsDiff(1, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/bitsDiff.test.js,Magic Number,"{'line': 8, 'column': 32, 'index': 279}","it('should calculate bits difference between two numbers', () => {
    expect(bitsDiff(0, 0)).toBe(0);
    expect(bitsDiff(1, 1)).toBe(0);
    expect(bitsDiff(124, 124)).toBe(0);
    expect(bitsDiff(0, 1)).toBe(1);
    expect(bitsDiff(1, 0)).toBe(1);
    expect(bitsDiff(1, 2)).toBe(2);
    expect(bitsDiff(1, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/bitsDiff.test.js,Magic Number,"{'line': 9, 'column': 32, 'index': 315}","it('should calculate bits difference between two numbers', () => {
    expect(bitsDiff(0, 0)).toBe(0);
    expect(bitsDiff(1, 1)).toBe(0);
    expect(bitsDiff(124, 124)).toBe(0);
    expect(bitsDiff(0, 1)).toBe(1);
    expect(bitsDiff(1, 0)).toBe(1);
    expect(bitsDiff(1, 2)).toBe(2);
    expect(bitsDiff(1, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/bitsDiff.test.js,Magic Number,"{'line': 10, 'column': 32, 'index': 351}","it('should calculate bits difference between two numbers', () => {
    expect(bitsDiff(0, 0)).toBe(0);
    expect(bitsDiff(1, 1)).toBe(0);
    expect(bitsDiff(124, 124)).toBe(0);
    expect(bitsDiff(0, 1)).toBe(1);
    expect(bitsDiff(1, 0)).toBe(1);
    expect(bitsDiff(1, 2)).toBe(2);
    expect(bitsDiff(1, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/bitsDiff.test.js,Magic Number,"{'line': 11, 'column': 32, 'index': 387}","it('should calculate bits difference between two numbers', () => {
    expect(bitsDiff(0, 0)).toBe(0);
    expect(bitsDiff(1, 1)).toBe(0);
    expect(bitsDiff(124, 124)).toBe(0);
    expect(bitsDiff(0, 1)).toBe(1);
    expect(bitsDiff(1, 0)).toBe(1);
    expect(bitsDiff(1, 2)).toBe(2);
    expect(bitsDiff(1, 3)).toBe(1);
  })",steel
/src/algorithms/math/bits/__test__/bitLength.test.js,Magic Number,"{'line': 5, 'column': 32, 'index': 180}","it('should calculate number of bits that the number is consists of', () => {
    expect(bitLength(0b0)).toBe(0);
    expect(bitLength(0b1)).toBe(1);
    expect(bitLength(0b01)).toBe(1);
    expect(bitLength(0b101)).toBe(3);
    expect(bitLength(0b0101)).toBe(3);
    expect(bitLength(0b10101)).toBe(5);
    expect(bitLength(0b11110101)).toBe(8);
    expect(bitLength(0b00011110101)).toBe(8);
  })",steel
/src/algorithms/math/bits/__test__/bitLength.test.js,Magic Number,"{'line': 6, 'column': 32, 'index': 216}","it('should calculate number of bits that the number is consists of', () => {
    expect(bitLength(0b0)).toBe(0);
    expect(bitLength(0b1)).toBe(1);
    expect(bitLength(0b01)).toBe(1);
    expect(bitLength(0b101)).toBe(3);
    expect(bitLength(0b0101)).toBe(3);
    expect(bitLength(0b10101)).toBe(5);
    expect(bitLength(0b11110101)).toBe(8);
    expect(bitLength(0b00011110101)).toBe(8);
  })",steel
/src/algorithms/math/bits/__test__/bitLength.test.js,Magic Number,"{'line': 7, 'column': 33, 'index': 253}","it('should calculate number of bits that the number is consists of', () => {
    expect(bitLength(0b0)).toBe(0);
    expect(bitLength(0b1)).toBe(1);
    expect(bitLength(0b01)).toBe(1);
    expect(bitLength(0b101)).toBe(3);
    expect(bitLength(0b0101)).toBe(3);
    expect(bitLength(0b10101)).toBe(5);
    expect(bitLength(0b11110101)).toBe(8);
    expect(bitLength(0b00011110101)).toBe(8);
  })",steel
/src/algorithms/math/bits/__test__/bitLength.test.js,Magic Number,"{'line': 8, 'column': 34, 'index': 291}","it('should calculate number of bits that the number is consists of', () => {
    expect(bitLength(0b0)).toBe(0);
    expect(bitLength(0b1)).toBe(1);
    expect(bitLength(0b01)).toBe(1);
    expect(bitLength(0b101)).toBe(3);
    expect(bitLength(0b0101)).toBe(3);
    expect(bitLength(0b10101)).toBe(5);
    expect(bitLength(0b11110101)).toBe(8);
    expect(bitLength(0b00011110101)).toBe(8);
  })",steel
/src/algorithms/math/bits/__test__/bitLength.test.js,Magic Number,"{'line': 9, 'column': 35, 'index': 330}","it('should calculate number of bits that the number is consists of', () => {
    expect(bitLength(0b0)).toBe(0);
    expect(bitLength(0b1)).toBe(1);
    expect(bitLength(0b01)).toBe(1);
    expect(bitLength(0b101)).toBe(3);
    expect(bitLength(0b0101)).toBe(3);
    expect(bitLength(0b10101)).toBe(5);
    expect(bitLength(0b11110101)).toBe(8);
    expect(bitLength(0b00011110101)).toBe(8);
  })",steel
/src/algorithms/math/bits/__test__/bitLength.test.js,Magic Number,"{'line': 10, 'column': 36, 'index': 370}","it('should calculate number of bits that the number is consists of', () => {
    expect(bitLength(0b0)).toBe(0);
    expect(bitLength(0b1)).toBe(1);
    expect(bitLength(0b01)).toBe(1);
    expect(bitLength(0b101)).toBe(3);
    expect(bitLength(0b0101)).toBe(3);
    expect(bitLength(0b10101)).toBe(5);
    expect(bitLength(0b11110101)).toBe(8);
    expect(bitLength(0b00011110101)).toBe(8);
  })",steel
/src/algorithms/math/bits/__test__/bitLength.test.js,Magic Number,"{'line': 11, 'column': 39, 'index': 413}","it('should calculate number of bits that the number is consists of', () => {
    expect(bitLength(0b0)).toBe(0);
    expect(bitLength(0b1)).toBe(1);
    expect(bitLength(0b01)).toBe(1);
    expect(bitLength(0b101)).toBe(3);
    expect(bitLength(0b0101)).toBe(3);
    expect(bitLength(0b10101)).toBe(5);
    expect(bitLength(0b11110101)).toBe(8);
    expect(bitLength(0b00011110101)).toBe(8);
  })",steel
/src/algorithms/math/bits/__test__/bitLength.test.js,Magic Number,"{'line': 12, 'column': 42, 'index': 459}","it('should calculate number of bits that the number is consists of', () => {
    expect(bitLength(0b0)).toBe(0);
    expect(bitLength(0b1)).toBe(1);
    expect(bitLength(0b01)).toBe(1);
    expect(bitLength(0b101)).toBe(3);
    expect(bitLength(0b0101)).toBe(3);
    expect(bitLength(0b10101)).toBe(5);
    expect(bitLength(0b11110101)).toBe(8);
    expect(bitLength(0b00011110101)).toBe(8);
  })",steel
/src/algorithms/math/binary-floating-point/__tests__/floatAsBinaryString.test.js,Conditional Test Logic,"{'line': 6, 'column': 4, 'index': 271}","it('should create a binary representation of the floating numbers', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases32Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases32Bits[testCaseIndex];
      expect(floatAs32BinaryString(decimal)).toBe(binary);
    }
  })",steel
/src/algorithms/math/binary-floating-point/__tests__/floatAsBinaryString.test.js,Conditional Test Logic,"{'line': 15, 'column': 4, 'index': 619}","it('should create a binary representation of the floating numbers', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases64Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases64Bits[testCaseIndex];
      expect(floatAs64BinaryString(decimal)).toBe(binary);
    }
  })",steel
/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js,Conditional Test Logic,"{'line': 6, 'column': 4, 'index': 290}","it('should convert floating point binary bits to floating point decimal number', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases16Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases16Bits[testCaseIndex];
      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
      expect(bitsToFloat16(bits)).toBeCloseTo(decimal, 4);
    }
  })",steel
/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js,Conditional Test Logic,"{'line': 16, 'column': 4, 'index': 730}","it('should convert floating point binary bits to floating point decimal number', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases32Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases32Bits[testCaseIndex];
      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
      expect(bitsToFloat32(bits)).toBeCloseTo(decimal, 7);
    }
  })",steel
/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js,Conditional Test Logic,"{'line': 26, 'column': 4, 'index': 1170}","it('should convert floating point binary bits to floating point decimal number', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases64Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases64Bits[testCaseIndex];
      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
      expect(bitsToFloat64(bits)).toBeCloseTo(decimal, 14);
    }
  })",steel
/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js,Magic Number,"{'line': 9, 'column': 55, 'index': 580}","it('should convert floating point binary bits to floating point decimal number', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases16Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases16Bits[testCaseIndex];
      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
      expect(bitsToFloat16(bits)).toBeCloseTo(decimal, 4);
    }
  })",steel
/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js,Magic Number,"{'line': 19, 'column': 55, 'index': 1020}","it('should convert floating point binary bits to floating point decimal number', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases32Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases32Bits[testCaseIndex];
      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
      expect(bitsToFloat32(bits)).toBeCloseTo(decimal, 7);
    }
  })",steel
/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js,Magic Number,"{'line': 29, 'column': 55, 'index': 1460}","it('should convert floating point binary bits to floating point decimal number', () => {
    for (let testCaseIndex = 0; testCaseIndex < testCases64Bits.length; testCaseIndex += 1) {
      const [decimal, binary] = testCases64Bits[testCaseIndex];
      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
      expect(bitsToFloat64(bits)).toBeCloseTo(decimal, 14);
    }
  })",steel
/src/algorithms/image-processing/seam-carving/__tests__/resizeImageWidth.node.js,Conditional Test Logic,"{'line': 18, 'column': 2, 'index': 710}",Unknown,steel
/src/algorithms/image-processing/seam-carving/__tests__/resizeImageWidth.node.js,Conditional Test Logic,"{'line': 25, 'column': 2, 'index': 900}",Unknown,steel
/src/algorithms/image-processing/seam-carving/__tests__/resizeImageWidth.node.js,Conditional Test Logic,"{'line': 35, 'column': 4, 'index': 1415}",Unknown,steel
/src/algorithms/image-processing/seam-carving/__tests__/resizeImageWidth.node.js,Duplicate Assert,"{'line': 71, 'column': 4, 'index': 2325}","it('should perform content-aware image width reduction', async () => {
    const imgBefore = await pngLoad(testImageBeforePath);
    const imgAfter = await pngLoad(testImageAfterPath);

    const toWidth = Math.floor(imgBefore.width / 2);

    const {
      img: imgResized,
      size: resizedSize,
    } = resizeImageWidth({ img: imgBefore, toWidth });

    expect(imgResized).toBeDefined();
    expect(resizedSize).toBeDefined();

    expect(resizedSize).toEqual({ w: toWidth, h: imgBefore.height });
    expect(imgResized.width).toBe(imgAfter.width);
    expect(imgResized.height).toBe(imgAfter.height);

    const colorThreshold = 50;
    const differentPixels = pixelsDiff(imgResized, imgAfter, colorThreshold);

    // Allow 10% of pixels to be different
    const pixelsThreshold = Math.floor((imgAfter.width * imgAfter.height) / 10);

    expect(differentPixels).toBeLessThanOrEqual(pixelsThreshold);
  })",steel
/src/algorithms/image-processing/seam-carving/__tests__/resizeImageWidth.node.js,Duplicate Assert,"{'line': 73, 'column': 4, 'index': 2365}","it('should perform content-aware image width reduction', async () => {
    const imgBefore = await pngLoad(testImageBeforePath);
    const imgAfter = await pngLoad(testImageAfterPath);

    const toWidth = Math.floor(imgBefore.width / 2);

    const {
      img: imgResized,
      size: resizedSize,
    } = resizeImageWidth({ img: imgBefore, toWidth });

    expect(imgResized).toBeDefined();
    expect(resizedSize).toBeDefined();

    expect(resizedSize).toEqual({ w: toWidth, h: imgBefore.height });
    expect(imgResized.width).toBe(imgAfter.width);
    expect(imgResized.height).toBe(imgAfter.height);

    const colorThreshold = 50;
    const differentPixels = pixelsDiff(imgResized, imgAfter, colorThreshold);

    // Allow 10% of pixels to be different
    const pixelsThreshold = Math.floor((imgAfter.width * imgAfter.height) / 10);

    expect(differentPixels).toBeLessThanOrEqual(pixelsThreshold);
  })",steel
/src/algorithms/graph/travelling-salesman/__test__/bfTravellingSalesman.test.js,Magic Number,"{'line': 44, 'column': 37, 'index': 1605}","it('should solve problem for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 1);
    const edgeDC = new GraphEdge(vertexD, vertexC, 1);
    const edgeCA = new GraphEdge(vertexC, vertexA, 1);

    const edgeBA = new GraphEdge(vertexB, vertexA, 5);
    const edgeDB = new GraphEdge(vertexD, vertexB, 8);
    const edgeCD = new GraphEdge(vertexC, vertexD, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 4);
    const edgeAD = new GraphEdge(vertexA, vertexD, 2);
    const edgeDA = new GraphEdge(vertexD, vertexA, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 3);
    const edgeCB = new GraphEdge(vertexC, vertexB, 9);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBD)
      .addEdge(edgeDC)
      .addEdge(edgeCA)
      .addEdge(edgeBA)
      .addEdge(edgeDB)
      .addEdge(edgeCD)
      .addEdge(edgeAC)
      .addEdge(edgeAD)
      .addEdge(edgeDA)
      .addEdge(edgeBC)
      .addEdge(edgeCB);

    const salesmanPath = bfTravellingSalesman(graph);

    expect(salesmanPath.length).toBe(4);

    expect(salesmanPath[0].getKey()).toEqual(vertexA.getKey());
    expect(salesmanPath[1].getKey()).toEqual(vertexB.getKey());
    expect(salesmanPath[2].getKey()).toEqual(vertexD.getKey());
    expect(salesmanPath[3].getKey()).toEqual(vertexC.getKey());
  })",steel
/src/algorithms/graph/topological-sorting/__test__/topologicalSort.test.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1387}","it('should do topological sorting on graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeDF = new GraphEdge(vertexD, vertexF);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeEH = new GraphEdge(vertexE, vertexH);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCE)
      .addEdge(edgeDF)
      .addEdge(edgeEF)
      .addEdge(edgeEH)
      .addEdge(edgeFG);

    const sortedVertices = topologicalSort(graph);

    expect(sortedVertices).toBeDefined();
    expect(sortedVertices.length).toBe(graph.getAllVertices().length);
    expect(sortedVertices).toEqual([
      vertexB,
      vertexD,
      vertexA,
      vertexC,
      vertexE,
      vertexH,
      vertexF,
      vertexG,
    ]);
  })",steel
/src/algorithms/graph/topological-sorting/__test__/topologicalSort.test.js,Duplicate Assert,"{'line': 42, 'column': 4, 'index': 1500}","it('should do topological sorting on graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeDF = new GraphEdge(vertexD, vertexF);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeEH = new GraphEdge(vertexE, vertexH);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCE)
      .addEdge(edgeDF)
      .addEdge(edgeEF)
      .addEdge(edgeEH)
      .addEdge(edgeFG);

    const sortedVertices = topologicalSort(graph);

    expect(sortedVertices).toBeDefined();
    expect(sortedVertices.length).toBe(graph.getAllVertices().length);
    expect(sortedVertices).toEqual([
      vertexB,
      vertexD,
      vertexA,
      vertexC,
      vertexE,
      vertexH,
      vertexF,
      vertexG,
    ]);
  })",steel
/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js,Magic Number,"{'line': 29, 'column': 35, 'index': 1053}","it('should detect strongly connected components in simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCA = new GraphEdge(vertexC, vertexA);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeCD);

    const components = stronglyConnectedComponents(graph);

    expect(components).toBeDefined();
    expect(components.length).toBe(2);

    expect(components[0][0].getKey()).toBe(vertexA.getKey());
    expect(components[0][1].getKey()).toBe(vertexC.getKey());
    expect(components[0][2].getKey()).toBe(vertexB.getKey());

    expect(components[1][0].getKey()).toBe(vertexD.getKey());
  })",steel
/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js,Magic Number,"{'line': 85, 'column': 35, 'index': 3003}","it('should detect strongly connected components in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');
    const vertexI = new GraphVertex('I');
    const vertexJ = new GraphVertex('J');
    const vertexK = new GraphVertex('K');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCA = new GraphEdge(vertexC, vertexA);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeGH = new GraphEdge(vertexG, vertexH);
    const edgeHI = new GraphEdge(vertexH, vertexI);
    const edgeIJ = new GraphEdge(vertexI, vertexJ);
    const edgeJG = new GraphEdge(vertexJ, vertexG);
    const edgeJK = new GraphEdge(vertexJ, vertexK);

    const graph = new Graph(true);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeBD)
      .addEdge(edgeDE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeGF)
      .addEdge(edgeGH)
      .addEdge(edgeHI)
      .addEdge(edgeIJ)
      .addEdge(edgeJG)
      .addEdge(edgeJK);

    const components = stronglyConnectedComponents(graph);

    expect(components).toBeDefined();
    expect(components.length).toBe(4);

    expect(components[0][0].getKey()).toBe(vertexG.getKey());
    expect(components[0][1].getKey()).toBe(vertexJ.getKey());
    expect(components[0][2].getKey()).toBe(vertexI.getKey());
    expect(components[0][3].getKey()).toBe(vertexH.getKey());

    expect(components[1][0].getKey()).toBe(vertexK.getKey());

    expect(components[2][0].getKey()).toBe(vertexA.getKey());
    expect(components[2][1].getKey()).toBe(vertexC.getKey());
    expect(components[2][2].getKey()).toBe(vertexB.getKey());

    expect(components[3][0].getKey()).toBe(vertexD.getKey());
    expect(components[3][1].getKey()).toBe(vertexF.getKey());
    expect(components[3][2].getKey()).toBe(vertexE.getKey());
  })",steel
/src/algorithms/graph/prim/__test__/prim.test.js,Magic Number,"{'line': 51, 'column': 38, 'index': 1687}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,E,D,F,G');
  })",steel
/src/algorithms/graph/prim/__test__/prim.test.js,Magic Number,"{'line': 55, 'column': 49, 'index': 1788}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,E,D,F,G');
  })",steel
/src/algorithms/graph/prim/__test__/prim.test.js,Magic Number,"{'line': 82, 'column': 38, 'index': 2762}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",steel
/src/algorithms/graph/prim/__test__/prim.test.js,Magic Number,"{'line': 86, 'column': 49, 'index': 2862}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = prim(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",steel
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,Magic Number,"{'line': 51, 'column': 38, 'index': 1699}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('E,C,A,B,D,F,G');
  })",steel
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,Magic Number,"{'line': 55, 'column': 49, 'index': 1803}","it('should find minimum spanning tree', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB, 2);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 4);
    const edgeBE = new GraphEdge(vertexB, vertexE, 3);
    const edgeDF = new GraphEdge(vertexD, vertexF, 7);
    const edgeEC = new GraphEdge(vertexE, vertexC, 1);
    const edgeEF = new GraphEdge(vertexE, vertexF, 8);
    const edgeFG = new GraphEdge(vertexF, vertexG, 9);
    const edgeFC = new GraphEdge(vertexF, vertexC, 6);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBE)
      .addEdge(edgeDF)
      .addEdge(edgeEC)
      .addEdge(edgeEF)
      .addEdge(edgeFC)
      .addEdge(edgeFG);

    expect(graph.getWeight()).toEqual(46);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(24);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('E,C,A,B,D,F,G');
  })",steel
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,Magic Number,"{'line': 82, 'column': 38, 'index': 2777}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",steel
/src/algorithms/graph/kruskal/__test__/kruskal.test.js,Magic Number,"{'line': 86, 'column': 49, 'index': 2880}","it('should find minimum spanning tree for simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 1);
    const edgeAD = new GraphEdge(vertexA, vertexD, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 1);
    const edgeBD = new GraphEdge(vertexB, vertexD, 3);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAD)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    expect(graph.getWeight()).toEqual(9);

    const minimumSpanningTree = kruskal(graph);

    expect(minimumSpanningTree.getWeight()).toBe(3);
    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
  })",steel
/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js,Magic Number,"{'line': 36, 'column': 44, 'index': 1305}","it('should find hamiltonian paths in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD)
      .addEdge(edgeDE);

    const hamiltonianCycleSet = hamiltonianCycle(graph);

    expect(hamiltonianCycleSet.length).toBe(8);

    expect(hamiltonianCycleSet[0][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[0][1].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[0][2].getKey()).toBe(vertexE.getKey());
    expect(hamiltonianCycleSet[0][3].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[0][4].getKey()).toBe(vertexC.getKey());

    expect(hamiltonianCycleSet[1][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[1][1].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[1][2].getKey()).toBe(vertexC.getKey());
    expect(hamiltonianCycleSet[1][3].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[1][4].getKey()).toBe(vertexE.getKey());

    expect(hamiltonianCycleSet[2][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[2][1].getKey()).toBe(vertexE.getKey());
    expect(hamiltonianCycleSet[2][2].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[2][3].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[2][4].getKey()).toBe(vertexC.getKey());

    expect(hamiltonianCycleSet[3][0].getKey()).toBe(vertexA.getKey());
    expect(hamiltonianCycleSet[3][1].getKey()).toBe(vertexE.getKey());
    expect(hamiltonianCycleSet[3][2].getKey()).toBe(vertexD.getKey());
    expect(hamiltonianCycleSet[3][3].getKey()).toBe(vertexB.getKey());
    expect(hamiltonianCycleSet[3][4].getKey()).toBe(vertexC.getKey());
  })",steel
/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js,Magic Number,"{'line': 88, 'column': 44, 'index': 3618}","it('should return false for graph without Hamiltonian path', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeBD = new GraphEdge(vertexB, vertexD);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeCD);

    const hamiltonianCycleSet = hamiltonianCycle(graph);

    expect(hamiltonianCycleSet.length).toBe(0);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 72, 'column': 55, 'index': 2676}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 73, 'column': 55, 'index': 2735}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 74, 'column': 55, 'index': 2794}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 75, 'column': 55, 'index': 2853}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 76, 'column': 55, 'index': 2912}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 77, 'column': 55, 'index': 2971}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 78, 'column': 55, 'index': 3031}","it('should find minimum paths to all vertices for undirected graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB, 4);
    const edgeAE = new GraphEdge(vertexA, vertexE, 7);
    const edgeAC = new GraphEdge(vertexA, vertexC, 3);
    const edgeBC = new GraphEdge(vertexB, vertexC, 6);
    const edgeBD = new GraphEdge(vertexB, vertexD, 5);
    const edgeEC = new GraphEdge(vertexE, vertexC, 8);
    const edgeED = new GraphEdge(vertexE, vertexD, 2);
    const edgeDC = new GraphEdge(vertexD, vertexC, 11);
    const edgeDG = new GraphEdge(vertexD, vertexG, 10);
    const edgeDF = new GraphEdge(vertexD, vertexF, 2);
    const edgeFG = new GraphEdge(vertexF, vertexG, 3);
    const edgeEG = new GraphEdge(vertexE, vertexG, 5);

    const graph = new Graph();

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG)
      .addVertex(vertexH);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeBD)
      .addEdge(edgeEC)
      .addEdge(edgeED)
      .addEdge(edgeDC)
      .addEdge(edgeDG)
      .addEdge(edgeDF)
      .addEdge(edgeFG)
      .addEdge(edgeEG);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexFIndex = vertices.indexOf(vertexF);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexHIndex = vertices.indexOf(vertexH);

    expect(distances[vertexAIndex][vertexHIndex]).toBe(Infinity);
    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(4);
    expect(distances[vertexAIndex][vertexEIndex]).toBe(7);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexAIndex][vertexGIndex]).toBe(12);
    expect(distances[vertexAIndex][vertexFIndex]).toBe(11);

    expect(nextVertices[vertexAIndex][vertexFIndex]).toBe(vertexD);
    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexB);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexGIndex]).toBe(vertexE);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 131, 'column': 55, 'index': 4970}","it('should find minimum paths to all vertices for directed graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 3);
    const edgeBA = new GraphEdge(vertexB, vertexA, 8);
    const edgeAD = new GraphEdge(vertexA, vertexD, 7);
    const edgeDA = new GraphEdge(vertexD, vertexA, 2);
    const edgeBC = new GraphEdge(vertexB, vertexC, 2);
    const edgeCA = new GraphEdge(vertexC, vertexA, 5);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBA)
      .addEdge(edgeAD)
      .addEdge(edgeDA)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeCD);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);

    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(5);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(6);

    expect(distances).toEqual([
      [0, 3, 5, 6],
      [5, 0, 2, 3],
      [3, 6, 0, 1],
      [2, 5, 7, 0],
    ]);

    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexB);
    expect(nextVertices[vertexBIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 132, 'column': 55, 'index': 5029}","it('should find minimum paths to all vertices for directed graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 3);
    const edgeBA = new GraphEdge(vertexB, vertexA, 8);
    const edgeAD = new GraphEdge(vertexA, vertexD, 7);
    const edgeDA = new GraphEdge(vertexD, vertexA, 2);
    const edgeBC = new GraphEdge(vertexB, vertexC, 2);
    const edgeCA = new GraphEdge(vertexC, vertexA, 5);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBA)
      .addEdge(edgeAD)
      .addEdge(edgeDA)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeCD);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);

    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(5);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(6);

    expect(distances).toEqual([
      [0, 3, 5, 6],
      [5, 0, 2, 3],
      [3, 6, 0, 1],
      [2, 5, 7, 0],
    ]);

    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexB);
    expect(nextVertices[vertexBIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 133, 'column': 55, 'index': 5088}","it('should find minimum paths to all vertices for directed graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 3);
    const edgeBA = new GraphEdge(vertexB, vertexA, 8);
    const edgeAD = new GraphEdge(vertexA, vertexD, 7);
    const edgeDA = new GraphEdge(vertexD, vertexA, 2);
    const edgeBC = new GraphEdge(vertexB, vertexC, 2);
    const edgeCA = new GraphEdge(vertexC, vertexA, 5);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBA)
      .addEdge(edgeAD)
      .addEdge(edgeDA)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeCD);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);

    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(5);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(6);

    expect(distances).toEqual([
      [0, 3, 5, 6],
      [5, 0, 2, 3],
      [3, 6, 0, 1],
      [2, 5, 7, 0],
    ]);

    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexB);
    expect(nextVertices[vertexBIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 134, 'column': 55, 'index': 5147}","it('should find minimum paths to all vertices for directed graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB, 3);
    const edgeBA = new GraphEdge(vertexB, vertexA, 8);
    const edgeAD = new GraphEdge(vertexA, vertexD, 7);
    const edgeDA = new GraphEdge(vertexD, vertexA, 2);
    const edgeBC = new GraphEdge(vertexB, vertexC, 2);
    const edgeCA = new GraphEdge(vertexC, vertexA, 5);
    const edgeCD = new GraphEdge(vertexC, vertexD, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBA)
      .addEdge(edgeAD)
      .addEdge(edgeDA)
      .addEdge(edgeBC)
      .addEdge(edgeCA)
      .addEdge(edgeCD);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);

    expect(distances[vertexAIndex][vertexAIndex]).toBe(0);
    expect(distances[vertexAIndex][vertexBIndex]).toBe(3);
    expect(distances[vertexAIndex][vertexCIndex]).toBe(5);
    expect(distances[vertexAIndex][vertexDIndex]).toBe(6);

    expect(distances).toEqual([
      [0, 3, 5, 6],
      [5, 0, 2, 3],
      [3, 6, 0, 1],
      [2, 5, 7, 0],
    ]);

    expect(nextVertices[vertexAIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexB);
    expect(nextVertices[vertexBIndex][vertexDIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexAIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 204, 'column': 55, 'index': 7608}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeFE = new GraphEdge(vertexF, vertexE, 8);
    const edgeFA = new GraphEdge(vertexF, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeFE)
      .addEdge(edgeFA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexFIndex = vertices.indexOf(vertexF);

    expect(distances[vertexFIndex][vertexGIndex]).toBe(Infinity);
    expect(distances[vertexFIndex][vertexFIndex]).toBe(0);
    expect(distances[vertexFIndex][vertexAIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexBIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexCIndex]).toBe(7);
    expect(distances[vertexFIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexFIndex][vertexEIndex]).toBe(8);

    expect(nextVertices[vertexFIndex][vertexGIndex]).toBe(null);
    expect(nextVertices[vertexFIndex][vertexFIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexFIndex][vertexBIndex]).toBe(vertexE);
    expect(nextVertices[vertexEIndex][vertexBIndex]).toBe(vertexD);
    expect(nextVertices[vertexDIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 205, 'column': 55, 'index': 7667}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeFE = new GraphEdge(vertexF, vertexE, 8);
    const edgeFA = new GraphEdge(vertexF, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeFE)
      .addEdge(edgeFA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexFIndex = vertices.indexOf(vertexF);

    expect(distances[vertexFIndex][vertexGIndex]).toBe(Infinity);
    expect(distances[vertexFIndex][vertexFIndex]).toBe(0);
    expect(distances[vertexFIndex][vertexAIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexBIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexCIndex]).toBe(7);
    expect(distances[vertexFIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexFIndex][vertexEIndex]).toBe(8);

    expect(nextVertices[vertexFIndex][vertexGIndex]).toBe(null);
    expect(nextVertices[vertexFIndex][vertexFIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexFIndex][vertexBIndex]).toBe(vertexE);
    expect(nextVertices[vertexEIndex][vertexBIndex]).toBe(vertexD);
    expect(nextVertices[vertexDIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 206, 'column': 55, 'index': 7726}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeFE = new GraphEdge(vertexF, vertexE, 8);
    const edgeFA = new GraphEdge(vertexF, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeFE)
      .addEdge(edgeFA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexFIndex = vertices.indexOf(vertexF);

    expect(distances[vertexFIndex][vertexGIndex]).toBe(Infinity);
    expect(distances[vertexFIndex][vertexFIndex]).toBe(0);
    expect(distances[vertexFIndex][vertexAIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexBIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexCIndex]).toBe(7);
    expect(distances[vertexFIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexFIndex][vertexEIndex]).toBe(8);

    expect(nextVertices[vertexFIndex][vertexGIndex]).toBe(null);
    expect(nextVertices[vertexFIndex][vertexFIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexFIndex][vertexBIndex]).toBe(vertexE);
    expect(nextVertices[vertexEIndex][vertexBIndex]).toBe(vertexD);
    expect(nextVertices[vertexDIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 207, 'column': 55, 'index': 7785}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeFE = new GraphEdge(vertexF, vertexE, 8);
    const edgeFA = new GraphEdge(vertexF, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeFE)
      .addEdge(edgeFA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexFIndex = vertices.indexOf(vertexF);

    expect(distances[vertexFIndex][vertexGIndex]).toBe(Infinity);
    expect(distances[vertexFIndex][vertexFIndex]).toBe(0);
    expect(distances[vertexFIndex][vertexAIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexBIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexCIndex]).toBe(7);
    expect(distances[vertexFIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexFIndex][vertexEIndex]).toBe(8);

    expect(nextVertices[vertexFIndex][vertexGIndex]).toBe(null);
    expect(nextVertices[vertexFIndex][vertexFIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexFIndex][vertexBIndex]).toBe(vertexE);
    expect(nextVertices[vertexEIndex][vertexBIndex]).toBe(vertexD);
    expect(nextVertices[vertexDIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 208, 'column': 55, 'index': 7844}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeFE = new GraphEdge(vertexF, vertexE, 8);
    const edgeFA = new GraphEdge(vertexF, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeFE)
      .addEdge(edgeFA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexFIndex = vertices.indexOf(vertexF);

    expect(distances[vertexFIndex][vertexGIndex]).toBe(Infinity);
    expect(distances[vertexFIndex][vertexFIndex]).toBe(0);
    expect(distances[vertexFIndex][vertexAIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexBIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexCIndex]).toBe(7);
    expect(distances[vertexFIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexFIndex][vertexEIndex]).toBe(8);

    expect(nextVertices[vertexFIndex][vertexGIndex]).toBe(null);
    expect(nextVertices[vertexFIndex][vertexFIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexFIndex][vertexBIndex]).toBe(vertexE);
    expect(nextVertices[vertexEIndex][vertexBIndex]).toBe(vertexD);
    expect(nextVertices[vertexDIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
  })",steel
/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js,Magic Number,"{'line': 209, 'column': 55, 'index': 7903}","it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeFE = new GraphEdge(vertexF, vertexE, 8);
    const edgeFA = new GraphEdge(vertexF, vertexA, 10);
    const edgeED = new GraphEdge(vertexE, vertexD, 1);
    const edgeDA = new GraphEdge(vertexD, vertexA, -4);
    const edgeDC = new GraphEdge(vertexD, vertexC, -1);
    const edgeAC = new GraphEdge(vertexA, vertexC, 2);
    const edgeCB = new GraphEdge(vertexC, vertexB, -2);
    const edgeBA = new GraphEdge(vertexB, vertexA, 1);

    const graph = new Graph(true);

    // Add vertices first just to have them in desired order.
    graph
      .addVertex(vertexA)
      .addVertex(vertexB)
      .addVertex(vertexC)
      .addVertex(vertexD)
      .addVertex(vertexE)
      .addVertex(vertexF)
      .addVertex(vertexG);

    // Now, when vertices are in correct order let's add edges.
    graph
      .addEdge(edgeFE)
      .addEdge(edgeFA)
      .addEdge(edgeED)
      .addEdge(edgeDA)
      .addEdge(edgeDC)
      .addEdge(edgeAC)
      .addEdge(edgeCB)
      .addEdge(edgeBA);

    const { distances, nextVertices } = floydWarshall(graph);

    const vertices = graph.getAllVertices();

    const vertexAIndex = vertices.indexOf(vertexA);
    const vertexBIndex = vertices.indexOf(vertexB);
    const vertexCIndex = vertices.indexOf(vertexC);
    const vertexDIndex = vertices.indexOf(vertexD);
    const vertexEIndex = vertices.indexOf(vertexE);
    const vertexGIndex = vertices.indexOf(vertexG);
    const vertexFIndex = vertices.indexOf(vertexF);

    expect(distances[vertexFIndex][vertexGIndex]).toBe(Infinity);
    expect(distances[vertexFIndex][vertexFIndex]).toBe(0);
    expect(distances[vertexFIndex][vertexAIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexBIndex]).toBe(5);
    expect(distances[vertexFIndex][vertexCIndex]).toBe(7);
    expect(distances[vertexFIndex][vertexDIndex]).toBe(9);
    expect(distances[vertexFIndex][vertexEIndex]).toBe(8);

    expect(nextVertices[vertexFIndex][vertexGIndex]).toBe(null);
    expect(nextVertices[vertexFIndex][vertexFIndex]).toBe(null);
    expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexAIndex][vertexCIndex]).toBe(vertexA);
    expect(nextVertices[vertexFIndex][vertexBIndex]).toBe(vertexE);
    expect(nextVertices[vertexEIndex][vertexBIndex]).toBe(vertexD);
    expect(nextVertices[vertexDIndex][vertexBIndex]).toBe(vertexC);
    expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
  })",steel
/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycleUsingDisjointSet.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 1131}","it('should detect undirected cycle', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');

    const edgeAF = new GraphEdge(vertexA, vertexF);
    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();
    graph
      .addEdge(edgeAF)
      .addEdge(edgeAB)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    expect(detectUndirectedCycleUsingDisjointSet(graph)).toBe(false);

    graph.addEdge(edgeDE);

    expect(detectUndirectedCycleUsingDisjointSet(graph)).toBe(true);
  })",steel
/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycleUsingDisjointSet.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1230}","it('should detect undirected cycle', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');

    const edgeAF = new GraphEdge(vertexA, vertexF);
    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();
    graph
      .addEdge(edgeAF)
      .addEdge(edgeAB)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    expect(detectUndirectedCycleUsingDisjointSet(graph)).toBe(false);

    graph.addEdge(edgeDE);

    expect(detectUndirectedCycleUsingDisjointSet(graph)).toBe(true);
  })",steel
/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycle.test.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 1083}","it('should detect undirected cycle', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');

    const edgeAF = new GraphEdge(vertexA, vertexF);
    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();
    graph
      .addEdge(edgeAF)
      .addEdge(edgeAB)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    expect(detectUndirectedCycle(graph)).toBeNull();

    graph.addEdge(edgeDE);

    expect(detectUndirectedCycle(graph)).toEqual({
      B: vertexC,
      C: vertexD,
      D: vertexE,
      E: vertexB,
    });
  })",steel
/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycle.test.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1165}","it('should detect undirected cycle', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');

    const edgeAF = new GraphEdge(vertexA, vertexF);
    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBE = new GraphEdge(vertexB, vertexE);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();
    graph
      .addEdge(edgeAF)
      .addEdge(edgeAB)
      .addEdge(edgeBE)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    expect(detectUndirectedCycle(graph)).toBeNull();

    graph.addEdge(edgeDE);

    expect(detectUndirectedCycle(graph)).toEqual({
      B: vertexC,
      C: vertexD,
      D: vertexE,
      E: vertexB,
    });
  })",steel
/src/algorithms/graph/detect-cycle/__test__/detectDirectedCycle.test.js,Duplicate Assert,"{'line': 32, 'column': 4, 'index': 1154}","it('should detect directed cycle', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeDA = new GraphEdge(vertexD, vertexA);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeDA)
      .addEdge(edgeDE)
      .addEdge(edgeEF);

    expect(detectDirectedCycle(graph)).toBeNull();

    graph.addEdge(edgeFD);

    expect(detectDirectedCycle(graph)).toEqual({
      D: vertexF,
      F: vertexE,
      E: vertexD,
    });
  })",steel
/src/algorithms/graph/detect-cycle/__test__/detectDirectedCycle.test.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 1234}","it('should detect directed cycle', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeDA = new GraphEdge(vertexD, vertexA);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);

    const graph = new Graph(true);
    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeDA)
      .addEdge(edgeDE)
      .addEdge(edgeEF);

    expect(detectDirectedCycle(graph)).toBeNull();

    graph.addEdge(edgeFD);

    expect(detectDirectedCycle(graph)).toEqual({
      D: vertexF,
      F: vertexE,
      E: vertexD,
    });
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Conditional Test Logic,"{'line': 64, 'column': 4, 'index': 2364}","it('should perform DFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first to check default ones.
    depthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Conditional Test Logic,"{'line': 80, 'column': 4, 'index': 3164}","it('should perform DFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first to check default ones.
    depthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Conditional Test Logic,"{'line': 143, 'column': 4, 'index': 5500}","it('allow users to redefine vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexG, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Conditional Test Logic,"{'line': 159, 'column': 4, 'index': 6300}","it('allow users to redefine vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexG, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Duplicate Assert,"{'line': 66, 'column': 6, 'index': 2522}","it('should perform DFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first to check default ones.
    depthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Duplicate Assert,"{'line': 67, 'column': 6, 'index': 2613}","it('should perform DFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first to check default ones.
    depthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Duplicate Assert,"{'line': 82, 'column': 6, 'index': 3322}","it('should perform DFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first to check default ones.
    depthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Duplicate Assert,"{'line': 83, 'column': 6, 'index': 3413}","it('should perform DFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first to check default ones.
    depthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexC },
      { currentVertex: vertexC, previousVertex: vertexB },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Duplicate Assert,"{'line': 145, 'column': 6, 'index': 5658}","it('allow users to redefine vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexG, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Duplicate Assert,"{'line': 146, 'column': 6, 'index': 5749}","it('allow users to redefine vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexG, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Duplicate Assert,"{'line': 161, 'column': 6, 'index': 6458}","it('allow users to redefine vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexG, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js,Duplicate Assert,"{'line': 162, 'column': 6, 'index': 6549}","it('allow users to redefine vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDG = new GraphEdge(vertexD, vertexG);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDG);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    depthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexG, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexG, previousVertex: vertexD },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexF, previousVertex: vertexE },
      { currentVertex: vertexE, previousVertex: vertexA },
      { currentVertex: vertexA, previousVertex: null },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,Magic Number,"{'line': 26, 'column': 32, 'index': 861}","it('should find bridges in simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(3);
    expect(bridges[0].getKey()).toBe(edgeCD.getKey());
    expect(bridges[1].getKey()).toBe(edgeBC.getKey());
    expect(bridges[2].getKey()).toBe(edgeAB.getKey());
  })",steel
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,Magic Number,"{'line': 53, 'column': 32, 'index': 1707}","it('should find bridges in simple graph with back edge', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(1);
    expect(bridges[0].getKey()).toBe(edgeCD.getKey());
  })",steel
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,Magic Number,"{'line': 92, 'column': 32, 'index': 2964}","it('should find bridges in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeDE)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(3);
    expect(bridges[0].getKey()).toBe(edgeFH.getKey());
    expect(bridges[1].getKey()).toBe(edgeDE.getKey());
    expect(bridges[2].getKey()).toBe(edgeCD.getKey());
  })",steel
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,Magic Number,"{'line': 133, 'column': 32, 'index': 4367}","it('should find bridges in graph starting with different root vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeDE)
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(3);
    expect(bridges[0].getKey()).toBe(edgeFH.getKey());
    expect(bridges[1].getKey()).toBe(edgeDE.getKey());
    expect(bridges[2].getKey()).toBe(edgeCD.getKey());
  })",steel
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,Magic Number,"{'line': 163, 'column': 32, 'index': 5323}","it('should find bridges in yet another graph #1', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeDE);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(2);
    expect(bridges[0].getKey()).toBe(edgeDE.getKey());
    expect(bridges[1].getKey()).toBe(edgeCD.getKey());
  })",steel
/src/algorithms/graph/bridges/__test__/graphBridges.test.js,Magic Number,"{'line': 200, 'column': 32, 'index': 6533}","it('should find bridges in yet another graph #2', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeCF = new GraphEdge(vertexC, vertexF);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeCE)
      .addEdge(edgeCF)
      .addEdge(edgeEG)
      .addEdge(edgeFG);

    const bridges = Object.values(graphBridges(graph));

    expect(bridges.length).toBe(1);
    expect(bridges[0].getKey()).toBe(edgeCD.getKey());
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Conditional Test Logic,"{'line': 68, 'column': 4, 'index': 2474}","it('should perform BFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first.
    breadthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(8);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(8);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Conditional Test Logic,"{'line': 85, 'column': 4, 'index': 3333}","it('should perform BFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first.
    breadthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(8);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(8);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Conditional Test Logic,"{'line': 152, 'column': 4, 'index': 5862}","it('should allow to create custom vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Conditional Test Logic,"{'line': 168, 'column': 4, 'index': 6634}","it('should allow to create custom vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Duplicate Assert,"{'line': 70, 'column': 6, 'index': 2632}","it('should perform BFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first.
    breadthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(8);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(8);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Duplicate Assert,"{'line': 71, 'column': 6, 'index': 2723}","it('should perform BFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first.
    breadthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(8);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(8);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Duplicate Assert,"{'line': 87, 'column': 6, 'index': 3491}","it('should perform BFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first.
    breadthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(8);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(8);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Duplicate Assert,"{'line': 88, 'column': 6, 'index': 3582}","it('should perform BFS operation on graph', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graphs without callbacks first.
    breadthFirstSearch(graph, vertexA);

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(8);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(8);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexB, previousVertex: vertexA },
      { currentVertex: vertexD, previousVertex: vertexB },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexC, previousVertex: vertexE },
      { currentVertex: vertexH, previousVertex: vertexC },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexG, previousVertex: vertexF },
    ];

    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Duplicate Assert,"{'line': 154, 'column': 6, 'index': 5992}","it('should allow to create custom vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Duplicate Assert,"{'line': 155, 'column': 6, 'index': 6083}","it('should allow to create custom vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Duplicate Assert,"{'line': 170, 'column': 6, 'index': 6764}","it('should allow to create custom vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js,Duplicate Assert,"{'line': 171, 'column': 6, 'index': 6855}","it('should allow to create custom vertex visiting logic', () => {
    const graph = new Graph(true);

    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCG = new GraphEdge(vertexC, vertexG);
    const edgeAD = new GraphEdge(vertexA, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeFD = new GraphEdge(vertexF, vertexD);
    const edgeDH = new GraphEdge(vertexD, vertexH);
    const edgeGH = new GraphEdge(vertexG, vertexH);

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCG)
      .addEdge(edgeAD)
      .addEdge(edgeAE)
      .addEdge(edgeEF)
      .addEdge(edgeFD)
      .addEdge(edgeDH)
      .addEdge(edgeGH);

    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');

    const enterVertexCallback = jest.fn();
    const leaveVertexCallback = jest.fn();

    // Traverse graph with enterVertex and leaveVertex callbacks.
    breadthFirstSearch(graph, vertexA, {
      enterVertex: enterVertexCallback,
      leaveVertex: leaveVertexCallback,
      allowTraversal: ({ currentVertex, nextVertex }) => {
        return !(currentVertex === vertexA && nextVertex === vertexB);
      },
    });

    expect(enterVertexCallback).toHaveBeenCalledTimes(7);
    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);

    const enterVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = enterVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
    }

    const leaveVertexParamsMap = [
      { currentVertex: vertexA, previousVertex: null },
      { currentVertex: vertexD, previousVertex: vertexA },
      { currentVertex: vertexE, previousVertex: vertexD },
      { currentVertex: vertexH, previousVertex: vertexE },
      { currentVertex: vertexF, previousVertex: vertexH },
      { currentVertex: vertexD, previousVertex: vertexF },
      { currentVertex: vertexH, previousVertex: vertexD },
    ];

    for (let callIndex = 0; callIndex < 7; callIndex += 1) {
      const params = leaveVertexCallback.mock.calls[callIndex][0];
      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
    }
  })",steel
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,Magic Number,"{'line': 26, 'column': 46, 'index': 925}","it('should find articulation points in simple graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(2);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexB.getKey());
  })",steel
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,Magic Number,"{'line': 52, 'column': 46, 'index': 1792}","it('should find articulation points in simple graph with back edge', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeAC = new GraphEdge(vertexA, vertexC);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(1);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,Magic Number,"{'line': 80, 'column': 46, 'index': 2709}","it('should find articulation points in simple graph with back edge #2', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeAE = new GraphEdge(vertexA, vertexE);
    const edgeCE = new GraphEdge(vertexC, vertexE);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAE)
      .addEdge(edgeCE)
      .addEdge(edgeBC)
      .addEdge(edgeCD);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(1);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,Magic Number,"{'line': 119, 'column': 46, 'index': 4027}","it('should find articulation points in graph', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeDE)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(4);
    expect(articulationPointsSet[0].getKey()).toBe(vertexF.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexE.getKey());
    expect(articulationPointsSet[2].getKey()).toBe(vertexD.getKey());
    expect(articulationPointsSet[3].getKey()).toBe(vertexC.getKey());
  })",steel
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,Magic Number,"{'line': 161, 'column': 46, 'index': 5594}","it('should find articulation points in graph starting with articulation root vertex', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');
    const vertexH = new GraphVertex('H');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeEF = new GraphEdge(vertexE, vertexF);
    const edgeGF = new GraphEdge(vertexG, vertexF);
    const edgeFH = new GraphEdge(vertexF, vertexH);

    const graph = new Graph();

    graph
      .addEdge(edgeDE)
      .addEdge(edgeAB)
      .addEdge(edgeBC)
      .addEdge(edgeAC)
      .addEdge(edgeCD)
      .addEdge(edgeEG)
      .addEdge(edgeEF)
      .addEdge(edgeGF)
      .addEdge(edgeFH);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(4);
    expect(articulationPointsSet[0].getKey()).toBe(vertexF.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexE.getKey());
    expect(articulationPointsSet[2].getKey()).toBe(vertexC.getKey());
    expect(articulationPointsSet[3].getKey()).toBe(vertexD.getKey());
  })",steel
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,Magic Number,"{'line': 192, 'column': 46, 'index': 6711}","it('should find articulation points in yet another graph #1', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeDE = new GraphEdge(vertexD, vertexE);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeDE);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(2);
    expect(articulationPointsSet[0].getKey()).toBe(vertexD.getKey());
    expect(articulationPointsSet[1].getKey()).toBe(vertexC.getKey());
  })",steel
/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js,Magic Number,"{'line': 229, 'column': 46, 'index': 7997}","it('should find articulation points in yet another graph #2', () => {
    const vertexA = new GraphVertex('A');
    const vertexB = new GraphVertex('B');
    const vertexC = new GraphVertex('C');
    const vertexD = new GraphVertex('D');
    const vertexE = new GraphVertex('E');
    const vertexF = new GraphVertex('F');
    const vertexG = new GraphVertex('G');

    const edgeAB = new GraphEdge(vertexA, vertexB);
    const edgeAC = new GraphEdge(vertexA, vertexC);
    const edgeBC = new GraphEdge(vertexB, vertexC);
    const edgeCD = new GraphEdge(vertexC, vertexD);
    const edgeCE = new GraphEdge(vertexC, vertexE);
    const edgeCF = new GraphEdge(vertexC, vertexF);
    const edgeEG = new GraphEdge(vertexE, vertexG);
    const edgeFG = new GraphEdge(vertexF, vertexG);

    const graph = new Graph();

    graph
      .addEdge(edgeAB)
      .addEdge(edgeAC)
      .addEdge(edgeBC)
      .addEdge(edgeCD)
      .addEdge(edgeCE)
      .addEdge(edgeCF)
      .addEdge(edgeEG)
      .addEdge(edgeFG);

    const articulationPointsSet = Object.values(articulationPoints(graph));

    expect(articulationPointsSet.length).toBe(1);
    expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js,Conditional Test Logic,"{'line': 25, 'column': 8, 'index': 1093}","it('should calculate new hash based on previous one', () => {
    const bases = [3, 5];
    const frameSizes = [5, 10];

    const text = 'Lorem Ipsum is simply dummy text of the printing and '
      + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
      + 'galley of type and \u{ffff} scrambled it to make a type specimen book. It '
      + 'electronic  typesetting, remaining essentially unchanged. It was '
      + 'popularised in the 1960s with the release of Letraset sheets '
      + 'publishing software like Aldus  PageMaker including versions of Lorem.';

    // Check hashing for different prime base.
    bases.forEach((base) => {
      const polynomialHash = new SimplePolynomialHash(base);

      // Check hashing for different word lengths.
      frameSizes.forEach((frameSize) => {
        let previousWord = text.substr(0, frameSize);
        let previousHash = polynomialHash.hash(previousWord);

        // Shift frame through the whole text.
        for (let frameShift = 1; frameShift < (text.length - frameSize); frameShift += 1) {
          const currentWord = text.substr(frameShift, frameSize);
          const currentHash = polynomialHash.hash(currentWord);
          const currentRollingHash = polynomialHash.roll(previousHash, previousWord, currentWord);

          // Check that rolling hash is the same as directly calculated hash.
          expect(currentRollingHash).toBe(currentHash);

          previousWord = currentWord;
          previousHash = currentHash;
        }
      });
    });
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js,Magic Number,"{'line': 43, 'column': 45, 'index': 1801}","it('should generate numeric hashed', () => {
    const polynomialHash = new SimplePolynomialHash();

    expect(polynomialHash.hash('Test')).toBe(604944);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(100);
    expect(polynomialHash.hash('e')).toBe(101);
    expect(polynomialHash.hash('ab')).toBe(1763);
    expect(polynomialHash.hash('abc')).toBe(30374);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js,Magic Number,"{'line': 44, 'column': 42, 'index': 1852}","it('should generate numeric hashed', () => {
    const polynomialHash = new SimplePolynomialHash();

    expect(polynomialHash.hash('Test')).toBe(604944);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(100);
    expect(polynomialHash.hash('e')).toBe(101);
    expect(polynomialHash.hash('ab')).toBe(1763);
    expect(polynomialHash.hash('abc')).toBe(30374);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js,Magic Number,"{'line': 45, 'column': 42, 'index': 1899}","it('should generate numeric hashed', () => {
    const polynomialHash = new SimplePolynomialHash();

    expect(polynomialHash.hash('Test')).toBe(604944);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(100);
    expect(polynomialHash.hash('e')).toBe(101);
    expect(polynomialHash.hash('ab')).toBe(1763);
    expect(polynomialHash.hash('abc')).toBe(30374);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js,Magic Number,"{'line': 46, 'column': 42, 'index': 1946}","it('should generate numeric hashed', () => {
    const polynomialHash = new SimplePolynomialHash();

    expect(polynomialHash.hash('Test')).toBe(604944);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(100);
    expect(polynomialHash.hash('e')).toBe(101);
    expect(polynomialHash.hash('ab')).toBe(1763);
    expect(polynomialHash.hash('abc')).toBe(30374);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js,Magic Number,"{'line': 47, 'column': 42, 'index': 1993}","it('should generate numeric hashed', () => {
    const polynomialHash = new SimplePolynomialHash();

    expect(polynomialHash.hash('Test')).toBe(604944);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(100);
    expect(polynomialHash.hash('e')).toBe(101);
    expect(polynomialHash.hash('ab')).toBe(1763);
    expect(polynomialHash.hash('abc')).toBe(30374);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js,Magic Number,"{'line': 48, 'column': 42, 'index': 2041}","it('should generate numeric hashed', () => {
    const polynomialHash = new SimplePolynomialHash();

    expect(polynomialHash.hash('Test')).toBe(604944);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(100);
    expect(polynomialHash.hash('e')).toBe(101);
    expect(polynomialHash.hash('ab')).toBe(1763);
    expect(polynomialHash.hash('abc')).toBe(30374);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js,Magic Number,"{'line': 49, 'column': 43, 'index': 2090}","it('should generate numeric hashed', () => {
    const polynomialHash = new SimplePolynomialHash();

    expect(polynomialHash.hash('Test')).toBe(604944);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(100);
    expect(polynomialHash.hash('e')).toBe(101);
    expect(polynomialHash.hash('ab')).toBe(1763);
    expect(polynomialHash.hash('abc')).toBe(30374);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js,Magic Number,"{'line': 50, 'column': 44, 'index': 2141}","it('should generate numeric hashed', () => {
    const polynomialHash = new SimplePolynomialHash();

    expect(polynomialHash.hash('Test')).toBe(604944);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(100);
    expect(polynomialHash.hash('e')).toBe(101);
    expect(polynomialHash.hash('ab')).toBe(1763);
    expect(polynomialHash.hash('abc')).toBe(30374);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Conditional Test Logic,"{'line': 28, 'column': 10, 'index': 1261}","it('should calculate new hash based on previous one', () => {
    const bases = [3, 79, 101, 3251, 13229, 122743, 3583213];
    const mods = [79, 101];
    const frameSizes = [5, 20];

    // @TODO: Provide Unicode support.
    const text = 'Lorem Ipsum is simply dummy text of the printing and '
      + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
      + 'galley of type and \u{ffff} scrambled it to make a type specimen book. It '
      + 'electronic  typesetting, remaining essentially unchanged. It was '
      // + 'popularised in the \u{20005} \u{20000}1960s with the release of Letraset sheets '
      + 'publishing software like Aldus PageMaker  including versions of Lorem.';

    // Check hashing for different prime base.
    bases.forEach((base) => {
      mods.forEach((modulus) => {
        const polynomialHash = new PolynomialHash({ base, modulus });

        // Check hashing for different word lengths.
        frameSizes.forEach((frameSize) => {
          let previousWord = text.substr(0, frameSize);
          let previousHash = polynomialHash.hash(previousWord);

          // Shift frame through the whole text.
          for (let frameShift = 1; frameShift < (text.length - frameSize); frameShift += 1) {
            const currentWord = text.substr(frameShift, frameSize);
            const currentHash = polynomialHash.hash(currentWord);
            const currentRollingHash = polynomialHash.roll(previousHash, previousWord, currentWord);

            // Check that rolling hash is the same as directly calculated hash.
            expect(currentRollingHash).toBe(currentHash);

            previousWord = currentWord;
            previousHash = currentHash;
          }
        });
      });
    });
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Magic Number,"{'line': 47, 'column': 77, 'index': 2053}","it('should generate numeric hashed less than 100', () => {
    const polynomialHash = new PolynomialHash({ modulus: 100 });

    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
    expect(polynomialHash.hash('Test')).toBe(92);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(0);
    expect(polynomialHash.hash('e')).toBe(1);
    expect(polynomialHash.hash('ab')).toBe(87);

    // @TODO: Provide Unicode support.
    expect(polynomialHash.hash('\u{20000}')).toBe(92);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Magic Number,"{'line': 48, 'column': 45, 'index': 2103}","it('should generate numeric hashed less than 100', () => {
    const polynomialHash = new PolynomialHash({ modulus: 100 });

    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
    expect(polynomialHash.hash('Test')).toBe(92);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(0);
    expect(polynomialHash.hash('e')).toBe(1);
    expect(polynomialHash.hash('ab')).toBe(87);

    // @TODO: Provide Unicode support.
    expect(polynomialHash.hash('\u{20000}')).toBe(92);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Magic Number,"{'line': 49, 'column': 42, 'index': 2150}","it('should generate numeric hashed less than 100', () => {
    const polynomialHash = new PolynomialHash({ modulus: 100 });

    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
    expect(polynomialHash.hash('Test')).toBe(92);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(0);
    expect(polynomialHash.hash('e')).toBe(1);
    expect(polynomialHash.hash('ab')).toBe(87);

    // @TODO: Provide Unicode support.
    expect(polynomialHash.hash('\u{20000}')).toBe(92);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Magic Number,"{'line': 50, 'column': 42, 'index': 2197}","it('should generate numeric hashed less than 100', () => {
    const polynomialHash = new PolynomialHash({ modulus: 100 });

    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
    expect(polynomialHash.hash('Test')).toBe(92);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(0);
    expect(polynomialHash.hash('e')).toBe(1);
    expect(polynomialHash.hash('ab')).toBe(87);

    // @TODO: Provide Unicode support.
    expect(polynomialHash.hash('\u{20000}')).toBe(92);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Magic Number,"{'line': 51, 'column': 42, 'index': 2244}","it('should generate numeric hashed less than 100', () => {
    const polynomialHash = new PolynomialHash({ modulus: 100 });

    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
    expect(polynomialHash.hash('Test')).toBe(92);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(0);
    expect(polynomialHash.hash('e')).toBe(1);
    expect(polynomialHash.hash('ab')).toBe(87);

    // @TODO: Provide Unicode support.
    expect(polynomialHash.hash('\u{20000}')).toBe(92);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Magic Number,"{'line': 52, 'column': 42, 'index': 2291}","it('should generate numeric hashed less than 100', () => {
    const polynomialHash = new PolynomialHash({ modulus: 100 });

    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
    expect(polynomialHash.hash('Test')).toBe(92);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(0);
    expect(polynomialHash.hash('e')).toBe(1);
    expect(polynomialHash.hash('ab')).toBe(87);

    // @TODO: Provide Unicode support.
    expect(polynomialHash.hash('\u{20000}')).toBe(92);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Magic Number,"{'line': 53, 'column': 42, 'index': 2337}","it('should generate numeric hashed less than 100', () => {
    const polynomialHash = new PolynomialHash({ modulus: 100 });

    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
    expect(polynomialHash.hash('Test')).toBe(92);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(0);
    expect(polynomialHash.hash('e')).toBe(1);
    expect(polynomialHash.hash('ab')).toBe(87);

    // @TODO: Provide Unicode support.
    expect(polynomialHash.hash('\u{20000}')).toBe(92);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Magic Number,"{'line': 54, 'column': 43, 'index': 2384}","it('should generate numeric hashed less than 100', () => {
    const polynomialHash = new PolynomialHash({ modulus: 100 });

    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
    expect(polynomialHash.hash('Test')).toBe(92);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(0);
    expect(polynomialHash.hash('e')).toBe(1);
    expect(polynomialHash.hash('ab')).toBe(87);

    // @TODO: Provide Unicode support.
    expect(polynomialHash.hash('\u{20000}')).toBe(92);
  })",steel
/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js,Magic Number,"{'line': 57, 'column': 50, 'index': 2479}","it('should generate numeric hashed less than 100', () => {
    const polynomialHash = new PolynomialHash({ modulus: 100 });

    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
    expect(polynomialHash.hash('Test')).toBe(92);
    expect(polynomialHash.hash('a')).toBe(97);
    expect(polynomialHash.hash('b')).toBe(98);
    expect(polynomialHash.hash('c')).toBe(99);
    expect(polynomialHash.hash('d')).toBe(0);
    expect(polynomialHash.hash('e')).toBe(1);
    expect(polynomialHash.hash('ab')).toBe(87);

    // @TODO: Provide Unicode support.
    expect(polynomialHash.hash('\u{20000}')).toBe(92);
  })",steel
/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js,Eager Test,"{'line': 10, 'column': 6, 'index': 404}","it('should throw an error when message or keyString contains none letter character', () => {
    const invalidCharacterInMessage = () => {
      hillCipherEncrypt('hell3', 'helloworld');
    };
    const invalidCharacterInKeyString = () => {
      hillCipherEncrypt('hello', 'hel12world');
    };
    expect(invalidCharacterInMessage).toThrowError(
      'The message and key string can only contain letters',
    );
    expect(invalidCharacterInKeyString).toThrowError(
      'The message and key string can only contain letters',
    );
  })",steel
/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js,Eager Test,"{'line': 13, 'column': 6, 'index': 507}","it('should throw an error when message or keyString contains none letter character', () => {
    const invalidCharacterInMessage = () => {
      hillCipherEncrypt('hell3', 'helloworld');
    };
    const invalidCharacterInKeyString = () => {
      hillCipherEncrypt('hello', 'hel12world');
    };
    expect(invalidCharacterInMessage).toThrowError(
      'The message and key string can only contain letters',
    );
    expect(invalidCharacterInKeyString).toThrowError(
      'The message and key string can only contain letters',
    );
  })",steel
/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js,Eager Test,"{'line': 42, 'column': 11, 'index': 1604}","it('should encrypt passed message using Hill Cipher', () => {
    expect(hillCipherEncrypt('ACT', 'GYBNQKURP')).toBe('POH');
    expect(hillCipherEncrypt('CAT', 'GYBNQKURP')).toBe('FIN');
    expect(hillCipherEncrypt('GFG', 'HILLMAGIC')).toBe('SWK');
  })",steel
/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js,Eager Test,"{'line': 43, 'column': 11, 'index': 1667}","it('should encrypt passed message using Hill Cipher', () => {
    expect(hillCipherEncrypt('ACT', 'GYBNQKURP')).toBe('POH');
    expect(hillCipherEncrypt('CAT', 'GYBNQKURP')).toBe('FIN');
    expect(hillCipherEncrypt('GFG', 'HILLMAGIC')).toBe('SWK');
  })",steel
/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js,Eager Test,"{'line': 44, 'column': 11, 'index': 1730}","it('should encrypt passed message using Hill Cipher', () => {
    expect(hillCipherEncrypt('ACT', 'GYBNQKURP')).toBe('POH');
    expect(hillCipherEncrypt('CAT', 'GYBNQKURP')).toBe('FIN');
    expect(hillCipherEncrypt('GFG', 'HILLMAGIC')).toBe('SWK');
  })",steel
/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js,Lazy Test,"{'line': 10, 'column': 6, 'index': 404}","it('should throw an error when message or keyString contains none letter character', () => {
    const invalidCharacterInMessage = () => {
      hillCipherEncrypt('hell3', 'helloworld');
    };
    const invalidCharacterInKeyString = () => {
      hillCipherEncrypt('hello', 'hel12world');
    };
    expect(invalidCharacterInMessage).toThrowError(
      'The message and key string can only contain letters',
    );
    expect(invalidCharacterInKeyString).toThrowError(
      'The message and key string can only contain letters',
    );
  })",steel
/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js,Lazy Test,"{'line': 25, 'column': 6, 'index': 966}","it('should throw an error when the length of the keyString has a square root which is not integer', () => {
    const invalidLengthOfKeyString = () => {
      hillCipherEncrypt('ab', 'ab');
    };
    expect(invalidLengthOfKeyString).toThrowError(
      'Invalid key string length. The square root of the key string must be an integer',
    );
  })",steel
/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js,Lazy Test,"{'line': 34, 'column': 6, 'index': 1333}","it('should throw an error when the length of the keyString does not equal to the power of length of the message', () => {
    const invalidLengthOfKeyString = () => {
      hillCipherEncrypt('ab', 'aaabbbccc');
    };
    expect(invalidLengthOfKeyString).toThrowError(
      'Invalid key string length. The key length must be a square of message length',
    );
  })",steel
/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js,Lazy Test,"{'line': 42, 'column': 11, 'index': 1604}","it('should encrypt passed message using Hill Cipher', () => {
    expect(hillCipherEncrypt('ACT', 'GYBNQKURP')).toBe('POH');
    expect(hillCipherEncrypt('CAT', 'GYBNQKURP')).toBe('FIN');
    expect(hillCipherEncrypt('GFG', 'HILLMAGIC')).toBe('SWK');
  })",steel
